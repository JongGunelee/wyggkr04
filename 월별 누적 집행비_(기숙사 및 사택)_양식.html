<html lang="ko"><head>
  <meta charset="UTF-8">
  <title>월별 누적 집행비 대시보드</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>
  <script>
    // 전역 범위에 확대 기능 관련 변수 선언
    let isZoomModeActive = false;
    let isZoomed = false;
    let zoomStartPoint = null; // { xIndex, yValue, xPixel, yPixel }
    let zoomEndPoint = null;   // { xIndex, yValue, xPixel, yPixel }
    let isFirstZoomClick = true;
    let originalScales = null;
    let budgetChart = null;
    let zoomPreviewRectAnnotation = null; 

    // 테이블 가시성 상태 변수: 초기값을 false로 변경하여 기본적으로 숨김
    let isTableVisibleUserSettings = false; 

    document.addEventListener('DOMContentLoaded', function () {
      const zoomToggleBtn = document.getElementById('zoomToggleBtn');
      const instruction = document.getElementById('zoomInstruction');
      const canvas = document.getElementById('budgetChart');
      const toggleTableBtn = document.getElementById('toggleTableBtn');
      const showTableIcon = document.getElementById('showTableIcon');

      if (zoomToggleBtn) {
        zoomToggleBtn.addEventListener('click', function () {
          if (!isZoomed && !isZoomModeActive) {
            isZoomModeActive = true;
            isFirstZoomClick = true;
            this.innerText = '확대 취소';
            if(instruction) instruction.innerText = '확대할 사각 영역의 첫 번째 모서리를 차트에서 클릭하세요.';
            removeZoomPreview(); 
          } else {
            resetZoom();
          }
        });
      }

      if (canvas) {
        canvas.onclick = function (evt) {
          if (isZoomModeActive) {
            if (!budgetChart) return;

            const rect = canvas.getBoundingClientRect();
            const xPixel = evt.clientX - rect.left;
            const yPixel = evt.clientY - rect.top;

            const rawXValue = budgetChart.scales.x.getValueForPixel(xPixel);
            const xIndex = Math.round(rawXValue); 
            const yValue = budgetChart.scales.y.getValueForPixel(yPixel);

            if (isFirstZoomClick) {
              zoomStartPoint = { xIndex, yValue, xPixel, yPixel }; 
              isFirstZoomClick = false;
              if(instruction) instruction.innerText = '확대할 사각 영역의 반대편 모서리를 차트에서 클릭하거나, 드래그하여 영역을 조절하세요.';
              removeZoomPreview(); 
            } else {
              zoomEndPoint = { xIndex, yValue, xPixel, yPixel }; 
              drawZoomPreview(zoomStartPoint.xPixel, zoomStartPoint.yPixel, xPixel, yPixel); 

              if (confirm("이 영역으로 확대하시겠습니까?")) {
                applyZoom();
              } else {
                zoomEndPoint = null; 
                removeZoomPreview(); 
                if(instruction) instruction.innerText = '확대할 사각 영역의 반대편 모서리를 다시 클릭하세요.';
              }
            }
          } else {
            if (typeof addMonthSelectionFeatureLogic === 'function') {
                 addMonthSelectionFeatureLogic(evt);
            }
          }
        };

        canvas.onmousemove = function(evt) {
          if (isZoomModeActive && zoomStartPoint && !isFirstZoomClick && !zoomEndPoint) { 
            if (!budgetChart) return;
            const rect = canvas.getBoundingClientRect();
            const currentXPixel = evt.clientX - rect.left;
            const currentYPixel = evt.clientY - rect.top;
            drawZoomPreview(zoomStartPoint.xPixel, zoomStartPoint.yPixel, currentXPixel, currentYPixel);
          }
        };
      }

      if (toggleTableBtn) {
        toggleTableBtn.addEventListener('click', function() {
          isTableVisibleUserSettings = !isTableVisibleUserSettings;
          updateTableAndControlsVisibility();
        });
      }

      if (showTableIcon) {
        showTableIcon.addEventListener('click', function() {
          isTableVisibleUserSettings = true;
          updateTableAndControlsVisibility();
        });
      }
      
      updateTableAndControlsVisibility(); 

    });

    function updateTableAndControlsVisibility() {
        const dataTable = document.getElementById('data-table');
        const toggleTableBtn = document.getElementById('toggleTableBtn');
        const showTableIcon = document.getElementById('showTableIcon');

        if (!dataTable || !toggleTableBtn || !showTableIcon) return;

        if (isZoomed) { 
            dataTable.style.display = 'none';
            showTableIcon.style.display = 'none'; 
            toggleTableBtn.innerText = isTableVisibleUserSettings ? '테이블 숨기기' : '테이블 보이기';
        } else { 
            if (isTableVisibleUserSettings) {
                dataTable.style.display = ''; 
                toggleTableBtn.innerText = '테이블 숨기기';
                showTableIcon.style.display = 'none';
            } else {
                dataTable.style.display = 'none';
                toggleTableBtn.innerText = '테이블 보이기';
                showTableIcon.style.display = 'flex'; 
            }
        }
    }


    function drawZoomPreview(x1, y1, x2, y2) {
      if (!budgetChart) return;
      removeZoomPreview(); 

      const xMinPixel = Math.min(x1, x2);
      const xMaxPixel = Math.max(x1, x2);
      const yMinPixel = Math.min(y1, y2);
      const yMaxPixel = Math.max(y1, y2);

      let previewXMinData = Math.round(budgetChart.scales.x.getValueForPixel(xMinPixel));
      let previewXMaxData = Math.round(budgetChart.scales.x.getValueForPixel(xMaxPixel));
      
      if (previewXMinData === previewXMaxData && budgetChart.data.labels.length > 1) {
         if (previewXMaxData < budgetChart.data.labels.length -1) {
            previewXMaxData +=1;
         } else if (previewXMinData > 0) {
            previewXMinData -=1;
         }
      }

      zoomPreviewRectAnnotation = {
        type: 'box',
        xMin: previewXMinData, 
        xMax: previewXMaxData,
        yMin: budgetChart.scales.y.getValueForPixel(yMaxPixel), 
        yMax: budgetChart.scales.y.getValueForPixel(yMinPixel),
        borderColor: 'rgba(255, 99, 132, 0.7)',
        borderWidth: 2,
        borderDash: [6, 6],
        backgroundColor: 'rgba(255, 99, 132, 0.1)',
        drawTime: 'afterDraw' 
      };

      if (!budgetChart.options.plugins.annotation) {
        budgetChart.options.plugins.annotation = { annotations: {} };
      }
      budgetChart.options.plugins.annotation.annotations.zoomPreviewRect = zoomPreviewRectAnnotation;
      budgetChart.update('none'); 
    }

    function removeZoomPreview() {
      if (budgetChart && budgetChart.options.plugins.annotation && budgetChart.options.plugins.annotation.annotations.zoomPreviewRect) {
        delete budgetChart.options.plugins.annotation.annotations.zoomPreviewRect;
        zoomPreviewRectAnnotation = null;
        budgetChart.update('none');
      }
    }

    function applyZoom() {
      if (!budgetChart || !zoomStartPoint || !zoomEndPoint) {
        resetZoom();
        return;
      }

      const xMin = Math.min(zoomStartPoint.xIndex, zoomEndPoint.xIndex);
      const xMax = Math.max(zoomStartPoint.xIndex, zoomEndPoint.xIndex);
      const yMin = Math.min(zoomStartPoint.yValue, zoomEndPoint.yValue);
      const yMax = Math.max(zoomStartPoint.yValue, zoomEndPoint.yValue);

      const finalXMin = Math.max(0, xMin); 
      const finalXMax = Math.min(budgetChart.data.labels.length - 1, xMax); 

      let finalYMin = yMin;
      let finalYMax = yMax;

      if (finalYMin === finalYMax) { 
        let dataBasedYMin = Number.MAX_VALUE;
        let dataBasedYMax = -Number.MAX_VALUE;
        budgetChart.data.datasets.forEach(ds => {
            if (!ds.hidden) {
                const sliceStart = Math.max(0, Math.floor(finalXMin)); 
                const sliceEnd = Math.min(budgetChart.data.labels.length, Math.ceil(finalXMax) + 1); 
                
                const dataInRange = ds.data.slice(sliceStart, sliceEnd).filter(v => v !== null && !isNaN(v));
                if (dataInRange.length > 0) {
                    dataBasedYMin = Math.min(dataBasedYMin, ...dataInRange);
                    dataBasedYMax = Math.max(dataBasedYMax, ...dataInRange);
                }
            }
        });
        if (dataBasedYMin !== Number.MAX_VALUE && dataBasedYMax !== -Number.MAX_VALUE) { 
             finalYMin = dataBasedYMin * 0.9;
             finalYMax = dataBasedYMax * 1.1;
             if (finalYMin === finalYMax) { 
                finalYMin -= 1; 
                finalYMax += 1;
             }
        } else { 
            const originalYScale = (originalScales && originalScales.y) ? originalScales.y : budgetChart.options.scales.y;
            const yAxisDefaultMin = originalYScale.min !== undefined ? originalYScale.min : 0;
            const yAxisDefaultMax = originalYScale.max !== undefined ? originalYScale.max : 100; 
            const yRange = (yAxisDefaultMax - yAxisDefaultMin) || 10000000; 
            
            finalYMin = yMin - yRange * 0.05; 
            finalYMax = yMax + yRange * 0.05;
            if (finalYMin === finalYMax) { 
                finalYMin -= 1;
                finalYMax += 1;
            }
        }
      }


      if (!originalScales) {
        originalScales = {
          x: { ...budgetChart.options.scales.x },
          y: { ...budgetChart.options.scales.y }
        };
      }

      budgetChart.options.scales.x.min = finalXMin;
      budgetChart.options.scales.x.max = finalXMax;
      budgetChart.options.scales.y.min = finalYMin;
      budgetChart.options.scales.y.max = finalYMax;

      budgetChart.update();

      isZoomed = true;
      isZoomModeActive = false;
      removeZoomPreview(); 

      updateTableAndControlsVisibility(); 

      const instruction = document.getElementById('zoomInstruction');
      if(instruction) instruction.innerText = "확대 완료. '확대 취소' 버튼으로 원래대로 돌아갑니다.";
      const zoomToggleBtn = document.getElementById('zoomToggleBtn');
      if(zoomToggleBtn) zoomToggleBtn.innerText = '확대 취소';

      zoomStartPoint = null;
      zoomEndPoint = null;
      isFirstZoomClick = true;
    }

    function resetZoom() {
      if (!budgetChart) return;
      removeZoomPreview(); 

      if (originalScales) {
        budgetChart.options.scales.x = { ...originalScales.x };
        budgetChart.options.scales.y = { ...originalScales.y };
        originalScales = null;
      } else {
        delete budgetChart.options.scales.x.min;
        delete budgetChart.options.scales.x.max;
        delete budgetChart.options.scales.y.min;
        delete budgetChart.options.scales.y.max;
      }

      budgetChart.update();

      isZoomed = false;
      isZoomModeActive = false;
      zoomStartPoint = null;
      zoomEndPoint = null;
      isFirstZoomClick = true;

      updateTableAndControlsVisibility(); 

      const instruction = document.getElementById('zoomInstruction');
      if(instruction) instruction.innerText = '';
      const zoomToggleBtn = document.getElementById('zoomToggleBtn');
      if(zoomToggleBtn) zoomToggleBtn.innerText = '확대 시작';
    }
  </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      font-family: 'Noto Sans KR', 'Apple SD Gothic Neo', Arial, sans-serif;
      background: #f5f7fa;
      color: #222;
      box-sizing: border-box;
      overflow: hidden;
    }
    #chart-container {
      position: relative; width: 100vw; height: 100vh;
      min-height: 100vh; min-width: 100vw;
      display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
      padding-top: 60px;
    }
    h1 {
      position: fixed; top: 0; left: 0; right: 0;
      background: #1a237e; color: #fff; font-size: 22px; font-weight: 700;
      text-align: center; padding: 16px 0 12px 0; z-index: 100;
      letter-spacing: 1px; box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      margin: 0;
    }
    #controls {
      position: fixed;
      top: 60px;
      right: 16px;
      z-index: 30;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      padding: 6px 10px;
      display: flex; 
      align-items: center; 
      transform: scale(0.8);
      transform-origin: top right;
      width: auto; 
      gap: 10px; 
    }
    .control-group { 
        display: flex;
        align-items: center;
        gap: 5px; 
        flex-grow: 1; 
        flex-basis: 0; 
        justify-content: center; 
    }
    .control-group:first-child { 
        justify-content: flex-start; 
        flex-grow: 1.5; 
    }
     .control-group:last-child { 
        justify-content: flex-end; 
    }


    #label-pos-controls { 
      position: fixed;
      z-index: 30;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      padding: 6px 10px;
      display: flex;
      flex-direction: row;
      gap: 6px;
      align-items: center;
      top: 60px; 
      left: 16px; 
      right: auto; 
      transform: scale(0.64); 
      transform-origin: top left; 
      flex-wrap: wrap;
    }

    #controls button, #legend-controls button, #label-pos-controls button {
      background: #1976d2; color: #fff; border: none; border-radius: 4px;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 500; cursor: pointer;
      transition: background 0.2s;
      white-space: nowrap; 
    }
    
    #controls button:hover, #legend-controls button:hover, #label-pos-controls button:hover {
      background: #0d47a1;
    }
    #label-pos-controls button.active {
        background: #0d47a1;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }
    #controls input[type="file"] {
      display: none;
    }
    #data-table {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%) scale(0.7);
      background: rgba(255,255,255,0.98);
      border: 1px solid #cfd8dc;
      border-radius: 8px;
      overflow-y: auto;
      max-height: calc(100vh - 100px);
      z-index: 10;
      padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.08);
      min-width: 320px;
      max-width: 95vw;
      transition: box-shadow 0.2s, transform 0.3s, opacity 0.3s, visibility 0.3s; 
    }
    #data-table:hover {
      box-shadow: 0 -4px 24px rgba(25,118,210,0.13);
      transform: translateX(-50%) scale(1.08) translateY(-12px);
      z-index: 20;
    }
    #data-table table {
      border-collapse: collapse; font-size: 13px; width: auto;
      background: transparent;
      table-layout: auto;
      min-width: 100px;
      max-width: 100%;
    }
    #data-table th, #data-table td {
      border: 1px solid #e3e6ea; padding: 5px 8px; text-align: center;
      background: transparent;
      white-space: nowrap;
      height: auto;
      min-width: 40px;
      max-width: 300px;
      word-break: keep-all;
    }
    #data-table tr {
      height: auto;
    }
    #data-table thead tr:nth-child(1) th {
      text-align: center; font-size: 17px; background: #e3f2fd; color: #1976d2; padding: 10px;
    }
    #data-table thead tr:nth-child(2) th {
      text-align: right; font-size: 11px; color: #666; background: #f5f7fa; padding-bottom: 6px;
    }
    #data-table tr:nth-child(even) td { background: #f8fafc; }
    #data-table tr:hover td { background: #e3f2fd; }
    #data-table th[scope="row"] { background: #f0f4ff; font-weight: 600; }
    #data-table tr.group-mokpyo td, #data-table tr.group-mokpyo th {
      background: #e3f0ff !important;
      color: #0d47a1 !important;
    }
    #data-table tr.group-siljeok td, #data-table tr.group-siljeok th {
      background: #e8f5e9 !important;
      color: #616161 !important;
    }
    #data-table tr.group-jiphaeng td, #data-table tr.group-jiphaeng th {
      background: #fff3e0 !important;
      color: #d32f2f !important;
    }
    #data-table tr.group-mokpyo:hover td, #data-table tr.group-mokpyo:hover th {
      background: #bbdefb !important;
    }
    #data-table tr.group-siljeok:hover td, #data-table tr.group-siljeok:hover th {
      background: #b2dfdb !important;
    }
    #data-table tr.group-jiphaeng:hover td, #data-table tr.group-jiphaeng:hover th {
      background: #ffe0b2 !important;
    }
    .avg-number-cell {
      color: #b0b0b0 !important;
      font-weight: 500;
      opacity: 0.75;
    }
    #status-message {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #222; color: #fff; padding: 22px 44px;
      border-radius: 10px; font-size: 19px; z-index: 1000; display: none;
      box-shadow: 0 2px 16px rgba(0,0,0,0.18);
      animation: fadeInOut 2s ease-in-out;
    }
    @keyframes fadeInOut { 0% { opacity: 0; } 20% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }

    #showTableIcon {
        display: none; 
        position: fixed;
        bottom: 5px; 
        right: 20px;
        cursor: pointer;
        z-index: 101; 
        background-color: #1976d2;
        color: white;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
     #showTableIcon svg { 
        width: 20px;
        height: 20px;
    }


    @media (max-width: 768px) { /* 모바일 화면 대응 강화 */
      h1 { font-size: 17px; padding: 12px 0 8px 0; }
      #controls {
          top: 50px;
          right: 5px;
          transform: scale(0.75); 
          transform-origin: top right;
          width: calc(100% - 10px); 
          padding: 4px;
          gap: 4px; 
          flex-wrap: wrap; 
          justify-content: space-around; 
      }
      #controls > .control-group {
          flex-basis: content; 
          margin: 2px 0; 
      }
      #controls button { 
          padding: 5px 8px; 
          font-size: 10px; 
      }
      #zoomInstruction {
          font-size: 9px !important; 
          margin-left: 3px !important;
          flex-shrink: 1; 
          min-width: 50px; 
      }

      #label-pos-controls {
          top: 50px; 
          left: 5px; 
          right: auto; 
          transform: scale(0.6); 
          transform-origin: top left; 
          max-width: calc(100% - 20px);
      }
      #label-pos-controls button { 
          padding: 5px 10px;
          font-size: 12px;
      }
      #data-table {
        top: 95px;
        min-width: 180px;
        font-size: 11px;
        max-height: calc(100vh - 115px);
        transform: translateX(-50%) scale(0.65); 
      }
      #data-table:hover {
        transform: translateX(-50%) scale(0.9) translateY(-10px); 
      }
      #data-table table { font-size: 11px; }
      #legend-controls {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: flex-start;
        gap: 5px;
        bottom: 5px;
        left: 5px;
        right: auto; top: auto; transform: none;
        max-width: calc(100% - 10px);
      }
      #legend-controls button {
          padding: 5px 8px;
          font-size: 12px;
      }
      #showTableIcon {
        width: 35px;
        height: 35px;
        bottom: 5px; 
        right: 15px;
      }
      #showTableIcon svg {
        width: 18px;
        height: 18px;
      }
    }
    canvas { width: 100% !important; height: 100% !important; display: block; margin-top: 30px; }
    #legend-controls {
        position: fixed;
        bottom: 10px;
        left: 10px;
        transform: none;
        background: #fff;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        padding: 4px 6px;
        display: flex;
        flex-direction: row;
        gap: 4px;
        align-items: center;
        z-index: 25;
    }

    #legend-controls button {
        background: #1976d2;
        color: #fff;
        border: none;
        border-radius: 3px;
        padding: 3px 6px;
        font-size: 10px;
        transform: scale(0.8);
        transform-origin: center;
        margin: 0 -1px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
    }

    .detail-link {
        display: inline-flex;
        align-items: center;
        margin-left: 6px;
        color: #d32f2f;
        text-decoration: none;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        top: -1px;
        transform: translateY(2px);
    }

    .detail-icon {
        width: 22px;
        height: 22px;
        margin-left: 4px;
        vertical-align: middle;
        opacity: 0.85;
        transition: opacity 0.2s;
    }

    .detail-link:hover {
        color: #ff1744;
    }

    .detail-link:hover .detail-icon {
        opacity: 1;
        transform: scale(1.1);
    }
  </style>
</head>
<body>
  <h1>월별 누적 집행비 대시보드</h1>
  <div id="chart-container">
    <div id="controls">
      <div class="control-group"> 
        <button id="zoomToggleBtn" title="차트의 선택한 사각 영역을 확대하거나 축소합니다.">확대 시작</button>
        <span id="zoomInstruction" style="margin-left:5px; font-size: 12px; color: #e91e63; white-space: nowrap;"></span>
      </div>
      <div class="control-group"> 
        <input type="file" id="file-input" accept=".csv" style="display:none;">
        <button onclick="document.getElementById('file-input').click()" title="CSV 파일을 업로드하여 차트 데이터를 변경합니다.">CSV 업로드</button>
      </div>
      <div class="control-group"> 
        <button id="download-csv" title="현재 차트 데이터를 CSV 파일로 다운로드합니다.">CSV 다운로드</button>
      </div>
      <div class="control-group"> 
        <button id="toggleTableBtn" title="아래 데이터 테이블을 숨기거나 표시합니다.">테이블 보이기</button>
      </div>
    </div>
    <div id="label-pos-controls">
        <span style="font-size: 11px; color: #555; margin-right: 5px; transform: scale(0.9); display:inline-block;">차액위치:</span>
        <button id="label-pos-auto" class="active" title="차액 정보 표시 위치를 자동으로 설정합니다.">자동</button>
        <button id="label-pos-top" title="차액 정보 표시 위치를 위쪽으로 설정합니다.">위</button>
        <button id="label-pos-bottom" title="차액 정보 표시 위치를 아래쪽으로 설정합니다.">아래</button>
        <button id="label-pos-left" title="차액 정보 표시 위치를 왼쪽으로 설정합니다.">왼쪽</button>
        <button id="label-pos-right" title="차액 정보 표시 위치를 오른쪽으로 설정합니다.">오른쪽</button>
    </div>
    <canvas id="budgetChart" style="box-sizing: border-box; display: block; height: 703px; width: 1524px;" width="1920" height="886"></canvas>
    <div id="data-table" style="display: none;"><table><thead><tr><th colspan="14" style="position: relative; vertical-align: middle; line-height: 1.5; text-align: center;">
            <div style="display:inline-flex; align-items:center; justify-content:center;">
                상세 내역
                <a href="https://onedrive.live.com/edit?id=180AD984A82A90C0!315024&amp;resid=180AD984A82A90C0!315024&amp;authkey=!AMrz9S-DVX333aw&amp;ithint=file,xlsx&amp;e=LNuEh5&amp;wdo=2&amp;cid=180ad984a82a90c0" class="detail-link" target="_blank" title="상세내역 보기" style="display:inline-flex; align-items:center; margin-left:6px; color:#d32f2f; text-decoration:none;">
                    <svg class="detail-icon" viewBox="0 0 24 24" fill="currentColor" style="width:22px; height:22px; margin-left:4px; vertical-align:middle;">
                        <path d="M14,2H6C4.9,2,4,2.9,4,4v16c0,1.1,0,2,2,2h12c1.1,0,2-0.9,2-2V8L14,2z M16,18H8v-2h8V18z M16,14H8v-2h8V14z M13,9V3.5 L18.5,9H13z"></path>
                    </svg>
                </a>
            </div></th></tr><tr><th colspan="14">(단위 : 백만원)</th></tr><tr><th>구분</th><th>01월</th><th>02월</th><th>03월</th><th>04월</th><th>05월</th><th>06월</th><th>07월</th><th>08월</th><th>09월</th><th>10월</th><th>11월</th><th>12월</th><th>소계</th></tr></thead><tbody><tr class="group-jiphaeng"><td style="font-weight:bold;color:#000">집행B</td><td>23.59</td><td>6.61</td><td>25.07</td><td>58.09</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td style="font-weight:bold;">113.36</td></tr><tr class="group-jiphaeng"><td style="font-weight:bold;color:#000">집행B 평균</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>28.34</td></tr><tr class="group-mokpyo"><td style="font-weight:bold;color:#000">목표A</td><td>35.00</td><td>35.00</td><td>40.00</td><td>50.00</td><td>35.00</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td style="font-weight:bold;">195.00</td></tr><tr class="group-mokpyo"><td style="font-weight:bold;color:#000">목표A 평균</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>39.00</td></tr><tr class="group-siljeok"><td style="font-weight:bold;color:#000">실적C</td><td>53.34</td><td>32.37</td><td>38.98</td><td>56.36</td><td>52.02</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td style="font-weight:bold;">233.07</td></tr><tr class="group-siljeok"><td style="font-weight:bold;color:#000">실적C 평균</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>46.61</td></tr><tr><th style="font-weight:bold;color:#000">소계(평균제외)</th><td style="font-weight:bold">111.93</td><td style="font-weight:bold">73.97</td><td style="font-weight:bold">104.05</td><td style="font-weight:bold">164.44</td><td style="font-weight:bold">87.02</td><td style="font-weight:bold"></td><td style="font-weight:bold"></td><td style="font-weight:bold"></td><td style="font-weight:bold"></td><td style="font-weight:bold"></td><td style="font-weight:bold"></td><td style="font-weight:bold"></td><td style="font-weight:bold">541.42</td></tr></tbody></table></div>
    <div id="legend-controls">
      <button id="toggle-all" title="모든 계열 전체를 차트에 표시하거나 숨깁니다.">전체 숨기기</button>
      <button id="toggle-jiphaeng" title="집행 계열 전체를 차트에 표시하거나 숨깁니다.">집행 숨기기</button>
      <button id="toggle-mokpyo" title="목표 계열 전체를 차트에 표시하거나 숨깁니다.">목표 숨기기</button>
      <button id="toggle-siljeok" title="실적 계열 전체를 차트에 표시하거나 숨깁니다.">실적 숨기기</button>
      <button id="toggle-average" title="모든 평균 계열만 차트에 표시하거나 숨깁니다.">평균만 숨기기</button>
    </div>
  </div>
  <div id="status-message"></div>
  <div id="showTableIcon" title="숨겨진 데이터 테이블을 다시 표시합니다." style="display: flex;">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
        <path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm15 2h-4v3h4V4zm0 4h-4v3h4V8zm0 4h-4v3h3a1 1 0 0 0 1-1v-2zm-5 3v-3H6v3h4zm-5 0v-3H1v2a1 1 0 0 0 1 1h3zm-4-4h4V8H1v3zm0-4h4V4H1v3zm5-3v3h4V4H6zm4 4H6v3h4V8z"></path>
    </svg>
  </div>
  <script>
    const CONFIG = {
        detailLink: 'https://onedrive.live.com/edit?id=180AD984A82A90C0!315024&resid=180AD984A82A90C0!315024&authkey=!AMrz9S-DVX333aw&ithint=file,xlsx&e=LNuEh5&wdo=2&cid=180ad984a82a90c0'
    };

    const initialCsvData = `,01월,02월,03월,04월,05월,06월,07월,08월,09월,10월,11월,12월
집행B,23590875,6608025,25072225,58085475,,,,,,,,
집행B 평균,28339150,28339150,28339150,28339150,,,,,,,,
목표A,35000000,35000000,40000000,50000000,35000000,,,,,,,
목표A 평균,39000000,39000000,39000000,39000000,39000000,,,,,,,
실적C,53340425,32366100,38981650,56357950,52021400,,,,,,,
실적C 평균,46613505,46613505,46613505,46613505,46613505,,,,,,,
`;

    const customY = {
      0: "0원", 20000000: "이천만원", 40000000: "사천만원",
      60000000: "육천만원", 80000000: "팔천만원", 100000000: "일억원",
      120000000: "일억이천만원", 140000000: "일억사천만원",
      160000000: "일억육천만원", 180000000: "일억팔천만원"
    };
    let currentMonthLineAnimationFrameId = null;
    let jiphangBLineAnimationFrameId = null;
    let originalJiphangBData = {};
    let jiphangBAnimationCount = 0;

    let selectionPoint1 = null;
    let selectionPoint2 = null;
    let currentLabelPositionOption = 'auto';


    window.addEventListener('load', function() {
      const canvas = document.getElementById('budgetChart');
      if(canvas) {
        canvas.removeAttribute('width');
        canvas.removeAttribute('height');
      }

      if (initialCsvData && !window.isInitialLoadComplete) {
          parseCSV(initialCsvData);
          setupLegendControls();
          setupLabelPositionControls();
          window.isInitialLoadComplete = false;
      }
    });

    function showStatusMessage(message) {
      const statusDiv = document.getElementById('status-message');
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 2000);
    }

    function downloadCSV() {
        const csvLines = initialCsvData.split('\n');
        const hyperLinkRow = `#HYPERLINK#,${CONFIG.detailLink}`;
        const csvContent = [hyperLinkRow, ...csvLines].join('\n');

        const BOM = '\uFEFF';
        const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8' });
        const now = new Date();
        const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;
        const fileName = `월별 누적 집행비_(기숙사 및 사택)_CSV_${dateStr}.csv`;

        if (window.showSaveFilePicker) {
            const opts = {
                suggestedName: fileName,
                types: [{
                    description: 'CSV 파일',
                    accept: { 'text/csv': ['.csv'] }
                }]
            };

            window.showSaveFilePicker(opts)
                .then(async (fileHandle) => {
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    showStatusMessage('CSV 파일이 저장되었습니다.');
                })
                .catch(err => {
                    if (err.name !== 'AbortError') {
                        console.error('파일 저장 중 오류:', err);
                        showStatusMessage('파일 저장에 실패했습니다.');
                    }
                });
        } else {
            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(blob);
            downloadLink.download = fileName;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(downloadLink.href);
        }
    }

    function saveUpdatedHtml(newLink, csvContent) {
        try {
            const now = new Date();
            const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;
            const fileName = `월별 누적 집행비_(기숙사 및 사택)_HTML_${dateStr}.html`;

            let htmlContent = document.documentElement.outerHTML;

            htmlContent = htmlContent.replace(
                /window\.isInitialLoadComplete\s*=\s*true/g,
                'window.isInitialLoadComplete = false'
            );

            htmlContent = htmlContent.replace(
                /(const CONFIG = \{[\s\S]*?detailLink:\s*')[^']*('[\s\S]*?\};)/,
                `$1${newLink}$2`
            );

            if (csvContent) {
                htmlContent = htmlContent.replace(
                    /(const initialCsvData = `)([\s\S]*?)(`)/,
                    `$1${csvContent.replace(/`/g, '\\`')}$3`
                );
            }

            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });

            if (window.showSaveFilePicker) {
                const opts = {
                    suggestedName: fileName,
                    types: [{
                        description: 'HTML 파일',
                        accept: { 'text/html': ['.html'] }
                    }]
                };

                window.showSaveFilePicker(opts)
                    .then(async (fileHandle) => {
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        showStatusMessage('HTML 파일이 저장되었습니다.');
                    })
                    .catch(err => {
                        if (err.name !== 'AbortError') {
                            console.error('파일 저장 중 오류:', err);
                            showStatusMessage('파일 저장에 실패했습니다.');
                        }
                    });
            } else {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }
        } catch (error) {
            console.error('HTML 저장 중 오류:', error);
            showStatusMessage('HTML 파일 저장에 실패했습니다.');
        }
    }

    document.getElementById('file-input').addEventListener('change', function(e){
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        const csvContent = ev.target.result;
        const lines = csvContent.split('\n');

        let hyperlink = CONFIG.detailLink;
        let actualCsvContent = csvContent;

        if (lines[0].startsWith('#HYPERLINK#')) {
            hyperlink = lines[0].split(',')[1]?.trim() || CONFIG.detailLink;
            actualCsvContent = lines.slice(1).join('\n');
        }

        showHyperlinkDialog(hyperlink, actualCsvContent);
      };
      reader.readAsText(file, 'utf-8');
      e.target.value = null;
    });

    function showHyperlinkDialog(currentLink, csvContent) {
        const dialog = document.createElement('div');
        dialog.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            min-width: 400px;
        `;

        dialog.innerHTML = `
            <h3 style="margin-top:0;">상세내역 링크 설정</h3>
            <p style="margin:10px 0 5px 0;">상세내역 링크를 확인하거나 수정하세요:</p>
            <input type="text" id="hyperlink-input" value="${currentLink}"
                   style="width:100%; padding:8px; margin:5px 0; box-sizing:border-box;">
            <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:15px;">
                <button onclick="processCSVWithHyperlink(this.parentElement.parentElement, '${encodeURIComponent(csvContent)}')"
                        style="padding:8px 16px; background:#4CAF50; color:white; border:none; border-radius:4px; cursor:pointer;">
                    확인
                </button>
                <button onclick="this.parentElement.parentElement.remove()"
                        style="padding:8px 16px; background:#f44336; color:white; border:none; border-radius:4px; cursor:pointer;">
                    취소
                </button>
            </div>
        `;

        document.body.appendChild(dialog);
    }

    function processCSVWithHyperlink(dialog, encodedCsvContent) {
        try {
            const newLink = document.getElementById('hyperlink-input').value.trim();
            const csvContent = decodeURIComponent(encodedCsvContent);

            CONFIG.detailLink = newLink || CONFIG.detailLink;
            parseCSV(csvContent);

            const detailLinkElement = document.querySelector('#data-table .detail-link');
            if (detailLinkElement) {
                detailLinkElement.href = CONFIG.detailLink;
            }

            dialog.remove();
            
            isTableVisibleUserSettings = false; // CSV 업로드 후 테이블 자동 숨김
            updateTableAndControlsVisibility();

            if (confirm('변경된 내용을 HTML 파일로 저장하시겠습니까?')) {
                saveUpdatedHtml(CONFIG.detailLink, csvContent);
            }
        } catch (error) {
            console.error('데이터 처리 중 오류:', error);
            showStatusMessage('오류가 발생했습니다.');
        }
    }

    function parseCSV(text) {
      selectionPoint1 = null;
      selectionPoint2 = null;

      const lines = text.trim().split(/\r?\n/);
      if (lines.length < 2) { alert('데이터가 없습니다.'); return; }
      const header = lines[0].split(',');
      const months = header.slice(1);
      const datasets = [], tableRows = [];
      originalJiphangBData = {};

      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(',');
        const label = cols[0].trim();

        if (label.startsWith('목표C')) {
            continue;
        }

        const vals = cols.slice(1).map(v => {
            const trimmedVal = v.trim();
            return trimmedVal === '' ? null : Number(trimmedVal);
        });

        const nonZeroOrNullExists = vals.some(v => v !== null && v !== 0);
        if (!label || (!nonZeroOrNullExists && !label.startsWith('집행B') && !label.endsWith(' 평균')) || label.includes('집행율') ) {
            if (label && vals.every(v => v === null || v === 0) && !label.includes('집행율')) {
            } else if (!label || label.includes('집행율')) {
                continue;
            } else if (!nonZeroOrNullExists && !label.startsWith('집행B') && !label.endsWith(' 평균')) {
                continue;
            }
        }

        const base = label.replace(/ 평균$/, '');
        const isAvg = /평균$/.test(label);
        let color = 'black', bw = 3, ps = 'circle', pRadius = 9, borderDashStyle = [];
        let initialDataForAnimation = [...vals];

        if (label.startsWith('집행B')) {
          if (label.includes('평균')) {
            color = 'rgba(255,0,0,0.5)'; bw = 5; ps = 'line'; pRadius = 6; borderDashStyle = [5,5];
          } else {
            color = 'red'; bw = 7; ps = 'circle'; pRadius = 9; borderDashStyle = [];
          }
          originalJiphangBData[label] = [...vals];
          initialDataForAnimation = new Array(vals.length).fill(null);
          if (vals.length > 0 && vals[0] !== null) initialDataForAnimation[0] = vals[0];
        } else if (base.includes('목표A')) {
          color = 'rgba(0,0,255,0.8)'; bw = isAvg ? 3 : 5; ps = isAvg ? 'line' : 'rect'; pRadius = isAvg ? 6 : 9;
          if(isAvg) borderDashStyle = [5,5];
        } else if (base.includes('실적C')) {
          color = 'rgba(128,128,128,0.8)'; bw = isAvg ? 2 : 4; ps = isAvg ? 'line' : 'triangle'; pRadius = isAvg ? 6 : 9;
          if(isAvg) borderDashStyle = [5,5];
        } else if (base.includes('목표C')) {
           color = 'rgba(0,128,0,0.8)';
           bw = isAvg ? 3 : 5;
           ps = isAvg ? 'line' : 'star';
           pRadius = isAvg ? 6 : 9;
           if(isAvg) borderDashStyle = [5,5];
        } else if (isAvg) {
            color = 'rgba(100,100,100,0.7)'; ps = 'line'; pRadius = 6; borderDashStyle = [5,5];
        }

        datasets.push({
            label, data: initialDataForAnimation, borderColor: color, borderDash: borderDashStyle,
            borderWidth: bw, tension: 0.3, pointStyle: ps, pointRadius: pRadius,
            pointBackgroundColor: '#fff', pointBorderColor: color, pointBorderWidth: 2,
            pointHoverRadius: 12, fill: false,
            hidden: false
        });

        if(label && !label.includes('집행율')){ tableRows.push({ label, vals, isAvg }); }
      }
      tableRows.sort((a, b) => a.label.localeCompare(b.label));
      renderChart(months, datasets);
      renderTable(months, tableRows);
      updateLegendButtonStates();
    }

    function renderChart(labels, datasets) {
      const ctx = document.getElementById('budgetChart').getContext('2d');
      if (budgetChart) {
        budgetChart.destroy();
        if (currentMonthLineAnimationFrameId) cancelAnimationFrame(currentMonthLineAnimationFrameId);
        currentMonthLineAnimationFrameId = null;
        if (jiphangBLineAnimationFrameId) clearTimeout(jiphangBLineAnimationFrameId);
        jiphangBLineAnimationFrameId = null;
        jiphangBAnimationCount = 0;
      }

      const currentMonthIndex = new Date().getMonth();
      const annotations = {};
      const yAxisMinVal = 0;

      if (currentMonthIndex < labels.length) {
          annotations.currentMonthLineMarker = {
              id: 'currentMonthLineMarker', type: 'line', xScaleID: 'x', yScaleID: 'y',
              xMin: currentMonthIndex, xMax: currentMonthIndex, yMin: yAxisMinVal, yMax: yAxisMinVal,
              borderColor: 'rgba(255, 99, 132, 0.8)', borderWidth: 5, borderDash: [6, 6],
              label: {
                  content: '현재 월', enabled: true, position: 'start', yAdjust: -25,
                  backgroundColor: 'rgba(255, 255, 255, 0.75)',
                  font: { size: 20, weight: 'bold' }, color: 'rgba(255, 99, 132, 1)'
              }
          };
      }

      budgetChart = new Chart(ctx, {
        type: 'line', data: { labels, datasets },
        options: {
            responsive: true, maintainAspectRatio: false, animation: { duration: 0 }, hover: { animationDuration: 0 },
            layout: { padding: { bottom: 60 } },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: { usePointStyle: true, font: { size: 14 }, boxWidth: 15, padding: 20 },
                    onClick: function(e, legendItem, legend) {
                        Chart.defaults.plugins.legend.onClick.call(this, e, legendItem, legend);
                        const clickedDataset = legend.chart.data.datasets.find(ds => ds.label === legendItem.text);
                        if (clickedDataset && clickedDataset.hidden) {
                            if (selectionPoint1 && selectionPoint1.datasetLabel === clickedDataset.label) {
                                selectionPoint1 = null;
                            }
                            if (selectionPoint2 && selectionPoint2.datasetLabel === clickedDataset.label) {
                                selectionPoint2 = null;
                            }
                        }
                        showDeviationAnnotation();
                    }
                },
                tooltip: { enabled: true, mode: 'nearest', intersect: true, position: 'nearest', caretPadding: 10, titleFont: { size: 18 }, bodyFont: { size: 18 }, padding: 12, filter: tooltipItem => tooltipItem.dataset.data[tooltipItem.dataIndex] != null, animation: false },
                annotation: {
                    annotations: annotations
                }
            },
            interaction: { mode: 'nearest', axis: 'xy', intersect: true },
            scales: {
                x: { ticks: { font: { size: 18 } }, min: 0, max: labels.length > 0 ? labels.length - 1 : 0, grid: { display: true } },
                y: { beginAtZero: true, min: 0, max: 180000000, ticks: { callback: v => customY[v] || '', font: { size: 18 }}, grid: { display: true }}
            },
            elements: { line: { tension: 0.3 } }
        }
      });

      if (annotations.currentMonthLineMarker && budgetChart.options.plugins.annotation.annotations.currentMonthLineMarker) {
        const yAxis = budgetChart.scales.y;
        if (!yAxis) { console.error("Y-axis not found for vertical line animation."); return; }
        const yMinChart = yAxis.min; const yMaxChart = yAxis.max;
        budgetChart.options.plugins.annotation.annotations.currentMonthLineMarker.yMin = yMinChart;
        budgetChart.options.plugins.annotation.annotations.currentMonthLineMarker.yMax = yMinChart;
        budgetChart.update('none');
        let verticalAnimationCount = 0; const maxVerticalAnimations = 2; let currentYMax = yMinChart;
        const animationDurationFrames = 50; const animationStep = (yMaxChart - yMinChart) / animationDurationFrames;
        function animateVerticalLine() {
          if (!budgetChart || !budgetChart.options?.plugins?.annotation?.annotations?.currentMonthLineMarker) {
            if (currentMonthLineAnimationFrameId) cancelAnimationFrame(currentMonthLineAnimationFrameId);
            currentMonthLineAnimationFrameId = null; return;
          }
          currentYMax += animationStep;
          if (currentYMax >= yMaxChart) {
            currentYMax = yMaxChart;
            budgetChart.options.plugins.annotation.annotations.currentMonthLineMarker.yMax = currentYMax;
            budgetChart.update('none');
            verticalAnimationCount++;
            if (verticalAnimationCount === 1) { startJiphangBAnimation(); }
            if (verticalAnimationCount < maxVerticalAnimations) {
              setTimeout(() => {
                if (!budgetChart || !budgetChart.options?.plugins?.annotation?.annotations?.currentMonthLineMarker) {
                   if (currentMonthLineAnimationFrameId) cancelAnimationFrame(currentMonthLineAnimationFrameId);
                   currentMonthLineAnimationFrameId = null; return;
                }
                currentYMax = yMinChart;
                budgetChart.options.plugins.annotation.annotations.currentMonthLineMarker.yMax = currentYMax;
                budgetChart.update('none');
                currentMonthLineAnimationFrameId = requestAnimationFrame(animateVerticalLine);
              }, 300);
            } else {
              currentMonthLineAnimationFrameId = null;
            }
          } else {
            budgetChart.options.plugins.annotation.annotations.currentMonthLineMarker.yMax = currentYMax;
            budgetChart.update('none');
            currentMonthLineAnimationFrameId = requestAnimationFrame(animateVerticalLine);
          }
        }
        setTimeout(() => {
            if (budgetChart && budgetChart.scales && budgetChart.scales.y) {
                 currentMonthLineAnimationFrameId = requestAnimationFrame(animateVerticalLine);
            }
        }, 100);
      }
      showDeviationAnnotation();
    }

    function startJiphangBAnimation() {
        if (!budgetChart || Object.keys(originalJiphangBData).length === 0) { return; }
        const datasetsToAnimate = budgetChart.data.datasets.filter(ds => ds.label.startsWith('집행B'));
        if (datasetsToAnimate.length === 0) return;

        datasetsToAnimate.forEach(ds => {
            const originalData = originalJiphangBData[ds.label];
            if (originalData) {
                ds.data = new Array(originalData.length).fill(null);
                if (originalData.length > 0 && originalData[0] !== null) {
                    ds.data[0] = originalData[0];
                }
            }
        });
        budgetChart.update('none');

        let currentPointIndex = 0;
        const firstDatasetLabel = datasetsToAnimate[0].label;
        const maxPointIndex = originalJiphangBData[firstDatasetLabel] ? originalJiphangBData[firstDatasetLabel].length : 0;

        if (maxPointIndex === 0) return;
        const pointRevealDelay = 350;
        const maxJiphangBAnimations = 2;

        function animateJiphangBLines() {
            if (!budgetChart) {
                if (jiphangBLineAnimationFrameId) clearTimeout(jiphangBLineAnimationFrameId);
                jiphangBLineAnimationFrameId = null; return;
            }
            currentPointIndex++;
            if (currentPointIndex >= maxPointIndex) {
                datasetsToAnimate.forEach(ds => {
                    if(originalJiphangBData[ds.label]) ds.data = [...originalJiphangBData[ds.label]];
                });
                budgetChart.update('none');
                jiphangBAnimationCount++;

                if (jiphangBAnimationCount < maxJiphangBAnimations) {
                    currentPointIndex = 0;
                    datasetsToAnimate.forEach(ds => {
                        const originalData = originalJiphangBData[ds.label];
                        if (originalData) {
                            ds.data = new Array(originalData.length).fill(null);
                            if (originalData.length > 0 && originalData[0] !== null) {
                                ds.data[0] = originalData[0];
                            }
                        }
                    });
                    budgetChart.update('none');
                    jiphangBLineAnimationFrameId = setTimeout(animateJiphangBLines, 100);
                } else {
                    if (jiphangBLineAnimationFrameId) clearTimeout(jiphangBLineAnimationFrameId);
                    jiphangBLineAnimationFrameId = null;
                }
                return;
            }

            datasetsToAnimate.forEach(ds => {
                const originalData = originalJiphangBData[ds.label];
                if (originalData && currentPointIndex < originalData.length) {
                    ds.data[currentPointIndex] = originalData[currentPointIndex];
                }
            });
            budgetChart.update({duration: pointRevealDelay - 50 > 0 ? pointRevealDelay - 50 : 0, easing: 'linear'});
            jiphangBLineAnimationFrameId = setTimeout(animateJiphangBLines, pointRevealDelay);
        }
        jiphangBLineAnimationFrameId = setTimeout(animateJiphangBLines, 50);
    }

    function renderTable(months, rows) {
        const sortedRows = [
            ...rows.filter(r => r.label.includes('집행B')),
            ...rows.filter(r => r.label.includes('목표A')),
            ...rows.filter(r => r.label.includes('실적C'))
        ].sort((a,b) => {
            const getOrder = (label) => {
                if (label.startsWith('집행B')) return 1;
                if (label.startsWith('목표A')) return 2;
                if (label.startsWith('실적C')) return 3;
                return 4;
            };
            const orderA = getOrder(a.label);
            const orderB = getOrder(b.label);
            if (orderA !== orderB) return orderA - orderB;
            return a.isAvg - b.isAvg;
        });

        const container = document.getElementById('data-table');
        container.innerHTML = '';
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const tbody = document.createElement('tbody');

        const tr0 = document.createElement('tr');
        const th0 = document.createElement('th');
        th0.colSpan = months.length + 2;
        th0.style.cssText = 'position:relative; vertical-align:middle; line-height:1.5; text-align:center;';
        th0.innerHTML = `
            <div style="display:inline-flex; align-items:center; justify-content:center;">
                상세 내역
                <a href="${CONFIG.detailLink}"
                   class="detail-link"
                   target="_blank"
                   title="상세내역 보기"
                   style="display:inline-flex; align-items:center; margin-left:6px; color:#d32f2f; text-decoration:none;">
                    <svg class="detail-icon" viewBox="0 0 24 24" fill="currentColor"
                         style="width:22px; height:22px; margin-left:4px; vertical-align:middle;">
                        <path d="M14,2H6C4.9,2,4,2.9,4,4v16c0,1.1,0,2,2,2h12c1.1,0,2-0.9,2-2V8L14,2z M16,18H8v-2h8V18z M16,14H8v-2h8V14z M13,9V3.5 L18.5,9H13z"/>
                    </svg>
                </a>
            </div>`;
        tr0.appendChild(th0);
        thead.appendChild(tr0);

        const tr1 = document.createElement('tr'); const th1 = document.createElement('th');
        th1.colSpan = months.length + 2; th1.textContent = '(단위 : 백만원)';
        tr1.appendChild(th1); thead.appendChild(tr1);

        const trh = document.createElement('tr');
        trh.innerHTML = '<th>구분</th>' + months.map(m => `<th>${m}</th>`).join('') + '<th>소계</th>';
        thead.appendChild(trh);

        const monthlySum = new Array(months.length).fill(0);
        const averageLabelsForStyling = ["목표A 평균", "실적C 평균", "집행B 평균"];

        sortedRows.forEach(r => {
            const tr = document.createElement('tr');
            let groupClass = '';
            if (r.label.includes('목표A')) groupClass = 'group-mokpyo';
            else if (r.label.includes('실적C')) groupClass = 'group-siljeok';
            else if (r.label.includes('집행B')) groupClass = 'group-jiphaeng';

            if (groupClass) tr.classList.add(groupClass);

            tr.innerHTML = `<td style="font-weight:bold;color:#000">${r.label}</td>`;
            const isStyledAverageLabel = averageLabelsForStyling.includes(r.label);
            r.vals.forEach((v, idx) => {
                let txt = v == null ? '' : (v / 1e6).toFixed(2);
                if (txt === '0.00') txt = '';
                if (isStyledAverageLabel) {
                  tr.innerHTML += `<td></td>`;
                } else {
                  tr.innerHTML += `<td>${txt}</td>`;
                }
            });
            let sumVal;
            const validVals = r.vals.filter(v => v != null);
            if (r.isAvg) {
                sumVal = validVals.length > 0 ? (validVals.reduce((s, v) => s + v, 0) / validVals.length) : 0;
            } else {
                sumVal = validVals.reduce((s, v) => s + v, 0);
            }
            let sumTxt = (sumVal / 1e6).toFixed(2);
            if (sumTxt === '0.00') sumTxt = '';
            let sumCellStyle = 'font-weight:bold;';
            if (isStyledAverageLabel) {
                tr.innerHTML += `<td>${sumTxt}</td>`;
            } else if (r.isAvg) {
                sumCellStyle += 'color:rgba(100,100,100,0.7);';
                tr.innerHTML += `<td style="${sumCellStyle}">${sumTxt}</td>`;
            } else {
                tr.innerHTML += `<td style="${sumCellStyle}">${sumTxt}</td>`;
            }
            if (!r.isAvg) {
                r.vals.forEach((v, i) => {
                    if (v != null) monthlySum[i] += v;
                });
            }
            tbody.appendChild(tr);
        });
        const trSum = document.createElement('tr');
        let sumRow = '<th style="font-weight:bold;color:#000">소계(평균제외)</th>';
        monthlySum.forEach(v => {
            let txt = (v / 1e6).toFixed(2);
            if (txt === '0.00') txt = '';
            sumRow += `<td style="font-weight:bold">${txt}</td>`;
        });
        const totalAll = monthlySum.reduce((a, b) => a + b, 0);
        let totalTxt = (totalAll / 1e6).toFixed(2);
        if (totalTxt === '0.00') totalTxt = '';
        sumRow += `<td style="font-weight:bold">${totalTxt}</td>`;
        trSum.innerHTML = sumRow;
        tbody.appendChild(trSum);
        table.appendChild(thead);
        table.appendChild(tbody);
        container.appendChild(table);
        setTimeout(() => {
          const tds = table.querySelectorAll('td,th');
          tds.forEach(cell => {
            cell.style.width = '';
            cell.style.height = '';
            cell.style.maxWidth = '300px';
            cell.style.whiteSpace = 'nowrap';
            cell.style.overflow = 'hidden';
            cell.style.textOverflow = 'ellipsis';
          });
        }, 0);
    }

    function setupLabelPositionControls() {
        const positions = ['auto', 'top', 'bottom', 'left', 'right'];
        positions.forEach(pos => {
            const btn = document.getElementById(`label-pos-${pos}`);
            if (btn) {
                btn.addEventListener('click', function() {
                    currentLabelPositionOption = pos;
                    document.querySelectorAll('#label-pos-controls button').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    showDeviationAnnotation();
                });
            }
        });
    }


    function setupLegendControls() {
        const buttonIds = [
            'toggle-all', 'toggle-jiphaeng', 'toggle-mokpyo', 'toggle-siljeok', 'toggle-average'
        ];
        buttonIds.forEach(id => {
            const oldBtn = document.getElementById(id);
            if (!oldBtn) return;
            const newBtn = oldBtn.cloneNode(true);
            newBtn.addEventListener('click', () => {
                if (!budgetChart || !budgetChart.data || !budgetChart.data.datasets) return;

                let mainLabelPattern = null;
                let averageLabelPattern = null;
                let isToggleAll = false;
                let isToggleAverageOnly = false;

                if (id === 'toggle-jiphaeng') {
                    mainLabelPattern = '집행B'; averageLabelPattern = '집행B 평균';
                } else if (id === 'toggle-mokpyo') {
                    mainLabelPattern = '목표A'; averageLabelPattern = '목표A 평균';
                } else if (id === 'toggle-siljeok') {
                    mainLabelPattern = '실적C'; averageLabelPattern = '실적C 평균';
                } else if (id === 'toggle-all') {
                    isToggleAll = true;
                } else if (id === 'toggle-average') {
                    isToggleAverageOnly = true;
                }

                let datasetsWereModified = false;

                if (isToggleAll) {
                    const allDatasets = budgetChart.data.datasets;
                    const allHidden = allDatasets.every(ds => ds.hidden);
                    allDatasets.forEach(ds => {
                        if (ds.hidden !== !allHidden) {
                            ds.hidden = !allHidden;
                            datasetsWereModified = true;
                            if(ds.hidden) {
                                if (selectionPoint1 && selectionPoint1.datasetLabel === ds.label) selectionPoint1 = null;
                                if (selectionPoint2 && selectionPoint2.datasetLabel === ds.label) selectionPoint2 = null;
                            }
                        }
                    });
                    if (datasetsWereModified && !allHidden) {
                        selectionPoint1 = null; selectionPoint2 = null;
                    }
                } else if (isToggleAverageOnly) {
                    const averageDatasets = budgetChart.data.datasets.filter(ds => ds.label.endsWith(' 평균'));
                    if (averageDatasets.length > 0) {
                        const allHidden = averageDatasets.every(ds => ds.hidden);
                        averageDatasets.forEach(ds => {
                            if (ds.hidden !== !allHidden) {
                                ds.hidden = !allHidden;
                                datasetsWereModified = true;
                                if (ds.hidden) {
                                    if (selectionPoint1 && selectionPoint1.datasetLabel === ds.label) selectionPoint1 = null;
                                    if (selectionPoint2 && selectionPoint2.datasetLabel === ds.label) selectionPoint2 = null;
                                }
                            }
                        });
                    }
                } else if (mainLabelPattern) {
                    const datasetsToToggle = budgetChart.data.datasets.filter(ds =>
                        ds.label === mainLabelPattern || ds.label === averageLabelPattern
                    );
                    if (datasetsToToggle.length > 0) {
                        const currentlyAllHiddenInGroup = datasetsToToggle.every(ds => ds.hidden);
                        datasetsToToggle.forEach(ds => {
                            if(ds.hidden !== !currentlyAllHiddenInGroup) {
                                ds.hidden = !currentlyAllHiddenInGroup;
                                datasetsWereModified = true;
                                if (ds.hidden) {
                                   if (selectionPoint1 && selectionPoint1.datasetLabel === ds.label) selectionPoint1 = null;
                                   if (selectionPoint2 && selectionPoint2.datasetLabel === ds.label) selectionPoint2 = null;
                                }
                            }
                        });
                    }
                }

                if(datasetsWereModified) {
                    budgetChart.update();
                    updateLegendButtonStates();
                    showDeviationAnnotation();
                }
            });
            oldBtn.parentNode.replaceChild(newBtn, oldBtn);
        });
    }


    function updateLegendButtonStates() {
        if (!budgetChart || !budgetChart.data || !budgetChart.data.datasets) return;

        const updateButtonState = (mainLabelPattern, averageLabelPattern, buttonId, buttonTextPrefix) => {
            const button = document.getElementById(buttonId);
            if (!button) return;
            const mainDataset = budgetChart.data.datasets.find(ds => ds.label === mainLabelPattern);
            const avgDataset = budgetChart.data.datasets.find(ds => ds.label === averageLabelPattern);

            let isCurrentlyVisible = false;
            if (mainDataset && !mainDataset.hidden) isCurrentlyVisible = true;
            if (avgDataset && !avgDataset.hidden) isCurrentlyVisible = true;

            if (mainDataset || avgDataset) {
                 button.textContent = `${buttonTextPrefix} ${isCurrentlyVisible ? '숨기기' : '보이기'}`;
            } else {
                 button.textContent = `${buttonTextPrefix} 전체`;
            }
        };

        const updateAverageOnlyButtonState = (buttonId, buttonTextPrefix) => {
            const button = document.getElementById(buttonId);
            if (!button) return;
            const averageDatasets = budgetChart.data.datasets.filter(ds => ds.label.endsWith(' 평균'));
            if (averageDatasets.length > 0) {
                const allHidden = averageDatasets.every(ds => ds.hidden);
                button.textContent = `${buttonTextPrefix} ${allHidden ? '보이기' : '숨기기'}`;
            } else {
                button.textContent = `${buttonTextPrefix} 전체`;
            }
        };

        const updateAllButtonState = () => {
            const button = document.getElementById('toggle-all');
            if (!button) return;

            const allDatasets = budgetChart.data.datasets;
            if (allDatasets.length > 0) {
                const allHidden = allDatasets.every(ds => ds.hidden);
                button.textContent = `전체 ${allHidden ? '보이기' : '숨기기'}`;
            } else {
                 button.textContent = `전체 전체`;
            }
        };

        updateButtonState('목표A', '목표A 평균', 'toggle-mokpyo', '목표');
        updateButtonState('집행B', '집행B 평균', 'toggle-jiphaeng', '집행');
        updateButtonState('실적C', '실적C 평균', 'toggle-siljeok', '실적');
        updateAverageOnlyButtonState('toggle-average', '평균만');
        updateAllButtonState();
    }

    function addMonthSelectionFeatureLogic(evt) {
        if (!budgetChart) return;

        const points = budgetChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
        let clickedPointInfo = null;

        if (points.length > 0) {
            const point = points[0];
            const dataset = budgetChart.data.datasets[point.datasetIndex];
            if (dataset && !dataset.hidden && dataset.data[point.index] != null) {
                clickedPointInfo = {
                    monthIndex: point.index,
                    datasetLabel: dataset.label,
                    value: dataset.data[point.index],
                    color: dataset.borderColor || dataset.backgroundColor
                };
            }
        }

        if (clickedPointInfo) {
            if (!selectionPoint1) {
                selectionPoint1 = clickedPointInfo;
                selectionPoint2 = null;
            } else if (!selectionPoint2) {
                if (selectionPoint1.monthIndex === clickedPointInfo.monthIndex && selectionPoint1.datasetLabel === clickedPointInfo.datasetLabel) {
                    selectionPoint1 = null;
                } else {
                    selectionPoint2 = clickedPointInfo;
                }
            } else {
                selectionPoint1 = clickedPointInfo;
                selectionPoint2 = null;
            }
        } else if (!points.length) {
            selectionPoint1 = null;
            selectionPoint2 = null;
        }
        showDeviationAnnotation();
    }


    function showDeviationAnnotation() {
        if (!budgetChart || !budgetChart.options || !budgetChart.options.plugins || !budgetChart.options.plugins.annotation) return;

        const ann = budgetChart.options.plugins.annotation.annotations;
        const existingAnnotationKeys = Object.keys(ann);
        existingAnnotationKeys.forEach(key => {
            if (key !== 'currentMonthLineMarker' && key !== 'zoomPreviewRect') { 
                 ann[key] = undefined;
            }
        });


        if (selectionPoint1) {
            const monthLabel1 = budgetChart.data.labels[selectionPoint1.monthIndex];
            ann.selectedPointMarker1 = {
                id: 'selectedPointMarker1',
                type: 'point',
                xValue: selectionPoint1.monthIndex,
                yValue: selectionPoint1.value,
                backgroundColor: selectionPoint1.color || 'rgba(25, 118, 210, 0.8)',
                borderColor: '#FFFFFF',
                borderWidth: 2.5,
                radius: 9,
                label: {
                    enabled: true,
                    content: `${selectionPoint1.datasetLabel.replace(" 평균", "Avg")} (${monthLabel1})`,
                    position: 'top',
                    yAdjust: -18,
                    backgroundColor: 'rgba(255,255,255,0.9)',
                    font: { size: 13, weight: '600' },
                    color: selectionPoint1.color || '#1976d2',
                    padding: {top: 4, bottom:4, left: 6, right: 6},
                    borderRadius: 4,
                    shadowOffsetX: 1,
                    shadowOffsetY: 1,
                    shadowBlur: 2,
                    shadowColor: 'rgba(0,0,0,0.15)'
                }
            };
        }

        if (selectionPoint2) {
            const monthLabel2 = budgetChart.data.labels[selectionPoint2.monthIndex];
            ann.selectedPointMarker2 = {
                id: 'selectedPointMarker2',
                type: 'point',
                xValue: selectionPoint2.monthIndex,
                yValue: selectionPoint2.value,
                backgroundColor: selectionPoint2.color || 'rgba(233, 30, 99, 0.8)',
                borderColor: '#FFFFFF',
                borderWidth: 2.5,
                radius: 9,
                 label: {
                    enabled: true,
                    content: `${selectionPoint2.datasetLabel.replace(" 평균", "Avg")} (${monthLabel2})`,
                    position: 'top',
                    yAdjust: -18,
                    backgroundColor: 'rgba(255,255,255,0.9)',
                    font: { size: 13, weight: '600' },
                    color: selectionPoint2.color || '#e91e63',
                    padding: {top: 4, bottom:4, left: 6, right: 6},
                    borderRadius: 4,
                    shadowOffsetX: 1,
                    shadowOffsetY: 1,
                    shadowBlur: 2,
                    shadowColor: 'rgba(0,0,0,0.15)'
                }
            };
        }


        if (selectionPoint1 && selectionPoint2) {
            if (selectionPoint1.value != null && selectionPoint2.value != null) {
                const val1 = selectionPoint1.value;
                const val2 = selectionPoint2.value;
                const diff = val2 - val1;

                const yLineMin = Math.min(val1, val2);
                const yLineMax = Math.max(val1, val2);

                let lineXDataValue;
                const pixelXOffsetForLine = 7;

                const targetMonthIndexForLine = Math.max(selectionPoint1.monthIndex, selectionPoint2.monthIndex);
                const basePixelXForLine = budgetChart.scales.x.getPixelForValue(targetMonthIndexForLine);

                if (selectionPoint1.monthIndex === selectionPoint2.monthIndex) {
                    const chartArea = budgetChart.chartArea;
                    if (basePixelXForLine + pixelXOffsetForLine + 5 > chartArea.right) {
                        lineXDataValue = budgetChart.scales.x.getValueForPixel(basePixelXForLine - pixelXOffsetForLine);
                    } else {
                        lineXDataValue = budgetChart.scales.x.getValueForPixel(basePixelXForLine + pixelXOffsetForLine);
                    }
                } else {
                    if (targetMonthIndexForLine < budgetChart.data.labels.length - 1 || selectionPoint1.monthIndex < targetMonthIndexForLine) {
                         lineXDataValue = budgetChart.scales.x.getValueForPixel(basePixelXForLine + pixelXOffsetForLine);
                    } else {
                         lineXDataValue = budgetChart.scales.x.getValueForPixel(basePixelXForLine - pixelXOffsetForLine);
                    }
                }

                ann.deviationConnectLine = {
                    type: 'line',
                    xMin: selectionPoint1.monthIndex,
                    yMin: val1,
                    xMax: selectionPoint2.monthIndex,
                    yMax: val2,
                    borderColor: 'rgba(150,150,150,0.7)',
                    borderWidth: 1.5,
                    borderDash: [4, 4]
                };

                ann.deviationValueLine = {
                    id: 'deviationValueLine',
                    type: 'line',
                    xMin: lineXDataValue,
                    xMax: lineXDataValue,
                    yMin: yLineMin,
                    yMax: yLineMax,
                    borderColor: 'rgba(255, 152, 0, 0.85)',
                    borderWidth: 3.5,
                };

                if (selectionPoint1.monthIndex === selectionPoint2.monthIndex && Math.abs(val1-val2) > 0) {
                    const capLengthPixel = 6;
                    const capColor = 'rgba(255, 152, 0, 0.85)';
                    const capWidth = 2.5;

                    const linePixelX = budgetChart.scales.x.getPixelForValue(lineXDataValue);

                    ann.deviationTopCap = {
                        type: 'line',
                        xMin: budgetChart.scales.x.getValueForPixel(linePixelX - capLengthPixel),
                        xMax: budgetChart.scales.x.getValueForPixel(linePixelX + capLengthPixel),
                        yMin: yLineMax,
                        yMax: yLineMax,
                        borderColor: capColor,
                        borderWidth: capWidth
                    };
                    ann.deviationBottomCap = {
                        type: 'line',
                        xMin: budgetChart.scales.x.getValueForPixel(linePixelX - capLengthPixel),
                        xMax: budgetChart.scales.x.getValueForPixel(linePixelX + capLengthPixel),
                        yMin: yLineMin,
                        yMax: yLineMin,
                        borderColor: capColor,
                        borderWidth: capWidth
                    };
                }

                const ds1LabelShort = selectionPoint1.datasetLabel.replace(" 평균", "Avg");
                const ds2LabelShort = selectionPoint2.datasetLabel.replace(" 평균", "Avg");
                const month1Short = budgetChart.data.labels[selectionPoint1.monthIndex];
                const month2Short = budgetChart.data.labels[selectionPoint2.monthIndex];

                const labelText = `${ds2LabelShort}(${month2Short}) - ${ds1LabelShort}(${month1Short}) = ${(diff / 1e6).toFixed(2)}백만`;
                const fontSize = 19;
                const paddingValue = 10;

                const ctx = budgetChart.ctx;
                ctx.font = `700 ${fontSize}px 'Noto Sans KR', sans-serif`;
                const textMetrics = ctx.measureText(labelText);
                const estimatedLabelWidth = textMetrics.width + (paddingValue * 2);
                const estimatedLabelHeight = fontSize + (paddingValue * 2) + 5;

                let labelXValue = lineXDataValue;
                let labelYValue = (yLineMin + yLineMax) / 2;
                let labelXAdjust = 0;
                let labelYAdjust = 0;

                const labelOffset = 15;
                const labelHeightOffset = estimatedLabelHeight / 2 + labelOffset;
                const labelWidthOffset = estimatedLabelWidth / 2 + labelOffset;

                if (currentLabelPositionOption === 'top') {
                    labelYAdjust = -labelHeightOffset;
                } else if (currentLabelPositionOption === 'bottom') {
                    labelYAdjust = labelHeightOffset;
                } else if (currentLabelPositionOption === 'left') {
                    labelXAdjust = -labelWidthOffset;
                    const linePixelXForLabel = budgetChart.scales.x.getPixelForValue(lineXDataValue);
                    if (linePixelXForLabel + labelXAdjust < budgetChart.chartArea.left + 10) {
                        labelXAdjust = -(linePixelXForLabel - budgetChart.chartArea.left - 10) + 5;
                    }

                } else if (currentLabelPositionOption === 'right') {
                    labelXAdjust = labelWidthOffset;
                    const linePixelXForLabel = budgetChart.scales.x.getPixelForValue(lineXDataValue);
                    if (linePixelXForLabel + labelXAdjust + estimatedLabelWidth > budgetChart.chartArea.right - 10) {
                        labelXAdjust = (budgetChart.chartArea.right - 10 - linePixelXForLabel - estimatedLabelWidth) - 5;
                    }

                } else { 
                    const chartRightEdge = budgetChart.chartArea.right;
                    const linePixelXForLabel = budgetChart.scales.x.getPixelForValue(lineXDataValue);
                    if (linePixelXForLabel + estimatedLabelWidth + 22 > chartRightEdge - 15) {
                        labelXAdjust = -estimatedLabelWidth - 22;
                    } else {
                        labelXAdjust = 22;
                    }

                    const yPixelLineMin = budgetChart.scales.y.getPixelForValue(yLineMin);
                    const yPixelLineMax = budgetChart.scales.y.getPixelForValue(yLineMax);
                    const isLineUpward = yPixelLineMax < yPixelLineMin;

                    if (Math.abs(yLineMax - yLineMin) < 15) {
                         labelYAdjust = - (estimatedLabelHeight / 2 + 12);
                    } else if (isLineUpward) {
                        labelYAdjust = - (estimatedLabelHeight / 2 + 10);
                    } else {
                        labelYAdjust = (estimatedLabelHeight / 2 + 10);
                    }
                }

                ann.deviationLabel = {
                    id: 'deviationLabelAnnotation',
                    type: 'label',
                    xValue: labelXValue,
                    yValue: labelYValue,
                    xAdjust: labelXAdjust,
                    yAdjust: labelYAdjust,
                    backgroundColor: 'rgba(255, 253, 231, 0.98)',
                    borderColor: 'rgba(212, 175, 55, 0.95)',
                    borderWidth: 1.5,
                    color: '#282C34',
                    font: {
                        size: fontSize,
                        weight: '700',
                        family: "'Noto Sans KR', 'Apple SD Gothic Neo', Arial, sans-serif"
                    },
                    content: labelText,
                    padding: {
                        top: paddingValue,
                        bottom: paddingValue,
                        left: paddingValue + 4,
                        right: paddingValue + 4
                    },
                    borderRadius: 8,
                    shadowOffsetX: 2,
                    shadowOffsetY: 2,
                    shadowBlur: 5,
                    shadowColor: 'rgba(0,0,0,0.28)'
                };

            } else {
                 ann.deviationLabel = {
                    id: 'deviationLabelAnnotation',
                    type: 'label',
                    xValue: (selectionPoint1.monthIndex + (selectionPoint2 ? selectionPoint2.monthIndex : selectionPoint1.monthIndex)) / 2,
                    yValue: budgetChart.scales.y.getPixelForValue(budgetChart.scales.y.min + (budgetChart.scales.y.max - budgetChart.scales.y.min) * 0.1),
                    backgroundColor: 'rgba(100,100,100,0.7)',
                    color: '#fff',
                    font: { size: 12, weight: 'normal' },
                    content: '선택된 포인트 값 부족',
                    padding: 6,
                    borderRadius: 4
                };
            }
        }
        budgetChart.update('none');
    }
</script>

</body></html>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>테이블 작성 양식 - 이미지 포함</title>
    <style type="text/css">
        /* --- 기본 및 기능 구현 스타일 --- */
        body { font-family: "Malgun Gothic", sans-serif; user-select: none; }
        .grid-container { padding: 10px; }
        .title-container { display: flex; justify-content: flex-start; align-items: center; flex-wrap: nowrap; gap: 15px; padding: 5px; margin-bottom: 10px; }
        .s0 { font-weight: bold; font-size: 24pt; flex-shrink: 0; }
        
        #main-table {
            table-layout: fixed;
            width: 100%;
            border-collapse: collapse;
            border: 1px solid #999;
            position: relative;
            z-index: 1;
        }

        #main-table th, #main-table td {
            border: 1px solid #cccccc;
            padding: 8px 5px;
            font-size: 10pt;
            white-space: normal;
            word-wrap: break-word;
            position: relative;
        }
        
        #main-table td {
            vertical-align: middle;
            text-align: left;
        }

        #main-table td a {
            color: #0000ee;
            text-decoration: underline;
            cursor: pointer;
        }
        
        #main-table tbody tr:nth-child(even) { background-color: #f8f9fa; }
        #main-table .no-cell, #main-table thead th:not(:first-child) { cursor: grab; }
        #main-table .no-cell { text-align: center; vertical-align: middle; user-select: none; }
        #main-table .checkbox-cell { text-align: center; font-weight: bold; font-size: 14pt; cursor: pointer; user-select: none; }
        #main-table tbody tr { position: relative; }
        .dragging-row { opacity: 0.7; background-color: #d9eaff; }
        .dragging-col { opacity: 0.7; background-color: #d9eaff !important; }
        .drop-indicator-row-before { border-top: 2px solid #1a73e8; }
        .drop-indicator-row-after { border-bottom: 2px solid #1a73e8; }
        .drop-indicator-col-before { border-left: 2px solid #1a73e8; }
        .drop-indicator-col-after { border-right: 2px solid #1a73e8; }

        #main-table thead th {
            background-color: #deeaf6; text-align: center; vertical-align: middle; font-weight: bold;
            font-size: 11pt; border: 1px solid #999999; user-select: none;
        }
        
        #main-toolbar { display: flex; align-items: center; flex-wrap: nowrap; gap: 8px; margin-left: auto; overflow: hidden; }
        #main-toolbar .button-group { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
        #main-toolbar button { background-color: #f0f0f0; border: 1px solid #cccccc; padding: 5px 12px; font-family: "Malgun Gothic", sans-serif; font-size: 10pt; cursor: pointer; border-radius: 4px; font-weight: bold; color: #333; }
        #main-toolbar button:hover { background-color: #e0e0e0; border-color: #999999; }
        #main-toolbar button:disabled { background-color: #e9ecef; color: #6c757d; cursor: not-allowed; }
        #main-toolbar button.active { background-color: #1a73e8; color: #fff; border-color: #1a73e8; }
        [contenteditable] { -webkit-user-select: text; user-select: text; }
        [contenteditable]:focus { outline: 2px solid #4d90fe; outline-offset: -2px; }
        #main-toolbar .editor-group { display: inline-flex; align-items: center; gap: 5px; background-color: #fff; border: 1px solid #ccc; border-radius: 6px; padding: 4px 6px; flex-shrink: 1; }
        #main-toolbar .editor-group button { background-color: transparent; border: none; color: #333; cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        #main-toolbar .editor-group button svg { width: 18px; height: 18px; fill: #333; }
        #main-toolbar .editor-group button:hover, #main-toolbar .editor-group button.active { background-color: #e9e9e9; }
        #main-toolbar .editor-group select, #main-toolbar .editor-group input[type="color"] { background-color: #fff; color: #333; border: 1px solid #ccc; border-radius: 4px; padding: 2px; font-family: "Malgun Gothic", sans-serif; font-size: 10pt; height: 28px; }
        #main-toolbar .editor-group input[type="color"] { padding: 1px; width: 28px; border: 1px solid #ccc; cursor: pointer; }
        #main-toolbar .editor-separator { width: 1px; height: 20px; background-color: #ccc; margin: 0 4px; flex-shrink: 0; }
        
        .cell-selected {
            outline: 2px solid #1a73e8 !important;
            outline-offset: -2px;
        }

        #main-table tbody tr.row-focused:nth-child(even),
        #main-table tbody tr.row-focused:nth-child(odd) {
            background-color: #eaf6ff !important;
        }

        @media (max-width: 1500px) {
            #main-toolbar button { padding: 5px 8px; font-size: 9pt; }
            #main-toolbar .editor-group button svg { width: 16px; height: 16px; }
            #main-toolbar .editor-group select, #main-toolbar .editor-group input[type="color"] { height: 26px; font-size: 9pt; }
        }

        #context-menu {
            display: none; position: absolute; z-index: 1000; background-color: #f9f9f9;
            border: 1px solid #ccc; border-radius: 5px; box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
            padding: 5px 0; font-family: "Malgun Gothic", sans-serif; font-size: 10pt;
        }
        #context-menu ul { list-style: none; margin: 0; padding: 0; }
        #context-menu li { padding: 8px 15px; cursor: pointer; }
        #context-menu li:hover { background-color: #e0e0e0; }
        #context-menu .separator { height: 1px; background-color: #ccc; margin: 4px 0; }
        
        #image-overlay-container { position: relative; overflow: visible; }
        .canvas-container { position: absolute; top: 0; left: 0; z-index: 2147483600; pointer-events: none; }
        #overlay-canvas { position: absolute; top: 0; left: 0; z-index: 2147483600; pointer-events: none; }
        .upper-canvas { z-index: 2147483601 !important; }

        #image-tools-popup { position: fixed; top: 64px; left: 20px; z-index: 2147483647; display: none; flex-direction: column; background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.2); padding: 10px; width: 520px; height: 360px; min-width: 260px; min-height: 160px; pointer-events: auto; user-select: none; font-size: 9pt; }
        #image-tools-popup .popup-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        #image-tools-popup .popup-content-area { display: flex; flex-wrap: wrap; align-content: flex-start; gap: 8px; flex: 1 1 auto; overflow: auto; }
        #image-tools-popup .popup-header .title { font-weight: 700; }
        #image-tools-popup .popup-header { cursor: move; user-select: none; }
        #image-tools-popup .popup-section { margin-bottom: 0; border: 1px solid #e8e8e8; padding: 6px 8px; border-radius: 6px; flex: 1 1 150px; box-sizing: border-box; }
        #image-tools-popup .popup-section-title { font-size: 1em; font-weight: bold; color: #555; margin-bottom: 4px; }
        #image-tools-popup .btn-row { display: flex; flex-wrap: wrap; gap: 6px; }
        #image-tools-popup button { background-color: #f7f7f7; border: 1px solid #ccc; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 1em; }
        #image-tools-popup #compression-options label { cursor: pointer; display: inline-flex; align-items: center; gap: 3px; padding: 2px 4px; border-radius: 4px; transition: background-color 0.2s; }
        #image-tools-popup #compression-options label:has(input:checked) { background-color: #e0e8f8; }
        #image-tools-popup button:hover { background-color: #eee; }
        #toggleImageToolsBtn.active { background-color: #1a73e8; color: #fff; border-color: #1a73e8; }
        .inline-image-tool { display: none; }
        #toggleImageToolsBtn { display: none; }
        #image-tools-popup .resize-handle { position: absolute; width: 12px; height: 12px; background: rgba(26,115,232,0.9); border-radius: 2px; pointer-events: auto; }
        #image-tools-popup .resize-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        #image-tools-popup .resize-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        #image-tools-popup .resize-handle.e { right: -5px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
        #image-tools-popup .resize-handle.w { left: -5px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
        #image-tools-popup .resize-handle.ne { right: -5px; top: -5px; cursor: nesw-resize; }
        #image-tools-popup .resize-handle.nw { left: -5px; top: -5px; cursor: nwse-resize; }
        #image-tools-popup .resize-handle.se { right: -5px; bottom: -5px; cursor: nwse-resize; }
        #image-tools-popup .resize-handle.sw { left: -5px; bottom: -5px; cursor: nesw-resize; }
        #ui-drag-overlay { position: fixed; inset: 0; background: transparent; z-index: 2147483646; display: none; cursor: default; pointer-events: all; }

        #image-tooltip { display: none; position: absolute; background: rgba(0, 0, 0, 0.75); color: white; padding: 6px 12px; border-radius: 5px; font-size: 10pt; z-index: 2147483647; pointer-events: none; white-space: nowrap; }
        #image-zoom-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 2147483647; justify-content: center; align-items: center; }
        #image-zoom-overlay.visible { display: flex; }
        #image-zoom-close { position: absolute; top: 15px; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; cursor: pointer; transition: color 0.3s; }
        #image-zoom-close:hover { color: #bbb; }
        #image-zoom-content { max-width: 90vw; max-height: 90vh; object-fit: contain; animation: zoom-in 0.3s ease-out; }
        @keyframes zoom-in { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #fullscreen-overlay { display: none; position: fixed; inset: 0; background-color: #ffffff; z-index: 2147483645; padding: 20px; box-sizing: border-box; overflow: auto; }
        #fullscreen-close-btn { position: fixed; top: 15px; right: 20px; font-size: 40px; font-weight: bold; color: #333; cursor: pointer; z-index: 2147483646; transition: color 0.3s; }
        #fullscreen-close-btn:hover { color: #000; }
        #toggleFullscreenBtn svg { width: 18px; height: 18px; fill: #333; }
        #toggleFullscreenBtn { padding: 5px; }

        #toggleAnnotationBtn { display: none; position: fixed; top: 24px; left: 20px; z-index: 2147483646; background-color: #f0f0f0; border: 1px solid #cccccc; padding: 5px; cursor: pointer; border-radius: 4px; }
         #toggleAnnotationBtn:hover { background-color: #e0e0e0; border-color: #999999; }
         #toggleAnnotationBtn.active { background-color: #1a73e8; color: #fff; border-color: #1a73e8; }
         #toggleAnnotationBtn.active svg { fill: #fff; }
         #toggleAnnotationBtn svg { width: 18px; height: 18px; fill: #333; }

        #annotation-tools-popup { display: none; position: fixed; top: 80px; left: 20px; z-index: 2147483647; background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 8px; flex-direction: column; gap: 8px; pointer-events: auto; user-select: none; min-width: 230px; min-height: 150px; }
        #annotation-tools-popup .popup-header { cursor: move; padding: 5px 8px; background-color: #f7f7f7; border-bottom: 1px solid #ddd; border-top-left-radius: 7px; border-top-right-radius: 7px; margin: -8px -8px 8px -8px; }
        #annotation-tools-popup .popup-header .title { font-weight: bold; font-size: 10pt; color: #333; }
        #annotation-tools-popup .tool-group { display: flex; align-items: center; gap: 5px; flex-wrap: wrap; }
        #annotation-tools-popup button { background-color: #f7f7f7; border: 1px solid #ccc; border-radius: 4px; padding: 5px; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; }
        #annotation-tools-popup button:hover { background-color: #eee; }
        #annotation-tools-popup button.active { background-color: #d9eaff; border-color: #1a73e8; }
        #annotation-tools-popup button svg { width: 20px; height: 20px; fill: #333; }
        #annotation-tools-popup input[type="color"] { width: 32px; height: 32px; border: 1px solid #ccc; padding: 2px; box-sizing: border-box; cursor: pointer; border-radius: 4px; }
        #annotation-tools-popup .tool-separator { width: 1px; height: 25px; background-color: #ddd; margin: 0 4px; }
        .upper-canvas { cursor: default; }

        #main-table thead th { position: relative; }
        .th-content {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            position: relative;
        }
        .th-title {
            max-width: calc(100% - 45px); /* MODIFIED: Prevent title from overlapping tools */
            text-align: center;
            cursor: text;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .th-tools {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 2px;
            background-color: #deeaf6; /* ADDED: Match header background to hide overflow */
            padding-left: 4px;
        }
        .sort-controls { display: flex; flex-direction: column; justify-content: center; } /* REMOVED margin-right */
        .sort-arrow { font-size: 8px; line-height: 1; cursor: pointer; color: #888; padding: 1px 0; transition: color 0.2s; }
        .sort-arrow:hover { color: #333; }
        .sort-arrow.active { color: #1a73e8; }
        .filter-btn { cursor: pointer; font-size: 16px; opacity: 0.6; transition: opacity 0.2s, color 0.2s; user-select: none; }
        .filter-btn:hover { opacity: 1; }
        .filter-btn.active { opacity: 1; color: #1a73e8; }
        
        #filter-popup { display: none; position: absolute; z-index: 1010; background-color: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); font-family: "Malgun Gothic", sans-serif; font-size: 10pt; width: 250px; }
        #filter-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background-color: #f7f7f7; border-bottom: 1px solid #ddd; border-top-left-radius: 5px; border-top-right-radius: 5px; }
        #filter-title { font-weight: bold; }
        #close-filter-popup { background: none; border: none; font-size: 20px; cursor: pointer; }
        .filter-search-wrapper { padding: 5px 10px; border-bottom: 1px solid #eee; }
        #filter-search-input { width: 100%; box-sizing: border-box; padding: 4px; border: 1px solid #ccc; border-radius: 3px; }
        #filter-options { max-height: 200px; overflow-y: auto; padding: 5px 0; }
        #filter-options-list { padding: 0 10px; }
        #filter-options label { display: block; margin-bottom: 5px; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #filter-select-all-wrapper { padding: 5px 10px; border-bottom: 1px solid #eee;}
        #filter-buttons { display: flex; justify-content: flex-end; gap: 8px; padding: 10px; border-top: 1px solid #ddd; }
        #filter-buttons button { padding: 5px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 9pt; }
        #apply-filter-btn { background-color: #1a73e8; color: white; border-color: #1a73e8; }


    </style>
</head>
<body>

<div class="grid-container">
    <div class="title-container">
        <span class="s0" contenteditable="true">테이블 작성 양식</span>
        <div id="main-toolbar">
            <div class="editor-group">
                <button id="editor-bold" title="굵게"><svg viewBox="0 0 24 24"><path d="M15.6,10.79c.97-.67,1.65-1.77,1.65-2.79,0-2.26-1.75-4-4.25-4H7v14h7.04c2.1,0,3.71-1.7,3.71-3.78,0-1.52-.86-2.82-2.15-3.43Zm-5.6-4.79h3.4c1.14,0,2.1.92,2.1,2.05,0,1.13-.96,2.05-2.1,2.05h-3.4V6Zm3.54,9H9.5V13h3.04c1.14,0,2.06.92,2.06,2.05,0,1.13-.92,2.04-2.06,2.04Z"></path></svg></button>
                <button id="editor-italic" title="기울임"><svg viewBox="0 0 24 24"><path d="M10,4v3h2.21l-3.42,8H6v3h8v-3h-2.21l3.42-8H18V4Z"></path></svg></button>
                <button id="editor-underline" title="밑줄"><svg viewBox="0 0 24 24"><path d="M12,17c3.31,0,6-2.69,6-6V3h-2.5v8c0,1.93-1.57,3.5-3.5,3.5S8.5,12.93,8.5,11V3H6v8c0,3.31,2.69,6,6,6Zm-7,2v2h14v-2Z"></path></svg></button>
                <button id="editor-link" title="링크 삽입"><svg viewBox="0 0 24 24"><path d="M3.9,12c0-1.71,1.39-3.1,3.1-3.1h4V7H7c-2.76,0-5,2.24-5,5s2.24,5,5,5h4v-1.9H7C5.29,15.1,3.9,13.71,3.9,12z M8,13h8v-2H8V13z M17,7h-4v1.9h4c1.71,0,3.1,1.39,3.1,3.1s-1.39,3.1-3.1,3.1h-4V17h4c2.76,0,5-2.24,5-5S19.76,7,17,7z"></path></svg></button>
                <button id="editor-unlink" title="링크 제거"><svg viewBox="0 0 24 24"><path d="M17,7h-4v1.9h4c1.71,0,3.1,1.39,3.1,3.1s-1.39,3.1-3.1,3.1h-4V17h4c2.76,0,5-2.24,5-5S19.76,7,17,7z M10.1,14.5l-1.5-1.5L14.5,7H17v2.5l-4.4,4.4V17h-2.5L10.1,14.5z M7,15.1c-1.71,0-3.1-1.39-3.1-3.1s1.39-3.1,3.1-3.1h4V7H7c-2.76,0-5,2.24-5,5s2.24,5,5,5h4v-1.9H7z"></path></svg></button>
            </div>
            <div class="editor-separator"></div>
            <div class="editor-group">
                <select id="editor-fontsize" title="글자 크기"><option value="">기본</option><option value="10pt">10pt</option><option value="11pt">11pt</option><option value="12pt">12pt</option><option value="14pt">14pt</option><option value="16pt">16pt</option><option value="18pt">18pt</option><option value="24pt">24pt</option><option value="36pt">36pt</option><option value="48pt">48pt</option><option value="72pt">72pt</option></select>
                <input type="color" id="editor-color" title="글자 색" value="#000000">
                <button id="editor-format-number" title="숫자 서식 (세 자리 쉼표)"><svg viewBox="0 0 24 24"><path d="M7,13V11H21V13H7M7,19V17H21V19H7M7,7V5H21V7H7M3,8V5H6V8H3M3,14V11H6V14H3M3,20V17H6V20H3Z"></path></svg></button>
            </div>
            <div class="editor-separator"></div>
            <div class="editor-group" id="align-h-group">
                <button id="align-left" title="왼쪽 정렬"><svg viewBox="0 0 24 24"><path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"></path></svg></button>
                <button id="align-center" title="가운데 정렬"><svg viewBox="0 0 24 24"><path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"></path></svg></button>
                <button id="align-right" title="오른쪽 정렬"><svg viewBox="0 0 24 24"><path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"></path></svg></button>
            </div>
             <div class="editor-separator"></div>
            <div class="editor-group" id="align-v-group">
                <button id="align-top" title="위쪽 정렬"><svg viewBox="0 0 24 24"><path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"></path></svg></button>
                <button id="align-middle" title="중간 정렬"><svg viewBox="0 0 24 24"><path d="M8 15h3v4h2v-4h3l-4-4-4 4zM4 11v2h16v-2H4zM8 9h3V5h2v4h3l-4 4-4-4z"></path></svg></button>
                <button id="align-bottom" title="아래쪽 정렬"><svg viewBox="0 0 24 24"><path d="M8 13h3V3h2v10h3l-4 4-4-4zM4 21v-2h16v2H4z"></path></svg></button>
            </div>
            <div class="editor-separator"></div>
             <div class="button-group">
                <button id="toggleImageEditBtn" title="이미지 편집 모드 전환">이미지 편집: 끔</button>
                <input type="file" id="excel-file-input" accept=".xls, .xlsx" style="display: none;">
                <button id="importExcelBtn">엑셀 매핑</button>
                <button id="exportExcelBtn">엑셀 추출</button>
                <button id="saveHtmlBtn">HTML 저장</button>
                <button id="toggleFullscreenBtn" title="전체 화면"><svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg></button>
            </div>
        </div>
    </div>

    <div id="ui-drag-overlay"></div>
    
    <div id="image-overlay-container">
        <table id="main-table">
            <colgroup>
                <col style="width: 5%;"> <col style="width: 4%;"> <col style="width: 8%;"> <col style="width: 28%;">
                <col style="width: 7%;"> <col style="width: 7%;"> <col style="width: 7%;"> <col style="width: 5%;">
                <col style="width: 24%;"> <col style="width: 5%;">
            </colgroup>
            <thead>
                <tr>
                    <th title="클릭 후 드래그하여 행 이동">NO.</th><th title="클릭 후 드래그하여 열 이동">적용</th><th title="클릭 후 드래그하여 열 이동">구분</th><th title="클릭 후 드래그하여 열 이동">공사명</th><th title="클릭 후 드래그하여 열 이동">매입 금액</th><th title="클릭 후 드래그하여 열 이동">PO금액</th><th title="클릭 후 드래그하여 열 이동">입고월<br>(예정)</th><th title="클릭 후 드래그하여 열 이동">공종</th><th title="클릭 후 드래그하여 열 이동">주요 사항</th><th title="클릭 후 드래그하여 열 이동">비고</th>
                </tr>
            </thead>
            <tbody>
                <tr><td class="no-cell" title="클릭 후 드래그하여 행 이동"></td><td class="checkbox-cell"></td><td contenteditable="true"></td><td contenteditable="true"></td><td class="currency-cell" contenteditable="true"></td><td class="currency-cell" contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td></tr>
            </tbody>
        </table>
        <canvas id="overlay-canvas"></canvas>
    </div>
    <div id="image-tools-popup" role="dialog" aria-modal="true" aria-labelledby="image-tools-title" tabindex="0">
        <div class="popup-header">
            <span class="title" id="image-tools-title">이미지 도구</span>
            <button id="closeImageToolsBtn" title="닫기">닫기</button>
        </div>
        <div class="popup-content-area">
             <div class="popup-section">
                <div class="popup-section-title">이미지 추가</div>
                <div class="btn-row">
                     <input type="file" id="image-file-input" accept="image/*" multiple style="display: none;"> <button id="addImageBtn">이미지 추가</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">이미지 업로드 설정</div>
                <div class="btn-row" id="compression-options">
                    <label><input type="radio" name="compression-level" value="high"> 고화질</label>
                    <label><input type="radio" name="compression-level" value="medium"> 표준</label>
                    <label><input type="radio" name="compression-level" value="low" checked> 저용량</label>
                </div>
                <div id="compression-status" style="font-size: 9pt; color: #666; margin-top: 4px; min-height: 1.2em;"></div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">선택</div>
                <div class="btn-row">
                    <button id="selectAllImagesBtn">모든 이미지 선택</button>
                    <button id="clearSelectionBtn">선택 해제</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">정렬</div>
                <div class="btn-row">
                    <button id="imgAlignLeft">좌</button>
                    <button id="imgAlignCenterH">가중</button>
                    <button id="imgAlignRight">우</button>
                    <button id="imgAlignTop">상</button>
                    <button id="imgAlignMiddleV">세중</button>
                    <button id="imgAlignBottom">하</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">레이어 순서</div>
                <div class="btn-row">
                    <button id="bringToFrontBtn">맨 앞으로</button>
                    <button id="bringForwardBtn">앞으로</button>
                    <button id="sendBackwardsBtn">뒤로</button>
                    <button id="sendToBackBtn">맨 뒤로</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">크기 / 배치</div>
                <div class="btn-row">
                    <button id="sameWidthBtn">폭 동일</button>
                    <button id="sameHeightBtn">높이 동일</button>
                    <button id="sameSizeBtn">크기 동일</button>
                    <button id="distributeHBtn">간격 균등 가로</button>
                    <button id="distributeVBtn">간격 균등 세로</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">셀 연동</div>
                <div class="btn-row">
                    <button id="attachToCellBtn" title="선택한 이미지를 선택한 표의 셀에 맞춥니다.">선택 셀에 맞춤</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">스냅/가이드 설정</div>
                <div class="btn-row">
                    <label>스냅(px) <input type="number" id="snapGridInput" value="5" min="0" style="width:64px"></label>
                    <label>허용오차(px) <input type="number" id="guideToleranceInput" value="4" min="0" style="width:64px"></label>
                    <label>가이드색 <input type="color" id="guideColorInput" value="#ff0000"></label>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">잠금</div>
                <div class="btn-row">
                    <button id="lockLayerBtn">선택 잠금</button>
                    <button id="unlockLayerBtn">전체 해제</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="context-menu">
    <ul>
        <li id="insert-row-above">위에 행 삽입</li> <li id="insert-row-below">아래에 행 삽입</li> <li id="delete-row">행 삭제</li>
        <li class="separator"></li>
        <li id="insert-col-left">왼쪽에 열 삽입</li> <li id="insert-col-right">오른쪽에 열 삽입</li> <li id="delete-col">열 삭제</li>
        <li class="separator"></li>
        <li id="set-row-height">행 높이 설정...</li>
        <li id="set-col-width">열 너비 설정...</li>
    </ul>
</div>

<div id="image-zoom-overlay">
    <span id="image-zoom-close" title="닫기">&times;</span>
    <img id="image-zoom-content" src="">
</div>
<div id="image-tooltip"></div>

<div id="fullscreen-overlay">
    <button id="toggleAnnotationBtn" title="주석 모드"><svg viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z"></path></svg></button>
    <span id="fullscreen-close-btn" title="닫기">&times;</span>
    <div id="fullscreen-content"></div>
</div>

<div id="annotation-tools-popup">
    <div class="popup-header">
        <span class="title">주석 도구</span>
    </div>
    <div class="tool-group">
        <button id="anno-select" title="이동/선택"><svg viewBox="0 0 24 24"><path d="M13.5,4.2C13.5,4.2 13.5,4.2 13.5,4.2L15.6,8.4L20.2,9L16.8,12.3L17.7,16.8L13.5,14.5L9.3,16.8L10.2,12.3L6.8,9L11.4,8.4L13.5,4.2M13.5,2L11,7.5L5,8.5L9.5,12.5L8,18.5L13.5,15.5L19,18.5L17.5,12.5L22,8.5L16,7.5L13.5,2Z"></path></svg></button>
        <button id="anno-pen" title="펜"><svg viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z"></path></svg></button>
        <button id="anno-line" title="직선"><svg viewBox="0 0 24 24"><path d="M4,11V13H19.95L18.47,15.47L19.88,16.88L23.71,12L19.88,7.12L18.47,8.53L19.95,11H4Z" transform="rotate(45 12 12)" /></svg></button>
        <button id="anno-arrow" title="화살표"><svg viewBox="0 0 24 24"><path d="M5,17.59L15.59,7H9V5H19V15H17V8.41L6.41,19L5,17.59Z"></path></svg></button>
        <button id="anno-rect" title="사각형"><svg viewBox="0 0 24 24"><path d="M19,3H5C3.89,3 3,3.89 3,5V19C3,20.11 3.9,21 5,21H19C20.11,21 21,20.11 21,19V5C21,3.89 20.11,3 19,3M19,19H5V5H19V19Z"></path></svg></button>
        <button id="anno-circle" title="원"><svg viewBox="0 0 24 24"><path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20Z"></path></svg></button>
    </div>
    <div class="tool-group">
        <input type="color" id="anno-color" title="선 색상" value="#FF0000">
        <input type="range" id="anno-width" title="선 굵기" min="1" max="30" value="5" style="width: 120px;">
    </div>
    <div class="tool-group">
        <button id="anno-memo" title="메모 삽입"><svg viewBox="0 0 24 24"><path d="M20,2H4C2.9,2 2,2.9 2,4V22L6,18H20C21.1,18 22,17.1 22,16V4C22,2.9 21.1,2 20,2M20,16H5.2L4,17.2V4H20V16Z"></path></svg></button>
        <div class="tool-separator"></div>
        <button id="anno-eraser" title="지우개 (객체 클릭)"><svg viewBox="0 0 24 24"><path d="M16.24,3.56L21.19,8.5C21.58,8.89 21.58,9.5 21.19,9.9L12.1,19H3V9.9L16.24,3.56M9.9,17H5V11.9L14.09,2.8L19.2,7.9L9.9,17Z"></path></svg></button>
        <button id="anno-clear" title="모두 지우기"><svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19C6,20.1 6.9,21 8,21H16C17.1,21 18,20.1 18,19V7H6V19Z"></path></svg></button>
    </div>
</div>

<div id="filter-popup">
    <div id="filter-header">
        <span id="filter-title">필터</span>
        <button id="close-filter-popup" title="닫기">&times;</button>
    </div>
    <div class="filter-search-wrapper">
        <input type="text" id="filter-search-input" placeholder="목록 검색...">
    </div>
    <div id="filter-options">
        <div id="filter-select-all-wrapper">
            <label><input type="checkbox" id="filter-select-all"> (모두 선택)</label>
        </div>
        <div id="filter-options-list"></div>
    </div>
    <div id="filter-buttons">
        <button id="clear-filter-btn">필터 초기화</button>
        <button id="apply-filter-btn">적용</button>
    </div>
</div>


<script id="canvas-data" type="application/json"></script>

<script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.1/dist/browser-image-compression.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const table = document.getElementById('main-table');
    const imageOverlayContainer = document.getElementById('image-overlay-container');
    let isImageEditMode = false;
    let isCropping = false;
    let cropTargetImage = null;
    let cropRect = null;    const fabricCanvas = new fabric.Canvas('overlay-canvas', {
        enableRetinaScaling: false,
        objectCaching: false,
        selection: true,
        preserveObjectStacking: true,
        willReadFrequently: true,
    });
    if (fabricCanvas && fabricCanvas.upperCanvasEl) {
        fabricCanvas.upperCanvasEl.style.pointerEvents = 'none';
    }
    const addImageBtn = document.getElementById('addImageBtn');
    const imageFileInput = document.getElementById('image-file-input');
    const lockLayerBtn = document.getElementById('lockLayerBtn');
    const unlockLayerBtn = document.getElementById('unlockLayerBtn');

    function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
    }
    let _clipboard = null;
    let selectedCells = [], contextTargetCell = null, currencyColIndices = [], checkboxColIndex = -1;
    let activeFilters = {};
    let currentFilterColumn = -1;

    function findSpecialColumns() {
        const headers = Array.from(table.querySelectorAll('thead th'));
        currencyColIndices = headers.map((th, i) => (th.innerText.includes('매입 금액') || th.innerText.includes('PO금액')) ? i : -1).filter(i => i !== -1);
        checkboxColIndex = headers.findIndex(th => th.innerText.includes('적용'));
    }

    function clearSelection() { 
        selectedCells.forEach(cell => cell.classList.remove('cell-selected')); 
        selectedCells = []; 
        updateEditorUI(); 
    }

    function addCellToSelection(cell) {
        if (!selectedCells.includes(cell) && !cell.classList.contains('no-cell') && cell.tagName === 'TD') {
            selectedCells.push(cell);
            cell.classList.add('cell-selected');
        }
    }

    function updateEditorUI() {
        document.querySelectorAll('#main-toolbar .editor-group button.active').forEach(b => b.classList.remove('active'));
        if (selectedCells.length === 0) return;
        const firstCell = selectedCells[0]; 
        const style = window.getComputedStyle(firstCell);
        document.querySelector(`#align-${style.textAlign}`)?.classList.add('active');
        document.querySelector(`#align-${style.verticalAlign}`)?.classList.add('active');
        if (style.fontWeight === '700' || style.fontWeight === 'bold') document.getElementById('editor-bold').classList.add('active');
        if (style.fontStyle === 'italic') document.getElementById('editor-italic').classList.add('active');
        if (style.textDecorationLine.includes('underline')) document.getElementById('editor-underline').classList.add('active');

        const fontSizeSelect = document.getElementById('editor-fontsize');
        if (firstCell.style.fontSize && Array.from(fontSizeSelect.options).some(opt => opt.value === firstCell.style.fontSize)) {
            fontSizeSelect.value = firstCell.style.fontSize;
        } else {
            const pxSize = parseFloat(style.fontSize);
            const ptSize = Math.round(pxSize * 0.75);
            let closestVal = "";
            let minDiff = Infinity;
            for (const opt of fontSizeSelect.options) {
                if (opt.value) {
                    const optPt = parseInt(opt.value, 10);
                    const diff = Math.abs(optPt - ptSize);
                    if (diff < minDiff) { minDiff = diff; closestVal = opt.value; }
                }
            }
            fontSizeSelect.value = minDiff <= 1 ? closestVal : "";
        }
        document.getElementById('editor-color').value = firstCell.style.color ? rgbToHex(firstCell.style.color) : rgbToHex(style.color);
    }

    table.addEventListener('click', function(e) {
        if (isAnnotationMode) return;
        const link = e.target.closest('a');
        if (link && link.href) { e.preventDefault(); e.stopPropagation(); window.open(link.href, '_blank', 'noopener,noreferrer'); return; }
        
        const targetCell = e.target.closest('td');

        document.querySelectorAll('.row-focused').forEach(r => r.classList.remove('row-focused'));
        if (targetCell) {
            const row = targetCell.closest('tr');
            if (row) row.classList.add('row-focused');
        }

        if (targetCell && targetCell.classList.contains('checkbox-cell')) { 
            e.preventDefault(); 
            targetCell.innerText = targetCell.innerText === '✓' ? '' : '✓'; 
            return; 
        }
        
        if (targetCell && targetCell.classList.contains('no-cell')) {
            e.preventDefault();
            clearSelection();
            const row = targetCell.closest('tr');
            Array.from(row.cells).forEach(cell => addCellToSelection(cell));
            updateEditorUI();
            return;
        }
        
        if (targetCell) {
             if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
                clearSelection();
                addCellToSelection(targetCell);
            } else if (e.ctrlKey || e.metaKey) {
                if (selectedCells.includes(targetCell)) {
                    targetCell.classList.remove('cell-selected');
                    selectedCells = selectedCells.filter(c => c !== targetCell);
                } else {
                    addCellToSelection(targetCell);
                }
            } else if (e.shiftKey && selectedCells.length > 0) {
                const allCells = Array.from(table.querySelectorAll('td:not(.no-cell)'));
                const firstIndex = allCells.indexOf(selectedCells[0]);
                const lastIndex = allCells.indexOf(targetCell);
                clearSelection();
                const start = Math.min(firstIndex, lastIndex);
                const end = Math.max(firstIndex, lastIndex);
                for (let i = start; i <= end; i++) {
                    addCellToSelection(allCells[i]);
                }
            }
            updateEditorUI();
        }
    });

    function applyStyle(style, value) {
        document.execCommand('styleWithCSS', false, true);
        const selection = window.getSelection();
        const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
        const isTextSelectedInCell = range && !range.collapsed && range.commonAncestorContainer.parentElement.closest('td[contenteditable="true"], th[contenteditable="true"]');

        if (isTextSelectedInCell) {
            if (style === 'fontSize' || style === 'foreColor') {
                const cssProperty = style === 'fontSize' ? 'fontSize' : 'color';
                const dummyFont = `_dummy_${Date.now()}`;
                document.execCommand('fontName', false, dummyFont);
                const fonts = table.querySelectorAll(`font[face="${dummyFont}"]`);
                fonts.forEach(font => {
                    const span = document.createElement('span');
                    span.style[cssProperty] = value;
                    while (font.firstChild) { span.appendChild(font.firstChild); }
                    font.parentNode.replaceChild(span, font);
                });
            } else { document.execCommand(style, false, value); }
        } else if (selectedCells.length > 0) {
            selectedCells.forEach(cell => {
                const tempRange = document.createRange();
                tempRange.selectNodeContents(cell);
                selection.removeAllRanges();
                selection.addRange(tempRange);
                if (style === 'fontSize') cell.style.fontSize = value;
                else if (style === 'foreColor') cell.style.color = value;
                else document.execCommand(style, false, value);
            });
            if (selection) selection.removeAllRanges();
        }
        updateEditorUI();
    }

    function applyAlignment(property, value) { 
        if (selectedCells.length === 0) { alert("정렬할 셀을 먼저 선택해주세요."); return; }
        selectedCells.forEach(cell => { cell.style[property] = value; }); 
        updateEditorUI(); 
    }
    
    function removeNumberFormatting(cell) {
        function unformatNode(node) {
            if (node.nodeType === 3) { node.nodeValue = node.nodeValue.replace(/,/g, ''); } 
            else if (node.nodeType === 1 && node.childNodes) { node.childNodes.forEach(unformatNode); }
        }
        unformatNode(cell);
    }
    function updateNumberFormatting(cell) {
        function formatNode(node) {
            if (node.nodeType === 3) {
                const num = parseFloat(node.nodeValue.replace(/,/g, ''));
                if (!isNaN(num)) { node.nodeValue = num.toLocaleString('en-US'); }
            } else if (node.nodeType === 1 && node.childNodes) { node.childNodes.forEach(formatNode); }
        }
        formatNode(cell);
    }
    table.addEventListener('focusin', (e) => { if (e.target.matches('.currency-cell')) { removeNumberFormatting(e.target); } });
    table.addEventListener('focusout', (e) => { 
        if (e.target.matches('.currency-cell')) { updateNumberFormatting(e.target); }
        if (e.target.matches('th')) { findSpecialColumns(); }
    });
    function formatAllCurrencyCells() { 
        if (currencyColIndices.length === 0) return;
        currencyColIndices.forEach(colIndex => {
            table.querySelectorAll(`tbody td:nth-child(${colIndex + 1})`).forEach(cell => {
                updateNumberFormatting(cell);
            });
        });
    }

    function addEditorButtonListener(id, event, callback) {
        const element = document.getElementById(id);
        if (!element) return;
        if (element.tagName === 'BUTTON') { element.addEventListener('mousedown', e => e.preventDefault()); }
        element.addEventListener(event, callback);
    }

    addEditorButtonListener('editor-bold', 'click', () => applyStyle('bold'));
    addEditorButtonListener('editor-italic', 'click', () => applyStyle('italic'));
    addEditorButtonListener('editor-underline', 'click', () => applyStyle('underline'));
    addEditorButtonListener('editor-fontsize', 'change', (e) => applyStyle('fontSize', e.target.value));
    addEditorButtonListener('editor-color', 'input', (e) => applyStyle('foreColor', e.target.value));
    addEditorButtonListener('editor-format-number', 'click', () => {
        if (selectedCells.length === 0) { alert("서식을 적용할 셀을 먼저 선택해주세요."); return; }
        selectedCells.forEach(cell => {
             const isCurrency = cell.classList.contains('currency-cell');
             if(isCurrency){ cell.classList.remove('currency-cell'); removeNumberFormatting(cell); } 
             else { cell.classList.add('currency-cell'); updateNumberFormatting(cell); }
        });
    });
    addEditorButtonListener('align-left', 'click', () => applyAlignment('textAlign', 'left'));
    addEditorButtonListener('align-center', 'click', () => applyAlignment('textAlign', 'center'));
    addEditorButtonListener('align-right', 'click', () => applyAlignment('textAlign', 'right'));
    addEditorButtonListener('align-top', 'click', () => applyAlignment('verticalAlign', 'top'));
    addEditorButtonListener('align-middle', 'click', () => applyAlignment('verticalAlign', 'middle'));
    addEditorButtonListener('align-bottom', 'click', () => applyAlignment('verticalAlign', 'bottom'));

    function addLinkButtonListener(buttonId, command, promptMessage = null) {
        document.getElementById(buttonId).addEventListener('mousedown', (e) => {
            e.preventDefault(); const selection = window.getSelection(); if (selection.rangeCount === 0) return; let value = null;
            if (promptMessage) {
                const range = selection.getRangeAt(0);
                if (range.collapsed && command === 'createLink') { alert("링크를 적용할 텍스트를 먼저 드래그하여 선택해주세요."); return; }
                value = prompt(promptMessage, "https://"); if (!value) return; 
            }
            document.execCommand(command, false, value);
        });
    }
    addLinkButtonListener('editor-link', 'createLink', '링크할 URL을 입력하세요:');
    addLinkButtonListener('editor-unlink', 'unlink');
    function rgbToHex(rgb) {
        if (!rgb || !/^rgb/.test(rgb)) return '#000000';
        let parts = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/); if (!parts) return '#000000';
        delete(parts[0]); let hex = "#";
        for (let i = 1; i <= 3; ++i) { let part = parseInt(parts[i]).toString(16); hex += (part.length == 1) ? '0' + part : part; }
        return hex;
    }

    document.getElementById('saveHtmlBtn').addEventListener('click', async () => {
        syncCanvasSize();
        const clonedDoc = document.documentElement.cloneNode(true);
        clonedDoc.querySelectorAll('.cell-selected, .row-focused').forEach(el => el.classList.remove('cell-selected', 'row-focused'));
        const canvasDataScript = clonedDoc.querySelector('#canvas-data');
        if (canvasDataScript) { canvasDataScript.textContent = JSON.stringify(fabricCanvas.toJSON(['persistentTop'])); }

        const externalScripts = Array.from(clonedDoc.querySelectorAll('script[src]'));
        if (externalScripts.length > 0) {
            try {
                const fetched = await Promise.all(externalScripts.map(async (s) => {
                    try {
                        const res = await fetch(s.src, { cache: 'no-cache' });
                        const code = await res.text();
                        return { node: s, code };
                    } catch (err) { console.warn('스크립트 인라인 실패:', s.src, err); return { node: s, code: null }; }
                }));
                fetched.forEach(item => {
                    const { node, code } = item;
                    if (!code) return;
                    node.removeAttribute('src');
                    node.textContent = code;
                });
            } catch (e) { console.warn('외부 스크립트 인라인 과정에서 예외 발생:', e); }
        }
        const pageHTML = '<!DOCTYPE html>\n' + clonedDoc.outerHTML;
        const blob = new Blob([pageHTML], { type: 'text/html;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); a.download = '테이블_양식_이미지포함.html'; a.click(); URL.revokeObjectURL(a.href);
    });

    document.getElementById('exportExcelBtn').addEventListener('click', () => {
        const wb = XLSX.utils.table_to_book(table, { sheet: "테이블 양식" });
        XLSX.writeFile(wb, "테이블_양식.xlsx");
    });
    document.getElementById('importExcelBtn').addEventListener('click', () => document.getElementById('excel-file-input').click());
    document.getElementById('excel-file-input').addEventListener('change', (e) => {
        const file = e.target.files[0]; if (!file) return; const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = new Uint8Array(event.target.result); const workbook = XLSX.read(data, { type: 'array' });
                const sheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                populateTableWithData(jsonData); alert('엑셀 데이터를 성공적으로 매핑했습니다.');
            } catch (error) { console.error("엑셀 파일 처리 중 오류:", error); alert('엑셀 파일을 처리하는 중 오류가 발생했습니다.'); } 
            finally { e.target.value = ''; }
        };
        reader.readAsArrayBuffer(file);
    });
     function populateTableWithData(data) {
        if (!data || data.length < 1) { alert('매핑할 데이터가 없습니다.'); return; }
        const thead = table.tHead, tbody = table.tBodies[0];
        const excelHeaders = data[0].map(h => String(h).replace(/\n/g, ' ').trim());
        const tableHeaders = Array.from(thead.rows[0].cells).map(th => th.querySelector('.th-title')?.innerText.replace(/\n/g, ' ').trim() || th.innerText.replace(/\n/g, ' ').trim());
        const columnIndexMap = new Array(tableHeaders.length);
        const matchedHeaders = [], unmatchedTableHeaders = [];

        tableHeaders.forEach((tableHeaderText, tableIndex) => {
            if (tableIndex === 0 || tableIndex === 1) { columnIndexMap[tableIndex] = -1; return; }
            const excelIndex = excelHeaders.findIndex(eh => eh === tableHeaderText);
            columnIndexMap[tableIndex] = excelIndex;
            if (excelIndex !== -1) { matchedHeaders.push(tableHeaderText); } 
            else { unmatchedTableHeaders.push(tableHeaderText); }
        });

        if (matchedHeaders.length === 0) { alert('일치하는 헤더가 하나도 없어 매핑을 중단합니다.\n엑셀 파일의 헤더를 확인해주세요.'); return; }
        tbody.innerHTML = '';
        const dataRows = data.slice(1);
        dataRows.forEach(rowData => {
            const newRow = tbody.insertRow();
            tableHeaders.forEach((thText, tableIndex) => {
                const cell = newRow.insertCell(tableIndex);
                if (tableIndex === 0) { cell.classList.add('no-cell'); return; }
                const excelIndex = columnIndexMap[tableIndex];
                const cellValue = (excelIndex !== -1 && rowData[excelIndex] !== undefined) ? rowData[excelIndex] : '';
                if (tableIndex === checkboxColIndex) { cell.classList.add('checkbox-cell'); cell.innerText = cellValue === '✓' ? '✓' : ''; } 
                else {
                    cell.contentEditable = 'true';
                    cell.innerHTML = String(cellValue).replace(/\n/g, '<br>');
                    if (currencyColIndices.includes(tableIndex)) { cell.classList.add('currency-cell'); }
                }
            });
        });
        updateRowNumbers(); updateCellIds(); initializeResizableTable(); formatAllCurrencyCells(); clearSelection(); updateAllAttachedImages();
        let summaryMessage = '엑셀 데이터 매핑이 완료되었습니다.\n';
        if (matchedHeaders.length > 0) { summaryMessage += `\n- 매핑된 열 (${matchedHeaders.length}개): \n  ${matchedHeaders.join(', ')}`; }
        if (unmatchedTableHeaders.length > 0) { summaryMessage += `\n\n- 헤더 불일치로 건너뛴 열 (${unmatchedTableHeaders.length}개): \n  ${unmatchedTableHeaders.join(', ')}`; }
        alert(summaryMessage);
    }
    
    function updateRowNumbers() {
        let visibleIndex = 1;
        table.querySelectorAll('tbody tr').forEach((row, index) => {
            const noCell = row.cells[0];
            if (noCell) {
                if (!row.dataset.originalIndex) { row.dataset.originalIndex = index; }
                if (row.style.display !== 'none') { noCell.innerText = visibleIndex++; }
            }
        });
    }

    function insertRow(index, above = true) {
        const tbody = table.tBodies[0];
        const colCount = table.rows[0].cells.length;
        const targetIndex = above ? index : index + 1;
        const newRow = tbody.insertRow(targetIndex);
        const noCell = newRow.insertCell(0);
        noCell.classList.add('no-cell');
        noCell.title = '클릭 후 드래그하여 행 이동';
        for (let i = 1; i < colCount; i++) {
            const newCell = newRow.insertCell(i);
            if (i === checkboxColIndex) { newCell.classList.add('checkbox-cell'); } 
            else {
                newCell.contentEditable = 'true';
                if (currencyColIndices.includes(i)) { newCell.classList.add('currency-cell'); }
            }
        }
        updateRowNumbers();
        syncCanvasSize();
        ensureCanvasOnTop();
        updateOverlayPosition();
    }

    function deleteRow(index) {
        if (table.tBodies[0].rows.length > 1) {
            table.tBodies[0].deleteRow(index);
            updateRowNumbers();
            updateCellIds();
            syncCanvasSize();
            ensureCanvasOnTop();
            updateOverlayPosition();
            updateAllAttachedImages();
        } else { alert("마지막 행은 삭제할 수 없습니다."); }
    }

    function insertColumn(index, before = true) {
        if (index === 0 && before) { alert("'NO.' 열의 왼쪽에 열을 추가할 수 없습니다."); return; }
        const targetIndex = before ? index : index + 1;
        table.querySelector('colgroup').children[targetIndex-1].insertAdjacentHTML('afterend', '<col style="width: 10%;">');
        const newTh = document.createElement('th');
        table.tHead.rows[0].insertBefore(newTh, table.tHead.rows[0].cells[targetIndex]);
        Array.from(table.tBodies[0].rows).forEach(row => { row.cells[targetIndex-1].insertAdjacentHTML('afterend', '<td contenteditable="true"></td>'); }); 
        initializeSortAndFilter();
        findSpecialColumns();
        updateCellIds();
        syncCanvasSize();
        ensureCanvasOnTop();
        updateOverlayPosition();
        updateAllAttachedImages();
    }

    function deleteColumn(index) {
        if (index === 0) { alert("'NO.' 열은 삭제할 수 없습니다."); return; }
        if (table.rows[0].cells.length > 2) {
            table.querySelector('colgroup').children[index].remove();
            Array.from(table.rows).forEach(row => row.deleteCell(index));
            initializeSortAndFilter();
            findSpecialColumns();
            updateCellIds();
            syncCanvasSize();
            ensureCanvasOnTop();
            updateOverlayPosition();
            updateAllAttachedImages();
        } else { alert("마지막 항목 열은 삭제할 수 없습니다."); }
    }
    const contextMenu = document.getElementById('context-menu');
    table.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const target = e.target.closest('td, th');
        if (!target) return;
        contextTargetCell = target;
        const isNoColumn = contextTargetCell.cellIndex === 0;
        const isTbody = contextTargetCell.closest('tbody');
        document.getElementById('delete-col').style.display = isNoColumn ? 'none' : 'block';
        document.getElementById('insert-col-left').style.display = isNoColumn ? 'none' : 'block';
        document.getElementById('set-row-height').style.display = isTbody ? 'block' : 'none';
        document.getElementById('set-col-width').style.display = !isNoColumn ? 'block' : 'none';
        contextMenu.style.display = 'block';
        contextMenu.style.left = `${e.pageX}px`;
        contextMenu.style.top = `${e.pageY}px`;
        ensureCanvasOnTop();
        updateOverlayPosition();
    });
    document.addEventListener('click', (e) => {
        if (!contextMenu.contains(e.target) && !e.target.closest('#main-toolbar')) { contextMenu.style.display = 'none'; }
        if (!e.target.closest('#filter-popup') && filterPopup.style.display === 'block') {
             if(!e.target.classList.contains('filter-btn')) filterPopup.style.display = 'none';
        }
        const clickedInsideOverlay = fabricCanvas.upperCanvasEl && fabricCanvas.upperCanvasEl.contains(e.target);
        const clickedInsideImageTools = !!e.target.closest('#image-tools-popup') || !!e.target.closest('#toggleImageEditBtn');
        const clickedInsideAnnotationTools = !!e.target.closest('#annotation-tools-popup') || !!e.target.closest('#toggleAnnotationBtn');
        if (!table.contains(e.target) && !document.getElementById('main-toolbar').contains(e.target) && !contextMenu.contains(e.target) && !clickedInsideOverlay && !clickedInsideImageTools && !clickedInsideAnnotationTools && !e.target.closest('#filter-popup')) {
            clearSelection();
            fabricCanvas.discardActiveObject().renderAll();
        }
    });
    contextMenu.addEventListener('click', (e) => {
        if (!contextTargetCell) return;
        const cellIndex = contextTargetCell.cellIndex;
        const tr = contextTargetCell.closest('tr');
        const rowIndex = Array.from(tr.parentNode.children).indexOf(tr);
        switch (e.target.id) {
            case 'insert-row-above': if (tr.parentNode.tagName === 'TBODY') insertRow(rowIndex, true); break;
            case 'insert-row-below': if (tr.parentNode.tagName === 'TBODY') insertRow(rowIndex, false); break;
            case 'delete-row': if (contextTargetCell.tagName === 'TD') deleteRow(rowIndex); break;
            case 'insert-col-left': insertColumn(cellIndex, true); break;
            case 'insert-col-right': insertColumn(cellIndex, false); break;
            case 'delete-col': deleteColumn(cellIndex); break;
            case 'set-row-height':
                if (tr && tr.parentNode.tagName === 'TBODY') {
                    const currentHeight = tr.offsetHeight;
                    const newHeightStr = prompt('새로운 행 높이를 입력하세요 (px 단위):', currentHeight);
                    if (newHeightStr) {
                        const newHeight = parseFloat(newHeightStr);
                        if (!isNaN(newHeight) && newHeight > 0) { tr.style.height = newHeight + 'px'; updateAllAttachedImages(); } 
                        else { alert('유효한 숫자를 입력해주세요.'); }
                    }
                }
                break;
            case 'set-col-width':
                if (cellIndex > 0) {
                    const colElement = table.querySelector('colgroup').children[cellIndex];
                    const currentWidth = colElement.offsetWidth;
                    const newWidthStr = prompt('새로운 열 너비를 입력하세요 (px 단위):', currentWidth);
                    if (newWidthStr) {
                        const newWidth = parseFloat(newWidthStr);
                        if (!isNaN(newWidth) && newWidth > 0) { colElement.style.width = newWidth + 'px'; updateAllAttachedImages(); } 
                        else { alert('유효한 숫자를 입력해주세요.'); }
                    }
                }
                break;
        }
        contextMenu.style.display = 'none';
    });

    function updateCellIds() {
        table.querySelectorAll('tbody tr').forEach((row, rowIndex) => {
            row.querySelectorAll('td').forEach((cell, colIndex) => {
                cell.id = `cell-${rowIndex}-${colIndex}`;
            });
        });
    }
    function ensureCanvasOnTop() { updateOverlayPosition(); }
    function ensureToolsPopupOnTop() {
        const popup = document.getElementById('image-tools-popup');
        if (!popup) return;
        if (popup.parentNode !== document.body) { document.body.appendChild(popup); }
        popup.style.zIndex = '2147483647';
        popup.style.pointerEvents = 'auto';
    }
    function updateOverlayPosition() {
        const wrapper = fabricCanvas.getElement().parentNode;
        if (wrapper) { wrapper.style.left = '0px'; wrapper.style.top = '0px'; }
        fabricCanvas.calcOffset();
    }
    function syncCanvasSize() {
        const rect = table.getBoundingClientRect();
        const width = Math.ceil(Math.max(rect.width, document.documentElement.clientWidth));
        const bodyScrollH = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
        const height = Math.max(table.scrollHeight, table.offsetHeight, rect.height, bodyScrollH);
        fabricCanvas.setDimensions({ width, height });
        const wrapper = fabricCanvas.getElement().parentNode;
        if (wrapper && wrapper.classList && wrapper.classList.contains('canvas-container')) {
            wrapper.style.width = width + 'px';
            wrapper.style.height = height + 'px';
        }
        fabricCanvas.renderAll();
    }
    if (typeof ResizeObserver !== 'undefined') {
        const resizeObserver = new ResizeObserver(() => { syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); });
        resizeObserver.observe(table);
    } else {
        const mutationObserver = new MutationObserver(() => { syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); });
        mutationObserver.observe(table, { attributes: true, childList: true, subtree: true });
    }
    
    const toggleFullscreenBtn = document.getElementById('toggleFullscreenBtn');
    const fullscreenOverlay = document.getElementById('fullscreen-overlay');
    const fullscreenContent = document.getElementById('fullscreen-content');
    const fullscreenCloseBtn = document.getElementById('fullscreen-close-btn');
    const uiDragOverlay = document.getElementById('ui-drag-overlay');
    const toggleAnnotationBtn = document.getElementById('toggleAnnotationBtn');

    window.addEventListener('scroll', () => { updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); });
    window.addEventListener('resize', () => { syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); });
    fullscreenOverlay.addEventListener('scroll', updateAnnotationPositions);

    addImageBtn.addEventListener('click', () => imageFileInput.click());
    const toggleImageEditBtn = document.getElementById('toggleImageEditBtn');
    function setEditMode(on) {
        if (on && isAnnotationMode) setAnnotationMode(false);
        isImageEditMode = !!on;
        const label = `이미지 편집: ${isImageEditMode ? '켬' : '끔'}`;
        if (toggleImageEditBtn) {
            toggleImageEditBtn.textContent = label;
            toggleImageEditBtn.classList.toggle('active', isImageEditMode);
        }
        if (imageToolsPopup) { imageToolsPopup.style.display = isImageEditMode ? 'flex' : 'none'; }
        syncCanvasSize();
        ensureCanvasOnTop();
        updateOverlayPosition();
        const upperCanvas = fabricCanvas.upperCanvasEl;
        if (upperCanvas) upperCanvas.style.pointerEvents = 'auto';
        fabricCanvas.skipTargetFind = false;
        if (isImageEditMode) { fabricCanvas.getObjects().forEach(o => { if (o.isAnnotation) o.evented = false; else o.evented = true; }); } 
        else { if (isCropping) cancelCrop(); fabricCanvas.discardActiveObject().requestRenderAll(); }
    }
    const imageToolsPopup = document.getElementById('image-tools-popup');
    const closeImageToolsBtn = document.getElementById('closeImageToolsBtn');
    const popupHeaderEl = imageToolsPopup.querySelector('.popup-header');
    toggleImageEditBtn.addEventListener('click', () => { setEditMode(!isImageEditMode); ensureToolsPopupOnTop(); });
    closeImageToolsBtn.addEventListener('click', () => { imageToolsPopup.style.display = 'none'; setEditMode(false); });
    lockLayerBtn.addEventListener('click', () => { lockSelected(); lockLayerBtn.classList.add('active'); setTimeout(() => lockLayerBtn.classList.remove('active'), 200); });
    unlockLayerBtn.addEventListener('click', () => { unlockAll(); unlockLayerBtn.classList.add('active'); setTimeout(() => unlockLayerBtn.classList.remove('active'), 200); });
    const imgAlignLeft = document.getElementById('imgAlignLeft');
    const imgAlignCenterH = document.getElementById('imgAlignCenterH');
    const imgAlignRight = document.getElementById('imgAlignRight');
    const imgAlignTop = document.getElementById('imgAlignTop');
    const imgAlignMiddleV = document.getElementById('imgAlignMiddleV');
    const imgAlignBottom = document.getElementById('imgAlignBottom');

    function getSelectionImages() {
        const active = fabricCanvas.getActiveObject();
        if (!active) return [];
        if (active.type === 'activeSelection') return active.getObjects().filter(o => o.type === 'image');
        return active.type === 'image' ? [active] : [];
    }
    function getAllImages() { return fabricCanvas.getObjects().filter(o => o.type === 'image'); }
    function alignSelected(horizontal, vertical) {
        const images = getSelectionImages(); if (images.length === 0) return;
        const canvasWidth = fabricCanvas.getWidth();
        const canvasHeight = fabricCanvas.getHeight();
        images.forEach(img => {
            const halfW = img.getScaledWidth() / 2, halfH = img.getScaledHeight() / 2;
            if (horizontal === 'left') img.left = halfW;
            if (horizontal === 'center') img.left = canvasWidth / 2;
            if (horizontal === 'right') img.left = canvasWidth - halfW;
            if (vertical === 'top') img.top = halfH;
            if (vertical === 'middle') img.top = canvasHeight / 2;
            if (vertical === 'bottom') img.top = canvasHeight - halfH;
            img.setCoords();
        });
        fabricCanvas.requestRenderAll();
    }
    imgAlignLeft.addEventListener('click', () => { alignSelected('left'); imgAlignLeft.classList.add('active'); setTimeout(() => imgAlignLeft.classList.remove('active'), 200); });
    imgAlignCenterH.addEventListener('click', () => { alignSelected('center'); imgAlignCenterH.classList.add('active'); setTimeout(() => imgAlignCenterH.classList.remove('active'), 200); });
    imgAlignRight.addEventListener('click', () => { alignSelected('right'); imgAlignRight.classList.add('active'); setTimeout(() => imgAlignRight.classList.remove('active'), 200); });
    imgAlignTop.addEventListener('click', () => { alignSelected(undefined, 'top'); imgAlignTop.classList.add('active'); setTimeout(() => imgAlignTop.classList.remove('active'), 200); });
    imgAlignMiddleV.addEventListener('click', () => { alignSelected(undefined, 'middle'); imgAlignMiddleV.classList.add('active'); setTimeout(() => imgAlignMiddleV.classList.remove('active'), 200); });
    imgAlignBottom.addEventListener('click', () => { alignSelected(undefined, 'bottom'); imgAlignBottom.classList.add('active'); setTimeout(() => imgAlignBottom.classList.remove('active'), 200); });
    function forEachSelection(cb) { const images = getSelectionImages(); if (images.length === 0) return; images.forEach(cb); fabricCanvas.requestRenderAll(); }
    document.getElementById('bringToFrontBtn').addEventListener('click', () => forEachSelection(o => o.bringToFront && o.bringToFront()));
    document.getElementById('bringForwardBtn').addEventListener('click', () => forEachSelection(o => o.bringForward && o.bringForward()));
    document.getElementById('sendBackwardsBtn').addEventListener('click', () => forEachSelection(o => o.sendBackwards && o.sendBackwards()));
    document.getElementById('sendToBackBtn').addEventListener('click', () => forEachSelection(o => o.sendToBack && o.sendToBack()));
    function sameWidth() { const images = getSelectionImages(); if (images.length < 2) return; const w = images[0].getScaledWidth(); images.forEach((img, i) => { if (i === 0) return; const scale = w / img.getScaledWidth(); img.scaleX *= scale; img.scaleY *= scale; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    function sameHeight() { const images = getSelectionImages(); if (images.length < 2) return; const h = images[0].getScaledHeight(); images.forEach((img, i) => { if (i === 0) return; const scale = h / img.getScaledHeight(); img.scaleX *= scale; img.scaleY *= scale; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    function sameSize() { const images = getSelectionImages(); if (images.length < 2) return; const w = images[0].getScaledWidth(), h = images[0].getScaledHeight(); images.forEach((img, i) => { if (i === 0) return; const scaleX = w / img.getScaledWidth(), scaleY = h / img.getScaledHeight(); img.scaleX *= scaleX; img.scaleY *= scaleY; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    document.getElementById('sameWidthBtn').addEventListener('click', () => sameWidth());
    document.getElementById('sameHeightBtn').addEventListener('click', () => sameHeight());
    document.getElementById('sameSizeBtn').addEventListener('click', () => sameSize());
    function distributeHorizontally() { const images = getSelectionImages(); if (images.length < 3) return; const sorted = [...images].sort((a,b) => a.left - b.left); const leftMost = sorted[0], rightMost = sorted[sorted.length-1]; const totalWidth = rightMost.left - leftMost.left; const step = totalWidth / (sorted.length - 1); sorted.forEach((img, idx) => { img.left = leftMost.left + step * idx; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    function distributeVertically() { const images = getSelectionImages(); if (images.length < 3) return; const sorted = [...images].sort((a,b) => a.top - b.top); const topMost = sorted[0], bottomMost = sorted[sorted.length-1]; const totalHeight = bottomMost.top - topMost.top; const step = totalHeight / (sorted.length - 1); sorted.forEach((img, idx) => { img.top = topMost.top + step * idx; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    document.getElementById('distributeHBtn').addEventListener('click', () => distributeHorizontally());
    document.getElementById('distributeVBtn').addEventListener('click', () => distributeVertically());
    function syncImageToCell(image) {
        if (!image.attachedCellId) return;
        const cell = document.getElementById(image.attachedCellId);
        const canvasContainer = imageOverlayContainer;
        if (!cell) { image.attachedCellId = null; image.set({ stroke: null, strokeWidth: 0 }); return; }
        const cellRect = cell.getBoundingClientRect(), containerRect = canvasContainer.getBoundingClientRect();
        const left = cellRect.left - containerRect.left, top = cellRect.top - containerRect.top;
        const width = cellRect.width, height = cellRect.height, padding = 4;
        const targetWidth = Math.max(1, width - padding), targetHeight = Math.max(1, height - padding);
        const scaleX = targetWidth / image.width, scaleY = targetHeight / image.height;
        image.set({ scaleX, scaleY, left: left + width / 2, top: top + height / 2, originX: 'center', originY: 'center' });
        image.setCoords();
    }
    function updateAllAttachedImages() {
        fabricCanvas.getObjects().forEach(obj => { if (obj.attachedCellId) { syncImageToCell(obj); } });
        fabricCanvas.renderAll();
    }
    function attachImageToCell() {
        const images = getSelectionImages();
        if (images.length !== 1) { alert('하나의 이미지를 선택해주세요.'); return; }
        if (selectedCells.length !== 1) { alert('하나의 표 셀을 선택해주세요.'); return; }
        const image = images[0], cell = selectedCells[0];
        if (!cell.id) { updateCellIds(); }
        if (!cell.id) { alert('셀을 식별할 수 없습니다. 다시 시도해주세요.'); return; }
        image.attachedCellId = cell.id;
        image.set({ stroke: 'rgba(26,115,232,0.8)', strokeWidth: 3 });
        syncImageToCell(image);
        fabricCanvas.requestRenderAll();
        captureCurrentSelection();
    }
    document.getElementById('attachToCellBtn').addEventListener('click', attachImageToCell);
    document.getElementById('selectAllImagesBtn').addEventListener('click', () => { const imgs = getAllImages(); if (imgs.length === 0) return; fabricCanvas.setActiveObject(new fabric.ActiveSelection(imgs, { canvas: fabricCanvas })); fabricCanvas.requestRenderAll(); });
    document.getElementById('clearSelectionBtn').addEventListener('click', () => { allowManualClear = true; fabricCanvas.discardActiveObject().requestRenderAll(); });
    function deleteSelection() {
        if (isCropping) return;
        const active = fabricCanvas.getActiveObject(); if (!active) return;
        if (active.type === 'activeSelection') { active.getObjects().forEach(o => fabricCanvas.remove(o)); } 
        else { fabricCanvas.remove(active); }
        persistentSelection = null;
        fabricCanvas.discardActiveObject().requestRenderAll();
    }
    
    imageFileInput.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        if (isCropping || files.length === 0) return;
        document.body.style.cursor = 'wait';
        addImageBtn.disabled = true;
        try {
            syncCanvasSize();
            const selectedLevel = document.querySelector('input[name="compression-level"]:checked')?.value || 'medium';
            const compressionStatusEl = document.getElementById('compression-status');
            if (compressionStatusEl) compressionStatusEl.textContent = '이미지 압축 중...';
            const compressionPresets = {
                high:   { maxSizeMB: 2.0, initialQuality: 0.9, maxWidthOrHeight: 2560 },
                medium: { maxSizeMB: 0.8, initialQuality: 0.8, maxWidthOrHeight: 1920 },
                low:    { maxSizeMB: 0.3, initialQuality: 0.6, maxWidthOrHeight: 1280 }
            };
            const baseOptions = compressionPresets[selectedLevel];
            let totalOriginalSize = 0, totalCompressedSize = 0;
            const imageProcessingPromises = files.map(async (file) => {
                totalOriginalSize += file.size;
                const compressionOptions = { ...baseOptions, useWebWorker: true, maxIteration: 10, alwaysKeepResolution: false };
                try {
                    const compressedFile = await imageCompression(file, compressionOptions);
                    totalCompressedSize += compressedFile.size;
                    return await imageCompression.getDataUrlFromFile(compressedFile);
                } catch (error) {
                    console.warn(`'${file.name}' 압축 실패, 캔버스 폴백 시도:`, error);
                    try {
                        return await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => {
                                const img = new Image();
                                img.onload = () => {
                                    const max = 1920;
                                    let { width, height } = img;
                                    const scale = Math.min(1, max / Math.max(width, height));
                                    width = Math.round(width * scale); height = Math.round(height * scale);
                                    const canvas = document.createElement('canvas');
                                    canvas.width = width; canvas.height = height;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(img, 0, 0, width, height);
                                    resolve(canvas.toDataURL('image/jpeg', 0.85));
                                };
                                img.onerror = reject;
                                img.src = reader.result;
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                    } catch (err2) { console.error(`'${file.name}' 폴백까지 실패:`, err2); return null; }
                }
            });
            const imageDataUrls = await Promise.all(imageProcessingPromises);
            if (compressionStatusEl) {
                const reduction = totalOriginalSize > 0 ? ((1 - totalCompressedSize / totalOriginalSize) * 100).toFixed(1) : 0;
                compressionStatusEl.textContent = `압축: ${formatBytes(totalOriginalSize)} → ${formatBytes(totalCompressedSize)} (${reduction}%↓)`;
            }
            const validUrls = imageDataUrls.filter(url => url !== null);
            const imageLoadingPromises = validUrls.map(url => new Promise((resolve, reject) => { fabric.Image.fromURL(url, img => { if (img) resolve(img); else reject(new Error('데이터 URL로부터 이미지를 로드하지 못했습니다.')); }, { crossOrigin: 'anonymous' }); }));
            let fabricImages = await Promise.all(imageLoadingPromises);
            fabricImages.forEach((img, i) => { img.selectable = true; img.evented = true; img.perPixelTargetFind = true; img.bringToFront(); img.set({ globalCompositeOperation: 'source-over' }); });
            fabricImages.forEach((img, index) => {
                const canvasRect = fabricCanvas.upperCanvasEl.getBoundingClientRect();
                const viewportCenterX = (window.innerWidth / 2), viewportCenterY = (window.innerHeight / 2);
                let targetLeft = viewportCenterX - canvasRect.left, targetTop = viewportCenterY - canvasRect.top;
                const offset = (index - (fabricImages.length - 1) / 2) * 40;
                targetLeft += offset; targetTop += offset;
                const targetWidth = Math.min(480, img.width || 480);
                img.scaleToWidth(targetWidth);
                img.set({ left: targetLeft, top: targetTop, originX: 'center', originY: 'center', angle: 0, padding: 10, cornerSize: 10, hasRotatingPoint: true, });
                const halfW = (img.getScaledWidth() || 200) / 2, halfH = (img.getScaledHeight() || 200) / 2;
                img.left = Math.max(halfW, Math.min(fabricCanvas.width - halfW, img.left));
                img.top = Math.max(halfH, Math.min(fabricCanvas.height - halfH, img.top));
                fabricCanvas.add(img);
                img.bringToFront();
            });
            if (validUrls.length < files.length) { alert('일부 이미지 처리 중 오류가 발생했습니다. 자세한 내용은 개발자 콘솔을 확인해주세요.'); }
            if (fabricImages.length > 0) {
                const upperCanvas = fabricCanvas.upperCanvasEl;
                if (upperCanvas) upperCanvas.style.pointerEvents = isImageEditMode ? 'auto' : 'none';
                setTimeout(() => {
                    try { const lastImg = fabricImages[fabricImages.length - 1]; if (lastImg) fabricCanvas.setActiveObject(lastImg); fabricCanvas.requestRenderAll(); } 
                    catch (e) { console.warn('selection 구성 중 경고:', e); }
                }, 0);
                ensureCanvasOnTop();
                updateOverlayPosition();
            }
            fabricCanvas.renderAll();
        } catch (error) { console.error("이미지 처리 과정에서 예기치 않은 오류 발생:", error); alert("이미지를 처리하는 중 심각한 오류가 발생했습니다."); } 
        finally { document.body.style.cursor = 'default'; addImageBtn.disabled = false; e.target.value = ''; ensureCanvasOnTop(); }
    });

    const deleteIcon="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='0 0 595.275 595.275' enable-background='new 0 0 595.275 595.275' xml:space='preserve'%3E%3Cg%3E%3Cpath d='M354.724,297.636l227.16-227.16c9.763-9.763,9.763-25.592,0-35.355L544.51,0l-227.16,227.16L89.675-0.002 L48.3,35.353c-9.763,9.763-9.763,25.592,0,35.355l227.69,227.69L48.3,524.801c-9.763,9.763-9.763,25.592,0,35.355 l37.375,37.375c9.763,9.763,25.592,9.763,35.355,0l227.16-227.16l227.16,227.16c9.763,9.763,25.592,9.763,35.355,0 l37.375-37.375c9.763-9.763,9.763-25.592,0-35.355L354.724,297.636z'/%3E%3C/g%3E%3C/svg%3E";
    const cloneIcon="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='iso-8859-1'%3F%3E%3Csvg version='1.1' id='Capa_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 35.635 35.635' style='enable-background:new 0 0 35.635 35.635;' xml:space='preserve'%3E%3Cg%3E%3Cpath d='M34.135,0H9.762c-0.828,0-1.5,0.672-1.5,1.5v4.323H1.5c-0.828,0-1.5,0.672-1.5,1.5v26.812c0,0.828,0.672,1.5,1.5,1.5 h24.373c0.828,0,1.5-0.672,1.5-1.5v-4.323h6.762c0.828,0,1.5-0.672,1.5-1.5V1.5C35.635,0.672,34.963,0,34.135,0z M24.373,32.635 H3V8.823h21.373V32.635z M32.635,28.312h-5.262V7.323c0-0.828-0.672-1.5-1.5-1.5H9.762V3h22.873V28.312z'/%3E%3C/g%3E%3C/svg%3E";
    const flipIcon="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='122.879px' height='104.918px' viewBox='0 0 122.879 104.918' enable-background='new 0 0 122.879 104.918' xml:space='preserve'%3E%3Cg%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M99.951,104.918H69.419c-3.172,0-5.742-2.57-5.742-5.742V5.742 c0-3.172,2.57-5.742,5.742-5.742h30.532c3.171,0,5.741,2.57,5.741,5.742v93.435C105.692,102.348,103.122,104.918,99.951,104.918z M53.46,5.742v93.435c0,3.172-2.57,5.742-5.742,5.742H22.936c-3.171,0-5.742-2.57-5.742-5.742V5.742c0-3.172,2.571-5.742,5.742-5.742 h24.782C50.89,0,53.46,2.57,53.46,5.742z M99.951,104.918'/%3E%3C/g%3E%3C/svg%3E";
    const cropIcon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M17 15h2V7c0-1.1-.9-2-2-2H9v2h8v8zM7 17V1H5v4H1v2h4v10c0 1.1.9 2 2 2h10v4h2v-4h4v-2H7z' fill='%23333'%3E%3C/path%3E%3C/svg%3E";
    const applyCropIcon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z' fill='white'%3E%3C/path%3E%3C/svg%3E";
    const cancelCropIcon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z' fill='white'%3E%3C/path%3E%3C/svg%3E";
    
    function renderIcon(icon, withBg = false) {
        return function renderIcon(ctx, left, top, styleOverride, fabricObject) {
            const size = this.cornerSize;
            ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            if (withBg) { ctx.beginPath(); ctx.arc(0, 0, size / 2, 0, Math.PI * 2, false); ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fill(); }
            ctx.drawImage(icon, -size / 2, -size / 2, size, size);
            ctx.restore();
        }
    }
    const deleteImg = document.createElement('img'); deleteImg.src = deleteIcon; const cloneImg = document.createElement('img'); cloneImg.src = cloneIcon; const flipImg = document.createElement('img'); flipImg.src = flipIcon;
    const cropImg = document.createElement('img'); cropImg.src = cropIcon;
    const applyCropImg = document.createElement('img'); applyCropImg.src = applyCropIcon;
    const cancelCropImg = document.createElement('img'); cancelCropImg.src = cancelCropIcon;
    
    fabric.Object.prototype.transparentCorners = false; fabric.Object.prototype.cornerColor = 'rgba(102,153,255,0.8)'; fabric.Object.prototype.cornerStyle = 'circle'; fabric.Object.prototype.borderColor = 'rgba(102,153,255,0.8)'; fabric.Object.prototype.borderScaleFactor = 2;
    fabricCanvas.snapToGrid = 5;
    fabricCanvas.on('object:moving', function(e) {
        const obj = e.target; if (!obj) return;
        if(isAnnotationMode) return;
        obj.left = Math.round(obj.left / fabricCanvas.snapToGrid) * fabricCanvas.snapToGrid;
        obj.top = Math.round(obj.top / fabricCanvas.snapToGrid) * fabricCanvas.snapToGrid;
        drawGuides(obj);
    });
    fabricCanvas.on('object:modified', function(e) {
        const obj = e.target;
        if (obj && obj.isAnnotation) { obj.persistentTop = obj.top; obj.bringToFront(); }
        if (obj && obj.attachedCellId) { if (isCropping) return; obj.attachedCellId = null; obj.set({ stroke: null, strokeWidth: 0 }); }
        clearGuides(); captureCurrentSelection(); });
    
    let allowManualClear = false, persistentSelection = null, mousedownOnToolsPopup = false;
    function captureCurrentSelection() { const active = fabricCanvas.getActiveObject(); if (active) { persistentSelection = active; } }
    fabricCanvas.on('before:transform', captureCurrentSelection);
    fabricCanvas.on('selection:created', captureCurrentSelection);
    fabricCanvas.on('selection:updated', captureCurrentSelection);
    document.addEventListener('mousedown', (e) => { if (!isImageEditMode) return; mousedownOnToolsPopup = !!e.target.closest('#image-tools-popup'); }, true);
    fabricCanvas.on('selection:cleared', function() {
        if (isCropping || !isImageEditMode) return;
        if (allowManualClear) { allowManualClear = false; persistentSelection = null; return; }
        if (mousedownOnToolsPopup && persistentSelection) {
            setTimeout(() => {
                try {
                    let objs = [];
                    if (persistentSelection.type === 'activeSelection') { objs = persistentSelection.getObjects().filter(o => fabricCanvas.getObjects().includes(o)); } 
                    else if (fabricCanvas.getObjects().includes(persistentSelection)) { objs = [persistentSelection]; }
                    if (objs.length > 0) {
                        const selectionToRestore = objs.length === 1 ? objs[0] : new fabric.ActiveSelection(objs, { canvas: fabricCanvas });
                        fabricCanvas.setActiveObject(selectionToRestore).requestRenderAll();
                    }
                } catch (e) { console.warn("Could not restore selection", e); }
            }, 0);
        }
    });
    document.addEventListener('mousedown', (e) => {
        if (!isImageEditMode || isCropping) return;
        const upper = fabricCanvas.upperCanvasEl;
        const clickedOnOverlay = upper && upper.contains(e.target);
        const clickedOnToolsPopup = !!e.target.closest('#image-tools-popup');
        if (!clickedOnOverlay && !clickedOnToolsPopup) { e.stopPropagation(); }
    }, true);
    const snapGridInputEl = document.getElementById('snapGridInput');
    const guideToleranceInputEl = document.getElementById('guideToleranceInput');
    const guideColorInputEl = document.getElementById('guideColorInput');
    if (snapGridInputEl) snapGridInputEl.addEventListener('change', () => { const v = parseInt(snapGridInputEl.value, 10); if (!isNaN(v) && v >= 0) fabricCanvas.snapToGrid = v; });
    if (guideToleranceInputEl) guideToleranceInputEl.addEventListener('change', () => { const v = parseInt(guideToleranceInputEl.value, 10); if (!isNaN(v) && v >= 0) guideTolerance = v; });
    if (guideColorInputEl) guideColorInputEl.addEventListener('input', () => { guideColor = guideColorInputEl.value || '#ff0000'; });
    (function enablePopupDragAndResize() {
        const popup = imageToolsPopup; const header = popupHeaderEl; const uiOverlay = document.getElementById('ui-drag-overlay');
        let drag = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
        let resizing = false, rsDir = '', rsStartX = 0, rsStartY = 0, rsStartW = 0, rsStartH = 0, rsStartL = 0, rsStartT = 0;
        function setPopupActive(active) {
            const handles = popup.querySelectorAll('.resize-handle');
            handles.forEach(h => h.style.display = active ? 'block' : 'none');
            popup.classList.toggle('active', active);
        }
        const observer = new MutationObserver(() => { const isShown = popup.style.display !== 'none'; if (isShown) { ensureToolsPopupOnTop(); setPopupActive(false); popup.focus(); } });
        observer.observe(popup, { attributes: true, attributeFilter: ['style'] });
        function startOverlay() { if (uiOverlay) uiOverlay.style.display = 'block'; }
        function stopOverlay() { if (uiOverlay) uiOverlay.style.display = 'none'; }
        header.addEventListener('mousedown', (e) => {
            if (e.target.closest('button')) return;
            drag = true; startOverlay(); startX = e.clientX; startY = e.clientY;
            const rect = popup.getBoundingClientRect(); startLeft = rect.left; startTop = rect.top;
            document.body.style.userSelect = 'none';
            e.preventDefault(); e.stopPropagation();
            setPopupActive(true);
            popup.focus({ preventScroll: true });
        });
        function isInteractive(el) { return !!el.closest('button, input, select, textarea, label, .resize-handle'); }
        ['n','s','e','w','ne','nw','se','sw'].forEach(dir => { const h = document.createElement('div'); h.className = 'resize-handle ' + dir; popup.appendChild(h); });
        popup.addEventListener('mousedown', (e) => {
            setPopupActive(true);
            if (e.target.classList.contains('resize-handle')) {
                e.preventDefault(); e.stopPropagation(); resizing = true;
                rsDir = [...e.target.classList].find(c => c.length <= 2 && c !== 'resize-handle');
                const rect = popup.getBoundingClientRect(); rsStartX = e.clientX; rsStartY = e.clientY; rsStartW = rect.width; rsStartH = rect.height; rsStartL = rect.left; rsStartT = rect.top;
                document.body.style.userSelect = 'none'; startOverlay();
            } else if (!isInteractive(e.target) && !drag && !resizing) {
                drag = true; startOverlay(); startX = e.clientX; startY = e.clientY;
                const rect = popup.getBoundingClientRect(); startLeft = rect.left; startTop = rect.top;
                document.body.style.userSelect = 'none'; e.preventDefault();
                popup.focus({ preventScroll: true });
            }
        });
        document.addEventListener('mousedown', (e) => { if (!e.target.closest('#image-tools-popup')) { setPopupActive(false); } });
        document.addEventListener('mousemove', (e) => {
            if (drag) {
                e.preventDefault(); const dx = e.clientX - startX, dy = e.clientY - startY;
                popup.style.left = Math.max(0, startLeft + dx) + 'px';
                popup.style.top = Math.max(0, startTop + dy) + 'px';
            } else if (resizing) {
                e.preventDefault();
                let dx = e.clientX - rsStartX, dy = e.clientY - rsStartY;
                let newW = rsStartW, newH = rsStartH, newL = rsStartL, newT = rsStartT;
                if (rsDir.includes('e')) newW = Math.max(260, rsStartW + dx);
                if (rsDir.includes('s')) newH = Math.max(160, rsStartH + dy);
                if (rsDir.includes('w')) { newW = Math.max(260, rsStartW - dx); newL = rsStartL + dx; }
                if (rsDir.includes('n')) { newH = Math.max(160, rsStartH - dy); newT = rsStartT + dy; }
                popup.style.width = newW + 'px'; popup.style.height = newH + 'px';
                popup.style.left = Math.max(0, newL) + 'px'; popup.style.top = Math.max(0, newT) + 'px';
            }
        });
        document.addEventListener('mouseup', () => { if (drag || resizing) { drag = false; resizing = false; stopOverlay(); document.body.style.userSelect = ''; } });
    })();

    let guideLines = [];
    let guideColor = '#ff0000';
    let guideTolerance = 4;
    function clearGuides() { guideLines.forEach(l => fabricCanvas.remove(l)); guideLines = []; fabricCanvas.requestRenderAll(); }
    function drawGuides(obj) {
        clearGuides();
        const objects = fabricCanvas.getObjects().filter(o => o !== obj && o.type === 'image');
        const tolerance = guideTolerance;
        const objBounds = obj.getBoundingRect(true);
        objects.forEach(o => {
            const b = o.getBoundingRect(true);
            const candidatesX = [b.left, b.left + b.width / 2, b.left + b.width];
            const currentX = [objBounds.left, objBounds.left + objBounds.width / 2, objBounds.left + objBounds.width];
            candidatesX.forEach(cx => currentX.forEach(ox => { if (Math.abs(cx - ox) <= tolerance) { guideLines.push(new fabric.Line([cx, 0, cx, fabricCanvas.height], { stroke: guideColor, strokeOpacity: 0.5, selectable: false, evented: false })); } }));
            const candidatesY = [b.top, b.top + b.height / 2, b.top + b.height];
            const currentY = [objBounds.top, objBounds.top + objBounds.height / 2, objBounds.top + objBounds.height];
            candidatesY.forEach(cy => currentY.forEach(oy => { if (Math.abs(cy - oy) <= tolerance) { guideLines.push(new fabric.Line([0, cy, fabricCanvas.width, cy], { stroke: guideColor, strokeOpacity: 0.5, selectable: false, evented: false })); } }));
        });
        guideLines.forEach(l => fabricCanvas.add(l));
        guideLines.forEach(l => l.bringToFront && l.bringToFront());
        fabricCanvas.requestRenderAll();
    }
    fabric.Object.prototype.controls.deleteControl = new fabric.Control({ x: 0.5, y: -0.5, offset: {x: 15, y: -15}, cursorStyle: 'pointer', mouseUpHandler: deleteObject, render: renderIcon(deleteImg), cornerSize: 24 });
    fabric.Object.prototype.controls.cloneControl = new fabric.Control({ x: -0.5, y: -0.5, offset: {x: -15, y: -15}, cursorStyle: 'pointer', mouseUpHandler: cloneObject, render: renderIcon(cloneImg), cornerSize: 24 });
    fabric.Object.prototype.controls.flipControl = new fabric.Control({ x: -0.5, y: 0.5, offset: {x: -15, y: 15}, cursorStyle: 'pointer', mouseUpHandler: flipObject, render: renderIcon(flipImg), cornerSize: 24 });
    fabric.Object.prototype.controls.cropControl = new fabric.Control({ x: 0.5, y: 0, offset: { x: 20, y: 0 }, cursorStyle: 'pointer', mouseUpHandler: startCrop, render: renderIcon(cropImg), cornerSize: 24, visible: function() { return this.type === 'image' && !isCropping; } });
    function deleteObject(eventData, transform) { const target = transform.target; const canvas = target.canvas; canvas.remove(target); canvas.requestRenderAll(); }
    function cloneObject(eventData, transform) { const target = transform.target; const canvas = target.canvas; target.clone(function(cloned) { cloned.left += 20; cloned.top += 20; cloned.bringToFront && cloned.bringToFront(); canvas.add(cloned); canvas.setActiveObject(cloned); canvas.requestRenderAll(); }); }
    function flipObject(eventData, transform) { const target = transform.target; target.toggle('flipX'); target.canvas.requestRenderAll(); }
    function setLockedVisual(o, locked) { o.opacity = locked ? 0.6 : 1.0; o.borderColor = locked ? 'rgba(200,0,0,0.8)' : 'rgba(102,153,255,0.8)'; o.cornerColor = locked ? 'rgba(200,0,0,0.6)' : 'rgba(102,153,255,0.8)'; }
    function lockSelected() { const obj = fabricCanvas.getActiveObject(); if (!obj) return; const setLock = (o, v) => { o.lockMovementX = v; o.lockMovementY = v; o.lockScalingX = v; o.lockScalingY = v; o.lockRotation = v; o.selectable = !v; setLockedVisual(o, v); }; if (obj.type === 'activeSelection') { obj.getObjects().forEach(o => setLock(o, true)); } else { setLock(obj, true); } fabricCanvas.discardActiveObject().requestRenderAll(); }
    function unlockAll() { fabricCanvas.getObjects().forEach(o => { o.lockMovementX = o.lockMovementY = o.lockScalingX = o.lockScalingY = o.lockRotation = false; o.selectable = true; setLockedVisual(o, false); }); fabricCanvas.requestRenderAll(); }
    window.addEventListener('keydown', (e) => {
        if (isCropping) { if (e.key === 'Escape') cancelCrop(); if (e.key === 'Enter') applyCrop(); return; }
        if (e.target.closest('[contenteditable="true"]')) return; const activeObject = fabricCanvas.getActiveObject(); if (!activeObject) return;
        if (e.key === 'Delete' || e.key === 'Backspace') { deleteSelection(); }
        if ((e.ctrlKey || e.metaKey) && e.key === 'c') { activeObject.clone(function(cloned) { _clipboard = cloned; }); }
        if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
            if (!_clipboard) return;
            _clipboard.clone(function(clonedObj) {
                fabricCanvas.discardActiveObject();
                clonedObj.set({ left: clonedObj.left + 20, top: clonedObj.top + 20, evented: true, });
                if (clonedObj.type === 'activeSelection') { clonedObj.canvas = fabricCanvas; clonedObj.forEachObject(function(obj) { fabricCanvas.add(obj); }); clonedObj.setCoords(); } 
                else { fabricCanvas.add(clonedObj); }
                _clipboard.top += 20; _clipboard.left += 20;
                fabricCanvas.setActiveObject(clonedObj); clonedObj.bringToFront && clonedObj.bringToFront(); ensureCanvasOnTop(); updateOverlayPosition(); fabricCanvas.requestRenderAll();
            });
        }
    });

    function loadCanvasData() {
        const canvasDataScript = document.getElementById('canvas-data');
        if (canvasDataScript && canvasDataScript.textContent) {
            try {
                const jsonData = JSON.parse(canvasDataScript.textContent);
                fabricCanvas.loadFromJSON(jsonData, () => {
                    updateCellIds(); updateAllAttachedImages(); updateAnnotationPositions();
                    fabricCanvas.getObjects().forEach(obj => { if (obj.attachedCellId) { obj.set({ stroke: 'rgba(26,115,232,0.8)', strokeWidth: 3 }); } });
                    fabricCanvas.renderAll();
                });
            } catch (e) { console.error("캔버스 데이터 로드 실패:", e); }
        }
    }

    function initializeDraggableTable() {
        let draggingElement = null, dragType = null, dropTarget = null;
        table.addEventListener('mousedown', (e) => {
            if (isImageEditMode || isAnnotationMode || e.button !== 0) return;
            // Prevent dragging when resize cursor is active
            if (table.style.cursor.includes('resize')) return;
            const th = e.target.closest('th'), noCell = e.target.closest('.no-cell');
            if (e.target.closest('.th-tools, [contenteditable="true"]')) return;
            if (th && th.cellIndex > 0) { e.preventDefault(); dragType = 'col'; draggingElement = { index: th.cellIndex, element: th }; document.body.style.cursor = 'grabbing'; setColumnDragging(draggingElement.index, true); } 
            else if (noCell) { e.preventDefault(); dragType = 'row'; const row = noCell.closest('tr'); draggingElement = { element: row }; row.classList.add('dragging-row'); document.body.style.cursor = 'grabbing'; } 
            else { return; }
            if (draggingElement) { document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp, { once: true }); }
        });
        function onMouseMove(e) {
            if (!draggingElement) return;
            const currentOver = e.target.closest(dragType === 'row' ? 'tr' : 'th');
            document.querySelectorAll('.drop-indicator-row-before, .drop-indicator-row-after, .drop-indicator-col-before').forEach(el => el.classList.remove('drop-indicator-row-before', 'drop-indicator-row-after', 'drop-indicator-col-before'));
            if (currentOver && currentOver !== draggingElement.element) {
                dropTarget = { element: currentOver };
                if (dragType === 'row') {
                    const rect = currentOver.getBoundingClientRect();
                    const isAfter = e.clientY > rect.top + rect.height / 2;
                    currentOver.classList.add(isAfter ? 'drop-indicator-row-after' : 'drop-indicator-row-before');
                    dropTarget.position = isAfter ? 'after' : 'before';
                } else {
                    const targetIndex = currentOver.cellIndex;
                    if (targetIndex > 0) { currentOver.classList.add('drop-indicator-col-before'); dropTarget.index = targetIndex; } 
                    else { dropTarget = null; }
                }
            } else { dropTarget = null; }
        }
        function onMouseUp() {
            if (draggingElement && dropTarget) {
                if (dragType === 'row') {
                    const dragEl = draggingElement.element, dropEl = dropTarget.element;
                    if (dropTarget.position === 'after') dropEl.parentNode.insertBefore(dragEl, dropEl.nextSibling);
                    else dropEl.parentNode.insertBefore(dragEl, dropEl);
                    updateRowNumbers(); updateCellIds(); updateAllAttachedImages();
                } else { const fromIndex = draggingElement.index, toIndex = dropTarget.index; if (fromIndex !== toIndex) moveColumn(fromIndex, toIndex); }
            }
            if (draggingElement?.element) draggingElement.element.classList.remove('dragging-row');
            setColumnDragging(draggingElement?.index, false);
            document.querySelectorAll('.drop-indicator-row-before, .drop-indicator-row-after, .drop-indicator-col-before').forEach(el => el.classList.remove('drop-indicator-row-before', 'drop-indicator-row-after', 'drop-indicator-col-before'));
            document.removeEventListener('mousemove', onMouseMove);
            document.body.style.cursor = '';
            draggingElement = null; dropTarget = null; dragType = null;
        }
        function moveColumn(fromIndex, toIndex) {
            Array.from(table.rows).forEach(row => { const cellToMove = row.cells[fromIndex]; if (cellToMove) row.insertBefore(cellToMove, row.cells[toIndex]); });
            const colgroup = table.querySelector('colgroup');
            colgroup.insertBefore(colgroup.children[fromIndex], colgroup.children[toIndex]);
            findSpecialColumns(); updateCellIds(); updateAllAttachedImages();
        }
        function setColumnDragging(colIndex, isDragging) {
            if (colIndex === undefined || colIndex < 1) return;
            Array.from(table.rows).forEach(row => { if (row.cells[colIndex]) { row.cells[colIndex].classList.toggle('dragging-col', isDragging); } });
        }
    }

    function initializeAutoFit() {
        table.addEventListener('dblclick', (e) => {
            const th = e.target.closest('th'), noCell = e.target.closest('.no-cell');
            if (th && th.cellIndex > 0) {
                const colIndex = th.cellIndex; let maxWidth = 0;
                Array.from(table.rows).forEach(row => { const cell = row.cells[colIndex]; if (cell) { maxWidth = Math.max(maxWidth, cell.scrollWidth); } });
                const colElement = table.querySelector('colgroup').children[colIndex];
                colElement.style.width = (maxWidth + 10) + 'px';
                updateAllAttachedImages();
            } else if (noCell) { const row = noCell.closest('tr'); row.style.height = 'auto'; updateAllAttachedImages(); }
        });
    }

    function startCrop(eventData, transform) {
        if (isCropping) return;
        const targetImage = transform.target;
        if (!targetImage || targetImage.type !== 'image') return;
        isCropping = true; cropTargetImage = targetImage; cropTargetImage.hasControls = false;
        fabricCanvas.getObjects().forEach(obj => {
            if (obj === cropTargetImage) { obj.set({ opacity: 0.7, evented: false, selectable: false }); } 
            else { obj.set({ evented: false, selectable: false }); }
        });
        fabricCanvas.discardActiveObject();
        const bounds = cropTargetImage.getBoundingRect();
        cropRect = new fabric.Rect({
            left: bounds.left, top: bounds.top, width: bounds.width, height: bounds.height, fill: 'rgba(0, 0, 0, 0.3)', stroke: '#4d90fe', strokeWidth: 2, strokeDashArray: [5, 5],
            hasRotatingPoint: false, cornerColor: '#4d90fe', cornerStyle: 'circle', transparentCorners: false, borderColor: '#4d90fe', evented: true, selectable: true,
        });
        cropRect.controls.apply = new fabric.Control({ x: 0.5, y: -0.5, offset: { x: 0, y: -30 }, cursorStyle: 'pointer', mouseUpHandler: applyCrop, render: renderIcon(applyCropImg, true), cornerSize: 24 });
        cropRect.controls.cancel = new fabric.Control({ x: -0.5, y: -0.5, offset: { x: 0, y: -30 }, cursorStyle: 'pointer', mouseUpHandler: () => cancelCrop(), render: renderIcon(cancelCropImg, true), cornerSize: 24 });
        fabricCanvas.add(cropRect);
        fabricCanvas.setActiveObject(cropRect);
        fabricCanvas.renderAll();
    }

    function applyCrop() {
        if (!isCropping || !cropTargetImage || !cropRect) return;
        const img = cropTargetImage;
        const invertedMatrix = fabric.util.invertTransform(img.calcTransformMatrix());
        const cropPoints = cropRect.getCoords();
        const transformedPoints = cropPoints.map(p => fabric.util.transformPoint(p, invertedMatrix));
        const minX = fabric.util.array.min(transformedPoints, 'x'), minY = fabric.util.array.min(transformedPoints, 'y');
        const maxX = fabric.util.array.max(transformedPoints, 'x'), maxY = fabric.util.array.max(transformedPoints, 'y');
        const cropWidthLocal = maxX - minX, cropHeightLocal = maxY - minY;
        const finalCropX = (img.cropX || 0) + minX + (img.width / 2), finalCropY = (img.cropY || 0) + minY + (img.height / 2);
        img.width = cropWidthLocal; img.height = cropHeightLocal;
        img.cropX = finalCropX; img.cropY = finalCropY;
        img.left = cropRect.getCenterPoint().x; img.top = cropRect.getCenterPoint().y;
        img.scaleX = cropRect.getScaledWidth() / cropWidthLocal; img.scaleY = cropRect.getScaledHeight() / cropHeightLocal;
        img.setCoords();
        cancelCrop(true);
        fabricCanvas.setActiveObject(img);
        fabricCanvas.requestRenderAll();
    }
    
    function cancelCrop(silent = false) {
        if (!isCropping) return;
        if (cropTargetImage) { cropTargetImage.hasControls = true; }
        isCropping = false;
        if (cropRect) fabricCanvas.remove(cropRect);
        cropRect = null;
        fabricCanvas.getObjects().forEach(obj => { obj.set({ opacity: 1.0, evented: true, selectable: true }); });
        if (!silent && cropTargetImage) { fabricCanvas.setActiveObject(cropTargetImage); }
        cropTargetImage = null;
        fabricCanvas.requestRenderAll();
    }

    const imageZoomOverlay = document.getElementById('image-zoom-overlay');
    const imageZoomContent = document.getElementById('image-zoom-content');
    const imageZoomClose = document.getElementById('image-zoom-close');
    function showZoomModal(imgObject) { if (!imgObject) return; const dataURL = imgObject.getSrc(); imageZoomContent.src = dataURL; imageZoomOverlay.classList.add('visible'); }
    function hideZoomModal() { imageZoomOverlay.classList.remove('visible'); imageZoomContent.src = ''; }
    imageZoomClose.addEventListener('click', hideZoomModal);
    imageZoomOverlay.addEventListener('click', (e) => { if (e.target === imageZoomOverlay) { hideZoomModal(); } });
    
    function enterFullscreen() {
        fullscreenContent.appendChild(imageOverlayContainer);
        fullscreenOverlay.style.display = 'block';
        fullscreenOverlay.appendChild(toggleAnnotationBtn);
        toggleAnnotationBtn.style.display = 'flex';
        setTimeout(() => { syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); }, 0);
    }

    function exitFullscreen() {
        uiDragOverlay.insertAdjacentElement('afterend', imageOverlayContainer);
        fullscreenOverlay.style.display = 'none';
        toggleAnnotationBtn.style.display = 'none';
        setAnnotationMode(false);
        setTimeout(() => { syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); }, 0);
    }

    toggleFullscreenBtn.addEventListener('click', enterFullscreen);
    fullscreenCloseBtn.addEventListener('click', exitFullscreen);
    const annotationToolsPopup = document.getElementById('annotation-tools-popup');
    let isAnnotationMode = false, annotationDrawingTool = 'select', drawingShape = null, startPoint = null;
    function setAnnotationMode(on) {
        if (on && isImageEditMode) setEditMode(false);
        isAnnotationMode = !!on;
        toggleAnnotationBtn.classList.toggle('active', on);
        annotationToolsPopup.style.display = on ? 'flex' : 'none';
        const upperCanvas = fabricCanvas.upperCanvasEl;
        if (upperCanvas) upperCanvas.style.pointerEvents = on ? 'auto' : 'none';
        if (on) { fabricCanvas.getObjects().forEach(o => { o.evented = !!o.isAnnotation; }); updateAnnotationTool(); } 
        else { fabricCanvas.isDrawingMode = false; fabricCanvas.selection = true; fabricCanvas.getObjects().forEach(o => { o.evented = true; }); if(upperCanvas) upperCanvas.style.cursor = 'default'; }
        fabricCanvas.renderAll();
    }

    function updateAnnotationTool() {
        if (!isAnnotationMode) return;
        document.querySelectorAll('#annotation-tools-popup button').forEach(btn => btn.classList.remove('active'));
        const currentToolBtn = document.getElementById(`anno-${annotationDrawingTool}`);
        if(currentToolBtn) currentToolBtn.classList.add('active');
        fabricCanvas.isDrawingMode = (annotationDrawingTool === 'pen');
        fabricCanvas.selection = (annotationDrawingTool === 'select' || annotationDrawingTool === 'eraser');
        const upperCanvas = fabricCanvas.upperCanvasEl;
        if (upperCanvas) { upperCanvas.style.cursor = (annotationDrawingTool === 'eraser') ? 'crosshair' : 'default'; }
        if (fabricCanvas.isDrawingMode) {
            fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
            fabricCanvas.freeDrawingBrush.color = document.getElementById('anno-color').value;
            fabricCanvas.freeDrawingBrush.width = parseInt(document.getElementById('anno-width').value, 10);
        }
    }

    function updateAnnotationPositions() {
        const scrollOffset = fullscreenOverlay.style.display === 'block' ? fullscreenOverlay.scrollTop : window.scrollY;
        fabricCanvas.getObjects().forEach(obj => { if (obj.persistentTop !== undefined) { obj.top = obj.persistentTop - scrollOffset; obj.setCoords(); } });
        fabricCanvas.renderAll();
    }
    
    fabricCanvas.on('path:created', function(e) { if (isAnnotationMode) { e.path.isAnnotation = true; e.path.bringToFront(); e.path.persistentTop = e.path.top; } });
    fabricCanvas.on('mouse:down', function (o) {
        if (isAnnotationMode) {
            o.e.stopPropagation();
            if (annotationDrawingTool === 'eraser') { if (o.target && o.target.isAnnotation) { fabricCanvas.remove(o.target).requestRenderAll(); } return; }
            if (fabricCanvas.isDrawingMode || annotationDrawingTool === 'select') return;
            startPoint = fabricCanvas.getPointer(o.e);
            const color = document.getElementById('anno-color').value;
            const width = parseInt(document.getElementById('anno-width').value, 10);
            switch(annotationDrawingTool) {
                case 'line': drawingShape = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], { stroke: color, strokeWidth: width, isAnnotation: true, evented: false }); break;
                case 'arrow': 
                    const line = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], { stroke: color, strokeWidth: width });
                    const arrowhead = new fabric.Triangle({ left: startPoint.x, top: startPoint.y, width: width * 3, height: width * 3, fill: color, angle: -90, originX: 'center', originY: 'center' });
                    drawingShape = new fabric.Group([line, arrowhead], { isAnnotation: true, evented: false });
                    break;
                case 'rect': drawingShape = new fabric.Rect({ left: startPoint.x, top: startPoint.y, width: 0, height: 0, stroke: color, strokeWidth: width, fill: 'transparent', isAnnotation: true, evented: false }); break;
                case 'circle': drawingShape = new fabric.Ellipse({ left: startPoint.x, top: startPoint.y, rx: 0, ry: 0, stroke: color, strokeWidth: width, fill: 'transparent', isAnnotation: true, evented: false }); break;
            }
            if (drawingShape) { fabricCanvas.add(drawingShape); drawingShape.bringToFront(); }
        } else if (!isImageEditMode && !isCropping) {
            if (o.target && o.target.type === 'image' && o.e.shiftKey) { o.e.preventDefault(); o.e.stopPropagation(); showZoomModal(o.target); return; }
            if (!o.target) {
                const upperCanvas = fabricCanvas.upperCanvasEl;
                upperCanvas.style.pointerEvents = 'none';
                const underlyingElement = document.elementFromPoint(o.e.clientX, o.e.clientY);
                upperCanvas.style.pointerEvents = 'auto';
                if (underlyingElement) {
                    if (table.contains(underlyingElement)) {
                        const isResizeHandle = table.style.cursor.includes('resize');
                        if (isResizeHandle) {
                           const mouseDownEvent = new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window, clientX: o.e.clientX, clientY: o.e.clientY, button: o.e.button });
                           underlyingElement.dispatchEvent(mouseDownEvent);
                        } else {
                           underlyingElement.click();
                        }
                    } else {
                        underlyingElement.click();
                    }
                }
            }
        }
    });

    fabricCanvas.on('mouse:move', function (o) {
        if (!isAnnotationMode || !drawingShape || !startPoint) return;
        const pointer = fabricCanvas.getPointer(o.e);
        let endX = pointer.x, endY = pointer.y;
        if (o.e.shiftKey) { const dx = Math.abs(endX - startPoint.x), dy = Math.abs(endY - startPoint.y); if (dx > dy) { endY = startPoint.y; } else { endX = startPoint.x; } }
        switch(annotationDrawingTool) {
            case 'line': drawingShape.set({ x2: endX, y2: endY }); break;
            case 'arrow':
                const line = drawingShape._objects[0], arrowhead = drawingShape._objects[1];
                line.set({ x2: endX, y2: endY });
                const finalDx = endX - startPoint.x, finalDy = endY - startPoint.y;
                const angle = Math.atan2(finalDy, finalDx) * 180 / Math.PI;
                arrowhead.set({ left: endX, top: endY, angle: angle + 90 }).setCoords();
                break;
            case 'rect': drawingShape.set({ width: Math.abs(endX - startPoint.x), height: Math.abs(endY - startPoint.y), left: endX > startPoint.x ? startPoint.x : endX, top: endY > startPoint.y ? startPoint.y : endY }); break;
            case 'circle': drawingShape.set({ rx: Math.abs(endX - startPoint.x) / 2, ry: Math.abs(endY - startPoint.y) / 2, left: endX > startPoint.x ? startPoint.x : endX, top: endY > startPoint.y ? startPoint.y : endY, originX: 'left', originY: 'top' }); break;
        }
        fabricCanvas.renderAll();
    });

    fabricCanvas.on('mouse:up', function (o) {
        if (isAnnotationMode && drawingShape) {
            drawingShape.set({ evented: true }); 
            drawingShape.persistentTop = drawingShape.top;
            if(drawingShape.type === 'group') {
                const groupTop = drawingShape.top;
                drawingShape.getObjects().forEach(obj => obj.persistentTop = groupTop + obj.top);
            }
            drawingShape = null; startPoint = null;
        }
    });

    toggleAnnotationBtn.addEventListener('click', () => setAnnotationMode(!isAnnotationMode));
    document.querySelectorAll('#annotation-tools-popup button[id^="anno-"]').forEach(btn => {
        btn.addEventListener('click', () => {
            const tool = btn.id.replace('anno-', '');
            if (['select','pen','line','arrow','rect','circle','eraser'].includes(tool)) { annotationDrawingTool = tool; updateAnnotationTool(); }
        });
    });
    document.getElementById('anno-color').addEventListener('input', updateAnnotationTool);
    document.getElementById('anno-width').addEventListener('input', updateAnnotationTool);
    document.getElementById('anno-memo').addEventListener('click', () => {
        const canvasRect = fabricCanvas.upperCanvasEl.getBoundingClientRect();
        const viewportCenterX = window.innerWidth / 2, viewportCenterY = window.innerHeight / 2;
        const targetLeft = viewportCenterX - canvasRect.left, targetTop = viewportCenterY - canvasRect.top;
        const memo = new fabric.Textbox('메모 입력...', {
            left: targetLeft, top: targetTop, width: 150, fontSize: 16, fill: '#333', backgroundColor: '#ffffa8', borderColor: '#e6e696',
            cornerColor: '#1a73e8', padding: 10, splitByGrapheme: true, editable: true, isAnnotation: true, originX: 'center', originY: 'center'
        });
        memo.persistentTop = memo.top;
        fabricCanvas.add(memo);
        memo.bringToFront();
        fabricCanvas.setActiveObject(memo).renderAll();
    });
    document.getElementById('anno-clear').addEventListener('click', () => {
        const objectsToRemove = fabricCanvas.getObjects().filter(obj => obj.isAnnotation);
        if (objectsToRemove.length > 0 && confirm('모든 주석과 메모를 삭제하시겠습니까?')) {
            objectsToRemove.forEach(obj => fabricCanvas.remove(obj));
            fabricCanvas.renderAll();
        }
    });

    (function enableAnnotationPopupDragAndResize() {
        const popup = document.getElementById('annotation-tools-popup');
        const header = popup.querySelector('.popup-header');
        const uiOverlay = document.getElementById('ui-drag-overlay');
        let drag = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
        let resizing = false, rsDir = '', rsStartX = 0, rsStartY = 0, rsStartW = 0, rsStartH = 0, rsStartL = 0, rsStartT = 0;
        function startOverlay() { if (uiOverlay) uiOverlay.style.display = 'block'; }
        function stopOverlay() { if (uiOverlay) uiOverlay.style.display = 'none'; }
        header.addEventListener('mousedown', (e) => {
            if (e.target.closest('button')) return;
            drag = true; startOverlay(); startX = e.clientX; startY = e.clientY;
            const rect = popup.getBoundingClientRect(); startLeft = rect.left; startTop = rect.top;
            document.body.style.userSelect = 'none';
            e.preventDefault(); e.stopPropagation();
            popup.focus({ preventScroll: true });
        });
        ['n','s','e','w','ne','nw','se','sw'].forEach(dir => { const h = document.createElement('div'); h.className = 'resize-handle ' + dir; popup.appendChild(h); });
        popup.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('resize-handle')) {
                e.preventDefault(); e.stopPropagation(); resizing = true;
                rsDir = [...e.target.classList].find(c => c.length <= 2 && c !== 'resize-handle');
                const rect = popup.getBoundingClientRect(); rsStartX = e.clientX; rsStartY = e.clientY; rsStartW = rect.width; rsStartH = rect.height; rsStartL = rect.left; rsStartT = rect.top;
                document.body.style.userSelect = 'none'; startOverlay();
            }
        });
        document.addEventListener('mousemove', (e) => {
            if (drag) {
                e.preventDefault(); const dx = e.clientX - startX, dy = e.clientY - startY;
                popup.style.left = Math.max(0, startLeft + dx) + 'px';
                popup.style.top = Math.max(0, startTop + dy) + 'px';
            } else if (resizing) {
                e.preventDefault();
                let dx = e.clientX - rsStartX, dy = e.clientY - rsStartY;
                let newW = rsStartW, newH = rsStartH, newL = rsStartL, newT = rsStartT;
                if (rsDir.includes('e')) newW = Math.max(230, rsStartW + dx);
                if (rsDir.includes('s')) newH = Math.max(150, rsStartH + dy);
                if (rsDir.includes('w')) { newW = Math.max(230, rsStartW - dx); newL = rsStartL + dx; }
                if (rsDir.includes('n')) { newH = Math.max(150, rsStartH - dy); newT = rsStartT + dy; }
                popup.style.width = newW + 'px'; popup.style.height = newH + 'px';
                popup.style.left = Math.max(0, newL) + 'px'; popup.style.top = Math.max(0, newT) + 'px';
            }
        });
        document.addEventListener('mouseup', () => { if (drag || resizing) { drag = false; resizing = false; stopOverlay(); document.body.style.userSelect = ''; } });
    })();

    function initializeResizableTable() {
        let resizing = false;
        let resizeInfo = {};

        table.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; 

            const cell = e.target.closest('th, td');
            if (!cell) return;

            const rect = cell.getBoundingClientRect();
            const threshold = 5;

            const atRightBorder = Math.abs(e.clientX - rect.right) < threshold;
            const atBottomBorder = Math.abs(e.clientY - rect.bottom) < threshold;
            
            if (atRightBorder && cell.cellIndex < table.rows[0].cells.length - 1) {
                resizing = true;
                e.preventDefault(); e.stopPropagation();
                
                const colElement = table.querySelector('colgroup').children[cell.cellIndex];
                resizeInfo = { type: 'col', element: colElement, startX: e.pageX, startWidth: colElement.offsetWidth };
            } else if (atBottomBorder && cell.closest('tr').parentNode.tagName === 'TBODY') {
                resizing = true;
                e.preventDefault(); e.stopPropagation();

                const rowElement = cell.closest('tr');
                resizeInfo = { type: 'row', element: rowElement, startY: e.pageY, startHeight: rowElement.offsetHeight };
            }

            if (resizing) {
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp, { once: true });
            }
        });

        table.addEventListener('mousemove', (e) => {
            if (resizing) return; 
            const cell = e.target.closest('th, td');
            if (!cell) { table.style.cursor = ''; return; }

            const rect = cell.getBoundingClientRect();
            const threshold = 5;

            const atRightBorder = Math.abs(e.clientX - rect.right) < threshold;
            const atBottomBorder = Math.abs(e.clientY - rect.bottom) < threshold;
            
            if (atRightBorder && cell.cellIndex < table.rows[0].cells.length - 1) { table.style.cursor = 'col-resize'; } 
            else if (atBottomBorder && cell.closest('tr').parentNode.tagName === 'TBODY') { table.style.cursor = 'row-resize'; } 
            else { table.style.cursor = ''; }
        });

        function onMouseMove(e) {
            if (!resizing) return;
            if (resizeInfo.type === 'col') {
                const newWidth = resizeInfo.startWidth + (e.pageX - resizeInfo.startX);
                if (newWidth > 30) { resizeInfo.element.style.width = newWidth + 'px'; updateAllAttachedImages(); }
            } else if (resizeInfo.type === 'row') {
                const newHeight = resizeInfo.startHeight + (e.pageY - resizeInfo.startY);
                if (newHeight > 30) { resizeInfo.element.style.height = newHeight + 'px'; updateAllAttachedImages(); }
            }
        }

        function onMouseUp() {
            resizing = false;
            resizeInfo = {};
            table.style.cursor = '';
            document.removeEventListener('mousemove', onMouseMove);
        }
    }
    
    function initializeSortAndFilter() {
        const headers = table.querySelectorAll('thead th');
        headers.forEach((th, colIndex) => {
            if (colIndex === 0 || colIndex === 1) { th.style.cursor = 'not-allowed'; return; }
            if (th.querySelector('.th-content')) { return; } 

            const originalContent = th.innerHTML;
            th.innerHTML = '';
            th.removeAttribute('contenteditable');
            const contentDiv = document.createElement('div'); contentDiv.className = 'th-content';
            const titleSpan = document.createElement('span'); titleSpan.className = 'th-title'; titleSpan.contentEditable = true; titleSpan.innerHTML = originalContent;
            const toolsDiv = document.createElement('div'); toolsDiv.className = 'th-tools';
            const sortContainer = document.createElement('div'); sortContainer.className = 'sort-controls';
            const sortUp = document.createElement('span'); sortUp.className = 'sort-arrow sort-up'; sortUp.innerHTML = '▲'; sortUp.title = '오름차순 정렬';
            const sortDown = document.createElement('span'); sortDown.className = 'sort-arrow sort-down'; sortDown.innerHTML = '▼'; sortDown.title = '내림차순 정렬';
            sortContainer.appendChild(sortUp); sortContainer.appendChild(sortDown);
            const filterBtn = document.createElement('span'); filterBtn.className = 'filter-btn'; filterBtn.innerHTML = '&#128269;'; filterBtn.title = '필터';
            toolsDiv.appendChild(sortContainer); toolsDiv.appendChild(filterBtn);
            contentDiv.appendChild(titleSpan); contentDiv.appendChild(toolsDiv);
            th.appendChild(contentDiv);
            sortUp.addEventListener('click', (e) => { e.stopPropagation(); sortTable(colIndex, 'asc'); });
            sortDown.addEventListener('click', (e) => { e.stopPropagation(); sortTable(colIndex, 'desc'); });
            filterBtn.addEventListener('click', (e) => { e.stopPropagation(); showFilterPopup(colIndex, filterBtn); });
        });
    }

    function sortTable(colIndex, newDirection) {
        const tbody = table.tBodies[0];
        const rows = Array.from(tbody.rows);
        const th = table.querySelector(`thead th:nth-child(${colIndex + 1})`);
        const currentDir = th.dataset.sortDir;
        document.querySelectorAll('thead th').forEach(otherTh => {
            if (otherTh !== th) { delete otherTh.dataset.sortDir; otherTh.querySelectorAll('.sort-arrow').forEach(arrow => arrow.classList.remove('active')); }
        });
        const nextDir = (currentDir === newDirection) ? 'none' : newDirection;
        th.dataset.sortDir = nextDir;
        th.querySelectorAll('.sort-arrow').forEach(arrow => arrow.classList.remove('active'));
        if (nextDir === 'asc') { th.querySelector('.sort-up').classList.add('active'); } 
        else if (nextDir === 'desc') { th.querySelector('.sort-down').classList.add('active'); }
        if (nextDir === 'none') { rows.sort((a, b) => parseInt(a.dataset.originalIndex, 10) - parseInt(b.dataset.originalIndex, 10)); } 
        else {
            const direction = nextDir === 'asc' ? 1 : -1;
            rows.sort((a, b) => {
                let valA = a.cells[colIndex].innerText.trim(), valB = b.cells[colIndex].innerText.trim();
                if (currencyColIndices.includes(colIndex)) { valA = parseFloat(valA.replace(/,/g, '')) || 0; valB = parseFloat(valB.replace(/,/g, '')) || 0; }
                if (typeof valA === 'string' && typeof valB === 'string') { return valA.localeCompare(valB, undefined, {numeric: true}) * direction; }
                if (valA < valB) return -1 * direction;
                if (valA > valB) return 1 * direction;
                return 0;
            });
        }
        rows.forEach(row => tbody.appendChild(row));
        applyFilters();
    }
    
    const filterPopup = document.getElementById('filter-popup');
    const filterOptionsList = document.getElementById('filter-options-list');
    const filterTitle = document.getElementById('filter-title');
    const applyFilterBtn = document.getElementById('apply-filter-btn');
    const clearFilterBtn = document.getElementById('clear-filter-btn');
    const closeFilterPopupBtn = document.getElementById('close-filter-popup');
    const selectAllCheckbox = document.getElementById('filter-select-all');
    const filterSearchInput = document.getElementById('filter-search-input');

    function showFilterPopup(colIndex, btnElement) {
        currentFilterColumn = colIndex;
        const headerText = table.querySelector(`thead th:nth-child(${colIndex + 1}) .th-title`).innerText;
        filterTitle.innerText = `'${headerText}' 필터`;
        const values = new Set();
        table.querySelectorAll('tbody tr').forEach(row => { const cell = row.cells[colIndex]; if (cell) { const value = cell.innerText.trim(); if (value) values.add(value); } });
        filterOptionsList.innerHTML = '';
        const sortedValues = Array.from(values).sort((a,b) => a.localeCompare(b, undefined, {numeric: true}));
        const currentFilters = activeFilters[colIndex];
        sortedValues.forEach(value => {
            const div = document.createElement('div'), label = document.createElement('label'), checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.value = value; checkbox.checked = !currentFilters || currentFilters.includes(value);
            label.appendChild(checkbox); label.appendChild(document.createTextNode(' ' + value));
            div.appendChild(label); filterOptionsList.appendChild(div);
        });
        updateSelectAllState();
        const rect = btnElement.getBoundingClientRect();
        filterPopup.style.left = `${Math.max(5, rect.left)}px`;
        filterPopup.style.top = `${rect.bottom + 5}px`;
        filterPopup.style.display = 'block';
        filterSearchInput.value = '';
        filterSearchInput.focus();
    }
    
    function applyFilters() {
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            let isVisible = true;
            for (const colIndex in activeFilters) {
                const allowedValues = activeFilters[colIndex];
                if (allowedValues && allowedValues.length > 0) {
                    const cellValue = row.cells[colIndex].innerText.trim();
                    if (!allowedValues.includes(cellValue)) { isVisible = false; break; }
                }
            }
            row.style.display = isVisible ? '' : 'none';
        });
        updateRowNumbers();
    }

    function updateSelectAllState() {
        const allCheckboxes = filterOptionsList.querySelectorAll('input[type="checkbox"]');
        const checkedCount = filterOptionsList.querySelectorAll('input[type="checkbox"]:checked').length;
        selectAllCheckbox.checked = allCheckboxes.length > 0 && checkedCount === allCheckboxes.length;
        selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < allCheckboxes.length;
    }

    filterOptionsList.addEventListener('change', updateSelectAllState);
    applyFilterBtn.addEventListener('click', () => {
        const allValues = Array.from(filterOptionsList.querySelectorAll('input[type="checkbox"]')).map(cb => cb.value);
        const selectedValues = Array.from(filterOptionsList.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
        const headerBtn = table.querySelector(`thead th:nth-child(${currentFilterColumn + 1}) .filter-btn`);
        if (selectedValues.length === allValues.length) { delete activeFilters[currentFilterColumn]; headerBtn.classList.remove('active'); } 
        else { activeFilters[currentFilterColumn] = selectedValues; headerBtn.classList.add('active'); }
        applyFilters();
        filterPopup.style.display = 'none';
    });
    clearFilterBtn.addEventListener('click', () => {
        const headerBtn = table.querySelector(`thead th:nth-child(${currentFilterColumn + 1}) .filter-btn`);
        delete activeFilters[currentFilterColumn];
        headerBtn.classList.remove('active');
        applyFilters();
        filterPopup.style.display = 'none';
    });
    closeFilterPopupBtn.addEventListener('click', () => { filterPopup.style.display = 'none'; });
    selectAllCheckbox.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        filterOptionsList.querySelectorAll('input[type="checkbox"]').forEach(cb => { if (cb.closest('div').style.display !== 'none') { cb.checked = isChecked; } });
    });
    filterSearchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        filterOptionsList.querySelectorAll('label').forEach(label => {
            const text = label.innerText.toLowerCase();
            const parentDiv = label.parentElement;
            if (text.includes(searchTerm)) { parentDiv.style.display = 'block'; } 
            else { parentDiv.style.display = 'none'; }
        });
    });
    
    findSpecialColumns();
    updateCellIds();
    initializeResizableTable();
    updateRowNumbers();
    formatAllCurrencyCells();
    clearSelection();
    initializeAutoFit();
    initializeDraggableTable();
    initializeSortAndFilter();
    syncCanvasSize();
    ensureCanvasOnTop();
    loadCanvasData();
});
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="ko"><head>
  <meta charset="UTF-8">
  <title>YYYY년 MM월 월간 회의 안건</title>
  <meta name="template-type" content="monthly-meeting">
  <meta name="editable-title" content="YYYY년 MM월 월간 회의 안건">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <style>
    body {
      font-family: '맑은 고딕', sans-serif;
      background-color: #fcfcfc;
      margin: 0;
      padding: 0;
      color: #2b2b2b;
      line-height: 1.6;
      transition: margin-top 0.3s ease-in-out;
      overflow-x: hidden;
    }

    body.meeting-cursor {
      cursor: cell;
    }

    #appContainer {
        background-color: #fcfcfc;
        position: relative;
    }

    #futureMeetingBlocker {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 15vw;
      max-font-size: 200px;
      color: rgba(220, 53, 69, 0.85);
      background-color: rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(2px);
      padding: 20px;
      border-radius: 50%;
      z-index: 10008;
      display: none;
      cursor: pointer;
      user-select: none;
      text-shadow: 0 0 10px rgba(0,0,0,0.2);
    }


    h1#page-title {
      font-size: 1.8em;
      color: #2a4d69;
      margin: 0;
      border-bottom: 2px solid #ccc;
      padding: 15px 40px;
      background: #fff;
      z-index: 999;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      box-sizing: border-box;
    }
    body:not(.true-fullscreen-active) h1#page-title {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
    }
    body.true-fullscreen-active #appContainer > h1#page-title {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        z-index: 1000;
    }

    #monthlyNavigatorContainer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 5px 15px;
        background-color: #f0f4f8;
        border-bottom: 1px solid #dce4eb;
        position: fixed;
        width: 100%;
        z-index: 998;
        box-sizing: border-box;
        top: 67px;
        transition: top 0.3s ease-in-out, height 0.3s ease-in-out;
    }
    #monthlyNavigatorContent {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-grow: 1;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out, opacity 0.3s, margin 0.3s;
        max-height: 200px;
    }
    
    #monthlyNavigatorContainer.nav-collapsed #monthlyNavigatorContent {
        max-height: 0;
        opacity: 0;
        pointer-events: none;
        margin-top: -10px;
        margin-bottom: -10px;
    }

    #navToggleBtn {
        background: none;
        border: 1px solid #c0c0c0;
        color: #a0a0a0;
        padding: 4px 8px;
        font-size: 1.0em;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
        margin-left: 10px;
    }
    #navToggleBtn:hover {
        background-color: #dce4eb;
    }


    body.true-fullscreen-active #monthlyNavigatorContainer {
      top: 67px;
    }

    #yearNavigator {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
    }

    #yearNavigator button {
        background: none;
        border: 1px solid #a0b4c8;
        color: #334e68;
        padding: 2px 10px;
        font-size: 1.1em;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    #yearNavigator button:hover {
        background-color: #dce4eb;
    }
    #currentYearSpan {
        margin: 0 12px;
        font-size: 1.1em;
        font-weight: 600;
        color: #2a4d69;
        min-width: 70px;
        text-align: center;
    }

    #monthLinksContainer {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
    }

    .month-link {
        display: inline-block;
        padding: 6px 12px;
        margin: 2px 4px;
        border-radius: 4px;
        font-size: 0.9em;
        font-weight: 500;
        text-decoration: none;
        color: #fff;
        transition: background-color 0.2s ease, transform 0.2s ease;
    }

    .month-link.skipped {
        background-color: #ced4da;
        color: #6c757d;
        cursor: not-allowed;
        text-decoration: line-through;
    }
    .month-link.skipped:hover {
        transform: none;
        background-color: #ced4da;
    }

    .month-link.current {
        background-color: rgb(215, 65, 31);
        font-weight: bold;
        font-size: 1em;
        cursor: default;
    }
    .month-link.current:hover {
        transform: none;
        background-color: rgb(215, 65, 31);
    }

    .month-link.past {
        background-color: rgb(195, 206, 212);
        cursor: pointer;
    }
    .month-link.past:hover {
        background-color: #546e7a;
        transform: translateY(-2px);
    }

    .month-link.future {
        background-color: rgb(75, 146, 223);
        cursor: pointer;
    }
    .month-link.future:hover {
        background-color: #357abd;
        transform: translateY(-2px);
    }

    .month-link.compare-selected {
      outline: 3px solid #ff9800;
      transform: scale(1.08) translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    #compareControlsContainer {
        display: none;
        align-items: center;
        gap: 8px;
        margin-left: 20px;
    }
    body.compare-mode-active #compareControlsContainer {
        display: flex;
    }
    #compareControlsContainer button {
      font-size: 0.9em;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
    #executeCompareBtn {
      background-color: #28a745;
      color: white;
      border: 1px solid #218838;
    }
    #executeCompareBtn:hover { background-color: #218838; }
    #cancelCompareBtn {
      background-color: #dc3545;
      color: white;
      border: 1px solid #c82333;
    }
    #cancelCompareBtn:hover { background-color: #c82333; }
    #comparisonViewOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: rgba(50, 50, 50, 0.9);
      z-index: 4000;
      display: none;
      padding: 40px 10px 10px 10px;
      box-sizing: border-box;
    }
    #comparisonFrameContainer {
      display: flex;
      width: 100%; height: 100%;
      gap: 10px;
    }
    #comparisonFrameContainer iframe {
      width: 100%; height: 100%;
      border: 1px solid #777;
      border-radius: 4px;
      background-color: #fff;
    }
    .close-comparison-view-btn {
      position: absolute;
      top: 5px; right: 10px;
      font-size: 28px;
      color: #ccc;
      background-color: transparent;
      border: none;
      cursor: pointer;
      z-index: 4001;
      line-height: 1;
    }
    .close-comparison-view-btn:hover { color: #fff; }
    
    .comparison-item-wrapper {
      flex: 1 1 0;
      position: relative;
    }
    .close-comparison-item-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.1);
      background-color: rgba(0,0,0,0.3);
      color: white;
      font-size: 16px;
      line-height: 22px;
      text-align: center;
      cursor: pointer;
      z-index: 4002;
    }
    .close-comparison-item-btn:hover {
      background-color: rgba(220, 53, 69, 0.85);
    }

    .container {
      width: 100%;
      max-width: none;
      margin: 0 auto;
      background: #fff;
      padding: 20px 60px 60px;
      box-sizing: border-box;
      min-height: calc(100vh - 160px);
      position: relative;
    }

    .is-in-iframe .floating-menu-icon,
    .is-in-iframe #compareModeToggleBtn,
    .is-in-iframe .fullscreen-btn-class,
    .is-in-iframe #multiZoomTriggerBtn,
    .is-in-iframe #annotationDisplayToggleBtn,
    .is-in-iframe #annotationSettingsToggleBtn,
    .is-in-iframe #memoAnnotationToggleBtn,
    .is-in-iframe .exit-true-fullscreen-btn,
    .is-in-iframe #header-info-display {
      display: none !important;
    }
    .is-in-iframe h1#page-title,
    .is-in-iframe #monthlyNavigatorContainer {
        position: relative !important;
        top: auto !important;
        left: auto !important;
        box-shadow: none !important;
    }
    .is-in-iframe .container {
        padding-top: 20px !important;
        min-height: 100vh;
    }
    body.comparison-view-active #header-info-display,
    body.comparison-view-active .floating-menu-icon,
    body.comparison-view-active #compareModeToggleBtn,
    body.comparison-view-active .fullscreen-btn-class,
    body.comparison-view-active #multiZoomTriggerBtn,
    body.comparison-view-active #annotationDisplayToggleBtn,
    body.comparison-view-active #annotationSettingsToggleBtn,
    body.comparison-view-active #memoAnnotationToggleBtn {
      display: none !important;
    }


    .section-title, .section-subtitle, .box, .flow span, .item, .insert-area {
        position: relative;
    }
    .item-controls {
        position: absolute;
        top: -10px;
        right: -10px;
        display: none;
        background-color: rgba(220, 220, 220, 0.95);
        border-radius: 5px;
        padding: 3px 5px;
        z-index: 100;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        gap: 4px;
    }
    
    body.show-icons-all [data-editable-type]:hover > .item-controls,
    body.show-icons-all .resizable-image-wrapper:hover > .item-controls {
        display: flex;
    }
    body.show-icons-selected [data-editable-type].controls-active > .item-controls,
    body.show-icons-selected .resizable-image-wrapper.controls-active > .item-controls {
        display: flex;
    }

    .item-control-btn {
        background: #fff; border: 1px solid #aaa; color: #333; cursor: pointer;
        font-size: 14px;
        padding: 2px 5px;
        border-radius: 4px;
        line-height: 1;
    }
    .item-control-btn:hover { background-color: #e8e8e8; border-color: #888; }


    .section-title {
      font-weight: bold; font-size: 1.4em; color: #00695c;
      margin-top: 20px; margin-bottom: 8px; padding-left: 0;
    }
    .section-subtitle {
      font-weight: 600; font-size: 1em; color: #00897b;
      margin-top: 6px; margin-bottom: 4px; margin-left: 20px; padding-left: 10px;
    }
    .box > .section-subtitle {
        margin-left: 0; padding-left: 0; color: #333; font-weight: normal;
        display: flex; align-items: baseline;
    }
    .box > .section-subtitle .bullet-char { margin-right: 8px; }
    .box .item-bulleted-left {
        display: flex; align-items: baseline; margin-left: 0 !important; padding-left: 0;
    }
    .box .item-bulleted-left .bullet-char { margin-right: 8px; flex-shrink: 0; }
    .box .item-bulleted-left .bullet-text { flex-grow: 1; }
    .box > .item:not(.item-bulleted-left),
    .box > .insert-area:not(.templated-insert-area),
    .box > button.add-sub-insert-area-btn {
        margin-left: 24px;
        margin-top: 8px;
        font-size: 0.9em;
        padding: 4px 8px;
        background-color: #e0e0e0;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        position: relative;
    }
     .box > button.add-sub-insert-area-btn:hover {
        background-color: #d0d0d0;
     }
     .box > button.add-sub-insert-area-btn > span[data-editable-type="button-text-label"] {
        display: inline-block;
        min-width: 20px;
        position: relative;
     }


    .flow {
      display: flex; flex-wrap: wrap; gap: 10px;
      margin: 0 0 10px 50px; position: relative;
    }
    .flow span {
      background-color: #e0f7fa; border-radius: 20px;
      padding: 6px 12px; font-size: 0.95em;
    }
    .box {
      background-color: #f9f9f9; border-left: 4px solid #b0bec5;
      padding: 12px 20px; margin: 10px 0 10px 50px; border-radius: 6px;
      transition: padding 0.3s ease-in-out;
    }
    .item { font-size: 0.96em; margin-bottom: 8px; padding: 2px; }
    .highlight { font-weight: bold; color: #d84315; }

    .insert-area {
      border: 1px dashed #bbb; background-color: #fff; padding: 8px;
      padding-top: 28px;
      min-height: 50px; margin: 6px 0 12px 0; position: relative;
      transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out, background-color 0.3s ease-in-out;
      overflow: hidden;
    }
    .box > .insert-area {
        margin-left: 24px;
        background-color: #fff;
    }
    
    .insert-area-toggle-btn, .box-toggle-btn {
        position: absolute;
        top: 4px; right: 4px;
        font-size: 16px; line-height: 1;
        background: #e9e9e9; border: 1px solid #ccc;
        border-radius: 4px; padding: 0 5px;
        cursor: pointer; user-select: none; z-index: 5;
        color: #a0a0a0;
    }
    .box-toggle-btn { top: 12px; right: 10px; }
    
    .insert-area-toggle-btn:hover, .box-toggle-btn:hover { background-color: #dcdcdc; }

    .insert-area.collapsed {
        max-height: 25px; min-height: 25px;
        padding-top: 4px; padding-bottom: 4px;
        background-color: #f5f5f5;
    }
    .insert-area.collapsed > *:not(.insert-area-toggle-btn) { display: none; }

    .box.box-collapsed > *:not(.section-subtitle):not(.box-toggle-btn) { display: none; }
    .box.box-collapsed { padding-bottom: 12px; }
    .box > .section-subtitle { padding-right: 30px; }
    
    .box.box-collapsed > .section-subtitle > .item,
    .box.box-collapsed > .section-subtitle .item {
      display: none;
    }

    .floating-menu-icon, .fullscreen-btn-class, #multiZoomTriggerBtn,
    #annotationDisplayToggleBtn, #annotationSettingsToggleBtn, #memoAnnotationToggleBtn, .exit-true-fullscreen-btn,
    #compareModeToggleBtn {
      position: fixed;
      right: 16px;
      background-color: rgba(150,150,150,0.3);
      color: #555;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      transition: background-color 0.2s ease;
      font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif;
      line-height: 1;
      z-index: 10001;
    }
    
    .floating-menu-icon { bottom: 16px; font-size: 20px; padding: 8px 10px; }
    #compareModeToggleBtn { bottom: 62px; font-size: 20px; padding: 8px 10px; z-index: 10002; }
    .fullscreen-btn-class { bottom: 108px; font-size: 20px; padding: 8px 10px; }
    
    #multiZoomTriggerBtn { bottom: 154px; font-size: 22px; background-color: rgba(0, 123, 255, 0.8); color: white; padding: 10px; }
    #annotationDisplayToggleBtn { bottom: 206px; font-size: 20px; padding: 8px 10px; z-index: 10002;}
    #annotationSettingsToggleBtn { bottom: 252px; font-size: 20px; padding: 8px 10px; z-index: 10002;}
    #memoAnnotationToggleBtn { bottom: 298px; font-size: 20px; padding: 8px 10px; z-index: 10002;}

    .floating-menu-icon:hover, .fullscreen-btn-class:hover, #multiZoomTriggerBtn:hover,
    #annotationDisplayToggleBtn:hover, #annotationSettingsToggleBtn:hover, #memoAnnotationToggleBtn:hover, .exit-true-fullscreen-btn:hover,
    #compareModeToggleBtn:hover {
        background-color: rgba(120,120,120,0.4);
    }

    #annotationDisplayToggleBtn.active, #annotationSettingsToggleBtn.active, #memoAnnotationToggleBtn.active,
    .fullscreen-btn-class.fs-active, 
    #compareModeToggleBtn.active {
        background-color: rgba(128, 0, 128, 0.6);
        color: white;
        opacity: 1;
    }
    #annotationDisplayToggleBtn:not(.active),
    #annotationSettingsToggleBtn:not(.active),
    #memoAnnotationToggleBtn:not(.active) {
        opacity: 0.6;
    }
    .exit-true-fullscreen-btn {
      top: 10px; right: 16px; font-size: 28px; padding: 0px 10px;
      background-color: rgba(255,255,255,0.6);
      z-index: 10005;
      display: none;
    }
     body.true-fullscreen-active .exit-true-fullscreen-btn { display: block; }
    .exit-true-fullscreen-btn:hover { color: #000; background-color: rgba(230,230,230,0.8); }


    #annotationSettingsPanel {
        position: fixed;
        right: 70px;
        bottom: 200px;
        background-color: rgba(245, 245, 245, 0.97);
        padding: 10px;
        padding-top: 30px;
        border-radius: 8px;
        box-shadow: -2px 0px 5px rgba(0,0,0,0.2);
        z-index: 10003;
        display: none;
        flex-direction: column;
        gap: 8px;
        width: 190px;
    }
    #closeAnnotationSettingsBtn {
        position: absolute;
        top: 5px;
        right: 8px;
        font-size: 24px;
        color: #777;
        background-color: transparent;
        border: none;
        cursor: pointer;
        padding: 2px 5px;
        line-height: 1;
    }
    #closeAnnotationSettingsBtn:hover {
        color: #333;
    }

    .accordion-item {
        border-bottom: 1px solid #ddd;
        margin-bottom: 5px;
    }
    .accordion-header {
        background-color: #e9ecef;
        padding: 8px 12px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 1.05em;
        font-weight: 600;
        color: #495057;
        margin: 0 0 5px 0;
        border-radius: 4px;
    }
    .accordion-header:hover {
        background-color: #dee2e6;
    }
    .accordion-icon {
        transition: transform 0.3s ease;
        font-size: 0.8em;
    }
    .accordion-item.active .accordion-icon {
        transform: rotate(180deg);
    }
    .accordion-content {
        padding: 5px 10px 10px 10px;
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out, opacity 0.4s ease-in-out;
    }
    .accordion-content.collapsed {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        pointer-events: none;
    }

    .floating-panel {
      position: fixed;
      background-color: #f5f5f5;
      border: 1px solid #ccc;
      border-radius: 8px;
      display: none;
      z-index: 10004;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      cursor: grab;
      min-width: 340px;
      min-height: 400px;
      box-sizing: border-box;
      flex-direction: column;
      overflow: hidden;
    }
    .floating-panel.dragging { cursor: grabbing; user-select: none; }

    .floating-panel-close-btn {
        position: absolute; top: 8px; right: 10px;
        font-size: 20px;
        color: #777; cursor: pointer; padding: 2px 5px; line-height: 1;
    }
    .floating-panel-close-btn:hover { color: #333; }

    .resize-handle {
        position: absolute;
        background: transparent;
        z-index: 10005;
    }
    .resize-handle.n { top: -5px; left: 0; height: 10px; width: 100%; cursor: ns-resize; }
    .resize-handle.s { bottom: -5px; left: 0; height: 10px; width: 100%; cursor: ns-resize; }
    .resize-handle.e { top: 0; right: -5px; height: 100%; width: 10px; cursor: ew-resize; }
    .resize-handle.w { top: 0; left: -5px; height: 100%; width: 10px; cursor: ew-resize; }
    .resize-handle.nw { top: -5px; left: -5px; height: 10px; width: 10px; cursor: nwse-resize; }
    .resize-handle.ne { top: -5px; right: -5px; height: 10px; width: 10px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -5px; left: -5px; height: 10px; width: 10px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -5px; right: -5px; height: 10px; width: 10px; cursor: se-resize; }

    /* START: Tabbed Panel UI */
    .panel-tabs {
      display: flex;
      background-color: #e9ecef;
      padding: 5px 5px 0 5px;
      border-bottom: 1px solid #ccc;
      flex-shrink: 0;
    }
    .tab-btn {
      padding: 8px 14px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      background-color: #e9ecef;
      border-radius: 4px 4px 0 0;
      font-size: 14px;
      font-weight: 500;
      color: #495057;
      transition: background-color 0.2s, color 0.2s;
    }
    .tab-btn:hover {
      background-color: #dee2e6;
    }
    .tab-btn.active {
      background-color: #f5f5f5;
      border-color: #ccc #ccc transparent #ccc;
      color: #007bff;
      font-weight: bold;
    }
    .panel-content-wrapper {
        padding: 15px;
        overflow-y: auto;
        flex-grow: 1;
        background-color: #f5f5f5;
    }
    .tab-pane {
      display: none;
      animation: fadeIn 0.3s;
    }
    .tab-pane.active {
      display: block;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    .panel-content-wrapper .panel-section {
        margin-bottom: 18px;
    }
    .panel-content-wrapper .panel-section-title {
        font-weight: bold;
        color: #00695c;
        margin-bottom: 10px;
        font-size: 14px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 4px;
    }
    .panel-content-wrapper input, .panel-content-wrapper button, .panel-content-wrapper select {
      width: 100%; margin-bottom: 10px; font-size: 13px; padding: 8px;
      box-sizing: border-box; border-radius: 4px; border: 1px solid #ddd;
    }
     .panel-content-wrapper input:focus, .panel-content-wrapper select:focus {
        border-color: #00897b; outline: none; box-shadow: 0 0 0 2px rgba(0, 137, 123, 0.2);
    }
    .panel-content-wrapper button {
        background-color: #00897b; color: white; border: none; cursor: pointer;
        transition: background-color 0.2s ease;
    }
    .panel-content-wrapper button:hover { background-color: #00695c; }
    .panel-content-wrapper button.secondary { background-color: #b0bec5; color: #333; }
    .panel-content-wrapper button.secondary:hover { background-color: #90a4ae; }

    .format-controls { display: flex; align-items: center; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; }
    .format-controls button {
        width: auto;
        min-width: 35px;
        padding: 6px 8px;
        margin-right: 0;
        margin-bottom: 0;
    }
    .format-controls button.active {
        background-color: #007bff;
        color: white;
        border-color: #0056b3;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }
    .format-controls input[type="number"] {
        width: 65px;
        flex-grow: 0;
        padding: 6px;
        margin-bottom: 0;
    }
    .format-controls input[type="color"] {
        width: auto; height: 35px; padding: 2px;
        vertical-align: middle; margin-left: 0; margin-bottom: 0;
    }
    
    #insert-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
    }
    .insert-grid-btn {
      display: flex; flex-direction: column; align-items: center;
      justify-content: center;
      padding: 10px 5px;
      font-size: 12px;
      height: 70px;
      line-height: 1.2;
      background-color: #fff;
      border: 1px solid #ddd;
      cursor: pointer;
      text-align: center;
    }
    .insert-grid-btn .icon { font-size: 24px; margin-bottom: 5px; }
    .insert-grid-btn:hover { background-color: #e9ecef; border-color: #007bff; }
    #status-tag-grid {
        display: flex; flex-wrap: wrap; gap: 5px;
    }
    
    .checkbox-label {
        font-weight: normal; display: inline-block; margin-bottom: 5px; color: #333; font-size: 13px;
    }
    .radio-label-group { display: flex; flex-direction: column; gap: 5px; }
    .radio-label-group input[type="radio"] { width: auto; margin-right: 5px; }
    
    #monthlyNavUrlHelpText {
      font-size: 11px;
      color: #555;
      margin-top: -8px;
      margin-bottom: 10px;
      display: block;
      line-height: 1.4;
    }
    #monthlyNavUrlBtnContainer { display: flex; gap: 10px; }
    
    /* '미작성 월' 관리 그리드 */
    #skipped-month-management-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
    }
    #skipped-month-management-container label { font-weight: normal; margin-bottom: 0; }
    #skipped-year-selector { width: auto; flex-grow: 1; margin-bottom: 0; }

    #skipped-month-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 5px;
        margin-bottom: 10px;
    }
    .skipped-month-btn {
        padding: 8px 5px;
        font-size: 13px;
        border: 1px solid #ccc;
        background-color: #f0f0f0;
        cursor: pointer;
        transition: all 0.2s;
    }
    .skipped-month-btn.is-written {
        background-color: #007bff;
        color: white;
        border-color: #0056b3;
    }
    .skipped-month-btn.is-written:hover { background-color: #0056b3; }
    .skipped-month-btn.is-skipped {
        background-color: #6c757d;
        color: #f0f0f0;
        border-color: #5a6268;
        text-decoration: line-through;
    }
    .skipped-month-btn.is-skipped:hover { background-color: #5a6268; }

    #saveSkippedMonthsBtn {
        margin-top: 10px;
        background-color: #28a745; 
    }
    #saveSkippedMonthsBtn:hover {
        background-color: #218838;
    }

    #image-insert-controls {
        font-size: 12px;
    }
    #image-insert-controls label {
        display: block; font-weight: normal; margin-bottom: 5px;
    }
     #image-insert-controls input[type="file"] {
        padding: 5px; margin-bottom: 5px;
    }
    #image-insert-controls .format-controls {
        margin-top: 5px; margin-bottom: 5px;
    }

    /* END: Tabbed Panel UI */

    .floating-panel .color-input-container {
        display: flex; align-items: center; gap: 10px; margin-bottom:10px;
    }
    .floating-panel .color-input-container label { margin-bottom: 0; flex-shrink: 0; }
    .floating-panel .char-insert-container {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 10px;
    }
    .floating-panel .char-insert-container input[type="text"] {
        flex-grow: 1;
        margin-bottom: 0;
    }
    .floating-panel .emoji-dropdown {
        position: relative;
        display: inline-block;
        margin-bottom: 0;
    }
    .floating-panel .emoji-dropdown-btn {
        width: auto;
        padding: 8px 10px;
        margin-left: 5px;
        margin-bottom: 0;
    }

    .emoji-dropdown-content {
        display: none; position: absolute; background-color: #f9f9f9;
        min-width: 200px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 10002; border-radius: 5px; padding: 10px;
        bottom: 100%; right: 0; max-height: 200px; overflow-y: auto;
        flex-wrap: wrap; gap: 5px; justify-content: space-around;
    }
    .emoji-dropdown-content button.emoji-btn {
        color: black; padding: 6px 8px; text-decoration: none; display: inline-block;
        font-size: 18px; border: none; background: none; cursor: pointer;
        width: auto; margin: 2px;
    }
    .emoji-dropdown-content button.emoji-btn:hover {background-color: #f1f1f1}
    .emoji-dropdown:hover .emoji-dropdown-content,
    .emoji-dropdown .emoji-dropdown-content.show { display: flex; }

    #elementInspectorPanel { margin-top: 15px; }
    #elementInspectorOutput {
        background-color: #e8e8e8; border: 1px solid #ccc; border-radius: 4px; padding: 8px;
        font-family: 'D2Coding', 'Consolas', monospace; font-size: 12px;
        line-height: 1.5; white-space: pre-wrap; word-break: break-all;
        min-height: 80px; color: #333;
    }
    #selectionInfoPanel .info-item {
        margin-bottom: 4px;
        font-size: 12px;
        display: flex;
        align-items: center;
    }
    #selectionInfoPanel .info-item strong {
        min-width: 55px;
        display: inline-block;
    }
    #selectionInfoPanel .info-item code {
        background-color: #e8eaf6; padding: 2px 5px; border-radius: 3px; font-family: 'Consolas', 'Monaco', monospace; color: #3f51b5; word-break: break-all;
    }
    #selectionInfoPanel .info-item .color-preview {
        display: inline-block; width: 12px; height: 12px; border: 1px solid #ccc; margin-right: 5px; vertical-align: middle;
    }

    .common-item-template { display: none; }

    body.true-fullscreen-active { overflow: auto !important; }

    #appContainer:-webkit-full-screen { background: #fcfcfc; width: 100%; height: 100%; overflow-y: auto;}
    #appContainer:-moz-full-screen { background: #fcfcfc; width: 100%; height: 100%; overflow-y: auto; }
    #appContainer:-ms-fullscreen { background: #fcfcfc; width: 100%; height: 100%; overflow-y: auto; }
    #appContainer:fullscreen { background: #fcfcfc; width: 100%; height: 100%; overflow-y: auto; }

    .custom-message-box {
        position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
        background-color: #ffc107; color: #333; padding: 15px 25px;
        border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 10006;
        display: none; font-size: 1em;
    }
    .custom-message-box.error { background-color: #f44336; color: white; }
    .custom-message-box.success { background-color: #4CAF50; color: white; }
    #content a { color: purple; cursor: pointer; text-decoration: underline; }
    #content a:hover { text-decoration: none; }

    .multi-zoom-selected {
        outline: 2px dashed #007bff; outline-offset: 2px;
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
    }

    [data-editable-type] { cursor: default; }
    [data-editable-type][contenteditable="true"],
    .insert-area[contenteditable="true"],
    span[data-editable-type="button-text-label"] { cursor: text; }
    body.ctrl-pressed [data-editable-type]:hover:not(.resizable-image-wrapper) { cursor: zoom-in; }
    body.ctrl-pressed span[data-editable-type="button-text-label"]:hover { cursor: text; }

    #annotationSettingsPanel > div { display: flex; align-items: center; gap: 5px; }
    #annotationSettingsPanel label { font-size: 12px; margin-bottom: 0; color: #333; flex-shrink: 0;}
    #annotationSettingsPanel button,
    #annotationSettingsPanel input[type="color"],
    #annotationSettingsPanel input[type="range"] {
        padding: 5px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: white;
        cursor: pointer;
        font-size: 12px;
        height: 28px;
        line-height: 1;
        box-sizing: border-box;
        margin-bottom: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-align: center;
    }
     #annotationSettingsPanel button {
        flex-grow: 0;
        flex-basis: auto;
        min-width: fit-content;
        padding: 5px 10px;
     }
    #annotationSettingsPanel input[type="color"] { width: 30px; min-width: auto; padding:1px; flex-grow: 0;}
    #annotationSettingsPanel input[type="range"] { flex-grow: 1; padding: 0; }
    #annotationSettingsPanel .tool-active {
        background-color: #800080;
        color: white;
        border-color: #600060;
    }
    #annoHighlighterOpacityContainer {
        display: none;
        align-items: center;
        gap: 5px;
    }
    #annoHighlighterOpacityContainer label {
        font-size: 12px;
        margin-bottom: 0;
        color: #333;
        flex-shrink: 0;
    }
    #annoHighlighterOpacityContainer input[type="range"] {
        flex-grow: 1;
        padding: 0;
        height: 20px;
    }

    #annotationCanvas {
        position: absolute;
        top: 0;
        left: 0;
        display: none;
        pointer-events: none;
        z-index: 10000;
    }
    
    .text-annotation-memo {
        position: absolute;
        background-color: #ffffe0;
        border: 1px solid #ccc;
        min-width: 150px;
        min-height: 70px;
        cursor: move;
        z-index: 10;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        resize: both;
        overflow: hidden;
        font-size: 14px;
        line-height: 1.4;
        box-sizing: border-box;
    }
    .text-annotation-memo > div[contenteditable] {
        padding: 8px;
        padding-right: 20px;
        min-height: 100%;
        box-sizing: border-box;
        outline: none;
        overflow-y: auto;
    }

    .text-annotation-memo:focus-within {
        border-color: #007bff;
        box-shadow: 0 0 5px rgba(0,123,255,0.5);
    }
    .text-annotation-memo .memo-delete-btn {
        position: absolute;
        top: 2px;
        right: 2px;
        cursor: pointer;
        font-size: 20px;
        font-weight: bold;
        color: #aaa;
        padding: 0 4px;
        line-height: 1;
    }
    .text-annotation-memo .memo-delete-btn:hover {
        color: #333;
    }

    #header-info-display {
      position: fixed;
      top: 10px;
      right: 15px;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 15px;
      background-color: rgba(240, 248, 255, 0.75);
      padding: 5px 12px;
      border-radius: 8px;
      font-size: 13px;
      color: #333;
      z-index: 10006;
      font-family: 'Segoe UI', '맑은 고딕', sans-serif;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(2px);
      border: 1px solid rgba(200, 200, 200, 0.5);
    }
    body.true-fullscreen-active #header-info-display {
        top: 12px;
        right: 60px;
    }
    .info-line {
      display: flex;
      align-items: center;
      gap: 6px;
      position: relative;
    }
    .info-line .icon {
      font-size: 1.1em;
      opacity: 0.8;
    }
    .info-line span {
        letter-spacing: 0.5px;
    }
    #info-date {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-color: rgba(0, 0, 0, 0.2);
    }
    #info-date:hover {
        color: #007bff;
        text-decoration-color: #007bff;
    }
    #calendar-container {
      position: absolute;
      top: 120%;
      right: 0;
      background: white;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10007;
      width: 280px;
      padding: 10px;
      display: none;
    }
    #calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-weight: bold;
    }
    #calendar-header button {
      background: none; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;
      padding: 2px 8px;
    }
    #calendar-header button:hover { background-color: #f0f0f0; }
    #calendar-days {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      text-align: center;
    }
    #calendar-days div {
      padding: 6px 2px;
      font-size: 12px;
    }
    #calendar-days .day-name {
      font-weight: bold;
      color: #666;
    }
    #calendar-days .day-cell {
      cursor: pointer;
      border-radius: 50%;
    }
    #calendar-days .day-cell.other-month {
      color: #ccc;
    }
    #calendar-days .day-cell:hover {
      background-color: #e0e0e0;
    }
    #calendar-days .day-cell.today {
      background-color: #007bff;
      color: white;
      font-weight: bold;
    }

    .action-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 4px;
      border-left: 3px solid #64b5f6;
      background-color: #fafafa;
      border-radius: 4px;
      margin-bottom: 6px;
      position: relative;
    }
    .action-item-status {
      flex-shrink: 0;
      cursor: pointer;
      font-weight: bold;
      user-select: none;
      width: 20px;
      text-align: center;
      font-size: 1.1em;
      padding-top: 1px;
    }
    .action-item-text {
      flex-grow: 1;
    }
    .action-item .action-item-assignee,
    .action-item .action-item-duedate {
      color: #555;
      font-size: 0.9em;
      background-color: #e8e8e8;
      padding: 0px 6px;
      border-radius: 10px;
      white-space: nowrap;
      min-width: 60px;
      text-align: center;
    }
    .action-item [data-placeholder]:empty::before {
        content: attr(data-placeholder);
        color: #888;
        font-style: italic;
    }
    .action-item[data-status="todo"] { border-left-color: #64b5f6; }
    .action-item[data-status="doing"] { border-left-color: #ffb74d; }
    .action-item[data-status="done"] {
      border-left-color: #81c784; background-color: #f1f1f1;
    }
    .action-item[data-status="done"] .action-item-text {
      text-decoration: line-through; color: #777;
    }
    .action-item-delete-btn {
        position: absolute; top: 2px; right: 2px;
        background: rgba(220, 220, 220, 0.95); border: 1px solid #aaa; color: #333;
        cursor: pointer; font-size: 14px; padding: 0px 5px; border-radius: 4px;
        line-height: 1.2; display: none;
    }
    .action-item:hover .action-item-delete-btn { display: block; }
    
    .key-decision {
      background-color: #fff9c4; padding: 2px 6px; border-radius: 4px; font-weight: bold;
      border-left: 3px solid #ffca28;
      -webkit-print-color-adjust: exact !important; color-adjust: exact !important;
    }
    .key-decision::before { content: '📌'; margin-right: 6px; }

    .poll-widget {
      margin-top: 8px; margin-left: 20px; display: flex;
      gap: 10px; align-items: center;
    }
    .poll-btn {
      background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 12px;
      padding: 2px 8px; cursor: pointer; font-size: 14px;
      user-select: none; transition: background-color 0.2s;
    }
    .poll-btn:hover { background-color: #e0e0e0; }
    .poll-count { margin-left: 4px; font-weight: bold; color: #333; }

    .status-tag {
        display: inline-block;
        padding: 2px 8px;
        font-size: 0.9em;
        font-weight: 500;
        border-radius: 4px;
        color: white;
        margin: 0 2px;
        -webkit-print-color-adjust: exact !important;
        color-adjust: exact !important;
    }
    .status-tag.status-done { background-color: #4CAF50; } /* Green */
    .status-tag.status-progress { background-color: #2196F3; } /* Blue */
    .status-tag.status-pending { background-color: #FFC107; color: #333; } /* Yellow */
    .status-tag.status-new { background-color: #9C27B0; } /* Purple */
    .status-tag.status-canceled { background-color: #f44336; } /* Red */

    #selectionZoomOverlay {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background-color: rgba(240, 240, 240, 0.97);
        z-index: 3000; display: none;
        padding: 20px; box-sizing: border-box; overflow-y: auto;
        cursor: zoom-out;
    }
    #selectionZoomContent {
        background-color: #ffffff; padding: 25px; border: 1px solid #ccc; border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); max-width: 90%; margin: 20px auto;
    }
    .close-selection-zoom-btn {
        position: absolute; top: 10px; right: 10px; font-size: 24px; color: #aaa;
        background-color: transparent; border: none; cursor: pointer; z-index: 3001;
    }
    .close-selection-zoom-btn:hover { color: #777; }

    /* START: 이미지 관련 CSS (주간 코드에서 이식) */
    .resizable-image-wrapper {
        position: relative;
        display: inline-block;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
        line-height: 0;
        vertical-align: bottom; /* contenteditable 내에서 정렬 문제 방지 */
    }
    .resizable-image-wrapper.is-dragging {
        cursor: grabbing;
        z-index: 1001; /* 드래그 중 다른 요소 위로 올라오도록 */
        opacity: 0.8;
        transform: scale(1.02);
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        transition: none;
    }
    .resizable-image-wrapper.active {
        z-index: 1000; /* 선택 시 다른 요소 위로 */
        position: relative;
    }
    .selection-box {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: 2px dashed #007bff;
        box-sizing: border-box;
        display: none;
        pointer-events: none;
    }
    .resizable-image-wrapper.active .selection-box {
        display: block;
    }
    .resizable-image-wrapper img {
        display: block;
        width: 100%;
        height: auto;
        cursor: grab; /* 이동 가능함을 암시 */
        user-select: none;
        -webkit-user-drag: none;
    }
    body.ctrl-pressed .resizable-image-wrapper img {
        cursor: zoom-in; /* Ctrl 누를 때만 확대 커서 */
    }
    body.shift-pressed .resizable-image-wrapper img {
      cursor: zoom-in;
    }
    .resize-handle-img {
        position: absolute;
        width: 10px;
        height: 10px;
        background-color: #007bff;
        border: 1px solid #fff;
        border-radius: 2px;
        display: none; /* 평소에는 숨김 */
        z-index: 10;
    }
    .resizable-image-wrapper.active .resize-handle-img {
        display: block; /* active 클래스가 있을 때만 보임 */
    }
    .rh-top-left { top: -5px; left: -5px; cursor: nwse-resize; }
    .rh-top-right { top: -5px; right: -5px; cursor: nesw-resize; }
    .rh-bottom-left { bottom: -5px; left: -5px; cursor: nesw-resize; }
    .rh-bottom-right { bottom: -5px; right: -5px; cursor: se-resize; }
    .ghost-image.is-copying::after {
      content: '+';
      position: absolute;
      bottom: 5px;
      right: 5px;
      background-color: #28a745; /* Green background for copy */
      color: white;
      font-weight: bold;
      font-size: 16px;
      border-radius: 50%;
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
      z-index: 20001;
    }

    #imageZoomOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: rgba(0, 0, 0, 0.85);
      z-index: 25000;
      display: none; /* 평소에는 숨김 */
      align-items: center;
      justify-content: center;
      cursor: zoom-out;
      backdrop-filter: blur(2px);
    }
    body.image-zoom-active { overflow: hidden !important; }

    .close-image-zoom-btn {
      position: absolute;
      top: 15px; right: 25px;
      font-size: 3em;
      color: white;
      cursor: pointer;
      line-height: 0.6;
      text-shadow: 0 0 5px black;
      z-index: 25001;
      user-select: none;
    }
    .close-image-zoom-btn:hover {
      color: #ff6b6b;
      text-shadow: 0 0 8px rgba(255, 107, 107, 0.8);
    }
    #imageZoomContent {
      max-width: 90%;
      max-height: 90%;
    }
    #imageZoomImg {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      box-shadow: 0 0 25px rgba(0,0,0,0.5);
    }
    body.image-zoom-active #appContainer:fullscreen,
    body.image-zoom-active #appContainer:-webkit-full-screen,
    body.image-zoom-active #appContainer:-moz-full-screen,
    body.image-zoom-active #appContainer:-ms-fullscreen {
        overflow: hidden !important;
    }
    /* END: 이미지 관련 CSS (주간 코드에서 이식) */

    /* START: 이미지 편집 고도화 CSS */
    .item-control-btn.image-edit-btn {
        font-size: 18px;
        padding: 1px 4px;
        line-height: 1.2;
    }
    .image-annotation-text {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(255, 255, 255, 0.75);
        border: 1px dashed #333;
        padding: 2px 5px;
        cursor: move;
        font-size: 16px;
        min-width: 20px;
        color: #000;
        z-index: 11;
        line-height: 1.3;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
    }
    .image-annotation-text:focus {
        outline: 1px solid #007bff;
        border-style: solid;
        background-color: rgba(255, 255, 255, 0.9);
    }

    #imageCropOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 26000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
    }
    #imageCropContainer {
      position: relative;
      max-width: 90vw;
      max-height: 80vh;
    }
    #imageCropImg {
      max-width: 100%;
      max-height: 100%;
      display: block;
    }
    #cropBox {
      position: absolute;
      top: 10%; left: 10%;
      width: 80%; height: 80%;
      border: 2px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
      cursor: move;
      z-index: 26001;
    }
    .crop-handle {
      position: absolute;
      width: 12px; height: 12px;
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #777;
    }
    .ch-top-left { top: -6px; left: -6px; cursor: nwse-resize; }
    .ch-top-right { top: -6px; right: -6px; cursor: nesw-resize; }
    .ch-bottom-left { bottom: -6px; left: -6px; cursor: nesw-resize; }
    .ch-bottom-right { bottom: -6px; right: -6px; cursor: se-resize; }
    .ch-top { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
    .ch-bottom { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
    .ch-left { top: 50%; left: -6px; transform: translateY(-50%); cursor: ew-resize; }
    .ch-right { top: 50%; right: -6px; transform: translateY(-50%); cursor: ew-resize; }

    #imageCropControls {
      margin-top: 15px;
      display: flex;
      gap: 15px;
      z-index: 26002;
    }
    #imageCropControls button {
      font-size: 1.1em;
      padding: 8px 18px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      color: white;
    }
    #cropConfirmBtn { background-color: #28a745; }
    #cropConfirmBtn:hover { background-color: #218838; }
    #cropCancelBtn { background-color: #dc3545; }
    #cropCancelBtn:hover { background-color: #c82333; }
    /* END: 이미지 편집 고도화 CSS */


    @media print {
      @page {
        size: a4 landscape;
        margin: 5mm !important;
      }
      body, html {
        margin: 0 !important; padding: 0 !important;
        width: 100% !important; height: auto !important;
        overflow: visible !important;
        -webkit-print-color-adjust: exact !important; color-adjust: exact !important;
      }

      .floating-menu-icon, .fullscreen-btn-class, #multiZoomTriggerBtn,
      .floating-panel, #customMessageBox, #selectionZoomOverlay, #imageZoomOverlay,
      .exit-true-fullscreen-btn, .item-controls, .add-sub-insert-area-btn,
      #annotationDisplayToggleBtn, #annotationSettingsToggleBtn, #annotationSettingsPanel, #memoAnnotationToggleBtn,
      .text-annotation-memo .memo-delete-btn, #header-info-display,
      #futureMeetingBlocker, .no-print, #navToggleBtn, #selectionZoomOverlay,
      .insert-area-toggle-btn, .box-toggle-btn,
      #compareModeToggleBtn,
      #compareControlsContainer, #comparisonViewOverlay,
      .resizable-image-wrapper .resize-handle-img,
      #imageCropOverlay /* 인쇄 시 자르기 도구 숨김 */ {
        display: none !important;
      }
      .resizable-image-wrapper { /* 인쇄 시 outline 제거 */
          outline: none !important;
      }
      .image-annotation-text { /* 인쇄 시 주석 스타일 조정 */
         background-color: rgba(255, 255, 255, 0.6) !important;
         border: 1px solid #555 !important;
         box-shadow: none !important;
         color: black !important;
         -webkit-print-color-adjust: exact !important; color-adjust: exact !important;
      }
      .action-item-status, 
      .action-item [data-placeholder]:empty::before,
      .action-item-delete-btn {
        display: none !important;
      }
      .action-item {
         gap: 5px; padding-left: 5px;
      }

      #monthlyNavigatorContainer {
        position: relative !important; top: auto !important; left: auto !important;
        width: 100% !important; box-shadow: none !important; border-bottom: 1px solid #ddd !important;
        margin-bottom: 5mm !important; page-break-after: avoid;
        -webkit-print-color-adjust: exact !important; color-adjust: exact !important;
      }
      #monthlyNavigatorContent {
          max-height: initial !important;
      }

      .insert-area.collapsed {
        max-height: none !important; min-height: 50px !important;
        padding-top: 28px !important; padding-bottom: 8px !important;
        background-color: #fff !important;
      }
      .insert-area.collapsed > *:not(.insert-area-toggle-btn) { display: block !important; }
      .box.box-collapsed { padding-bottom: 12px !important; }
      .box.box-collapsed > *:not(.section-subtitle):not(.box-toggle-btn) { display: block !important; }
      .box.box-collapsed > .section-subtitle > .item,
      .box.box-collapsed > .section-subtitle .item {
        display: flex !important;
      }

      #annotationCanvas { }
      .text-annotation-memo {
        border: 1px solid #ddd !important; background-color: #fff !important;
        box-shadow: none !important; page-break-inside: avoid;
      }
      h1#page-title {
        position: relative !important; border-bottom: 1px solid #ccc !important;
        padding: 5mm 0 !important; margin: 0 0 0 0 !important;
        width: 100% !important; box-sizing: border-box !important;
      }
       #appContainer, .container {
         margin: 0 !important; padding: 0 !important; width: 100% !important;
         border: none !important; box-shadow: none !important;
       }
      .container {
        padding-top: 0 !important;
      }
      .box {
        border-left: 4px solid #b0bec5 !important; page-break-inside: avoid;
        margin-left: 0 !important; padding-left: 10px !important;
      }
      .section {
        page-break-inside: avoid; padding: 0 5px !important;
      }
      .flow { margin-left: 5px !important; }

      .flow span, .highlight, .key-decision, .action-item[data-status="done"], .status-tag {
         -webkit-print-color-adjust: exact !important;
         color-adjust: exact !important;
      }
      a {
        color: purple !important; text-decoration: underline !important;
      }
      
      .multi-zoom-selected, .month-link.compare-selected {
         outline: none !important; box-shadow: none !important; transform: none !important;
      }
      body.ctrl-pressed [data-editable-type]:hover { cursor: default !important; }
    }
  </style>
  <script id="app-state-data"></script>
</head>
<body class="meeting-cursor">

<div id="appContainer">
    <div id="futureMeetingBlocker" title="닫기" style="display: none;">🚫</div>

    <div id="header-info-display">
      <div class="info-line">
        <span class="icon">⏰</span>
        <span id="info-timer">00:00</span>
      </div>
      <div class="info-line">
        <span id="info-time">AM 12:00</span>
      </div>
      <div class="info-line">
        <span class="icon">📅</span>
        <span id="info-date" title="달력 보기">YY-MM-DD</span>
        <div id="calendar-container">
          <div id="calendar-header">
            <button id="calendar-prev-month">&lt;</button>
            <span id="calendar-month-year">YYYY년 M월</span>
            <button id="calendar-next-month">&gt;</button>
          </div>
          <div id="calendar-days"></div>
        </div>
      </div>
    </div>

    <button class="exit-true-fullscreen-btn" id="exitTrueFullscreenBtnActual" title="기본 보기로 돌아가기">✕</button>
    
    <button class="floating-menu-icon" id="floatingMenuToggleBtn" title="메뉴 열기">☰</button>
    <button id="compareModeToggleBtn" title="문서 비교 모드 켜기">⇆</button>
    <button class="fullscreen-btn-class" id="trueFullscreenBtn" title="전체 화면 보기">⛶</button>
    
    <button id="multiZoomTriggerBtn" title="선택된 항목 모두 확대" style="display: none;">🔍</button>

    <button id="annotationDisplayToggleBtn" title="주석 켜기/끄기" style="display: none;">👁️</button>
    <button id="annotationSettingsToggleBtn" title="주석 설정" style="display: none;">⚙️</button>
    <button id="memoAnnotationToggleBtn" title="텍스트 메모 추가 (전체 화면에서 내용 영역 클릭)" style="display: none;">📝</button>

    <h1 id="page-title" contenteditable="true" data-editable-type="page-title">YYYY년 MM월 월간 회의 안건</h1>

    <div id="monthlyNavigatorContainer">
        <div id="monthlyNavigatorContent"></div>
        <button id="navToggleBtn" title="네비게이션 접기">▲</button>
    </div>

    <div class="container" id="content" contenteditable="true">
      <canvas id="annotationCanvas"></canvas>
      <div class="section"><div class="section-title" data-editable-type="section-title"><font size="5" style="color: rgb(5, 5, 5);">→</font><span style="color: rgb(5, 5, 5);"> </span><font size="5" style="color: rgb(5, 5, 5);"><a href="https://jonggunelee.github.io/wyggkr/01%20%EC%9B%94%EB%B3%84%20%EB%88%84%EC%A0%81%20%EC%A7%91%ED%96%89%EB%B9%84_(%EA%B8%B0%EC%88%99%EC%82%AC%20%EB%B0%8F%20%EC%82%AC%ED%83%9D)_2025-06-00.html" target="_blank" rel="noopener noreferrer" style="text-decoration-line: none;">절감 및 집행 현황</a></font><span style="font-size: 20px;"><font color="#292929">(누적)</font></span></div>
        <div class="section-subtitle" data-editable-type="section-subtitle"><span style="font-size: large;">▶ 절감액 산출 기준</span><font color="#3e3c3c">(공통)</font></div>
        <div class="flow" data-editable-type="flow-container">
          <span data-editable-type="flow-span" class=""><span style="font-size: medium; font-weight: 600;">항목 발굴 ➡️</span></span>
          <span data-editable-type="flow-span" class=""><span style="font-size: medium; font-weight: 600;">검토(현실성) ➡️</span></span>
          <span data-editable-type="flow-span" class=""><span style="font-size: medium; font-weight: 600;">반영(협의) ➡️</span></span>
          <span data-editable-type="flow-span" class=""><span style="font-size: medium; font-weight: 600;">개선 및 확장(지속성)</span></span>
        </div>
        <div class="box" data-editable-type="box">
          <div class="section-subtitle" data-editable-type="section-subtitle"><span class="bullet-char"><div class="item item-bulleted-left" data-editable-type="item" style="cursor: zoom-in; color: rgb(43, 43, 43);"><span class="bullet-char"><span class="bullet-char" style="font-size: 14.7456px;"><font size="3">▪</font><strong><font size="3">항목(실비정산 ①예시) </font></strong><font size="3">: 기계 긴급성 (23년 하반기) ➡️ 건축·기계 규모 파악 및 합의('24년) ➡️ 지속적 보완('25년~)<br></font><font size="5" color="#f70808">                     </font><b><font size="5" color="#f70808"><u>∴</u></font><font size="3"> 동일 조건 1:1 절감액 산출 불가</font></b><font size="3"> </font></span></span><div><span class="bullet-char" style="font-size: 14.7456px;"><font size="3"><br></font></span></div><span class="bullet-text"><font size="3"><br><br></font></span></div><div class="item item-bulleted-left" data-editable-type="item" style="color: rgb(43, 43, 43);"><span class="bullet-char"><font size="3">▪</font><strong style="font-size: medium;">비용(산출기준 ①</strong><strong><font size="2">예시</font></strong><strong style="font-size: medium;">) </strong><span style="font-size: medium;">: </span><font size="3">공사 적용시 산출비(보수적) </font><font size="2" color="#fb0945">➖</font><font size="3"> 실 투입비  </font><span style="background-color: rgb(224, 247, 250); font-size: x-large; font-weight: 700;"><font color="#757575">=</font></span><span style="font-size: medium;"> </span><b style="font-size: medium;"><font color="#ee4f4f">차액(절감액)</font></b><span style="font-size: medium;"> <br></span><span style="font-size: medium;">                              ※ <b>기실적</b> 또는 <b>최소 인건비 기준</b> 적용 (자재비 미반영, 선택 적용)</span></span><span class="bullet-char"><span style="font-size: medium;"><br></span></span></div></span></div></div><div class="section-subtitle" data-editable-type="section-subtitle"><span style="font-size: large;"><br></span></div>
        
        <div class="section-subtitle" data-editable-type="section-subtitle"><span style="font-size: large;">▶ 5월말 집행비</span></div>
        <div class="flow" data-editable-type="flow-container">
          <span data-editable-type="flow-span" class="highlight">총 4.4천만원 (16건)</span>
          <span data-editable-type="flow-span"><b>=</b></span>
          <span data-editable-type="flow-span">수장공사 2.6천만원 (6건)</span>
          <span data-editable-type="flow-span">➕</span>
          <span data-editable-type="flow-span">건축(실비정산) 4.8백만원 (1건)</span>
          <span data-editable-type="flow-span">➕</span>
          <span data-editable-type="flow-span">세대내 보일러 外 1.3천만원 (9건)</span>
        </div>

      </div>

      <div class="section">
        <div class="section-title" data-editable-type="section-title"><span style="font-size: 24px;"><br></span></div><div class="section-title" data-editable-type="section-title"><span style="font-size: 24px;">→ 주요 현황</span></div>
        <div class="box" data-editable-type="box">
          <div class="section-subtitle" data-editable-type="section-subtitle"><span class="bullet-char">▪<b style="font-size: 20px;">업무지원팀</b></span></div>
           <div class="insert-area" contenteditable="true" data-editable-type="insert-area" style="background-color: rgb(255, 255, 255); line-height: 2.2;" tabindex="-1"><br></div><button class="add-sub-insert-area-btn" contenteditable="false">
                <span contenteditable="true" data-editable-type="button-text-label">+ 하위 입력창 추가</span>
           </button>
        </div>
        <div class="box" data-editable-type="box">
          <div class="section-subtitle" data-editable-type="section-subtitle"><span class="bullet-char">▪<b style="font-size: 20px;">관리소</b></span></div>
           <div class="insert-area" contenteditable="true" data-editable-type="insert-area" style="background-color: rgb(255, 255, 255); line-height: 2.2;" tabindex="-1"><br></div><button class="add-sub-insert-area-btn" contenteditable="false">
                <span contenteditable="true" data-editable-type="button-text-label" class="">+ 하위 입력창 추가</span>
           </button>
        </div>
        <div class="box" data-editable-type="box">
          <div class="section-subtitle" data-editable-type="section-subtitle"><span class="bullet-char"><span style="font-size: 20px;"><b>▪공 통</b></span></span></div>
             <div class="insert-area" contenteditable="true" data-editable-type="insert-area" style="line-height: 2.2; background-color: rgb(255, 255, 255);" tabindex="-1"><br></div><button class="add-sub-insert-area-btn" contenteditable="false">
                <span contenteditable="true" data-editable-type="button-text-label" class="">+ 하위 입력창 추가</span>
             </button>
          </div>
      </div>

      <div class="section">
        <div class="section-title" data-editable-type="section-title"><span style="font-size: 24px;">→ 현장 점검</span></div>
        <div class="box" data-editable-type="box">
          <div class="section-subtitle" data-editable-type="section-subtitle"><span class="bullet-char"><span style="font-size: 20px;"><b>▪점 검</b></span></span></div>
           <div class="insert-area" contenteditable="true" data-editable-type="insert-area" style="background-color: rgb(255, 255, 255); line-height: 2.4;" tabindex="-1"><br></div><button class="add-sub-insert-area-btn" contenteditable="false">
                <span contenteditable="true" data-editable-type="button-text-label">+ 하위 입력창 추가</span>
           </button>
           </div>
      </div>
    </div>
    <div id="annotationSettingsPanel">
        <span id="closeAnnotationSettingsBtn" title="설정 적용 및 닫기">&times;</span>
        <div>
            <button id="annoToolPen" data-tool="pen" title="펜">펜</button>
            <button id="annoToolHighlighter" data-tool="highlighter" title="형광펜">형광펜</button>
            <button id="annoToolCircle" data-tool="circle" title="원">○</button>
            <button id="annoToolEllipse" data-tool="ellipse" title="타원">◌</button>
            <button id="annoToolOrthoLine" data-tool="orthoLine" title="직각선">📐</button>
        </div>
        <div>
            <label for="annoColorPicker">색:</label>
            <input type="color" id="annoColorPicker" title="색상 선택">
        </div>
        <div>
            <label for="annoLineWidth">굵기:</label>
            <input type="range" id="annoLineWidth" min="1" max="20" title="선 굵기">
        </div>
        <div id="annoHighlighterOpacityContainer">
            <label for="annoHighlighterOpacity">투명도:</label>
            <input type="range" id="annoHighlighterOpacity" min="0.1" max="1" step="0.1" value="0.3" title="형광펜 투명도">
        </div>
        <div>
            <button id="annoToolEraser" data-tool="eraser" title="지우개">지우개</button>
            <button id="annoClearCanvas" title="모두 지우기">전체삭제</button>
        </div>
        <div>
            <input type="checkbox" id="annoKeepDrawingsVisible" checked>
            <label for="annoKeepDrawingsVisible" style="font-size:11px; white-space: nowrap;">그림 유지(비활성시)</label>
        </div>
    </div>

    <!-- START: 이미지 확대 보기(Zoom)를 위한 HTML 구조 (주간 코드에서 이식) -->
    <div id="imageZoomOverlay">
        <span class="close-image-zoom-btn" title="닫기">&times;</span>
        <div id="imageZoomContent">
            <img id="imageZoomImg" src="" alt="Zoomed Image">
        </div>
    </div>
    <!-- END: 이미지 확대 보기(Zoom)를 위한 HTML 구조 (주간 코드에서 이식) -->
</div> 
<div id="customMessageBox" class="custom-message-box"></div>

<!-- ================================================================= -->
<!-- START: 개선된 탭 기반 패널 UI -->
<!-- ================================================================= -->
<div class="floating-panel" id="menuPanel" style="display: none;">
  <span class="floating-panel-close-btn" id="closeMenuPanelBtn" title="메뉴 닫기">✕</span>
  <div class="panel-tabs">
    <button class="tab-btn active" data-tab="tab-format">서식</button>
    <button class="tab-btn" data-tab="tab-insert">삽입</button>
    <button class="tab-btn" data-tab="tab-doc">문서 관리</button>
    <button class="tab-btn" data-tab="tab-settings">환경 설정</button>
  </div>
  <div class="panel-content-wrapper">
    <!-- 서식 탭 -->
    <div id="tab-format" class="tab-pane active">
      <div class="panel-section">
        <div class="panel-section-title">텍스트 스타일</div>
        <div class="format-controls">
          <button id="formatPainterBtn" title="서식 복사">🖌️</button>
          <button id="applyBoldBtn" title="굵게"><b>B</b></button>
          <button id="applyItalicBtn" title="기울임꼴"><i>I</i></button>
          <button id="applyUnderlineBtn" title="밑줄"><u>U</u></button>
          <button id="applyStrikethroughBtn" title="취소선" style="text-decoration: line-through;">S</button>
          <button id="applySuperscriptBtn" title="위 첨자">A<sup>+</sup></button>
          <button id="applySubscriptBtn" title="아래 첨자">A<sub>-</sub></button>
        </div>
        <div class="format-controls">
          <input type="number" id="fontSizeInput" title="글꼴 크기 (px)" min="8" value="16" step="1">
          <input type="color" id="fontColorSelector" title="글꼴 색상" value="#000000">
          <input type="color" id="backColorSelector" title="텍스트 배경색" value="#ffffff">
        </div>
      </div>
      <div class="panel-section">
        <div class="panel-section-title">단락 서식</div>
        <div class="format-controls">
          <button id="lineHeightBtn" title="줄 간격">⇕</button>
          <input type="number" id="lineHeightInput" title="줄 간격" min="1" step="0.1" value="1.6">
          <button id="alignLeftBtn" title="왼쪽 정렬" class="active">⇇</button>
          <button id="alignCenterBtn" title="가운데 정렬">⇹</button>
          <button id="alignRightBtn" title="오른쪽 정렬">⇉</button>
          <button id="alignVcenterBtn" title="수직 가운데 정렬">↕</button>
        </div>
        <div class="format-controls">
          <button id="insertUnorderedListBtn" title="글머리 기호 목록">● 목록</button>
          <button id="insertOrderedListBtn" title="번호 매기기 목록">1. 목록</button>
        </div>
      </div>
    </div>

    <!-- 삽입 탭 (레이아웃 변경됨) -->
    <div id="tab-insert" class="tab-pane">
      <div class="panel-section">
          <div class="panel-section-title">링크</div>
          <input type="text" id="linkURL" placeholder="연결할 URL 입력">
          <div style="display:flex; gap: 5px;">
            <button id="applyLinkBtn">링크 삽입</button>
            <button id="removeLinkBtn" class="secondary">링크 제거</button>
          </div>
      </div>
      <div class="panel-section" id="image-insert-controls">
        <div class="panel-section-title">이미지</div>
        <label for="imageFileInput">로컬 파일 선택 (다중 선택 가능):</label>
        <input type="file" id="imageFileInput" accept="image/*" multiple>
        <div class="format-controls">
            <label for="imageWidthInput" style="margin-right: 5px;">초기 너비(px):</label>
            <input type="number" id="imageWidthInput" min="10" value="300" style="width: 80px;">
            <button id="insertImageBtn" style="flex-grow: 1;">선택 위치에 삽입</button>
        </div>
      </div>
      <div class="panel-section">
        <div class="panel-section-title">특수문자</div>
        <div class="char-insert-container">
          <input type="text" id="charInput" placeholder="문자 입력 (예: ⭐, ✔)">
          <div class="emoji-dropdown">
              <button type="button" class="emoji-dropdown-btn" id="emojiDropdownBtn">▼</button>
              <div class="emoji-dropdown-content" id="emojiPalette">
                  <!-- Emoji buttons will be populated by JS -->
              </div>
          </div>
        </div>
         <button id="insertCharFromInputBtn" title="선택 위치에 삽입">입력 문자 삽입</button>
      </div>
      <div class="panel-section">
          <div class="panel-section-title">콘텐츠 요소 삽입</div>
          <div id="insert-grid">
              <button id="addOrUpdateActionItemBtn" class="insert-grid-btn" title="선택된 항목을 액션 아이템으로 변환하거나 새 액션 아이템 추가"><span class="icon">📋</span>액션 아이템</button>
              <button id="toggleKeyDecisionBtn" class="insert-grid-btn" title="선택된 텍스트를 주요 결정사항으로 강조/해제"><span class="icon">📌</span>결정사항</button>
              <button id="addPollWidgetBtn" class="insert-grid-btn" title="선택된 항목에 의견 투표 위젯 추가"><span class="icon">📊</span>의견투표</button>
          </div>
      </div>
      <div class="panel-section">
          <div class="panel-section-title">상태 태그</div>
          <div id="status-tag-grid">
              <button class="status-tag status-done" data-status="done">완료</button>
              <button class="status-tag status-progress" data-status="progress">진행중</button>
              <button class="status-tag status-pending" data-status="pending">보류</button>
              <button class="status-tag status-new" data-status="new">신규</button>
              <button class="status-tag status-canceled" data-status="canceled">취소</button>
          </div>
      </div>
    </div>

    <!-- 문서 관리 탭 -->
    <div id="tab-doc" class="tab-pane">
      <div class="panel-section">
        <div class="panel-section-title">파일 저장 및 내보내기</div>
        <button id="saveHtmlBtn" style="margin-top:5px;">💾 HTML로 저장</button>
        <button id="printPdfBtn" style="margin-top:5px;">📄 PDF로 인쇄</button>
      </div>
      <div class="panel-section">
        <div class="panel-section-title">문서 설정</div>
        <button id="applyDateUpdateBtn" class="secondary" style="width:100%; margin-bottom: 5px;">현재 날짜로 제목/기간 업데이트</button>
      </div>
       <div class="panel-section">
        <div class="panel-section-title">주석 도구</div>
        <div style="display:flex; flex-direction: column; gap: 5px;">
            <label class="checkbox-label" for="menuAnnoKeepDrawingsVisible" style="display:flex; align-items:center;">
              <input type="checkbox" id="menuAnnoKeepDrawingsVisible" style="width: auto; margin-right: 5px;">
              그림 유지(비활성시)
            </label>
            <button id="menuAnnoDrawingToggle">주석 켜기/끄기</button>
            <button id="menuAnnoSettingsPanelToggle">주석 설정 열기/닫기</button>
            <button id="menuMemoAnnotationBtn">메모 추가 (전체화면)</button>
        </div>
       </div>
    </div>

    <!-- 환경설정 탭 -->
    <div id="tab-settings" class="tab-pane">
        <div class="panel-section">
            <div class="panel-section-title">편집 환경</div>
            <label class="checkbox-label" for="pauseScreensaverCheckbox" style="display:flex; align-items:center;">
              <input type="checkbox" id="pauseScreensaverCheckbox" checked style="width: auto; margin-right: 5px;">
              ⏸️ 스크린 세이버 일시정지
            </label>
        </div>
        <div class="panel-section">
            <div class="panel-section-title">편집 아이콘 표시</div>
            <div class="radio-label-group" id="editIconsOptionsContainer">
                <label class="checkbox-label" for="editIconsModeOff">
                    <input type="radio" id="editIconsModeOff" name="editIconsMode" value="off"> 아이콘 숨김
                </label>
                <label class="checkbox-label" for="editIconsModeAll">
                    <input type="radio" id="editIconsModeAll" name="editIconsMode" value="all"> 전체 아이콘 표시
                </label>
                <label class="checkbox-label" for="editIconsModeSelected">
                    <input type="radio" id="editIconsModeSelected" name="editIconsMode" value="selected"> 선택 아이콘만 표시
                </label>
            </div>
        </div>
        <div class="panel-section">
            <div class="panel-section-title">네비게이션</div>
             <div id="monthlyNavUrlSettings">
              <label for="monthlyNavUrlTemplate" style="font-weight: normal; font-size: 13px;">월별 회의록 URL 설정</label>
              <input type="text" id="monthlyNavUrlTemplate" placeholder="현재/미래 회의록 경로 템플릿">
              <span id="monthlyNavUrlHelpText">현재 및 미래 월의 HTML 링크에 적용됩니다.<br>
                   {YYYY}: 4자리 연도, {MM}: 2자리 월</span>
              <div id="monthlyNavUrlBtnContainer">
                <button id="applyMonthlyNavUrlBtn">URL 적용</button>
                <button id="removeMonthlyNavUrlBtn" class="secondary">네비게이션 제거</button>
              </div>
            </div>
        </div>
        <div class="panel-section">
            <div class="panel-section-title">미작성 월 관리</div>
            <div id="skipped-month-management-container">
                <label for="skipped-year-selector">연도 선택:</label>
                <select id="skipped-year-selector"></select>
            </div>
            <div id="skipped-month-grid"></div>
            <button id="saveSkippedMonthsBtn" title="현재 '미작성 월' 설정을 파일에 영구적으로 저장합니다. 기존 파일을 덮어써주세요.">💾 설정 저장 (파일 업데이트)</button>
        </div>
    </div>
  </div>

  <div class="resize-handle n"></div><div class="resize-handle s"></div>
  <div class="resize-handle w"></div><div class="resize-handle e"></div>
  <div class="resize-handle nw"></div><div class="resize-handle ne"></div>
  <div class="resize-handle sw"></div><div class="resize-handle se"></div>
</div>
<!-- ================================================================= -->
<!-- END: 개선된 탭 기반 패널 UI -->
<!-- ================================================================= -->


<div id="selectionZoomOverlay">
    <button class="close-selection-zoom-btn" id="closeSelectionZoomBtn" title="닫기 (또는 바깥 클릭)">✕</button>
    <div id="selectionZoomContent"></div>
</div>

<div id="comparisonViewOverlay">
    <button class="close-comparison-view-btn" title="비교 닫기">✕</button>
    <div id="comparisonFrameContainer"></div>
</div>

<!-- START: 이미지 편집 고도화 UI (Crop) -->
<div id="imageCropOverlay">
    <div id="imageCropContainer">
        <img id="imageCropImg" src="">
        <div id="cropBox">
            <div class="crop-handle ch-top-left"></div>
            <div class="crop-handle ch-top-right"></div>
            <div class="crop-handle ch-bottom-left"></div>
            <div class="crop-handle ch-bottom-right"></div>
            <div class="crop-handle ch-top"></div>
            <div class="crop-handle ch-bottom"></div>
            <div class="crop-handle ch-left"></div>
            <div class="crop-handle ch-right"></div>
        </div>
    </div>
    <div id="imageCropControls">
        <button id="cropConfirmBtn">적용</button>
        <button id="cropCancelBtn">취소</button>
    </div>
</div>
<!-- END: 이미지 편집 고도화 UI (Crop) -->

<div class="common-item-template">
  <div class="item" data-editable-type="item" contenteditable="true">새로운 기본 항목...</div>
  <div class="default-shape-item" data-editable-type="item" contenteditable="true">새로운 항목 내용...</div>
  <div class="insert-area templated-insert-area" contenteditable="true" data-editable-type="insert-area" style="background-color: #fff;" tabindex="-1"></div>
  <div class="box" data-editable-type="box" style="margin-left: 0; background-color: #e9e9e9;">새 박스
      <div class="section-subtitle" data-editable-type="section-subtitle" style="margin-left:0;">새 하위 제목</div>
  </div>
  <span data-editable-type="flow-span" style="background-color: #cceeff;">새 흐름 단계</span>
  <span data-editable-type="status-tag" class="status-tag status-new" contenteditable="true">신규</span>
  <div class="item action-item" data-editable-type="item" data-status="todo">
    <span class="action-item-status" title="상태 변경 (미완료)" contenteditable="false">►</span>
    <span class="action-item-text" contenteditable="true">새로운 할 일...</span>
    <span class="action-item-assignee" contenteditable="true" data-placeholder="담당자"></span>
    <span class="action-item-duedate" contenteditable="true" data-placeholder="~기한"></span>
    <button class="action-item-delete-btn no-print" title="액션 아이템 삭제">🗑️</button>
  </div>
</div>

<script id="mainAppScript">
// 시작 코드 라인: <script id="mainAppScript"> 내부의 모든 것을 이 코드로 교체하세요.

  if (window.self !== window.top) {
    document.body.classList.add('is-in-iframe');
  }

  let monthlyNavigatorConfig = {
    enabled: true,
    baseURL: 'https://jonggunelee.github.io/wyggkr/',
    pastFilenameTemplate: '{YYYY}/{YYYY}_{MM}_회의록.pdf',
    futureFilenameTemplate: '{YYYY}/{YYYY}_{MM}_회의록.html',
    isNavCollapsed: false,
    skippedMonths: ["2014-1","2014-2","2014-3","2014-4","2014-5","2014-6","2014-7","2014-8","2014-9","2014-10","2014-11","2014-12","2015-1","2015-2","2015-3","2015-4","2015-5","2015-6","2015-7","2015-8","2015-9","2015-10","2015-11","2015-12","2016-1","2016-2","2016-3","2016-4","2016-5","2016-6","2016-7","2016-8","2016-9","2016-10","2016-11","2016-12","2017-1","2017-2","2017-3","2017-4","2017-5","2017-6","2017-7","2017-8","2017-9","2017-10","2017-11","2017-12","2018-1","2018-2","2018-3","2018-4","2018-5","2018-6","2018-7","2018-8","2018-9","2018-10","2018-11","2018-12","2019-1","2019-2","2019-3","2019-4","2019-5","2019-6","2019-7","2019-8","2019-9","2019-10","2019-11","2019-12","2020-1","2020-2","2020-3","2020-4","2020-5","2020-6","2020-7","2020-8","2020-9","2020-10","2020-11","2020-12","2021-1","2021-2","2021-3","2021-4","2021-5","2021-6","2021-7","2021-8","2021-9","2021-10","2021-11","2021-12","2022-1","2022-2","2022-3","2022-4","2022-5","2022-6","2022-7","2022-8","2022-9","2022-10","2022-11","2022-12","2023-1","2023-2"]
  };
  
  let panelState = { x: null, y: null, width: 360, height: 520 };

  const appContainer = document.getElementById('appContainer');
  const contentArea = document.getElementById('content');
  const pageTitle = document.getElementById("page-title");
  const menuPanel = document.getElementById("menuPanel");
  const floatingMenuToggleBtn = document.getElementById("floatingMenuToggleBtn");
  const closeMenuPanelBtn = document.getElementById("closeMenuPanelBtn");
  const trueFullscreenBtn = document.getElementById('trueFullscreenBtn');
  const exitTrueFullscreenBtnActual = document.getElementById('exitTrueFullscreenBtnActual');
  const multiZoomTriggerBtn = document.getElementById('multiZoomTriggerBtn');
  const selectionZoomOverlay = document.getElementById('selectionZoomOverlay');
  const selectionZoomContent = document.getElementById('selectionZoomContent');
  const annotationDisplayToggleBtn = document.getElementById('annotationDisplayToggleBtn');
  const annotationSettingsToggleBtn = document.getElementById('annotationSettingsToggleBtn');
  const annotationSettingsPanel = document.getElementById('annotationSettingsPanel');
  const closeAnnotationSettingsBtn = document.getElementById('closeAnnotationSettingsBtn');
  const annotationCanvas = document.getElementById('annotationCanvas');
  const annoToolPenBtn = document.getElementById('annoToolPen');
  const annoToolHighlighterBtn = document.getElementById('annoToolHighlighter');
  const annoToolCircleBtn = document.getElementById('annoToolCircle');
  const annoToolEllipseBtn = document.getElementById('annoToolEllipse');
  const annoToolOrthoLineBtn = document.getElementById('annoToolOrthoLine');
  const annoColorPicker = document.getElementById('annoColorPicker');
  const annoLineWidthSlider = document.getElementById('annoLineWidth');
  const annoToolEraserBtn = document.getElementById('annoToolEraser');
  const annoClearCanvasBtn = document.getElementById('annoClearCanvas');
  const annoHighlighterOpacityContainer = document.getElementById('annoHighlighterOpacityContainer');
  const annoHighlighterOpacitySlider = document.getElementById('annoHighlighterOpacity');
  const annoKeepDrawingsVisibleCheckbox = document.getElementById('annoKeepDrawingsVisible');
  const menuAnnoKeepDrawingsVisible = document.getElementById('menuAnnoKeepDrawingsVisible');
  const menuAnnoDrawingToggle = document.getElementById('menuAnnoDrawingToggle');
  const menuAnnoSettingsPanelToggle = document.getElementById('menuAnnoSettingsPanelToggle');
  const menuMemoAnnotationBtn = document.getElementById('menuMemoAnnotationBtn');
  const memoAnnotationToggleBtn = document.getElementById('memoAnnotationToggleBtn');
  const pauseScreensaverCheckbox = document.getElementById('pauseScreensaverCheckbox');
  const compareModeToggleBtn = document.getElementById('compareModeToggleBtn');
  const comparisonViewOverlay = document.getElementById('comparisonViewOverlay');
  const comparisonFrameContainer = document.getElementById('comparisonFrameContainer');
  const closeComparisonViewBtn = document.querySelector('.close-comparison-view-btn');

  let isMemoModeActive = false;
  let annotationCtx = annotationCanvas.getContext('2d');
  let isDrawingFeatureActive = false;
  let isAnnotationPanelOpen = false;
  let isDrawingAnnotation = false;
  let lastAnnotationX, lastAnnotationY;
  let shapeStartX, shapeStartY;
  let isShiftKeyDown = false;
  let previewImageData = null;
  let drawingSettings = {
    tool: 'orthoLine',
    penColor: '#FF0000',
    penLineWidth: '5',
    highlighterColor: '#FFFFE0',
    highlighterLineWidth: '20',
    highlighterOpacity: '1.0',
  };
  let panelUISettings = { ...drawingSettings };
  let keepDrawingsVisibleOnDeactivate = true;
  let drawnStrokes = [];
  let isDraggingPanel = false, panelOffsetX, panelOffsetY;
  let currentlySelectedElementForStyling = null;
  let currentlyActiveItemControlsElement = null;
  let elementsForMultiZoom = [];
  let displayedYearInNav;
  let documentYear, documentMonth;
  let idleTimer = null;
  let autoScrollInterval = null;
  let isScreensaverActive = false;
  let isScreensaverPaused = true; 
  let scrollPositionBeforeScreensaver = 0;
  const IDLE_TIMEOUT = 5000;
  let meetingStartTime;
  let clockInterval;
  let calendarDate = new Date();
  
  // === 텍스트 서식 이식을 위한 전역 변수 ===
  let isFormatPainterActive = false;
  let copiedFormatInfo = null;
  let savedRange = null;
  let isUpdatingUI = false;
  // ===================================
  
  let isCompareModeActive = false;
  let monthsForComparison = [];

  // --- START: 이미지 편집 고도화 관련 변수 ---
  let currentCroppingWrapper = null;
  // --- END: 이미지 편집 고도화 관련 변수 ---

  // --- START: 이미지 관련 함수 (주간 코드에서 이식) ---
  function initializeImageResizeFeature() {
      let activeHandle = null;
      let wrapper = null;
      let startX, startWidth;

      function startResize(e) {
          e.preventDefault();
          e.stopPropagation();
          activeHandle = e.target;
          wrapper = activeHandle.closest('.resizable-image-wrapper');
          if (!wrapper) return;

          backupOriginalState(wrapper);

          startX = e.clientX;
          const rect = wrapper.getBoundingClientRect();
          startWidth = rect.width;
          startHeight = rect.height; // Add this

          document.addEventListener('mousemove', doResize);
          document.addEventListener('mouseup', stopResize, { once: true });
      }

      function doResize(e) {
          if (!activeHandle || !wrapper) return;
          e.preventDefault();
          
          const dx = e.clientX - startX;
          let newWidth = startWidth;

          if (activeHandle.classList.contains('rh-bottom-right') || activeHandle.classList.contains('rh-top-right')) {
              newWidth = startWidth + dx;
          } else if (activeHandle.classList.contains('rh-bottom-left') || activeHandle.classList.contains('rh-top-left')) {
              newWidth = startWidth - dx;
          }
          
          if (newWidth > 20) {
              const aspectRatio = startHeight / startWidth;
              if (isFinite(aspectRatio) && aspectRatio > 0) {
                  wrapper.style.width = newWidth + 'px';
                  wrapper.style.height = (newWidth * aspectRatio) + 'px';
              } else { // Fallback if aspect ratio is weird
                  wrapper.style.width = newWidth + 'px';
                  wrapper.style.height = 'auto';
              }

              const state = JSON.parse(wrapper.dataset.transformState || '{}');
              applyImageTransforms(wrapper, state);
          }
      }

      function stopResize() {
          if (wrapper) {
               const currentActive = document.querySelector('.resizable-image-wrapper.active');
               if (currentActive && currentActive !== wrapper) currentActive.classList.remove('active');
               wrapper.classList.add('active');
               currentlyActiveItemControlsElement = wrapper;
          }
          document.removeEventListener('mousemove', doResize);
          activeHandle = null;
          wrapper = null;
      }

      contentArea.addEventListener('mousedown', (e) => {
          if (e.target.classList.contains('resize-handle-img')) {
              startResize(e);
          }
      });
  }

  function makeImageDraggable(wrapper) {
      if (wrapper._isDraggable) {
          return;
      }
      wrapper._isDraggable = true;
       // 이미지 래퍼에 고유 식별자 부여로 정확한 타겟팅 보장
       if (!wrapper.dataset.imageId) {
           wrapper.dataset.imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
       }

      let ghostElement = null;
      let isDragging = false;
      let offsetX, offsetY;

      const handleKeyEvents = (e) => {
          if (isDragging && ghostElement) {
              ghostElement.classList.toggle('is-copying', e.ctrlKey);
          }
      };

      function onDragStart(e) {
          // 주석 텍스트 드래그를 먼저 확인해야 합니다.
          const annotationText = e.target.closest('.image-annotation-text');
          if (annotationText) {
              // 텍스트를 편집하려는 경우가 아닐 때만 드래그 시작
              if (getComputedStyle(e.target).cursor !== 'text' && e.button === 0) {
                  e.preventDefault();
                  e.stopPropagation();
                  makeAnnotationDraggable(annotationText, wrapper, e);
              }
              // 이미지 드래그가 시작되지 않도록 항상 반환
              return;
          }

          if (e.shiftKey) {
              e.preventDefault();
              e.stopPropagation();
              const imgToZoom = wrapper.querySelector('img');
              if (imgToZoom && imgToZoom.src) {
                  openImageZoom(imgToZoom.src);
              }
              return;
          }

          // 이미지나 래퍼 자체에서만 드래그를 허용하고, 리사이즈 핸들 같은 다른 요소에서는 허용하지 않음
          if ((e.target.tagName !== 'IMG' && !e.target.classList.contains('resizable-image-wrapper')) || e.button !== 0) {
              return;
          }

          e.preventDefault();
          e.stopPropagation();

          isDragging = true;
          
          const rect = wrapper.getBoundingClientRect();

          ghostElement = wrapper.cloneNode(true);
          ghostElement.removeAttribute('id');
          ghostElement.classList.add('ghost-image');
          ghostElement.style.position = 'fixed';
          ghostElement.style.left = `${rect.left}px`;
          ghostElement.style.top = `${rect.top}px`;
          ghostElement.style.width = `${rect.width}px`;
          ghostElement.style.height = `${rect.height}px`;
          ghostElement.style.opacity = '0.7';
          ghostElement.style.pointerEvents = 'none';
          ghostElement.style.zIndex = '20000';
          document.body.appendChild(ghostElement);
          
          offsetX = e.clientX - rect.left;
          offsetY = e.clientY - rect.top;

          wrapper.style.opacity = '0.4';

          document.addEventListener('keydown', handleKeyEvents);
          document.addEventListener('keyup', handleKeyEvents);
          document.addEventListener('mousemove', onDragMove);
          document.addEventListener('mouseup', onDragEnd, { once: true });
          handleKeyEvents(e);
      }

      function onDragMove(e) {
          if (!isDragging || !ghostElement) return;
          ghostElement.style.left = `${e.clientX - offsetX}px`;
          ghostElement.style.top = `${e.clientY - offsetY}px`;
      }

      function onDragEnd(e) {
          if (!isDragging) return;
          isDragging = false;
          
          document.removeEventListener('keydown', handleKeyEvents);
          document.removeEventListener('keyup', handleKeyEvents);
          document.removeEventListener('mousemove', onDragMove);

          if (ghostElement) {
              ghostElement.style.display = 'none';
          }
          
          const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
          
          if (ghostElement && ghostElement.parentElement) {
              ghostElement.parentElement.removeChild(ghostElement);
          }
          ghostElement = null;

          wrapper.style.opacity = '1';

             // [개선] contenteditable 영역에서는 캐럿 위치에 정확히 삽입
   if (dropTarget) {
       const editableAncestor = dropTarget.closest('[contenteditable="true"]');
       if (editableAncestor) {
           let range = null;
           if (document.caretRangeFromPoint) {
               range = document.caretRangeFromPoint(e.clientX, e.clientY);
           } else if (document.caretPositionFromPoint) {
               const pos = document.caretPositionFromPoint(e.clientX, e.clientY);
               if (pos) {
                   range = document.createRange();
                   range.setStart(pos.offsetNode, pos.offset);
                   range.collapse(true);
               }
           }
           if (range) {
               // 범위가 편집 가능한 영역 내에 있는지 확인
               if (!editableAncestor.contains(range.startContainer)) {
                   range.selectNodeContents(editableAncestor);
                   range.collapse(false);
               }
               
               const nodeToInsert = e.ctrlKey ? wrapper.cloneNode(true) : wrapper;
               if (nodeToInsert !== wrapper) {
                   nodeToInsert.removeAttribute('id');
                   // 복제된 이미지에 새로운 고유 ID 부여
                   nodeToInsert.dataset.imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
               }
               
               // 정확한 위치에 삽입
               range.insertNode(nodeToInsert);
               range.setStartAfter(nodeToInsert);
               range.collapse(true);
               
               if (nodeToInsert !== wrapper) {
                   ensureImageWrapperStructure(nodeToInsert);
                   makeImageDraggable(nodeToInsert);
                   generateItemControls(nodeToInsert);
                   showMessage('이미지가 복사되었습니다.', 'success');
               }
               
               // 활성화 상태 정리 및 새 이미지 활성화
               const currentlyActive = document.querySelector('.resizable-image-wrapper.active');
               if (currentlyActive && currentlyActive !== nodeToInsert) {
                   currentlyActive.classList.remove('active');
               }
               nodeToInsert.classList.add('active');
               currentlyActiveItemControlsElement = nodeToInsert;
               return;
           }
       }
   }

          const dropContainer = dropTarget ? dropTarget.closest('.insert-area, .item-group, .action-item, .box > .section-subtitle, .box, .section, .container') : contentArea;
          
          if (dropContainer) {
              let nextSibling = null;
              const children = Array.from(dropContainer.children);
              for (const child of children) {
                  if (child === wrapper || child.style.display === 'none') continue;
                  const childRect = child.getBoundingClientRect();
                  if (e.clientY < childRect.top + childRect.height / 2) {
                      nextSibling = child;
                      break;
                  }
              }
              
              if (e.ctrlKey) {
                  const newWrapper = wrapper.cloneNode(true);
                  newWrapper.style.opacity = '1';
                  newWrapper.removeAttribute('id');
                  dropContainer.insertBefore(newWrapper, nextSibling);
                  ensureImageWrapperStructure(newWrapper);
                  makeImageDraggable(newWrapper);
                  generateItemControls(newWrapper);
                  showMessage('이미지가 복사되었습니다.', 'success');
              } else {
                  dropContainer.insertBefore(wrapper, nextSibling);
              }
          }
          
          const currentlyActive = document.querySelector('.resizable-image-wrapper.active');
          if (currentlyActive && currentlyActive !== wrapper) {
              currentlyActive.classList.remove('active');
          }
          wrapper.classList.add('active');
          currentlyActiveItemControlsElement = wrapper;
      }

      wrapper.addEventListener('mousedown', onDragStart);
  }

  function ensureImageWrapperStructure(wrapper) {
      const img = wrapper.querySelector('img');
      if (!img) return false;
      
       // 리사이즈 핸들이 없으면 추가
      const resizeHandles = wrapper.querySelectorAll('.resize-handle-img');
      if (resizeHandles.length === 0) {
          wrapper.innerHTML += `
              <div class="resize-handle-img rh-top-left"></div>
              <div class="resize-handle-img rh-top-right"></div>
              <div class="resize-handle-img rh-bottom-left"></div>
              <div class="resize-handle-img rh-bottom-right"></div>
          `;
      }
      
       // 클래스와 속성 보장
      if (!wrapper.classList.contains('resizable-image-wrapper')) {
          wrapper.classList.add('resizable-image-wrapper');
      }
       
       // 고유 식별자 부여 (없는 경우)
       if (!wrapper.dataset.imageId) {
           wrapper.dataset.imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
       }
       
       // contenteditable 속성 설정으로 편집 영역 내 안정성 보장
       wrapper.setAttribute('contenteditable', 'false');
       
      return true;
  }

  function openImageZoom(src) {
      const overlay = document.getElementById('imageZoomOverlay');
      const img = document.getElementById('imageZoomImg');
      if (overlay && img && src) {
          img.src = src;
          overlay.style.display = 'flex';
          document.body.classList.add('image-zoom-active');
          
          img.onload = () => {
              overlay.focus();
          };
          
          img.onerror = () => {
              console.error('이미지 로드 실패:', src);
              closeImageZoom();
          };
      }
  }

  function closeImageZoom() {
      const overlay = document.getElementById('imageZoomOverlay');
      if (overlay) {
          overlay.style.display = 'none';
          document.body.classList.remove('image-zoom-active');
      }
  }
  // --- END: 이미지 관련 함수 (주간 코드에서 이식) ---

  // --- START: 이미지 편집 고도화 함수 ---
  function handleImageAction(wrapper, action) {
    if (!wrapper) return;
    backupOriginalState(wrapper);
    const img = wrapper.querySelector('img');
    if (!img) return;
    
    let state = JSON.parse(wrapper.dataset.transformState || '{"rotation":0, "scaleX":1, "scaleY":1}');
    const oldRotation = state.rotation;

    // Get dimensions BEFORE changing state
    const rect = wrapper.getBoundingClientRect();
    const oldWidth = rect.width;
    const oldHeight = rect.height;

    switch(action) {
        case 'rotate-right':
            state.rotation = (state.rotation + 90) % 360;
            break;
        case 'flip-h':
            state.scaleX *= -1;
            break;
        case 'flip-v':
            state.scaleY *= -1;
            break;
        case 'annotate':
            addImageAnnotation(wrapper);
            return;
        case 'crop':
            openCropUI(wrapper);
            return;
        case 'reset':
            resetImage(wrapper);
            return;
    }
    
    if (action.startsWith('rotate')) {
        const wasSideways = oldRotation % 180 !== 0;
        const isNowSideways = state.rotation % 180 !== 0;
        if (isNowSideways !== wasSideways) {
            wrapper.style.width = oldHeight + 'px';
            wrapper.style.height = oldWidth + 'px';
        }
    }
    
    wrapper.dataset.transformState = JSON.stringify(state);
    applyImageTransforms(wrapper, state);
  }

  function applyImageTransforms(wrapper, state) {
      const img = wrapper.querySelector('img');
      if (!img) return;

      const wrapperRect = wrapper.getBoundingClientRect();
      const wrapperWidth = wrapperRect.width;
      const wrapperHeight = wrapperRect.height;
      
      const isSideways = (state.rotation || 0) % 180 !== 0;

      const imgUnrotatedWidth = isSideways ? wrapperHeight : wrapperWidth;
      const imgUnrotatedHeight = isSideways ? wrapperWidth : wrapperHeight;

      Object.assign(img.style, {
          position: 'absolute',
          width: imgUnrotatedWidth + 'px',
          height: imgUnrotatedHeight + 'px',
          left: `${(wrapperWidth - imgUnrotatedWidth) / 2}px`,
          top: `${(wrapperHeight - imgUnrotatedHeight) / 2}px`,
          transform: `rotate(${state.rotation || 0}deg) scaleX(${state.scaleX || 1}) scaleY(${state.scaleY || 1})`
      });
  }

  function backupOriginalState(wrapper) {
      if (!wrapper.dataset.originalSrc) {
          const img = wrapper.querySelector('img');
          if (img) {
              wrapper.dataset.originalSrc = img.src;
          }
      }
      if (!wrapper.dataset.originalWidth) {
          wrapper.dataset.originalWidth = wrapper.style.width || `${wrapper.offsetWidth}px`;
      }
  }

  function resetImage(wrapper) {
      const img = wrapper.querySelector('img');
      if (img && wrapper.dataset.originalSrc) {
          img.src = wrapper.dataset.originalSrc;
      }
      if (wrapper.dataset.originalWidth) {
          wrapper.style.width = wrapper.dataset.originalWidth;
          wrapper.style.height = '';
      }
      
      if (img) {
        Object.assign(img.style, {
            position: '',
            width: '',
            height: '',
            left: '',
            top: '',
            transform: ''
        });
      }
      
      delete wrapper.dataset.transformState;
      delete wrapper.dataset.originalSrc;
      delete wrapper.dataset.originalWidth;

      wrapper.querySelectorAll('.image-annotation-text').forEach(el => el.remove());
      showMessage('이미지가 초기 상태로 복원되었습니다.', 'success');
  }

  function addImageAnnotation(wrapper) {
      const annotation = document.createElement('div');
      annotation.className = 'image-annotation-text';
      annotation.setAttribute('contenteditable', 'true');
      annotation.textContent = '주석 입력';
      wrapper.appendChild(annotation);
      annotation.focus();
  }

  function makeAnnotationDraggable(element, container, initialEvent) {
      let isDragging = true;
      let startX = initialEvent.clientX;
      let startY = initialEvent.clientY;
      let startLeft = element.offsetLeft;
      let startTop = element.offsetTop;
  
      element.style.cursor = 'grabbing';
  
      const onMouseMove = (e) => {
          if (!isDragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          let newLeft = startLeft + dx;
          let newTop = startTop + dy;
          
          const containerWidth = container.offsetWidth;
          const containerHeight = container.offsetHeight;
          const elementWidth = element.offsetWidth;
          const elementHeight = element.offsetHeight;
  
          newLeft = Math.max(0, Math.min(newLeft, containerWidth - elementWidth));
          newTop = Math.max(0, Math.min(newTop, containerHeight - elementHeight));
  
          element.style.left = `${newLeft}px`;
          element.style.top = `${newTop}px`;
      };
  
      const onMouseUp = () => {
          isDragging = false;
          element.style.cursor = 'move';
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
      };
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp, { once: true });
  }

  function openCropUI(wrapper) {
    currentCroppingWrapper = wrapper;
    const img = wrapper.querySelector('img');
    const overlay = document.getElementById('imageCropOverlay');
    const cropImg = document.getElementById('imageCropImg');
    
    cropImg.src = img.src;
    cropImg.onload = () => {
      overlay.style.display = 'flex';
      // Reset crop box to default
      const cropBox = document.getElementById('cropBox');
      cropBox.style.cssText = 'top: 10%; left: 10%; width: 80%; height: 80%;';
    };
  }

  function closeCropUI() {
    document.getElementById('imageCropOverlay').style.display = 'none';
    currentCroppingWrapper = null;
  }

  function initializeCropTool() {
      const overlay = document.getElementById('imageCropOverlay');
      const container = document.getElementById('imageCropContainer');
      const cropBox = document.getElementById('cropBox');
      const cropImg = document.getElementById('imageCropImg');

      let activeHandle = null;
      let isDraggingBox = false;
      let startX, startY, startLeft, startTop, startWidth, startHeight;

      const onHandleMouseDown = (e) => {
          e.stopPropagation();
          activeHandle = e.target;
          startX = e.clientX;
          startY = e.clientY;
          const rect = cropBox.getBoundingClientRect();
          startLeft = cropBox.offsetLeft;
          startTop = cropBox.offsetTop;
          startWidth = rect.width;
          startHeight = rect.height;
          document.addEventListener('mousemove', onHandleMouseMove);
          document.addEventListener('mouseup', onHandleMouseUp, { once: true });
      };

      const onBoxMouseDown = (e) => {
          if (e.target !== cropBox) return;
          isDraggingBox = true;
          startX = e.clientX;
          startY = e.clientY;
          startLeft = cropBox.offsetLeft;
          startTop = cropBox.offsetTop;
          document.addEventListener('mousemove', onBoxMouseMove);
          document.addEventListener('mouseup', onBoxMouseUp, { once: true });
      };

      const onHandleMouseMove = (e) => {
          if (!activeHandle) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          const containerRect = container.getBoundingClientRect();
          let newLeft = startLeft, newTop = startTop, newWidth = startWidth, newHeight = startHeight;

          if (activeHandle.classList.contains('ch-top-left')) {
              newWidth = Math.max(20, startWidth - dx); newHeight = Math.max(20, startHeight - dy);
              newLeft = startLeft + dx; newTop = startTop + dy;
          } else if (activeHandle.classList.contains('ch-top-right')) {
              newWidth = Math.max(20, startWidth + dx); newHeight = Math.max(20, startHeight - dy);
              newTop = startTop + dy;
          } else if (activeHandle.classList.contains('ch-bottom-left')) {
              newWidth = Math.max(20, startWidth - dx); newHeight = Math.max(20, startHeight + dy);
              newLeft = startLeft + dx;
          } else if (activeHandle.classList.contains('ch-bottom-right')) {
              newWidth = Math.max(20, startWidth + dx); newHeight = Math.max(20, startHeight + dy);
          } else if (activeHandle.classList.contains('ch-top')) {
              newHeight = Math.max(20, startHeight - dy); newTop = startTop + dy;
          } else if (activeHandle.classList.contains('ch-bottom')) {
              newHeight = Math.max(20, startHeight + dy);
          } else if (activeHandle.classList.contains('ch-left')) {
              newWidth = Math.max(20, startWidth - dx); newLeft = startLeft + dx;
          } else if (activeHandle.classList.contains('ch-right')) {
              newWidth = Math.max(20, startWidth + dx);
          }
          
          if (newLeft < 0) { newWidth += newLeft; newLeft = 0; }
          if (newTop < 0) { newHeight += newTop; newTop = 0; }
          if (newLeft + newWidth > containerRect.width) { newWidth = containerRect.width - newLeft; }
          if (newTop + newHeight > containerRect.height) { newHeight = containerRect.height - newTop; }

          cropBox.style.left = `${newLeft}px`; cropBox.style.top = `${newTop}px`;
          cropBox.style.width = `${newWidth}px`; cropBox.style.height = `${newHeight}px`;
      };
      
      const onBoxMouseMove = (e) => {
          if (!isDraggingBox) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          let newLeft = startLeft + dx;
          let newTop = startTop + dy;
          
          newLeft = Math.max(0, Math.min(newLeft, container.offsetWidth - cropBox.offsetWidth));
          newTop = Math.max(0, Math.min(newTop, container.offsetHeight - cropBox.offsetHeight));
          
          cropBox.style.left = `${newLeft}px`;
          cropBox.style.top = `${newTop}px`;
      };

      const onHandleMouseUp = () => { activeHandle = null; document.removeEventListener('mousemove', onHandleMouseMove); };
      const onBoxMouseUp = () => { isDraggingBox = false; document.removeEventListener('mousemove', onBoxMouseMove); };

      cropBox.addEventListener('mousedown', onBoxMouseDown);
      overlay.querySelectorAll('.crop-handle').forEach(h => h.addEventListener('mousedown', onHandleMouseDown));

      document.getElementById('cropCancelBtn').addEventListener('click', closeCropUI);
      document.getElementById('cropConfirmBtn').addEventListener('click', () => {
          if (!currentCroppingWrapper) return;
          const scaleX = cropImg.naturalWidth / cropImg.width;
          const scaleY = cropImg.naturalHeight / cropImg.height;

          const cropData = {
              sx: cropBox.offsetLeft * scaleX, sy: cropBox.offsetTop * scaleY,
              sWidth: cropBox.offsetWidth * scaleX, sHeight: cropBox.offsetHeight * scaleY
          };
          
          const canvas = document.createElement('canvas');
          canvas.width = cropData.sWidth;
          canvas.height = cropData.sHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(cropImg, cropData.sx, cropData.sy, cropData.sWidth, cropData.sHeight, 0, 0, canvas.width, canvas.height);
          
          const newDataUrl = canvas.toDataURL('image/webp', 0.9);
          const targetImg = currentCroppingWrapper.querySelector('img');
          targetImg.src = newDataUrl;
          
          closeCropUI();
          showMessage('이미지가 잘렸습니다.', 'success');
      });
  }
  // --- END: 이미지 편집 고도화 함수 ---
  
  // --- START: 개선된 패널 관련 함수 추가 ---
  function applyPanelState() {
      if (menuPanel && panelState.x !== null && panelState.y !== null) {
          menuPanel.style.left = `${panelState.x}px`;
          menuPanel.style.top = `${panelState.y}px`;
          menuPanel.style.width = `${panelState.width}px`;
          menuPanel.style.height = `${panelState.height}px`;
          menuPanel.style.right = 'auto';
          menuPanel.style.bottom = 'auto';
      } else if (menuPanel) {
          const defaultWidth = 360;
          const defaultHeight = 520;
          menuPanel.style.right = '16px';
          menuPanel.style.bottom = '16px';
          menuPanel.style.left = 'auto';
          menuPanel.style.top = 'auto';
          menuPanel.style.width = `${defaultWidth}px`;
          menuPanel.style.height = `${defaultHeight}px`;
          panelState.width = defaultWidth;
          panelState.height = defaultHeight;
      }
  }

  function initializePanelResizing() {
      const handles = menuPanel.querySelectorAll('.resize-handle');
      let initialRect;
      let initialMouseX, initialMouseY;
      let direction;

      function onResizeMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();

          direction = e.target.className.replace('resize-handle ', '');
          initialRect = menuPanel.getBoundingClientRect();
          initialMouseX = e.clientX;
          initialMouseY = e.clientY;

          document.addEventListener('mousemove', onResizeMouseMove);
          document.addEventListener('mouseup', onResizeMouseUp);
      }

      function onResizeMouseMove(e) {
          if (!initialRect) return;

          const dx = e.clientX - initialMouseX;
          const dy = e.clientY - initialMouseY;
          
          let newWidth = initialRect.width;
          let newHeight = initialRect.height;
          let newLeft = initialRect.left;
          let newTop = initialRect.top;
          
          const minWidth = 340;
          const minHeight = 400;

          if (direction.includes('e')) {
              newWidth = Math.max(minWidth, initialRect.width + dx);
          }
          if (direction.includes('w')) {
              newWidth = Math.max(minWidth, initialRect.width - dx);
              newLeft = initialRect.left + dx;
          }
          if (direction.includes('s')) {
              newHeight = Math.max(minHeight, initialRect.height + dy);
          }
          if (direction.includes('n')) {
              newHeight = Math.max(minHeight, initialRect.height - dy);
              newTop = initialRect.top + dy;
          }

          menuPanel.style.width = `${newWidth}px`;
          menuPanel.style.height = `${newHeight}px`;
          menuPanel.style.left = `${newLeft}px`;
          menuPanel.style.top = `${newTop}px`;
      }

      function onResizeMouseUp() {
          document.removeEventListener('mousemove', onResizeMouseMove);
          document.removeEventListener('mouseup', onResizeMouseUp);
          
          const finalRect = menuPanel.getBoundingClientRect();
          panelState.x = finalRect.left;
          panelState.y = finalRect.top;
          panelState.width = finalRect.width;
          panelState.height = finalRect.height;
      }

      handles.forEach(handle => {
          handle.addEventListener('mousedown', onResizeMouseDown);
      });
  }

    // --- START: 탭 패널 UI 관련 함수 ---
    function initializeTabPanel() {
        const tabButtons = menuPanel.querySelectorAll('.tab-btn');
        const tabPanes = menuPanel.querySelectorAll('.tab-pane');

        tabButtons.forEach(button => {
            if (button.dataset.listenerAttached === 'true') return;
            button.addEventListener('click', () => {
                const targetTabId = button.dataset.tab;

                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabPanes.forEach(pane => {
                    if (pane.id === targetTabId) {
                        pane.classList.add('active');
                    } else {
                        pane.classList.remove('active');
                    }
                });
            });
            button.dataset.listenerAttached = 'true';
        });
    }
  // --- END: 탭 패널 UI 관련 함수 ---


  function applyDynamicDateUpdates() {
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1;

    const prevMonthDate = new Date();
    prevMonthDate.setMonth(prevMonthDate.getMonth() - 1);
    const prevMonth = prevMonthDate.getMonth() + 1;

    if (pageTitle) {
      const originalTitleHTML = pageTitle.innerHTML;
      const newTitleHTML = originalTitleHTML.replace(
        /\d{2,4}년\s*\d{1,2}월|YYYY년\s*MM월/,
        `${currentYear}년 ${String(currentMonth).padStart(2, '0')}월`
      );
      pageTitle.innerHTML = newTitleHTML;
    }

    const subtitles = contentArea.querySelectorAll('.section-subtitle');
    subtitles.forEach(subtitle => {
      if (subtitle.textContent.includes('월말 집행비')) {
        subtitle.innerHTML = subtitle.innerHTML.replace(
          /\d{1,2}월말/,
          `${prevMonth}월말`
        );
      }
    });

    initializeMonthlyNavigator();
  }

  function showMessage(message, type = 'warning', duration = 3000) {
    const messageBox = document.getElementById('customMessageBox');
    if (!messageBox) return;
    messageBox.textContent = message;
    messageBox.className = 'custom-message-box';
    if (type === 'error') messageBox.classList.add('error');
    else if (type === 'success') messageBox.classList.add('success');
    messageBox.style.display = 'block';
    setTimeout(() => { messageBox.style.display = 'none'; }, duration);
  }

  function adjustContainerPadding() {
      const titleEl = pageTitle;
      const navigatorEl = document.getElementById('monthlyNavigatorContainer');
      const contentEl = contentArea;

      if (!titleEl || !navigatorEl || !contentEl || document.body.classList.contains('is-in-iframe')) return;

      requestAnimationFrame(() => {
          const titleHeight = titleEl.offsetHeight;
          const isNavVisible = getComputedStyle(navigatorEl).display !== 'none';
          
          let navigatorHeight = 0;
          if (isNavVisible) {
              navigatorEl.style.top = `${titleHeight}px`;

              if (navigatorEl.classList.contains('nav-collapsed')) {
                  const yearNavigator = document.getElementById('yearNavigator');
                  if (yearNavigator) {
                      const yearNavHeight = yearNavigator.offsetHeight;
                      navigatorHeight = yearNavHeight * 1.1; 
                  } else {
                      navigatorHeight = navigatorEl.offsetHeight;
                  }
              } else {
                  navigatorHeight = navigatorEl.offsetHeight;
              }
          }
          
          const totalHeaderHeight = titleHeight + navigatorHeight;
          contentEl.style.paddingTop = `${totalHeaderHeight + 20}px`;
      });
  }

  function startScreensaver() {
    if (isScreensaverPaused || isScreensaverActive) return;
    window.removeEventListener('scroll', resetIdleTimer, true);
    isScreensaverActive = true;
    
    const isFs = document.body.classList.contains('true-fullscreen-active');
    const scrollTarget = isFs ? appContainer : window;
    const scrollableElement = isFs ? appContainer : document.documentElement;
    scrollPositionBeforeScreensaver = scrollableElement.scrollTop;
    
    const navContainer = document.getElementById('monthlyNavigatorContainer');
    if (navContainer) {
        navContainer.style.display = 'none';
        adjustContainerPadding();
    }

    autoScrollInterval = setInterval(() => {
        if ((scrollableElement.clientHeight + scrollableElement.scrollTop + 2) >= scrollableElement.scrollHeight) {
            scrollTarget.scrollTo(0, 0);
        } else {
            scrollTarget.scrollBy(0, 1);
        }
    }, 50);
  }

  function stopScreensaver() {
    if (!isScreensaverActive) return;

    clearInterval(autoScrollInterval);
    autoScrollInterval = null;

    const navContainer = document.getElementById('monthlyNavigatorContainer');
    if (navContainer && monthlyNavigatorConfig.enabled) {
        navContainer.style.display = 'flex';
        requestAnimationFrame(adjustContainerPadding);
    }
    
    const isFs = document.body.classList.contains('true-fullscreen-active');
    const scrollTarget = isFs ? appContainer : window;
    scrollTarget.scrollTo(0, scrollPositionBeforeScreensaver);
    
    isScreensaverActive = false;
    window.addEventListener('scroll', resetIdleTimer, true);
  }

  function resetIdleTimer() {
    if (isScreensaverPaused) return;

    if (isScreensaverActive) {
        stopScreensaver();
    }
    
    clearTimeout(idleTimer);
    idleTimer = setTimeout(startScreensaver, IDLE_TIMEOUT);
  }

  function getFormattedDateForFilename() {
    const now = new Date();
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, '0');
    const day = now.getDate().toString().padStart(2, '0');
    return {
        yearYY: year.toString().slice(-2),
        monthMM: month,
        yearYYYY: year,
        dayDD: day,
    };
  }

  function showFutureMeetingBlocker() {
    const blocker = document.getElementById('futureMeetingBlocker');
    if (blocker) blocker.style.display = 'block';
    showMessage('해당 월의 회의는 아직 진행되지 않았습니다.', 'warning', 4000);
  }

  function hideFutureMeetingBlocker() {
    const blocker = document.getElementById('futureMeetingBlocker');
    if (blocker) blocker.style.display = 'none';
  }
  
  function isYearFullySkipped(year) {
    return year < 2014;
  }
  
  function toggleCompareMode(forceOff = false) {
    isCompareModeActive = forceOff ? false : !isCompareModeActive;
    
    document.body.classList.toggle('compare-mode-active', isCompareModeActive);
    compareModeToggleBtn.classList.toggle('active', isCompareModeActive);
    
    const tooltipTextOff = '문서 비교 모드 켜기';
    const tooltipTextOn = '문서 비교 모드 끄기\n(비교 불가능: PDF, 미작성/미래 월)';
    compareModeToggleBtn.title = isCompareModeActive ? tooltipTextOn : tooltipTextOff;

    if (isCompareModeActive) {
      showMessage('비교할 월들을 선택하세요. (2개 이상)', 'info');
    } else {
      monthsForComparison = [];
      document.querySelectorAll('.month-link.compare-selected').forEach(link => {
        link.classList.remove('compare-selected');
      });
      showMessage('문서 비교 모드가 비활성화되었습니다.', 'success');
    }
  }

  function handleCompareMonthSelect(event, linkElement, url) {
    event.preventDefault();
    if (!url || url.endsWith('#')) {
      showMessage('비교할 수 없는 월입니다 (미작성 또는 미래).', 'warning');
      return;
    }
    
    const index = monthsForComparison.indexOf(url);
    if (index > -1) {
      monthsForComparison.splice(index, 1);
      linkElement.classList.remove('compare-selected');
    } else {
      monthsForComparison.push(url);
      linkElement.classList.add('compare-selected');
    }
  }

  function executeComparison() {
    if (monthsForComparison.length < 2) {
      showMessage('비교하려면 문서를 2개 이상 선택해야 합니다.', 'error');
      return;
    }
    
    comparisonFrameContainer.innerHTML = '';
    monthsForComparison.forEach(url => {
      const itemWrapper = document.createElement('div');
      itemWrapper.className = 'comparison-item-wrapper';

      const iframe = document.createElement('iframe');
      iframe.src = url;

      const closeItemBtn = document.createElement('button');
      closeItemBtn.className = 'close-comparison-item-btn';
      closeItemBtn.innerHTML = '&times;';
      closeItemBtn.title = '이 창 닫기';
      
      closeItemBtn.addEventListener('click', (event) => {
          event.stopPropagation();

          const urlToRemove = itemWrapper.querySelector('iframe').src;
          
          monthsForComparison = monthsForComparison.filter(u => u !== urlToRemove);
          
          itemWrapper.remove();
          
          if (comparisonFrameContainer.children.length < 2) {
              closeComparisonView();
          }
      });

      itemWrapper.appendChild(iframe);
      itemWrapper.appendChild(closeItemBtn);
      comparisonFrameContainer.appendChild(itemWrapper);
    });

    comparisonViewOverlay.style.display = 'block';
    document.body.classList.add('comparison-view-active');
    document.body.style.overflow = 'hidden';
  }

  function closeComparisonView() {
    comparisonViewOverlay.style.display = 'none';
    comparisonFrameContainer.innerHTML = ''; 
    document.body.classList.remove('comparison-view-active');
    document.body.style.overflow = '';
  }

  function renderMonthlyNavigator() {
    const navContainer = document.getElementById('monthlyNavigatorContainer');
    const navContent = document.getElementById('monthlyNavigatorContent');
    if (!monthlyNavigatorConfig.enabled || !displayedYearInNav) {
        if(navContainer) navContainer.style.display = 'none';
        adjustContainerPadding();
        return;
    }

    navContent.innerHTML = '';

    const yearNavWrapper = document.createElement('div');
    yearNavWrapper.style.display = 'flex';
    yearNavWrapper.style.alignItems = 'center';
    yearNavWrapper.style.justifyContent = 'center';
    yearNavWrapper.style.width = '100%';

    const yearNav = document.createElement('div');
    yearNav.id = 'yearNavigator';
    const prevYearBtn = document.createElement('button');
    prevYearBtn.id = 'prevYearBtn';
    prevYearBtn.textContent = '<';
    prevYearBtn.title = '이전 연도';
    prevYearBtn.onclick = () => { displayedYearInNav--; renderMonthlyNavigator(); };
    const currentYearSpan = document.createElement('span');
    currentYearSpan.id = 'currentYearSpan';
    currentYearSpan.textContent = `${displayedYearInNav}년`;
    const nextYearBtn = document.createElement('button');
    nextYearBtn.id = 'nextYearBtn';
    nextYearBtn.textContent = '>';
    nextYearBtn.title = '다음 연도';
    nextYearBtn.onclick = () => { displayedYearInNav++; renderMonthlyNavigator(); };
    yearNav.appendChild(prevYearBtn);
    yearNav.appendChild(currentYearSpan);
    yearNav.appendChild(nextYearBtn);
    
    yearNavWrapper.appendChild(yearNav);

    const compareControls = document.createElement('div');
    compareControls.id = 'compareControlsContainer';
    compareControls.innerHTML = `
      <button id="executeCompareBtn" title="선택한 월들을 나란히 놓고 비교합니다.">선택 월 비교 실행</button>
      <button id="cancelCompareBtn" title="비교 모드를 취소하고 선택을 초기화합니다.">비교 모드 취소</button>
    `;
    yearNavWrapper.appendChild(compareControls);
    compareControls.querySelector('#executeCompareBtn').onclick = executeComparison;
    compareControls.querySelector('#cancelCompareBtn').onclick = () => toggleCompareMode(true);
    
    navContent.appendChild(yearNavWrapper);

    const monthLinksContainer = document.createElement('div');
    monthLinksContainer.id = 'monthLinksContainer';

    for (let i = 1; i <= 12; i++) {
        const monthLink = document.createElement('a');
        monthLink.className = 'month-link';
        monthLink.textContent = `${i}월`;

        const monthKey = `${displayedYearInNav}-${i}`;
        const isSkipped = isYearFullySkipped(displayedYearInNav) || monthlyNavigatorConfig.skippedMonths.includes(monthKey);
        
        let url = '#';
        let isPdf = false;

        if (isSkipped) {
            monthLink.classList.add('skipped');
            monthLink.title = `${i}월 (미작성 처리됨)`;
        } else if (displayedYearInNav === documentYear && i === documentMonth) {
            monthLink.classList.add('current');
            monthLink.title = '현재 화면의 내용'; 
            const template = monthlyNavigatorConfig.futureFilenameTemplate;
            const pathTemplate = template.replace(/{YYYY}/g, displayedYearInNav).replace(/{YY}/g, String(displayedYearInNav).slice(-2)).replace(/{MM}/g, String(i).padStart(2, '0')).replace(/{M}/g, i);
            url = monthlyNavigatorConfig.baseURL && !pathTemplate.startsWith('http') ? monthlyNavigatorConfig.baseURL + pathTemplate : pathTemplate;
        } else {
            const now = new Date();
            const currentMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const linkDate = new Date(displayedYearInNav, i - 1, 1);
            const isPast = linkDate < currentMonthStart;
            
            let pathTemplate = '';
            if (isPast) {
                const newRuleCutoffDate = new Date(2025, 5, 1);
                const template = (linkDate >= newRuleCutoffDate) ? monthlyNavigatorConfig.futureFilenameTemplate : monthlyNavigatorConfig.pastFilenameTemplate;
                isPdf = template.endsWith('.pdf');
                pathTemplate = template.replace(/{YYYY}/g, displayedYearInNav).replace(/{YY}/g, String(displayedYearInNav).slice(-2)).replace(/{MM}/g, String(i).padStart(2, '0')).replace(/{M}/g, i);
                monthLink.classList.add('past');
                monthLink.title = `${i}월 회의록 보기 (${isPdf ? 'PDF' : 'HTML'})`;
            } else {
                const isCurrentMonth = linkDate.getFullYear() === currentMonthStart.getFullYear() && linkDate.getMonth() === currentMonthStart.getMonth();
                if (isCurrentMonth) {
                  const template = monthlyNavigatorConfig.futureFilenameTemplate;
                  pathTemplate = template.replace(/{YYYY}/g, displayedYearInNav).replace(/{YY}/g, String(displayedYearInNav).slice(-2)).replace(/{MM}/g, String(i).padStart(2, '0')).replace(/{M}/g, i);
                  monthLink.classList.add('future');
                  monthLink.title = `${i}월 회의록 보기 (HTML)`;
                } else {
                  monthLink.classList.add('future');
                  monthLink.title = `${i}월 (회의 미진행)`;
                }
            }
            if (pathTemplate) {
              url = monthlyNavigatorConfig.baseURL && !pathTemplate.startsWith('http') ? monthlyNavigatorConfig.baseURL + pathTemplate : pathTemplate;
            }
        }
        
        monthLink.href = url;
        
        monthLink.onclick = (e) => {
          e.preventDefault(); 

          if (monthLink.classList.contains('current')) {
              if (!isCompareModeActive) {
                return; 
              }
          }

          if (isCompareModeActive) {
            if (isPdf || url === '#') {
              showMessage('비교할 수 없는 월입니다 (PDF, 미작성, 미래 월).', 'warning');
            } else {
              handleCompareMonthSelect(e, monthLink, url);
            }
          } else {
            if (url !== '#') {
                window.open(url, '_blank', 'noopener,noreferrer');
            } else { 
              if (monthLink.classList.contains('skipped')) {
                showMessage('미작성 처리된 월입니다.', 'warning');
              } else {
                showFutureMeetingBlocker();
              }
            }
          }
        };

        if (isCompareModeActive && monthsForComparison.includes(url)) {
            monthLink.classList.add('compare-selected');
        }

        monthLinksContainer.appendChild(monthLink);
    }
    navContent.appendChild(monthLinksContainer);

    navContainer.style.display = 'flex';
    setNavCollapsedState(monthlyNavigatorConfig.isNavCollapsed);
  }
  
  function setNavCollapsedState(isCollapsed) {
    const navContainer = document.getElementById('monthlyNavigatorContainer');
    const toggleBtn = document.getElementById('navToggleBtn');
    if (!navContainer || !toggleBtn) return;

    monthlyNavigatorConfig.isNavCollapsed = isCollapsed;
    navContainer.classList.toggle('nav-collapsed', isCollapsed);
    toggleBtn.textContent = isCollapsed ? '▼' : '▲';
    toggleBtn.title = isCollapsed ? '네비게이션 펴기' : '네비게이션 접기';
    
    adjustContainerPadding();
  }

    // --- START: 시각적 '미작성 월' 관리 기능 ---
    function renderSkippedMonthGrid(year) {
        const gridContainer = document.getElementById('skipped-month-grid');
        if (!gridContainer) return;
        
        gridContainer.innerHTML = '';

        for (let month = 1; month <= 12; month++) {
            const monthKey = `${year}-${month}`;
            const isSkipped = monthlyNavigatorConfig.skippedMonths.includes(monthKey);

            const button = document.createElement('button');
            button.type = 'button';
            button.className = `skipped-month-btn ${isSkipped ? 'is-skipped' : 'is-written'}`;
            button.textContent = `${month}월`;
            button.title = `${month}월 상태 변경: ${isSkipped ? '작성됨으로' : '미작성으로'}`;
            button.dataset.month = month;

            button.addEventListener('click', () => {
                toggleSkippedMonth(year, month);
            });

            gridContainer.appendChild(button);
        }
    }

    function toggleSkippedMonth(year, month) {
        const monthKey = `${year}-${month}`;
        const index = monthlyNavigatorConfig.skippedMonths.indexOf(monthKey);

        if (index > -1) {
            monthlyNavigatorConfig.skippedMonths.splice(index, 1);
        } else {
            monthlyNavigatorConfig.skippedMonths.push(monthKey);
            monthlyNavigatorConfig.skippedMonths.sort(); 
        }

        // UI 즉시 업데이트
        renderSkippedMonthGrid(year);
        renderMonthlyNavigator(); // 상단 네비게이션도 즉시 반영
    }

    function initializeSkippedMonthControls() {
        const yearSelect = document.getElementById('skipped-year-selector');
        if (!yearSelect) return;
        
        yearSelect.innerHTML = '';
        const currentDocYear = documentYear || new Date().getFullYear();
        
        for (let y = 2010; y <= currentDocYear + 3; y++) {
            const option = document.createElement('option');
            option.value = y;
            option.textContent = `${y}년`;
            yearSelect.appendChild(option);
        }
        
        yearSelect.value = documentYear || new Date().getFullYear();
        
        if (yearSelect.dataset.listenerAttached !== 'true') {
            yearSelect.addEventListener('change', (e) => {
                renderSkippedMonthGrid(parseInt(e.target.value, 10));
            });
            yearSelect.dataset.listenerAttached = 'true';
        }

        // 초기 그리드 렌더링
        renderSkippedMonthGrid(parseInt(yearSelect.value, 10));
    }
    // --- END: 시각적 '미작성 월' 관리 기능 ---

  function initializeMonthlyNavigator() {
    const navContainer = document.getElementById('monthlyNavigatorContainer');
    if (!navContainer) {
        console.error("네비게이션 컨테이너(#monthlyNavigatorContainer)를 찾을 수 없습니다.");
        return;
    }
    
    const navToggleBtn = document.getElementById('navToggleBtn');
    if(navToggleBtn && navToggleBtn.dataset.listenerAttached !== 'true') {
        navToggleBtn.addEventListener('click', () => {
            setNavCollapsedState(!monthlyNavigatorConfig.isNavCollapsed);
        });
        navToggleBtn.dataset.listenerAttached = 'true';
    }

    const urlTemplateInput = document.getElementById('monthlyNavUrlTemplate');
    const applyUrlBtn = document.getElementById('applyMonthlyNavUrlBtn');
    const removeUrlBtn = document.getElementById('removeMonthlyNavUrlBtn');

    if (urlTemplateInput) urlTemplateInput.value = monthlyNavigatorConfig.futureFilenameTemplate;
    
    if (applyUrlBtn && applyUrlBtn.dataset.listenerAttached !== 'true') {
      applyUrlBtn.addEventListener('click', () => {
          const newTemplate = urlTemplateInput.value.trim();
          if (newTemplate) {
              monthlyNavigatorConfig.enabled = true;
              if (newTemplate.startsWith('http://') || newTemplate.startsWith('https://')) {
                  monthlyNavigatorConfig.baseURL = '';
                  monthlyNavigatorConfig.futureFilenameTemplate = newTemplate;
                   showMessage('전체 URL 템플릿이 적용되었습니다.', 'success');
              } else {
                   monthlyNavigatorConfig.baseURL = 'https://jonggunelee.github.io/wyggkr/';
                   monthlyNavigatorConfig.futureFilenameTemplate = newTemplate;
                   showMessage('URL 경로 템플릿이 적용되었습니다.', 'success');
              }
              renderMonthlyNavigator();
          } else {
              showMessage('URL 템플릿을 입력하세요.', 'error');
          }
      });
      applyUrlBtn.dataset.listenerAttached = 'true';
    }
    
    if (removeUrlBtn && removeUrlBtn.dataset.listenerAttached !== 'true') {
      removeUrlBtn.addEventListener('click', () => {
          monthlyNavigatorConfig.enabled = false;
          showMessage('월별 네비게이션이 비활성화되었습니다.', 'success');
          renderMonthlyNavigator();
      });
      removeUrlBtn.dataset.listenerAttached = 'true';
    }

    const titleText = pageTitle.textContent || '';
    const match = titleText.match(/(\d{2,4})년\s*(\d{1,2})월/);

    if (!match) {
        console.warn("페이지 제목에서 연도와 월을 찾을 수 없어 네비게이션을 생성할 수 없습니다.");
        monthlyNavigatorConfig.enabled = false;
        documentYear = null;
        documentMonth = null;
        displayedYearInNav = new Date().getFullYear();
    } else {
        let year = parseInt(match[1], 10);
        if (year < 100) {
            year += 2000; 
        }
        documentYear = year;
        documentMonth = parseInt(match[2], 10);
        displayedYearInNav = documentYear;
    }

    renderMonthlyNavigator();
  }
  
  function populateInitialSkippedMonths(docYear) {
      monthlyNavigatorConfig.skippedMonths = [];
      const startYear = 2014;
      for (let y = startYear; y < docYear; y++) {
          for (let m = 1; m <= 12; m++) {
              monthlyNavigatorConfig.skippedMonths.push(`${y}-${m}`);
          }
      }
  }

  function toggleActionItemStatus(statusElement) {
    const actionItem = statusElement.closest('.action-item');
    if (!actionItem) return;

    const currentStatus = actionItem.dataset.status || 'todo';
    let nextStatus;
    let nextIcon;
    let nextTitle;

    if (currentStatus === 'todo') {
      nextStatus = 'doing';
      nextIcon = '»';
      nextTitle = '상태 변경 (진행중)';
    } else if (currentStatus === 'doing') {
      nextStatus = 'done';
      nextIcon = '✔';
      nextTitle = '상태 변경 (완료)';
    } else {
      nextStatus = 'todo';
      nextIcon = '►';
      nextTitle = '상태 변경 (미완료)';
    }

    actionItem.dataset.status = nextStatus;
    statusElement.textContent = nextIcon;
    statusElement.title = nextTitle;
  }

  function toggleKeyDecision() {
    const selection = window.getSelection();
    if (!selection.rangeCount || selection.isCollapsed) {
        showMessage('강조할 텍스트를 먼저 선택해주세요.', 'warning');
        return;
    }

    const range = selection.getRangeAt(0);
    const parentElement = range.commonAncestorContainer.nodeType === 1 
      ? range.commonAncestorContainer 
      : range.commonAncestorContainer.parentElement;

    const existingWrapper = parentElement.closest('.key-decision');
    if (existingWrapper) {
        const fragment = document.createDocumentFragment();
        while (existingWrapper.firstChild) {
            fragment.appendChild(existingWrapper.firstChild);
        }
        existingWrapper.parentNode.replaceChild(fragment, existingWrapper);
        return;
    }
    
    const wrapper = document.createElement('span');
    wrapper.className = 'key-decision';
    try {
      wrapper.appendChild(range.extractContents());
      range.insertNode(wrapper);
      selection.removeAllRanges();
      selection.addRange(range);
    } catch (e) {
      console.error("Could not wrap selection:", e);
      document.execCommand('insertHTML', false, `<span class="key-decision">${selection.toString()}</span>`);
      showMessage("결정사항으로 강조되었습니다.", 'success', 1500);
    }
  }
  
  function insertElementAfterSelection(elementToInsert) {
    let targetElement = currentlyActiveItemControlsElement || 
                        (elementsForMultiZoom.length > 0 ? elementsForMultiZoom[elementsForMultiZoom.length-1] : null);

    if (targetElement) {
        targetElement.parentNode.insertBefore(elementToInsert, targetElement.nextSibling);
    } else {
        const sections = contentArea.querySelectorAll('.section');
        const lastSection = sections[sections.length - 1] || contentArea;
        lastSection.appendChild(elementToInsert);
    }

    generateItemControls(elementToInsert);
    activateControls(elementToInsert, true);
  }

  function addOrUpdateActionItem() {
      const template = document.querySelector('.common-item-template .action-item');
      if (!template) {
        showMessage('액션 아이템 템플릿을 찾을 수 없습니다!', 'error');
        return;
      }
      
      const newItem = template.cloneNode(true);
      insertElementAfterSelection(newItem);
      showMessage('새로운 액션 아이템이 추가되었습니다.', 'success');
  }

  function addPollWidget() {
    const targetElement = currentlyActiveItemControlsElement;
    if (!targetElement || !(targetElement.classList.contains('item') || targetElement.classList.contains('box'))) {
      showMessage('의견 투표를 추가할 항목(.item 또는 .box)을 먼저 선택해주세요.', 'warning');
      return;
    }

    if (targetElement.querySelector('.poll-widget')) {
      showMessage('이미 투표 위젯이 있습니다.', 'warning');
      return;
    }

    const pollWidget = document.createElement('div');
    pollWidget.className = 'poll-widget no-print';
    pollWidget.setAttribute('contenteditable', 'false');
    pollWidget.innerHTML = `
      <button class="poll-btn" data-vote="like" title="찬성">👍 <span class="poll-count">0</span></button>
      <button class="poll-btn" data-vote="dislike" title="반대">👎 <span class="poll-count">0</span></button>
      <button class="poll-btn" data-vote="think" title="보류/생각">🤔 <span class="poll-count">0</span></button>
    `;

    targetElement.appendChild(pollWidget);
    showMessage('의견 투표 위젯이 추가되었습니다.', 'success');
  }

  function initializeHeaderInfoDisplay() {
      if (!meetingStartTime) {
          meetingStartTime = new Date();
      }

      clockInterval = setInterval(updateHeaderInfo, 1000);
      updateHeaderInfo();
      
      renderCalendar();
  }
  
  function updateHeaderInfo() {
      const now = new Date();
      
      const elapsedMs = now - meetingStartTime;
      const elapsedSeconds = Math.floor(elapsedMs / 1000);
      const hours = Math.floor(elapsedSeconds / 3600);
      const minutes = Math.floor((elapsedSeconds % 3600) / 60);
      const timerStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
      document.getElementById('info-timer').textContent = timerStr;

      let currentHours = now.getHours();
      const ampm = currentHours >= 12 ? 'PM' : 'AM';
      currentHours = currentHours % 12;
      currentHours = currentHours ? currentHours : 12;
      const currentMinutes = String(now.getMinutes()).padStart(2, '0');
      const timeStr = `${ampm} ${String(currentHours).padStart(2, '0')}:${currentMinutes}`;
      document.getElementById('info-time').textContent = timeStr;
      
      const year = String(now.getFullYear()).slice(-2);
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      document.getElementById('info-date').textContent = dateStr;
  }

  function renderCalendar() {
      const calendarContainer = document.getElementById('calendar-container');
      const monthYearEl = document.getElementById('calendar-month-year');
      const daysEl = document.getElementById('calendar-days');
      if (!calendarContainer || !monthYearEl || !daysEl) return;
      
      daysEl.innerHTML = '';
      const year = calendarDate.getFullYear();
      const month = calendarDate.getMonth();
      
      monthYearEl.textContent = `${year}년 ${month + 1}월`;
      
      const firstDayOfMonth = new Date(year, month, 1).getDay();
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      
      const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
      dayNames.forEach(name => {
          const dayNameDiv = document.createElement('div');
          dayNameDiv.className = 'day-name';
          dayNameDiv.textContent = name;
          daysEl.appendChild(dayNameDiv);
      });
      
      for (let i = 0; i < firstDayOfMonth; i++) {
          daysEl.appendChild(document.createElement('div'));
      }
      
      for (let i = 1; i <= daysInMonth; i++) {
          const dayCell = document.createElement('div');
          dayCell.className = 'day-cell';
          dayCell.textContent = i;
          
          const today = new Date();
          if (i === today.getDate() && year === today.getFullYear() && month === today.getMonth()) {
              dayCell.classList.add('today');
          }
          
          daysEl.appendChild(dayCell);
      }
  }

  function toggleCalendar(event) {
      event.stopPropagation();
      const calendarContainer = document.getElementById('calendar-container');
      const isVisible = calendarContainer.style.display === 'block';
      calendarContainer.style.display = isVisible ? 'none' : 'block';
  }
  
  function handleCalendarNavigation(direction) {
      calendarDate.setMonth(calendarDate.getMonth() + direction);
      renderCalendar();
  }

  function toggleTrueFullscreen() {
    try {
        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
            let requestPromise;
            if (appContainer.requestFullscreen) {
                requestPromise = appContainer.requestFullscreen();
            } else if (appContainer.webkitRequestFullscreen) {
                requestPromise = appContainer.webkitRequestFullscreen();
            } else if (appContainer.mozRequestFullScreen) {
                requestPromise = appContainer.mozRequestFullScreen();
            } else if (appContainer.msRequestFullscreen) {
                requestPromise = appContainer.msRequestFullscreen();
            }

            if (requestPromise) {
                requestPromise.catch(err => {
                    console.error(`Fullscreen request error: ${err.message} (${err.name})`);
                    showMessage("전체 화면 모드를 시작할 수 없습니다. 브라우저 권한을 확인해주세요.", "error");
                });
            }
        } else {
            let exitPromise;
            if (document.exitFullscreen) {
                exitPromise = document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                exitPromise = document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                exitPromise = document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                exitPromise = document.msExitFullscreen();
            }
            
            if (exitPromise) {
                exitPromise.catch(err => {
                    console.error(`Exit fullscreen error: ${err.message} (${err.name})`);
                });
            }
        }
    } catch (e) {
        console.error("A synchronous error occurred when trying to toggle fullscreen:", e);
        showMessage("전체 화면 기능에 접근할 수 없습니다.", "error");
    }
}

function exitTrueFullscreen() {
    try {
        let exitPromise;
        if (document.exitFullscreen) {
            exitPromise = document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            exitPromise = document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            exitPromise = document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            exitPromise = document.msExitFullscreen();
        }
        
        if (exitPromise) {
            exitPromise.catch(err => {
                console.error(`Exit fullscreen error: ${err.message} (${err.name})`);
            });
        }
    } catch (e) {
        console.error("A synchronous error occurred when trying to exit fullscreen:", e);
    }
}

  function fullscreenChangeHandler() {
    const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
    const isSelectionZoomActive = document.body.classList.contains('selection-zoom-active');
    document.body.classList.toggle('true-fullscreen-active', isFs || isSelectionZoomActive);

    if (!isFs && isScreensaverActive) {
        stopScreensaver();
    }

    if (multiZoomTriggerBtn) {
        multiZoomTriggerBtn.style.display = (isFs && elementsForMultiZoom.length > 0 && !isSelectionZoomActive) ? 'block' : 'none';
    }
    
    if (isSelectionZoomActive) {
        [floatingMenuToggleBtn, trueFullscreenBtn, multiZoomTriggerBtn, annotationDisplayToggleBtn, annotationSettingsToggleBtn, memoAnnotationToggleBtn, annotationSettingsPanel, compareModeToggleBtn].forEach(el => {
            if(el) el.style.display = 'none';
        });
        return;
    }

    if (floatingMenuToggleBtn) floatingMenuToggleBtn.style.display = isFs ? 'none' : 'block';
    if (trueFullscreenBtn) {
        trueFullscreenBtn.style.display = isFs ? 'none' : 'block';
        trueFullscreenBtn.innerHTML = isFs ? '나가기' : '⛶';
        trueFullscreenBtn.title = isFs ? "전체 화면 나가기" : "전체 화면 보기";
    }
    if (exitTrueFullscreenBtnActual) exitTrueFullscreenBtnActual.style.display = isFs ? 'block' : 'none';


    if (isFs) {
        annotationDisplayToggleBtn.style.display = 'block';
        annotationSettingsToggleBtn.style.display = 'block';
        memoAnnotationToggleBtn.style.display = 'block';

        if (isDrawingFeatureActive) {
            annotationDisplayToggleBtn.classList.add('active');
            annotationCanvas.style.display = 'block';
            annotationCanvas.style.pointerEvents = 'auto';
            annotationSettingsPanel.style.display = isAnnotationPanelOpen ? 'flex' : 'none';
            annotationSettingsToggleBtn.classList.toggle('active', isAnnotationPanelOpen);
            if (isAnnotationPanelOpen) loadPanelUIWithSettings(panelUISettings);
        } else {
            annotationDisplayToggleBtn.classList.remove('active');
            annotationCanvas.style.display = keepDrawingsVisibleOnDeactivate ? 'block' : 'none';
            annotationCanvas.style.pointerEvents = 'none';
            annotationSettingsPanel.style.display = 'none';
            annotationSettingsToggleBtn.classList.remove('active');
            isAnnotationPanelOpen = false;
        }
    } else {
        annotationDisplayToggleBtn.style.display = 'none';
        annotationSettingsToggleBtn.style.display = 'none';
        memoAnnotationToggleBtn.style.display = 'none';
        annotationSettingsPanel.style.display = 'none';
        isAnnotationPanelOpen = false;

        if (annotationCanvas) {
            annotationCanvas.style.pointerEvents = 'none';
            annotationCanvas.style.display = (isDrawingFeatureActive || keepDrawingsVisibleOnDeactivate) && drawnStrokes.length > 0 ? 'block' : 'none';
        }
    }

    adjustContainerPadding();
    updateAnnotationDisplayToggleBtnStyle();
    setupAnnotationCanvas();
  }

  function togglePanel() {
    const isPanelCurrentlyOpen = menuPanel.style.display === "flex";
    menuPanel.style.display = isPanelCurrentlyOpen ? "none" : "flex";

    if (isPanelCurrentlyOpen) {
        floatingMenuToggleBtn.innerHTML = '☰';
        floatingMenuToggleBtn.title = "메뉴 열기";
    } else {
        floatingMenuToggleBtn.innerHTML = '✕';
        floatingMenuToggleBtn.title = "메뉴 닫기";
        applyPanelState();

        if(menuAnnoKeepDrawingsVisible) menuAnnoKeepDrawingsVisible.checked = keepDrawingsVisibleOnDeactivate;
        if(menuAnnoDrawingToggle) menuAnnoDrawingToggle.classList.toggle('active', isDrawingFeatureActive);
        if(menuAnnoSettingsPanelToggle) menuAnnoSettingsPanelToggle.classList.toggle('active', isAnnotationPanelOpen && isDrawingFeatureActive);
        if(menuMemoAnnotationBtn) menuMemoAnnotationBtn.classList.toggle('active', isMemoModeActive && document.body.classList.contains('true-fullscreen-active'));
        
        initializeSkippedMonthControls();
        updateAllFormattingUIs();
    }
  }

  function handleCloseMenuPanel() {
    menuPanel.style.display = "none";
    floatingMenuToggleBtn.innerHTML = '☰';
    floatingMenuToggleBtn.title = "메뉴 열기";
  }
  
  function handlePanelDragStart(e) {
      if (e.target.closest('.resize-handle, button, input, select, .floating-panel-close-btn, .checkbox-label, .emoji-dropdown-content, .emoji-btn, #elementInspectorOutput, .tab-btn')) return;
      isDraggingPanel = true;
      menuPanel.classList.add('dragging');
      panelOffsetX = e.clientX - menuPanel.getBoundingClientRect().left;
      panelOffsetY = e.clientY - menuPanel.getBoundingClientRect().top;
      if (!menuPanel.style.left || !menuPanel.style.top) {
        const rect = menuPanel.getBoundingClientRect();
        menuPanel.style.left = `${rect.left}px`; menuPanel.style.top = `${rect.top}px`;
        menuPanel.style.right = 'auto'; menuPanel.style.bottom = 'auto';
      }
  }

  function handlePanelDragMove(e) {
    if (!isDraggingPanel) return;
    e.preventDefault();
    let newX = e.clientX - panelOffsetX;
    let newY = e.clientY - panelOffsetY;
    const panelRect = menuPanel.getBoundingClientRect();
    newX = Math.max(0, Math.min(newX, window.innerWidth - panelRect.width));
    newY = Math.max(0, Math.min(newY, window.innerHeight - panelRect.height));
    menuPanel.style.left = `${newX}px`;
    menuPanel.style.top = `${newY}px`;
  }

  function handlePanelDragEnd() {
    if (isDraggingPanel) {
      isDraggingPanel = false;
      menuPanel.classList.remove('dragging');
      const finalRect = menuPanel.getBoundingClientRect();
      panelState.x = finalRect.left;
      panelState.y = finalRect.top;
    }
  }

  function triggerZoomOnElement(zoomTarget) {
    if (!zoomTarget || !appContainer.contains(zoomTarget) || selectionZoomOverlay.style.display === 'block') return;
    const activeEl = document.activeElement;
    if (activeEl && activeEl !== zoomTarget && appContainer.contains(activeEl) && ['INPUT', 'TEXTAREA', 'SELECT'].includes(activeEl.tagName)) return;
    if (window.getSelection().toString().length > 0 && activeEl === zoomTarget && zoomTarget.isContentEditable) return;

    const clone = zoomTarget.cloneNode(true);
    clone.querySelectorAll('.item-controls, .resize-handle-img').forEach(ctrl => ctrl.remove());
    clone.classList.remove('controls-active', 'multi-zoom-selected', 'active');
    Object.assign(clone.style, { transform: 'none', cursor: 'auto' });

    selectionZoomContent.innerHTML = '';
    selectionZoomContent.appendChild(clone);
    selectionZoomOverlay.style.display = 'block';
    document.body.classList.add('selection-zoom-active');
    document.body.style.overflow = 'hidden';
    fullscreenChangeHandler();
  }

  function displayMultiZoom(elementsToZoom) {
    if (!elementsToZoom || elementsToZoom.length === 0 || selectionZoomOverlay.style.display === 'block') return;
    selectionZoomContent.innerHTML = '';

    let isOriginalLayoutFlex = false;
    let originalParentFlexProperties = { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px' };

    if (elementsToZoom.length > 0 && elementsToZoom[0].parentElement) {
        const parentStyle = getComputedStyle(elementsToZoom[0].parentElement);
        if (parentStyle.display.includes('flex')) {
            isOriginalLayoutFlex = true;
            Object.assign(originalParentFlexProperties, {
                display: parentStyle.display, flexDirection: parentStyle.flexDirection, flexWrap: parentStyle.flexWrap,
                justifyContent: parentStyle.justifyContent, alignItems: parentStyle.alignItems,
                gap: parentStyle.gap === 'normal' ? '10px' : parentStyle.gap
            });
        }
    }
    Object.assign(selectionZoomContent.style, originalParentFlexProperties);

    elementsToZoom.forEach(originalEl => {
        const clone = originalEl.cloneNode(true);
        clone.querySelectorAll('.item-controls, .resize-handle-img').forEach(ctrl => ctrl.remove());
        clone.classList.remove('controls-active', 'multi-zoom-selected', 'active');
        Object.assign(clone.style, { transform: 'none', cursor: 'auto' });
        
        const originalStyle = getComputedStyle(originalEl);
        if (isOriginalLayoutFlex) clone.style.margin = '';
        else Object.assign(clone.style, { marginTop: '0', marginLeft: 'auto', marginRight: 'auto', marginBottom: '15px' });
        
        selectionZoomContent.appendChild(clone);
    });
    if (!isOriginalLayoutFlex && selectionZoomContent.lastChild) selectionZoomContent.lastChild.style.marginBottom = '0';

    selectionZoomOverlay.style.display = 'block';
    document.body.classList.add('selection-zoom-active');
    document.body.style.overflow = 'hidden';
    fullscreenChangeHandler();
  }

  function closeSelectionZoom() {
    selectionZoomOverlay.style.display = 'none';
    selectionZoomContent.innerHTML = '';
    document.body.classList.remove('selection-zoom-active');
    document.body.style.overflow = '';
    fullscreenChangeHandler();
  }
  
  function handleSelectionZoomOverlayClick(event) {
    if (event.target === selectionZoomOverlay || event.target.closest('.close-selection-zoom-btn')) closeSelectionZoom();
  }


  function handleMultiZoomTrigger() {
    if (elementsForMultiZoom.length > 0) {
        elementsForMultiZoom.length === 1 ? triggerZoomOnElement(elementsForMultiZoom[0]) : displayMultiZoom([...elementsForMultiZoom]);
    }
  }

  function activateControls(elementToActivate, focusAndSelect = false) {
      if (currentlyActiveItemControlsElement && currentlyActiveItemControlsElement !== elementToActivate) {
          currentlyActiveItemControlsElement.classList.remove('controls-active');
      }
      if (elementToActivate) {
          elementToActivate.classList.add('controls-active');
          currentlyActiveItemControlsElement = elementToActivate;
          if (focusAndSelect && elementToActivate.dataset.editableType !== 'page-title') {
              setTimeout(() => {
                  elementToActivate.focus();
                  if (typeof elementToActivate.select === 'function') {
                      elementToActivate.select();
                  } else if (elementToActivate.isContentEditable) {
                      const selection = window.getSelection(), range = document.createRange();
                      if (elementToActivate.firstChild) {
                          range.selectNodeContents(elementToActivate);
                      } else {
                          range.setStart(elementToActivate, 0);
                          range.collapse(true);
                      }
                      try { selection.removeAllRanges(); selection.addRange(range); } catch(e) { console.warn("Could not set selection:", e); }
                  }
              }, 0);
          }
      } else if (currentlyActiveItemControlsElement) {
          currentlyActiveItemControlsElement.classList.remove('controls-active');
          currentlyActiveItemControlsElement = null;
      }
  }

  function generateItemControls(element) {
    if (element.querySelector(':scope > .item-controls')) return;
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'item-controls';

    if (element.classList.contains('resizable-image-wrapper')) {
        const imageButtons = [
            { icon: '↪️', title: '회전', action: 'rotate-right' },
            { icon: '↔️', title: '좌우 대칭', action: 'flip-h' },
            { icon: '↕️', title: '상하 대칭', action: 'flip-v' },
            { icon: '💬', title: '주석 추가', action: 'annotate' },
            { icon: '✂️', title: '자르기', action: 'crop' },
            { icon: '✨', title: '초기화', action: 'reset' },
        ];
        imageButtons.forEach(item => {
            const btn = document.createElement('button');
            btn.className = 'item-control-btn image-edit-btn';
            btn.innerHTML = item.icon;
            btn.title = item.title;
            btn.dataset.action = item.action;
            controlsDiv.appendChild(btn);
        });
        const separator = document.createElement('span');
        separator.style.borderLeft = '1px solid #999';
        separator.style.margin = '0 3px';
        controlsDiv.appendChild(separator);
    }

    if (element.dataset.editableType !== 'button-text-label' && element.dataset.editableType !== 'page-title') {
        const addBtn = document.createElement('button');
        addBtn.className = 'item-control-btn item-control-clone-btn';
        addBtn.innerHTML = '➕'; addBtn.title = '항목 복제';
        controlsDiv.appendChild(addBtn);
    }
    
    if (element.dataset.editableType !== 'page-title') {
        const delBtn = document.createElement('button');
        delBtn.className = 'item-control-btn item-control-delete-btn';
        delBtn.innerHTML = '🗑️'; delBtn.title = '삭제';
        controlsDiv.appendChild(delBtn);
    }

    if (controlsDiv.children.length > 0 && !element.querySelector(':scope > .item-controls')) {
        element.appendChild(controlsDiv);
    }
  }

  function cloneAndInsertElement(sourceElement) {
    let newItem = sourceElement.cloneNode(true);
    newItem.removeAttribute('id');
    newItem.querySelectorAll('.item-controls').forEach(ctrl => ctrl.remove());
    newItem.classList.remove('controls-active', 'multi-zoom-selected', 'active');
    // Ensure cloned image has new unique ID for its wrapper
    if (newItem.classList.contains('resizable-image-wrapper')) {
        newItem.dataset.imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }


    const computedStyle = getComputedStyle(sourceElement);
    for (let i = 0; i < computedStyle.length; i++) {
        const propName = computedStyle[i];
        const styleBlacklist = ['position','top','right','left','bottom','z-index','display','visibility','opacity','transform','margin','margin-top','margin-right','margin-bottom','margin-left','outline','outline-color','outline-style','outline-width','outline-offset','box-shadow', 'transition', 'cursor'];
        if (!styleBlacklist.includes(propName)) {
            try { newItem.style.setProperty(computedStyle[i], computedStyle.getPropertyValue(computedStyle[i]), computedStyle.getPropertyPriority(computedStyle[i])); } catch (e) {}
        }
    }
    if (computedStyle.display.includes('block') || computedStyle.display.includes('flex') || computedStyle.display.includes('grid')) newItem.style.display = computedStyle.display;
    else if (sourceElement.tagName === 'SPAN' && (computedStyle.display === 'inline' || !computedStyle.display) ) newItem.style.display = 'inline-block';
    else newItem.style.display = computedStyle.display || 'block';

    if (computedStyle.width !== 'auto' && computedStyle.width !== '0px') newItem.style.width = computedStyle.width;
    if (computedStyle.height !== 'auto' && computedStyle.height !== '0px') newItem.style.height = computedStyle.height;


    sourceElement.parentNode.insertBefore(newItem, sourceElement.nextSibling);
    generateItemControls(newItem);
    newItem.querySelectorAll('[data-editable-type]').forEach(desc => generateItemControls(desc));
    
    if (newItem.classList.contains('resizable-image-wrapper')) {
        ensureImageWrapperStructure(newItem);
        makeImageDraggable(newItem);
       generateItemControls(newItem);
   }
   
   // 내부에 포함된 이미지들도 초기화 보장
   newItem.querySelectorAll('.resizable-image-wrapper').forEach(w => {
       ensureImageWrapperStructure(w);
       makeImageDraggable(w);
       generateItemControls(w);
   });
    

    if (newItem.classList.contains('insert-area')) addCollapseToggle(newItem);
    if (newItem.classList.contains('box')) addBoxCollapseToggle(newItem);
    newItem.querySelectorAll('.insert-area').forEach(addCollapseToggle);
    newItem.querySelectorAll('.box').forEach(addBoxCollapseToggle);

    activateControls(newItem, true);
    showMessage('항목이 복제되었습니다.', 'success');
  }

  function toggleMultiZoomSelection(element) {
    const index = elementsForMultiZoom.indexOf(element);
    if (index > -1) { elementsForMultiZoom.splice(index, 1); element.classList.remove('multi-zoom-selected'); }
    else { elementsForMultiZoom.push(element); element.classList.add('multi-zoom-selected'); }
    updateMultiZoomTriggerVisibility();
  }

  function updateMultiZoomTriggerVisibility() {
    if (multiZoomTriggerBtn) {
        const isSelectionZoomActive = document.body.classList.contains('selection-zoom-active');
        const shouldBeVisible = elementsForMultiZoom.length >= 1 && document.body.classList.contains('true-fullscreen-active') && !isSelectionZoomActive;
        multiZoomTriggerBtn.style.display = shouldBeVisible ? 'block' : 'none';
    }
  }
  function clearMultiZoomSelectionVisuals() {
    elementsForMultiZoom.forEach(e => e.classList.remove('multi-zoom-selected'));
    updateMultiZoomTriggerVisibility();
  }

  function handleAppContainerClick(event) {
    const target = event.target;

    hideFutureMeetingBlocker(); 

    // --- START: 이미지 관련 클릭 핸들러 (주간 코드에서 이식) ---
    const clickedImageWrapper = target.closest('.resizable-image-wrapper');
    const activeImageWrapper = document.querySelector('.resizable-image-wrapper.active');
    
    if (clickedImageWrapper) {
        event.stopPropagation();
        if (clickedImageWrapper.classList.contains('is-dragging')) return;

        if (clickedImageWrapper !== activeImageWrapper) {
            if (activeImageWrapper) activeImageWrapper.classList.remove('active');
            clickedImageWrapper.classList.add('active');
            currentlyActiveItemControlsElement = clickedImageWrapper;
        }
        
        if (target.classList.contains('resize-handle-img')) return;

        if ((event.ctrlKey || event.metaKey) && target.tagName === 'IMG') {
            openImageZoom(target.src);
            return;
        }
          // 이미지 클릭 시 활성화 보장 및 다른 요소와의 충돌 방지
   // event.preventDefault(); // This can prevent text selection in annotations
   event.stopPropagation();
   // return; // This prevents clicks on controls from working

    } else {
        if (activeImageWrapper && !target.closest('.item-controls')) {
            activeImageWrapper.classList.remove('active');
            if (currentlyActiveItemControlsElement === activeImageWrapper) {
                currentlyActiveItemControlsElement = null;
            }
        }
    }
    // --- END: 이미지 관련 클릭 핸들러 (주간 코드에서 이식) ---


    if (target.closest('.floating-menu-icon, .fullscreen-btn-class, #multiZoomTriggerBtn, #annotationDisplayToggleBtn, #annotationSettingsToggleBtn, #memoAnnotationToggleBtn, .exit-true-fullscreen-btn, #compareModeToggleBtn')) {
        return;
    }

    const insertAreaToggleBtn = target.closest('.insert-area-toggle-btn');
    if (insertAreaToggleBtn) {
        event.stopPropagation(); event.preventDefault();
        const area = insertAreaToggleBtn.closest('.insert-area');
        if(area) {
            const isCollapsing = !area.classList.contains('collapsed');
            area.classList.toggle('collapsed', isCollapsing);
            insertAreaToggleBtn.textContent = isCollapsing ? '▼' : '▲';
            area.dataset.collapsed = isCollapsing ? 'true' : 'false';
        }
        return;
    }
    const boxToggleBtn = target.closest('.box-toggle-btn');
    if (boxToggleBtn) {
        event.stopPropagation(); event.preventDefault();
        const box = boxToggleBtn.closest('.box');
        if(box) {
            const isCollapsing = !box.classList.contains('box-collapsed');
            box.classList.toggle('box-collapsed', isCollapsing);
            boxToggleBtn.textContent = isCollapsing ? '▶' : '▼';
            box.dataset.boxCollapsed = isCollapsing ? 'true' : 'false';
        }
        return;
    }

    const statusButton = target.closest('.action-item-status');
    if (statusButton) {
      event.preventDefault();
      event.stopPropagation();
      toggleActionItemStatus(statusButton);
      return;
    }
    
    const deleteActionButton = target.closest('.action-item-delete-btn');
    if(deleteActionButton) {
        event.preventDefault();
        event.stopPropagation();
        const actionItem = deleteActionButton.closest('.action-item');
        if(actionItem) {
            actionItem.remove();
            showMessage('액션 아이템이 삭제되었습니다.', 'success');
        }
        return;
    }

    const pollButton = target.closest('.poll-btn');
    if (pollButton) {
        event.preventDefault();
        event.stopPropagation();
        const countSpan = pollButton.querySelector('.poll-count');
        if (countSpan) {
            let currentCount = parseInt(countSpan.textContent, 10) || 0;
            countSpan.textContent = currentCount + 1;
        }
        return;
    }

    const controlButton = target.closest('.item-control-btn');
    if (controlButton) {
        event.stopPropagation();
        const element = controlButton.closest('[data-editable-type], .resizable-image-wrapper');
        if (!element) return;

        if (controlButton.classList.contains('image-edit-btn')) {
            handleImageAction(element, controlButton.dataset.action);
        } else if (controlButton.classList.contains('item-control-clone-btn')) {
            cloneAndInsertElement(element);
        } else if (controlButton.classList.contains('item-control-delete-btn')) {
            const itemText = (element.textContent.substring(0,20) || "이 항목").trim();
            if (element.dataset.editableType === 'button-text-label' && element.parentElement?.classList.contains('add-sub-insert-area-btn')) {
                element.parentElement.remove();
            } else {
                element.remove();
            }
            showMessage(`'${itemText}...' 항목 삭제됨.`, 'success');
            if (currentlyActiveItemControlsElement === element) activateControls(null);
            const indexInMultiZoom = elementsForMultiZoom.indexOf(element);
            if (indexInMultiZoom > -1) { elementsForMultiZoom.splice(indexInMultiZoom, 1); updateMultiZoomTriggerVisibility(); }
        }
        return;
    }
    
    const addInsertAreaButton = target.closest('.add-sub-insert-area-btn');
    if (addInsertAreaButton && !target.closest('[data-editable-type="button-text-label"]')) {
        event.stopPropagation();
        const boxElement = addInsertAreaButton.closest('.box');
        if (boxElement) {
             addInsertAreaToBox(boxElement);
        }
        return;
    }

    const clickedItem = target.closest('[data-editable-type], .resizable-image-wrapper');
    if (!clickedItem) {
        activateControls(null);
        if (elementsForMultiZoom.length > 0 && !target.closest('#multiZoomTriggerBtn')) {
            clearMultiZoomSelectionVisuals(); elementsForMultiZoom = [];
        } return;
    }
    
    if (clickedItem.dataset.editableType === 'button-text-label' && target === clickedItem) {
        activateControls(clickedItem, true); event.stopPropagation(); return;
    }
    const interactiveChild = target.closest('a, button:not(.add-sub-insert-area-btn), input, select, textarea');
    if (interactiveChild && clickedItem.contains(interactiveChild) && interactiveChild !== clickedItem) {
        if (interactiveChild.tagName === 'A' && interactiveChild.href && !(event.ctrlKey || event.metaKey)) {
            if (!isCompareModeActive && !interactiveChild.href.endsWith('#')) {
                 event.preventDefault();
                 window.open(interactiveChild.href, '_blank', 'noopener,noreferrer');
            }
        } return;
    }
    
    if (!clickedImageWrapper) {
      // event.stopPropagation(); // This prevents text selection
    }

    if (event.ctrlKey || event.metaKey) {
        event.preventDefault();
        if (!(clickedItem.dataset.editableType === 'page-title' && elementsForMultiZoom.length > 0 && !elementsForMultiZoom.includes(clickedItem)) &&
            !(clickedItem.dataset.editableType === 'page-title' && elementsForMultiZoom.length === 0 && elementsForMultiZoom.includes(clickedItem) && elementsForMultiZoom.length > 1) ) {
            toggleMultiZoomSelection(clickedItem);
        }
        if (elementsForMultiZoom.length === 1 && elementsForMultiZoom[0] === clickedItem) activateControls(clickedItem);
        else if (elementsForMultiZoom.length !== 1 && currentlyActiveItemControlsElement === clickedItem) activateControls(null);
        else if (elementsForMultiZoom.length > 1 && currentlyActiveItemControlsElement) activateControls(null);

    } else {
        if (elementsForMultiZoom.length > 0 && !elementsForMultiZoom.includes(clickedItem)) {
            clearMultiZoomSelectionVisuals(); elementsForMultiZoom = [];
        }
        if (elementsForMultiZoom.length === 1 && elementsForMultiZoom[0] === clickedItem && clickedItem.dataset.editableType === 'page-title') {
            toggleMultiZoomSelection(clickedItem);
        }
        if (!clickedImageWrapper) {
          activateControls(clickedItem);
        }
    }
  }

  function handleDocumentClick(event) {
    const isClickInsideAppOrGlobalControls = appContainer.contains(event.target) ||
                                       (menuPanel && menuPanel.contains(event.target)) ||
                                       (multiZoomTriggerBtn && multiZoomTriggerBtn.contains(event.target)) ||
                                       (floatingMenuToggleBtn && floatingMenuToggleBtn.contains(event.target)) ||
                                       (trueFullscreenBtn && trueFullscreenBtn.contains(event.target)) ||
                                       (document.getElementById('header-info-display') && document.getElementById('header-info-display').contains(event.target)) ||
                                       (annotationSettingsPanel && annotationSettingsPanel.contains(event.target)) ||
                                       (selectionZoomOverlay && selectionZoomOverlay.contains(event.target)) ||
                                       (document.getElementById('imageZoomOverlay') && document.getElementById('imageZoomOverlay').contains(event.target)) ||
                                       (document.getElementById('imageCropOverlay') && document.getElementById('imageCropOverlay').contains(event.target)) ||
                                       (compareModeToggleBtn && compareModeToggleBtn.contains(event.target));


    if (!isClickInsideAppOrGlobalControls) {
        if (currentlyActiveItemControlsElement) activateControls(null);
        if (elementsForMultiZoom.length > 0) { clearMultiZoomSelectionVisuals(); elementsForMultiZoom = []; }
        const activeImage = document.querySelector('.resizable-image-wrapper.active');
        if (activeImage) activeImage.classList.remove('active');
    }
    
    const calendarContainer = document.getElementById('calendar-container');
    if (calendarContainer.style.display === 'block' && !calendarContainer.parentElement.contains(event.target)) {
        calendarContainer.style.display = 'none';
    }
  }


  function handleKeyDown(event) {
    if (event.key === 'Shift') {
        isShiftKeyDown = true;
        document.body.classList.add('shift-pressed');
    }

    // --- START: 개선된 이미지 삭제 로직 ---
   // Delete나 Backspace 키를 눌렀을 때 선택된(active) 이미지만 정확히 삭제
    if (event.key === 'Delete' || event.key === 'Backspace') {
        // Do not delete image if an annotation text on it is focused
        if (document.activeElement && document.activeElement.classList.contains('image-annotation-text')) {
            return;
        }

        const activeImageWrapper = document.querySelector('.resizable-image-wrapper.active');
        const isImageSelected = activeImageWrapper && activeImageWrapper.classList.contains('active');

       if (isImageSelected) {
            event.preventDefault(); // 브라우저의 뒤로가기 등 기본 동작을 막습니다.
           event.stopPropagation(); // 이벤트 버블링 방지로 주변 요소 보호
            
            const indexInMultiZoom = elementsForMultiZoom.indexOf(activeImageWrapper);
            if (indexInMultiZoom > -1) {
                elementsForMultiZoom.splice(indexInMultiZoom, 1);
                updateMultiZoomTriggerVisibility();
            }
            if(currentlyActiveItemControlsElement === activeImageWrapper){
                activateControls(null);
            }

              // 이미지만 정확히 삭제하고 주변 콘텐츠는 보호
   const parentElement = activeImageWrapper.parentElement;
            activeImageWrapper.remove();
   
   // 삭제 후 포커스 정리로 주변 요소 보호
   if (parentElement && parentElement.focus) {
       parentElement.focus();
   }
   
            showMessage('이미지가 삭제되었습니다.', 'success');
            return; // 이미지 삭제 후 다른 키보드 로직 실행을 중단합니다.
        }
    }
    // --- END: 개선된 이미지 삭제 로직 ---

    if (event.key === 'Enter') {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const anchorNode = selection.anchorNode;
            const targetElement = anchorNode.nodeType === 1 ? anchorNode : anchorNode.parentElement;
            const insertArea = targetElement.closest('.insert-area');
            
            if (insertArea && !event.shiftKey) {
                event.preventDefault();
                document.execCommand('insertLineBreak', false, null);
                return;
            }
        }
    }

    if (event.ctrlKey || event.metaKey) {
        document.body.classList.add('ctrl-pressed');
        if ((event.key === 'z' || event.key === 'Z') && !event.shiftKey) {
            event.preventDefault(); try { document.execCommand('undo', false, null); showMessage('실행 취소됨', 'success', 1500); }
            catch (e) { showMessage('실행 취소 실패.', 'error'); console.error("Undo failed:", e); }
        } else if ((event.key === 'y' || event.key === 'Y') && !event.shiftKey) {
            event.preventDefault(); try { document.execCommand('redo', false, null); showMessage('다시 실행됨', 'success', 1500); }
            catch (e) { showMessage('다시 실행 실패.', 'error'); console.error("Redo failed:", e); }
        }
    }

    if (event.key === 'Escape') {
      const imageZoomOverlay = document.getElementById('imageZoomOverlay');
      if (imageZoomOverlay && imageZoomOverlay.style.display === 'flex') {
          closeImageZoom();
      }
      const cropOverlay = document.getElementById('imageCropOverlay');
      if(cropOverlay && cropOverlay.style.display === 'flex') {
          closeCropUI();
      }
    }
  }

  function handleKeyUp(event) {
    if (event.key === 'Shift') {
        isShiftKeyDown = false;
        document.body.classList.remove('shift-pressed');
    }
    if (!(event.ctrlKey || event.metaKey)) {
      document.body.classList.remove('ctrl-pressed');
    }
  }

  function addInsertAreaToBox(boxElement) {
    if (!boxElement || !boxElement.classList.contains('box')) return;
    const template = document.querySelector('.common-item-template .insert-area.templated-insert-area');
    if (!template) { console.error("Insert area template not found!"); showMessage('템플릿을 찾을 수 없습니다.', 'error'); return; }
    let newInsertArea = template.cloneNode(true);
    newInsertArea.innerHTML = "<br>";
    newInsertArea.classList.remove('templated-insert-area');
    
    const lastButton = boxElement.querySelector('.add-sub-insert-area-btn:last-of-type');
    if (lastButton) {
        boxElement.insertBefore(newInsertArea, lastButton);
    } else {
        boxElement.appendChild(newInsertArea);
    }

    generateItemControls(newInsertArea);
    addCollapseToggle(newInsertArea);
    activateControls(newInsertArea, true);
    showMessage('하위 입력창이 추가되었습니다.', 'success');
  }
  
  function rgbToHex(rgb) {
    if (!rgb || typeof rgb !== 'string' || rgb.indexOf('rgb') === -1) return '#000000';
    if (rgb === 'rgba(0, 0, 0, 0)' || rgb === 'transparent') return '#ffffff';
    let parts = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)$/);
    if (!parts) return '#000000';
    delete parts[0];
    for (let i = 1; i <= 3; ++i) { parts[i] = parseInt(parts[i]).toString(16); if (parts[i].length == 1) parts[i] = '0' + parts[i]; }
    return `#${parts[1]}${parts[2]}${parts[3]}`;
  }

  function applyLink() {
    restoreSelection();
    const linkURLInput = document.getElementById("linkURL"); const linkURL = linkURLInput.value.trim();
    if (!linkURL) { showMessage("링크 URL을 입력하세요.", "error"); return; }
    const selection = window.getSelection();
    if (selection.isCollapsed) { showMessage("텍스트를 먼저 선택해주세요.", "error"); return; }

    let prefixedURL = linkURL;
    if (!linkURL.startsWith('http://')&&!linkURL.startsWith('https://')&&!linkURL.startsWith('mailto:')&&!linkURL.startsWith('#')&&!linkURL.includes('://')) {
        prefixedURL = 'http://' + linkURL;
    }
    try { if (!prefixedURL.includes(':') && !prefixedURL.startsWith('#') && !prefixedURL.startsWith('/')) new URL(prefixedURL); }
    catch (_) { showMessage("유효한 URL 형식이 아닙니다.", "error"); return; }

    document.execCommand('createLink', false, prefixedURL);
    
    let createdLink = selection.anchorNode?.nodeType === Node.TEXT_NODE ? selection.anchorNode.parentElement : selection.anchorNode;
    if (createdLink && createdLink.tagName !== 'A') createdLink = createdLink.closest('a');
    if(createdLink?.tagName === 'A'){ createdLink.target = '_blank'; createdLink.rel = 'noopener noreferrer'; }
    
    savedRange = selection.getRangeAt(0).cloneRange();
    
    showMessage("링크가 삽입되었습니다.", "success"); linkURLInput.value = '';
    updateAllFormattingUIs();
  }
  
  function removeLink() { 
      restoreSelection();
      executeFormatCommand('unlink');
      showMessage("링크가 제거되었습니다.", "success");
  }
  
  function updateAllFormattingUIs() {
    updateFormattingUI();
  }

  function updateFormattingUI() {
      if (isUpdatingUI || (menuPanel && menuPanel.style.display !== "flex")) return;
      isUpdatingUI = true;

      const selection = window.getSelection();
      if (!selection.rangeCount || !contentArea.contains(selection.anchorNode)) {
          isUpdatingUI = false;
          return;
      };
      
      const element = selection.anchorNode.nodeType === 1 ? selection.anchorNode : selection.anchorNode.parentElement;
      const computedStyle = window.getComputedStyle(element);

      document.getElementById('applyBoldBtn').classList.toggle('active', document.queryCommandState('bold'));
      document.getElementById('applyItalicBtn').classList.toggle('active', document.queryCommandState('italic'));
      document.getElementById('applyUnderlineBtn').classList.toggle('active', document.queryCommandState('underline'));
      document.getElementById('applyStrikethroughBtn').classList.toggle('active', document.queryCommandState('strikeThrough'));
      document.getElementById('applySuperscriptBtn').classList.toggle('active', document.queryCommandState('superscript'));
      document.getElementById('applySubscriptBtn').classList.toggle('active', document.queryCommandState('subscript'));
      
      document.getElementById('fontSizeInput').value = parseInt(computedStyle.fontSize);
      document.getElementById('fontColorSelector').value = rgbToHex(document.queryCommandValue('foreColor'));
      document.getElementById('backColorSelector').value = rgbToHex(document.queryCommandValue('backColor'));
      
      const blockElement = element.closest('div[data-editable-type], p, li, h1, h2, h3, h4, h5, h6, .insert-area');
      if (blockElement && contentArea.contains(blockElement)) {
          const blockStyle = window.getComputedStyle(blockElement);
          const lineHeightValue = parseFloat(blockStyle.lineHeight) / parseFloat(blockStyle.fontSize);
          document.getElementById('lineHeightInput').value = isNaN(lineHeightValue) ? 1.6 : lineHeightValue.toFixed(1);
          
          ['alignLeftBtn', 'alignCenterBtn', 'alignRightBtn'].forEach(id => document.getElementById(id).classList.remove('active'));
          if (blockStyle.textAlign === 'center') document.getElementById('alignCenterBtn').classList.add('active');
          else if (blockStyle.textAlign === 'right') document.getElementById('alignRightBtn').classList.add('active');
          else document.getElementById('alignLeftBtn').classList.add('active');

          document.getElementById('alignVcenterBtn').classList.toggle('active', blockStyle.display === 'flex');
      }
      
      setTimeout(() => { isUpdatingUI = false; }, 50);
  }

  function restoreSelection() {
    if (savedRange) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(savedRange);
    }
  }

  function executeFormatCommand(command, value = null) {
      restoreSelection();
      document.execCommand(command, false, value);
      savedRange = window.getSelection().getRangeAt(0).cloneRange();
      setTimeout(updateAllFormattingUIs, 0);
  }

  function applyStyleToSelection(styleProperty, styleValue) {
    restoreSelection();

    const selection = window.getSelection();
    if (!selection.rangeCount || selection.isCollapsed) {
        showMessage("먼저 텍스트를 선택하세요.", "warning");
        return;
    }

    document.execCommand('styleWithCSS', false, true);
    
    if (styleProperty === 'fontSize') {
        const sizeMap = { "1": "10px", "2": "13px", "3": "16px", "4": "18px", "5": "24px", "6": "32px", "7": "48px" };
        const legacySize = Object.keys(sizeMap).find(key => sizeMap[key] === styleValue);

        if (legacySize) {
            document.execCommand('fontSize', false, legacySize);
        } else {
             const range = selection.getRangeAt(0);
             const selectedFragment = range.extractContents();
             const span = document.createElement('span');
             span.style.fontSize = styleValue;
             
             selectedFragment.querySelectorAll('span').forEach(s => s.style.fontSize = '');
             span.appendChild(selectedFragment);
             range.insertNode(span);
             
             selection.removeAllRanges();
             const newRange = document.createRange();
             newRange.selectNodeContents(span);
             selection.addRange(newRange);
        }
    } else if (styleProperty === 'color') {
        document.execCommand('foreColor', false, styleValue);
    } else if (styleProperty === 'backgroundColor') {
        document.execCommand('backColor', false, styleValue);
    }
    document.execCommand('styleWithCSS', false, false);
    savedRange = window.getSelection().getRangeAt(0).cloneRange();
    setTimeout(updateAllFormattingUIs, 0);
}

function applyBlockStyle(styleProperty, styleValue) {
    restoreSelection();
    const selection = window.getSelection();
    if (!selection.rangeCount) return;

    const range = selection.getRangeAt(0);
    const blockSelector = 'p, li, h1, h2, h3, h4, h5, h6, div[data-editable-type="item"], div[data-editable-type="section-header"], div[data-editable-type="column-title-text"], .insert-area';

    const blocksToStyle = new Set();

    if (range.collapsed) {
        let element = range.startContainer;
        let container = element.nodeType === Node.TEXT_NODE ? element.parentElement : element;
        const blockElement = container.closest(blockSelector);
        if (blockElement) blocksToStyle.add(blockElement);
    } else {
        const walker = document.createTreeWalker(
            range.commonAncestorContainer, NodeFilter.SHOW_TEXT,
            (node) => range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
        );

        let hasTextNodes = false;
        while (walker.nextNode()) {
            hasTextNodes = true;
            const parentBlock = walker.currentNode.parentElement.closest(blockSelector);
            if (parentBlock && contentArea.contains(parentBlock)) {
                blocksToStyle.add(parentBlock);
            }
        }
        
        if (!hasTextNodes) {
            const elementWalker = document.createTreeWalker(
                range.commonAncestorContainer, NodeFilter.SHOW_ELEMENT,
                (node) => range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
            );
            while(elementWalker.nextNode()) {
                const el = elementWalker.currentNode;
                if (el.matches(blockSelector)) {
                    blocksToStyle.add(el);
                }
            }
        }
    }

    blocksToStyle.forEach(block => {
        if (contentArea.contains(block)) {
            block.style[styleProperty] = styleValue;
        }
    });

    selection.removeAllRanges();
    selection.addRange(range);
    savedRange = range.cloneRange();
    setTimeout(updateAllFormattingUIs, 0);
}


  function changeFontSize(size) { applyStyleToSelection('fontSize', size + 'px'); }
  function changeFontColor(color) { applyStyleToSelection('color', color); }
  function changeBackColor(color) { applyStyleToSelection('backgroundColor', color); }
  function changeLineHeight(value) { applyBlockStyle('lineHeight', value); }
  function alignLeft() { applyBlockStyle('textAlign', 'left'); }
  function alignCenter() { applyBlockStyle('textAlign', 'center'); }
  function alignRight() { applyBlockStyle('textAlign', 'right'); }

  function alignVcenter() {
      restoreSelection();
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      let element = selection.getRangeAt(0).commonAncestorContainer;
      let container = element.nodeType === Node.TEXT_NODE ? element.parentElement : element;
      const blockSelector = '.item, .insert-area, .action-item-header, .column-title, .section-header, h1, h2, h3, h4, h5, h6, .section-title, .section-subtitle, .box';
      const blockElement = container.closest(blockSelector);
      if (blockElement && contentArea.contains(blockElement)) {
          const isActive = getComputedStyle(blockElement).display === 'flex';
          blockElement.style.display = isActive ? '' : 'flex';
          blockElement.style.alignItems = isActive ? '' : 'center';
          blockElement.style.flexWrap = isActive ? '' : 'wrap';
          blockElement.style.gap = isActive ? '' : '8px';
      }
      savedRange = window.getSelection().getRangeAt(0).cloneRange();
      setTimeout(updateAllFormattingUIs, 0);
  }

  function toggleFormatPainter() {
    const formatPainterBtn = document.getElementById('formatPainterBtn');
    if (isFormatPainterActive) {
        isFormatPainterActive = false;
        copiedFormatInfo = null;
        if(formatPainterBtn) formatPainterBtn.classList.remove('active');
        contentArea.style.cursor = '';
        contentArea.removeEventListener('mouseup', applyCopiedFormat, true);
        document.removeEventListener('keydown', cancelPainterOnEscape, true);
        showMessage('서식 복사 모드가 비활성화되었습니다.', 'success', 1500);
    } else {
        const selection = window.getSelection();
        if (!selection.rangeCount || selection.isCollapsed) {
            showMessage('서식을 복사할 텍스트를 먼저 선택해주세요.', 'warning');
            return;
        }

        copiedFormatInfo = {
            bold: document.queryCommandState('bold'),
            italic: document.queryCommandState('italic'),
            underline: document.queryCommandState('underline'),
            strikethrough: document.queryCommandState('strikeThrough'),
            superscript: document.queryCommandState('superscript'),
            subscript: document.queryCommandState('subscript'),
            foreColor: document.queryCommandValue('foreColor'),
            backColor: document.queryCommandValue('backColor'),
            fontSize: document.queryCommandValue('fontSize')
        };

        isFormatPainterActive = true;
        if(formatPainterBtn) formatPainterBtn.classList.add('active');
        contentArea.style.cursor = 'copy';
        showMessage('서식을 적용할 텍스트를 선택하세요. (취소: Esc)', 'info', 3000);

        contentArea.addEventListener('mouseup', applyCopiedFormat, true);
        document.addEventListener('keydown', cancelPainterOnEscape, true);
    }
  }

  function applyCopiedFormat() {
    if (!isFormatPainterActive || !copiedFormatInfo) return;
    const selection = window.getSelection();
    if (selection.isCollapsed) return;

    if (document.queryCommandState('bold') !== copiedFormatInfo.isBold) document.execCommand('bold');
    if (document.queryCommandState('italic') !== copiedFormatInfo.isItalic) document.execCommand('italic');
    if (document.queryCommandState('underline') !== copiedFormatInfo.isUnderline) document.execCommand('underline');
    if (document.queryCommandState('strikeThrough') !== copiedFormatInfo.isStrikethrough) document.execCommand('strikeThrough');
    if (document.queryCommandState('superscript') !== copiedFormatInfo.isSuperscript) document.execCommand('superscript');
    if (document.queryCommandState('subscript') !== copiedFormatInfo.isSubscript) document.execCommand('subscript');
    
    document.execCommand('foreColor', false, copiedFormatInfo.fontColor);
    document.execCommand('backColor', false, copiedFormatInfo.backColor);
    if (copiedFormatInfo.fontSize) document.execCommand('fontSize', false, copiedFormatInfo.fontSize);
    
    showMessage('서식이 적용되었습니다.', 'success', 1500);
    
    setTimeout(() => {
        if(isFormatPainterActive) toggleFormatPainter();
    }, 100);
  }

  function cancelPainterOnEscape(event) {
    if (event.key === 'Escape' && isFormatPainterActive) {
        event.preventDefault();
        toggleFormatPainter();
    }
  }
  
  function insertCharacterFromInput() { restoreSelection(); const charToInsert=document.getElementById('charInput').value; if(!charToInsert){showMessage("삽입할 문자를 입력하세요.","warning");return;} insertCharacter(charToInsert); }
  function insertCharacter(char) { restoreSelection(); if (!char) {showMessage("삽입할 문자를 입력하세요.","warning");return;} document.execCommand('insertText', false, char); }
  function toggleEmojiPalette(event) { event.stopPropagation(); document.getElementById('emojiPalette').classList.toggle('show'); }
  function handleGlobalEmojiPaletteClick(event) {
    const palette = document.getElementById('emojiPalette'); const dropdown = document.querySelector('.emoji-dropdown');
    if (palette && dropdown && !dropdown.contains(event.target) && palette.classList.contains('show')) palette.classList.remove('show');
  }

  function handleEmojiPaletteButtonClick(event) {
    const button = event.target.closest('.emoji-btn');
    if(button) {
        insertCharacter(button.textContent);
    }
  }

  function getSaveFileName(extension, titleText) { 
    let processedTitle = titleText || pageTitle.textContent || '';
    
    processedTitle = processedTitle.replace(/^\D+/, '').trim();

    const match = processedTitle.match(/(\d{2,4})년\s*(\d{1,2})월/);

    if (match) {
        let year = parseInt(match[1], 10);
        if (year < 100) {
            year += 2000; 
        }
        let month = parseInt(match[2], 10);
        
        const template = monthlyNavigatorConfig.futureFilenameTemplate;
        const filenameTemplate = template.split('/').pop();
        const filename = filenameTemplate
            .replace(/{YYYY}/g, year)
            .replace(/{YY}/g, String(year).slice(-2))
            .replace(/{MM}/g, String(month).padStart(2, '0'))
            .replace(/{M}/g, month);

        if (filename.includes('.') && !filename.toLowerCase().endsWith(`.${extension.toLowerCase()}`)) {
             const baseName = filename.substring(0, filename.lastIndexOf('.'));
             return `${baseName}.${extension}`;
        }
        if (!filename.includes('.')) {
            return `${filename}.${extension}`;
        }
        return filename;
    }
    
    const dateInfo = getFormattedDateForFilename();
    return `${dateInfo.yearYYYY}_${dateInfo.monthMM}월_회의안건.${extension}`;
  }

 function saveHTML() {
    if (menuPanel.style.display === "flex") togglePanel();
    if(currentlyActiveItemControlsElement) activateControls(null);
    document.querySelectorAll('.resizable-image-wrapper.active, .is-dragging').forEach(el => el.classList.remove('active', 'is-dragging'));

    const appSaveState = {
        meetingStartTimestamp: meetingStartTime.getTime(),
        monthlyNavigatorConfig: monthlyNavigatorConfig, 
        drawnStrokes: drawnStrokes,
        drawingSettings: drawingSettings,
        keepDrawingsVisibleOnDeactivate: keepDrawingsVisibleOnDeactivate,
        isDrawingFeatureActive: isDrawingFeatureActive,
        isAnnotationPanelOpen: isAnnotationPanelOpen,
        isMemoModeActive: isMemoModeActive,
        panelUISettings: panelUISettings,
        editIconsMode: document.querySelector('input[name="editIconsMode"]:checked')?.value || 'off',
        isScreensaverPaused: isScreensaverPaused,
        panelState: panelState
    };
    
    const clonedDoc = document.cloneNode(true);
    
    const oldStateScript = clonedDoc.querySelector('script#app-state-data');
    if (oldStateScript) {
      oldStateScript.textContent = `window.__SAVED_APP_STATE__ = ${JSON.stringify(appSaveState)};`;
    } else {
        const stateScript = clonedDoc.createElement('script');
        stateScript.id = 'app-state-data';
        stateScript.type = 'application/json';
        stateScript.textContent = JSON.stringify(appSaveState);
        clonedDoc.head.appendChild(stateScript);
    }
    
    clonedDoc.querySelectorAll('.controls-active, .multi-zoom-selected, .format-size-btn.active, .resizable-image-wrapper.active, .is-dragging').forEach(el => {
        el.classList.remove('controls-active', 'multi-zoom-selected', 'active', 'is-dragging');
    });
    clonedDoc.querySelectorAll('.item-controls').forEach(el => el.remove());

    clonedDoc.querySelectorAll('[data-listener-attached]').forEach(el => {
        el.removeAttribute('data-listener-attached');
    });

    const originalAreas = Array.from(document.querySelectorAll('.insert-area, .box'));
    const clonedAreas = Array.from(clonedDoc.querySelectorAll('.insert-area, .box'));
    
    originalAreas.forEach((originalArea, index) => {
        const clonedArea = clonedAreas[index];
        if (!clonedArea) return; 
        
        const isCollapsed = originalArea.classList.contains('collapsed') || originalArea.classList.contains('box-collapsed');
        const datasetKey = originalArea.classList.contains('box') ? 'boxCollapsed' : 'collapsed';

        if (isCollapsed) {
            clonedArea.setAttribute(`data-${datasetKey}`, 'true');
        } else {
            clonedArea.removeAttribute(`data-${datasetKey}`);
        }
    });
    
    const stateScriptTag = clonedDoc.querySelector('script#app-state-data');
    if (stateScriptTag) {
        stateScriptTag.remove();
    }
    
    const newScriptTag = clonedDoc.createElement('script');
    newScriptTag.id = 'app-state-data';
    newScriptTag.textContent = `window.__SAVED_APP_STATE__ = ${JSON.stringify(appSaveState)};`;
    clonedDoc.head.appendChild(newScriptTag);

    
    const htmlOutput = `<!DOCTYPE html>\n${clonedDoc.documentElement.outerHTML}`;
    const blob = new Blob([htmlOutput], { type: "text/html;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    
    const currentTitleText = pageTitle.textContent || '';
    a.download = getSaveFileName('html', currentTitleText); 
    
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
    showMessage("HTML 파일이 모든 기능과 함께 저장되었습니다.", "success");
  }

  function saveSkippedMonthsConfig() {
    if (menuPanel.style.display === "flex") togglePanel();
    if(currentlyActiveItemControlsElement) activateControls(null);
    document.querySelectorAll('.resizable-image-wrapper.active, .is-dragging').forEach(el => el.classList.remove('active', 'is-dragging'));

    const clonedDoc = document.cloneNode(true);
    
    const mainScriptTag = clonedDoc.querySelector('script#mainAppScript');
    if (!mainScriptTag) {
        showMessage('오류: 주 스크립트를 찾을 수 없어 설정을 저장할 수 없습니다.', 'error');
        return;
    }

    const configRegex = /let\s+monthlyNavigatorConfig\s*=\s*({[\s\S]*?};)/;
    
    const newConfigString = 'let monthlyNavigatorConfig = ' + JSON.stringify(monthlyNavigatorConfig, null, 2) + ';';

    if (configRegex.test(mainScriptTag.textContent)) {
        mainScriptTag.textContent = mainScriptTag.textContent.replace(configRegex, newConfigString);
    } else {
        showMessage('오류: 스크립트에서 설정(config)을 찾지 못했습니다.', 'error');
        return;
    }
    
    clonedDoc.querySelectorAll('.controls-active, .multi-zoom-selected, .compare-selected, .is-dragging').forEach(el => {
        el.classList.remove('controls-active', 'multi-zoom-selected', 'compare-selected', 'is-dragging');
    });
    clonedDoc.querySelectorAll('.item-controls').forEach(el => el.remove());
    
    const htmlOutput = `<!DOCTYPE html>\n${clonedDoc.documentElement.outerHTML}`;
    const blob = new Blob([htmlOutput], { type: "text/html;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    
    const currentTitleText = pageTitle.textContent || '';
    a.download = getSaveFileName('html', currentTitleText); 
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);

    showMessage("설정이 적용된 새 HTML 파일이 다운로드됩니다. 기존 파일을 이 파일로 교체하여 설정을 영구적으로 저장하세요.", "success", 8000);
  }

  function printPDF() {
    if(currentlyActiveItemControlsElement) activateControls(null);
    clearMultiZoomSelectionVisuals(); elementsForMultiZoom = [];
    document.querySelectorAll('.resizable-image-wrapper.active').forEach(el => el.classList.remove('active'));

    const elementsToHide = [
        floatingMenuToggleBtn, trueFullscreenBtn, multiZoomTriggerBtn, menuPanel,
        exitTrueFullscreenBtnActual, document.getElementById('customMessageBox'),
        annotationDisplayToggleBtn, annotationSettingsToggleBtn, annotationSettingsPanel, memoAnnotationToggleBtn,
        document.getElementById('header-info-display'),
        document.getElementById('futureMeetingBlocker'),
        document.getElementById('navToggleBtn'),
        document.getElementById('selectionZoomOverlay'),
        document.getElementById('imageZoomOverlay'),
        compareModeToggleBtn,
        document.getElementById('imageCropOverlay')
    ];
    
    const originalDisplays = elementsToHide.map(el => el ? el.style.display : null);
    elementsToHide.forEach(el => { if(el) el.style.display = 'none'; });
    document.querySelectorAll('.no-print, .insert-area-toggle-btn, .box-toggle-btn, .resize-handle-img').forEach(el => el.style.display = 'none');


    let tempImgForPrint = null;
    if (annotationCanvas.width > 0 && annotationCanvas.height > 0 && (isDrawingFeatureActive || (keepDrawingsVisibleOnDeactivate && drawnStrokes.length > 0))) {
        try {
            const dataUrl = annotationCanvas.toDataURL('image/png');
            if (dataUrl !== 'data:,') {
                tempImgForPrint = document.createElement('img');
                tempImgForPrint.src = dataUrl;
                Object.assign(tempImgForPrint.style, {
                    position: 'absolute', top: annotationCanvas.offsetTop + 'px', left: annotationCanvas.offsetLeft + 'px',
                    width: annotationCanvas.width + 'px', height: annotationCanvas.height + 'px',
                    zIndex: '4', pointerEvents: 'none', display: 'block'
                });
                contentArea.appendChild(tempImgForPrint);
            }
        } catch (e) { console.error("Error generating annotation image for PDF:", e); }
    }
    const originalCanvasDisplay = annotationCanvas.style.display;
    if(annotationCanvas) annotationCanvas.style.display = 'none';
    
    const originalBodyPaddingTop = document.body.style.paddingTop;
    const originalPageTitlePosition = pageTitle.style.position;
    const navigatorEl = document.getElementById('monthlyNavigatorContainer');
    const originalNavigatorPosition = navigatorEl ? navigatorEl.style.position : null;
    const originalContentEditable = contentArea.contentEditable;

    document.body.style.paddingTop = '0px'; 
    if (getComputedStyle(pageTitle).position === 'fixed' || getComputedStyle(pageTitle).position === 'sticky') {
        pageTitle.style.position = 'relative';
    }
    if (navigatorEl && (getComputedStyle(navigatorEl).position === 'fixed' || getComputedStyle(navigatorEl).position === 'sticky')) {
        navigatorEl.style.position = 'relative';
    }
    contentArea.contentEditable = 'false';

    window.scrollTo(0, 0);

    const pdfOptions = {
        margin: [5, 5, 5, 5],
        filename: getSaveFileName('pdf', pageTitle.textContent || ''),
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
            scale: 2,
            useCORS: true,
            logging: false,
            removeContainer: true,
            scrollY: 0,
            windowWidth: document.documentElement.scrollWidth,
            windowHeight: document.documentElement.scrollHeight,
        },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
        enableLinks: true
    };

    showMessage("PDF 생성 준비 중...", "success", 2000);

    setTimeout(() => {
        html2pdf().from(appContainer).set(pdfOptions).save()
        .then(() => {
            showMessage("PDF 생성이 완료되었습니다.", "success");
        }).catch(err => {
            console.error("PDF 생성 오류:", err);
            showMessage("PDF 생성 중 오류가 발생했습니다.", "error");
        }).finally(() => {
            if (tempImgForPrint && contentArea.contains(tempImgForPrint)) contentArea.removeChild(tempImgForPrint);
            if(annotationCanvas) annotationCanvas.style.display = originalCanvasDisplay;

            elementsToHide.forEach((el, i) => { if(el) el.style.display = originalDisplays[i] || ''; });
            document.querySelectorAll('.no-print, .insert-area-toggle-btn, .box-toggle-btn, .resize-handle-img').forEach(el => el.style.display = '');

            const checkedMode = document.querySelector('input[name="editIconsMode"]:checked');
            if(checkedMode) toggleEditIconsVisibility(checkedMode.value);

            pageTitle.style.position = originalPageTitlePosition;
            if(navigatorEl) navigatorEl.style.position = originalNavigatorPosition;
            contentArea.contentEditable = originalContentEditable;
            
            adjustContainerPadding();
            fullscreenChangeHandler();
        });
    }, 300);
  }

  function toggleEditIconsVisibility(mode) {
      if(!mode) return;
      localStorage.setItem('editIconsMode', mode);
      
      document.body.classList.remove('show-icons-all', 'show-icons-selected');

      if (mode === 'all') {
          document.body.classList.add('show-icons-all');
      } else if (mode === 'selected') {
          document.body.classList.add('show-icons-selected');
      }
  }


  function updateAnnotationDisplayToggleBtnStyle() {
    if(!annotationDisplayToggleBtn) return;
    if (isDrawingFeatureActive) {
        annotationDisplayToggleBtn.classList.add('active');
        annotationDisplayToggleBtn.title = "주석 끄기";
    } else {
        annotationDisplayToggleBtn.classList.remove('active');
        annotationDisplayToggleBtn.title = "주석 켜기";
    }
  }

  function loadPanelUIWithSettings(settings) {
    [annoToolPenBtn, annoToolHighlighterBtn, annoToolCircleBtn, annoToolEllipseBtn, annoToolOrthoLineBtn, annoToolEraserBtn].forEach(btn => {
        if(btn) btn.classList.remove('tool-active');
    });
    const activeBtn = document.querySelector(`#annotationSettingsPanel button[data-tool="${settings.tool}"]`);
    if (activeBtn) activeBtn.classList.add('tool-active');


    if (settings.tool === 'highlighter') {
        annoColorPicker.value = settings.highlighterColor;
        annoLineWidthSlider.value = settings.highlighterLineWidth;
        annoHighlighterOpacitySlider.value = settings.highlighterOpacity;
        if(annoHighlighterOpacityContainer) annoHighlighterOpacityContainer.style.display = 'flex';
    } else if (settings.tool === 'pen' || settings.tool === 'circle' || settings.tool === 'ellipse' || settings.tool === 'orthoLine') {
        annoColorPicker.value = settings.penColor;
        annoLineWidthSlider.value = settings.penLineWidth;
        if(annoHighlighterOpacityContainer) annoHighlighterOpacityContainer.style.display = 'none';
    } else {
        annoLineWidthSlider.value = settings.penLineWidth;
        if(annoHighlighterOpacityContainer) annoHighlighterOpacityContainer.style.display = 'none';
    }
  }

  function applySettingsToContext(settings) {
    if (!annotationCtx) return;
    annotationCtx.globalCompositeOperation = 'source-over';

    if (settings.tool === 'highlighter') {
        annotationCtx.strokeStyle = settings.highlighterColor;
        annotationCtx.lineWidth = settings.highlighterLineWidth;
        annotationCtx.globalAlpha = 1.0 - parseFloat(settings.highlighterOpacity);
    } else if (settings.tool === 'pen' || settings.tool === 'circle' || settings.tool === 'ellipse' || settings.tool === 'orthoLine') {
        annotationCtx.strokeStyle = settings.penColor;
        annotationCtx.lineWidth = settings.penLineWidth;
        annotationCtx.globalAlpha = 1.0;
    } else if (settings.tool === 'eraser') {
        annotationCtx.lineWidth = settings.penLineWidth;
        annotationCtx.globalAlpha = 1.0;
    }
  }

  function setAnnotationDefaults() {
    drawingSettings = {
        tool: 'orthoLine',
        penColor: '#FF0000',
        penLineWidth: '5',
        highlighterColor: '#FFFFE0', 
        highlighterLineWidth: '20', 
        highlighterOpacity: '0.3',
    };
    panelUISettings = { ...drawingSettings };
    if(annoKeepDrawingsVisibleCheckbox) keepDrawingsVisibleOnDeactivate = annoKeepDrawingsVisibleCheckbox.checked;
    if(menuAnnoKeepDrawingsVisible) menuAnnoKeepDrawingsVisible.checked = keepDrawingsVisibleOnDeactivate;
    if(annoHighlighterOpacitySlider) annoHighlighterOpacitySlider.value = drawingSettings.highlighterOpacity;
  }

  function redrawAllStrokes() {
    if (!annotationCtx || !annotationCanvas) return;
    annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    drawnStrokes.forEach(stroke => {
        annotationCtx.beginPath();
        annotationCtx.lineWidth = stroke.lineWidth;
        annotationCtx.strokeStyle = stroke.color;
        annotationCtx.globalAlpha = stroke.opacity;
        annotationCtx.globalCompositeOperation = 'source-over';

        if (stroke.type === 'path' || stroke.type === 'line') {
            annotationCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                annotationCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
            annotationCtx.stroke();
        } else if (stroke.type === 'circle') {
            annotationCtx.arc(stroke.x, stroke.y, stroke.radius, 0, Math.PI * 2);
            annotationCtx.stroke();
        } else if (stroke.type === 'ellipse') {
            annotationCtx.ellipse(stroke.x, stroke.y, stroke.radiusX, stroke.radiusY, 0, 0, Math.PI * 2);
            annotationCtx.stroke();
        }
    });
    applySettingsToContext(drawingSettings);
  }


  function setupAnnotationCanvas() {
    if (!contentArea || !annotationCanvas) return;

    const isFs = document.body.classList.contains('true-fullscreen-active');
    const newWidth = contentArea.scrollWidth;
    const newHeight = contentArea.scrollHeight;

    if (annotationCanvas.width !== newWidth || annotationCanvas.height !== newHeight) {
        annotationCanvas.width = newWidth;
        annotationCanvas.height = newHeight;
    }

    annotationCtx = annotationCanvas.getContext('2d');
    annotationCtx.lineCap = 'round';
    annotationCtx.lineJoin = 'round';

    redrawAllStrokes();

    annotationCanvas.style.top = `0px`;
    annotationCanvas.style.left = `0px`;


    if (isFs) {
        annotationCanvas.style.display = isDrawingFeatureActive ? 'block' : (keepDrawingsVisibleOnDeactivate && drawnStrokes.length > 0 ? 'block' : 'none');
        annotationCanvas.style.pointerEvents = isDrawingFeatureActive ? 'auto' : 'none';
        annotationCanvas.style.cursor = (isDrawingFeatureActive && drawingSettings.tool === 'eraser') ? 'crosshair' :
                                       (isDrawingFeatureActive) ? 'crosshair' : 'default';
    } else {
        annotationCanvas.style.display = (isDrawingFeatureActive || keepDrawingsVisibleOnDeactivate) && drawnStrokes.length > 0 ? 'block' : 'none';
        annotationCanvas.style.pointerEvents = 'none';
        annotationCanvas.style.cursor = 'default';
    }
    applySettingsToContext(drawingSettings);
  }


  function getAnnotationMousePos(event) {
    const rect = annotationCanvas.getBoundingClientRect();
    const scaleX = annotationCanvas.width / rect.width;
    const scaleY = annotationCanvas.height / rect.height;
    let clientX = event.clientX;
    let clientY = event.clientY;
    if (event.touches && event.touches.length > 0) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
    }
    return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
    };
  }

  let currentStroke = null;

  function startAnnotationDrawing(e) {
    if (!isDrawingFeatureActive || (e.button !== undefined && e.button !== 0) ) {
        return;
    }
    if(isDrawingFeatureActive) e.preventDefault();


    if (isMemoModeActive) return;

    const pos = getAnnotationMousePos(e);

    if (drawingSettings.tool === 'eraser') {
        eraseStrokeAtPoint(pos);
        isDrawingAnnotation = false;
        return;
    }

    applySettingsToContext(drawingSettings);
    isDrawingAnnotation = true;
    shapeStartX = pos.x;
    shapeStartY = pos.y;
    lastAnnotationX = pos.x;
    lastAnnotationY = pos.y;


    if (drawingSettings.tool === 'orthoLine' || drawingSettings.tool === 'circle' || drawingSettings.tool === 'ellipse' || (isShiftKeyDown && (drawingSettings.tool === 'pen' || drawingSettings.tool === 'highlighter'))) {
        if (annotationCanvas.width > 0 && annotationCanvas.height > 0) {
            previewImageData = annotationCtx.getImageData(0, 0, annotationCanvas.width, annotationCanvas.height);
        } else { previewImageData = null;}
        currentStroke = null;
    } else if (drawingSettings.tool === 'pen' || drawingSettings.tool === 'highlighter') {
        annotationCtx.moveTo(pos.x, pos.y);
        currentStroke = {
            type: 'path',
            tool: drawingSettings.tool,
            color: drawingSettings.tool === 'highlighter' ? drawingSettings.highlighterColor : drawingSettings.penColor,
            lineWidth: drawingSettings.tool === 'highlighter' ? drawingSettings.highlighterLineWidth : drawingSettings.penLineWidth,
            opacity: drawingSettings.tool === 'highlighter' ? (1.0 - parseFloat(drawingSettings.highlighterOpacity)) : 1.0,
            points: [pos]
        };
    }
  }

  function drawAnnotation(e) {
    if (!isDrawingAnnotation || !isDrawingFeatureActive ) return;
    if (isMemoModeActive || drawingSettings.tool === 'eraser') return;
    if(isDrawingFeatureActive) e.preventDefault();
    const pos = getAnnotationMousePos(e);

    if (previewImageData) annotationCtx.putImageData(previewImageData, 0, 0);
    applySettingsToContext(drawingSettings);
    annotationCtx.beginPath();

    if ((isShiftKeyDown && (drawingSettings.tool === 'pen' || drawingSettings.tool === 'highlighter')) || drawingSettings.tool === 'orthoLine') {
        let endX = pos.x;
        let endY = pos.y;
        if (drawingSettings.tool === 'orthoLine') {
            if (Math.abs(pos.x - shapeStartX) > Math.abs(pos.y - shapeStartY)) { endY = shapeStartY; }
            else { endX = shapeStartX; }
        }
        annotationCtx.moveTo(shapeStartX, shapeStartY);
        annotationCtx.lineTo(endX, endY);
    } else if (drawingSettings.tool === 'circle') {
        const radius = Math.sqrt(Math.pow(pos.x - shapeStartX, 2) + Math.pow(pos.y - shapeStartY, 2));
        annotationCtx.arc(shapeStartX, shapeStartY, radius, 0, Math.PI * 2);
    } else if (drawingSettings.tool === 'ellipse') {
        const radiusX = Math.abs(pos.x - shapeStartX) / 2;
        const radiusY = Math.abs(pos.y - shapeStartY) / 2;
        const centerX = shapeStartX + (pos.x - shapeStartX) / 2;
        const centerY = shapeStartY + (pos.y - shapeStartY) / 2;
        annotationCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
    } else {
        if (!currentStroke) return;
        annotationCtx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
        for(let i = 1; i < currentStroke.points.length; i++) {
            annotationCtx.lineTo(currentStroke.points[i].x, currentStroke.points[i].y);
        }
        annotationCtx.lineTo(pos.x, pos.y);
    }
    annotationCtx.stroke();

    if (!isShiftKeyDown && drawingSettings.tool !== 'circle' && drawingSettings.tool !== 'ellipse' && drawingSettings.tool !== 'orthoLine' && currentStroke) {
        currentStroke.points.push(pos);
    }

    lastAnnotationX = pos.x;
    lastAnnotationY = pos.y;
  }

  function stopAnnotationDrawing(e) {
    if (!isDrawingAnnotation) {
        return;
    }
    if (isMemoModeActive || drawingSettings.tool === 'eraser') {
        isDrawingAnnotation = false;
        currentStroke = null;
        previewImageData = null;
        return;
    }
    if(isDrawingFeatureActive) e.preventDefault();

    const pos = getAnnotationMousePos(e);
    if (previewImageData) {
        annotationCtx.putImageData(previewImageData, 0, 0);
        previewImageData = null;
    }
    applySettingsToContext(drawingSettings);
    annotationCtx.beginPath();

    let newStroke = null;
    let endX = pos.x;
    let endY = pos.y;

    if (drawingSettings.tool === 'orthoLine') {
        if (Math.abs(pos.x - shapeStartX) > Math.abs(pos.y - shapeStartY)) { endY = shapeStartY; }
        else { endX = shapeStartX; }
         annotationCtx.moveTo(shapeStartX, shapeStartY);
         annotationCtx.lineTo(endX, endY);
         newStroke = { type: 'line', tool: drawingSettings.tool, points: [{x: shapeStartX, y: shapeStartY}, {x: endX, y: endY}] };
    } else if (isShiftKeyDown && (drawingSettings.tool === 'pen' || drawingSettings.tool === 'highlighter')) {

        annotationCtx.moveTo(shapeStartX, shapeStartY);
        annotationCtx.lineTo(pos.x, pos.y);
        newStroke = { type: 'line', tool: drawingSettings.tool, points: [{x: shapeStartX, y: shapeStartY}, {x: pos.x, y: pos.y}] };
    } else if (drawingSettings.tool === 'circle') {
        const radius = Math.sqrt(Math.pow(pos.x - shapeStartX, 2) + Math.pow(pos.y - shapeStartY, 2));
        if (radius > 0.1) {
            annotationCtx.arc(shapeStartX, shapeStartY, radius, 0, Math.PI * 2);
            newStroke = { type: 'circle', tool: drawingSettings.tool, x: shapeStartX, y: shapeStartY, radius: radius };
        }
    } else if (drawingSettings.tool === 'ellipse') {
        const radiusX = Math.abs(pos.x - shapeStartX) / 2;
        const radiusY = Math.abs(pos.y - shapeStartY) / 2;
        if (radiusX > 0.1 && radiusY > 0.1) {
            const centerX = shapeStartX + (pos.x - shapeStartX) / 2;
            const centerY = shapeStartY + (pos.y - shapeStartY) / 2;
            annotationCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
            newStroke = { type: 'ellipse', tool: drawingSettings.tool, x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY };
        }
    } else if (currentStroke && currentStroke.points.length > 0) {
         currentStroke.points.push(pos);
         annotationCtx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
         for(let i=1; i < currentStroke.points.length; i++) {
            annotationCtx.lineTo(currentStroke.points[i].x, currentStroke.points[i].y);
         }
         newStroke = { ...currentStroke };
    }

    if (newStroke) {
        newStroke.color = drawingSettings.tool === 'highlighter' ? drawingSettings.highlighterColor : drawingSettings.penColor;
        newStroke.lineWidth = drawingSettings.tool === 'highlighter' ? drawingSettings.highlighterLineWidth : drawingSettings.penLineWidth;
        newStroke.opacity = drawingSettings.tool === 'highlighter' ? (1.0 - parseFloat(drawingSettings.highlighterOpacity)) : 1.0;
        drawnStrokes.push(newStroke);
        annotationCtx.stroke();
    }

    isDrawingAnnotation = false;
    currentStroke = null;
  }

  function distToSegmentSquared(p, v, w) {
    const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
    if (l2 === 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const closestX = v.x + t * (w.x - v.x);
    const closestY = v.y + t * (w.y - v.y);
    return (p.x - closestX)**2 + (p.y - closestY)**2;
  }


  function eraseStrokeAtPoint(clickPos) {
    if(drawingSettings.tool !== 'eraser') return;
    const clickTolerance = 10;
    let erased = false; 

    for (let i = drawnStrokes.length - 1; i >= 0; i--) {
        const stroke = drawnStrokes[i];
        const strokeWidth = parseFloat(stroke.lineWidth || drawingSettings.penLineWidth);
        const tolerance = (strokeWidth / 2) + clickTolerance;
        let hit = false;

        if (stroke.type === 'path' || stroke.type === 'line') {
            for (let j = 0; j < stroke.points.length - 1; j++) {
                if (distToSegmentSquared(clickPos, stroke.points[j], stroke.points[j+1]) < tolerance**2) {
                    hit = true; break;
                }
            }
            if (!hit && stroke.points.length === 1) {
                 if (distToSegmentSquared(clickPos, stroke.points[0], stroke.points[0]) < tolerance**2) hit = true;
            }
        } else if (stroke.type === 'circle') {
            const dist = Math.sqrt(Math.pow(clickPos.x - stroke.x, 2) + Math.pow(clickPos.y - stroke.y, 2));
            if (Math.abs(dist - stroke.radius) < tolerance ) hit = true;
        } else if (stroke.type === 'ellipse') {
            const dx = clickPos.x - stroke.x;
            const dy = clickPos.y - stroke.y;
            const normalizedX = dx / (stroke.radiusX + tolerance);
            const normalizedY = dy / (stroke.radiusY + tolerance);
            if ((normalizedX * normalizedX) + (normalizedY * normalizedY) <= 1) {
                hit = true;
            }
        }

        if (hit) {
            drawnStrokes.splice(i, 1);
            erased = true;
            break;
        }
    }
    if (erased) {
        redrawAllStrokes();
        showMessage("주석이 삭제되었습니다.", "success", 1000);
    }
  }


  function toggleDrawingFeature() {
      if (isMemoModeActive) {
          isMemoModeActive = false;
          memoAnnotationToggleBtn.classList.remove('active');
          if(menuMemoAnnotationBtn) menuMemoAnnotationBtn.classList.remove('active');
          contentArea.style.cursor = 'auto';
          showMessage("메모 모드 비활성화됨.", "success", 1500);
      }

      isDrawingFeatureActive = !isDrawingFeatureActive;
      updateAnnotationDisplayToggleBtnStyle();
      if(menuAnnoDrawingToggle) menuAnnoDrawingToggle.classList.toggle('active', isDrawingFeatureActive);

      if (isDrawingFeatureActive) {
          annotationCanvas.style.display = 'block';
          if (document.body.classList.contains('true-fullscreen-active')) {
              annotationCanvas.style.pointerEvents = 'auto';
          } else {
              annotationCanvas.style.pointerEvents = 'none';
          }
          applySettingsToContext(drawingSettings);
          showMessage("주석 그리기 활성화됨.", "success", 1500);
      } else {
          annotationCanvas.style.pointerEvents = 'none';
          annotationCanvas.style.display = keepDrawingsVisibleOnDeactivate && drawnStrokes.length > 0 ? 'block' : 'none';
          annotationCanvas.style.display = keepDrawingsVisibleOnDeactivate && drawnStrokes.length > 0 ? 'block' : 'none';
          if (isAnnotationPanelOpen) {
              isAnnotationPanelOpen = false;
              annotationSettingsPanel.style.display = 'none';
              annotationSettingsToggleBtn.classList.remove('active');
              if(menuAnnoSettingsPanelToggle) menuAnnoSettingsPanelToggle.classList.remove('active');
          }
          showMessage("주석 그리기 비활성화됨.", "success", 1500);
      }
      setupAnnotationCanvas();
  }

  function toggleAnnotationSettingsPanel() {
      if (!isDrawingFeatureActive && document.body.classList.contains('true-fullscreen-active')) {
          showMessage("주석 그리기를 먼저 켜주세요 (👁️ 아이콘).", "warning");
          return;
      }
      if (!isDrawingFeatureActive && !document.body.classList.contains('true-fullscreen-active')) {
          showMessage("주석 기능을 먼저 켜주세요 (메뉴 열기 > 주석 켜기/끄기).", "warning");
          return;
      }


      isAnnotationPanelOpen = !isAnnotationPanelOpen;
      annotationSettingsPanel.style.display = isAnnotationPanelOpen ? 'flex' : 'none';
      annotationSettingsToggleBtn.classList.toggle('active', isAnnotationPanelOpen);
      if(menuAnnoSettingsPanelToggle) menuAnnoSettingsPanelToggle.classList.toggle('active', isAnnotationPanelOpen);

      if (isAnnotationPanelOpen) {
          panelUISettings = { ...drawingSettings };
          loadPanelUIWithSettings(panelUISettings);
      } else {
          drawingSettings = { ...panelUISettings };
          applySettingsToContext(drawingSettings);
      }
      setupAnnotationCanvas();
  }
  
  function handleAnnotationToolClick(e) {
    const newTool = e.target.closest('button').dataset.tool;

    if (newTool === 'eraser') {
        panelUISettings.tool = (panelUISettings.tool === 'eraser') ? 'pen' : 'eraser';
    } else {
        panelUISettings.tool = newTool;
    }

    if (panelUISettings.tool === 'highlighter') {
        panelUISettings.highlighterColor = panelUISettings.highlighterColor || drawingSettings.highlighterColor;
        panelUISettings.highlighterLineWidth = panelUISettings.highlighterLineWidth || drawingSettings.highlighterLineWidth;
        panelUISettings.highlighterOpacity = panelUISettings.highlighterOpacity || drawingSettings.highlighterOpacity;
    } else if (['pen', 'circle', 'ellipse', 'orthoLine'].includes(panelUISettings.tool)) {
         panelUISettings.penColor = panelUISettings.penColor || drawingSettings.penColor;
         panelUISettings.penLineWidth = panelUISettings.penLineWidth || drawingSettings.penLineWidth;
    }

    loadPanelUIWithSettings(panelUISettings);
    applySettingsToContext(panelUISettings);
    setupAnnotationCanvas();
  }
  
  function handleCloseAnnotationSettings() {
    drawingSettings = { ...panelUISettings };
    applySettingsToContext(drawingSettings);
    isAnnotationPanelOpen = false;
    annotationSettingsPanel.style.display = 'none';
    annotationSettingsToggleBtn.classList.remove('active');
    if(menuAnnoSettingsPanelToggle) menuAnnoSettingsPanelToggle.classList.remove('active');
    setupAnnotationCanvas();
    showMessage("주석 설정 적용됨.", "success", 1500);
  }

  function handleMenuKeepDrawingsToggle(isChecked) {
    keepDrawingsVisibleOnDeactivate = isChecked;
    if(annoKeepDrawingsVisibleCheckbox) annoKeepDrawingsVisibleCheckbox.checked = keepDrawingsVisibleOnDeactivate;
    if (!isDrawingFeatureActive && annotationCanvas) {
        annotationCanvas.style.display = keepDrawingsVisibleOnDeactivate && drawnStrokes.length > 0 ? 'block' : 'none';
    }
  }

  function handleClearCanvasClick() {
    if (!isDrawingFeatureActive) {
         showMessage("주석 그리기 기능이 활성화되어야 합니다.", "warning"); return;
    }
    drawnStrokes = [];
    redrawAllStrokes();
    showMessage("모든 주석이 삭제되었습니다.", "success", 1500);
  }


  function handleMemoToggleClick() {
    const isFs = document.body.classList.contains('true-fullscreen-active');
    if (!isFs) {
        showMessage("메모 추가는 전체 화면 모드에서 사용 가능합니다.", "warning");
        return;
    }
    toggleMemoMode();
  }
  
  function handleMenuMemoToggleClick() {
    handleMemoToggleClick();
    if(menuPanel.style.display === "flex") togglePanel();
  }

  function toggleMemoMode() {
      isMemoModeActive = !isMemoModeActive;
      memoAnnotationToggleBtn.classList.toggle('active', isMemoModeActive);
      if(menuMemoAnnotationBtn) menuMemoAnnotationBtn.classList.toggle('active', isMemoModeActive);
      contentArea.style.cursor = isMemoModeActive ? 'copy' : 'auto';

      if (isMemoModeActive) {
          if (isDrawingFeatureActive) {
              isDrawingFeatureActive = false;
              isAnnotationPanelOpen = false;
              annotationSettingsPanel.style.display = 'none';
              annotationSettingsToggleBtn.classList.remove('active');
              if(menuAnnoSettingsPanelToggle) menuAnnoSettingsPanelToggle.classList.remove('active');
              annotationCanvas.style.pointerEvents = 'none';
              annotationCanvas.style.display = keepDrawingsVisibleOnDeactivate && drawnStrokes.length > 0 ? 'block' : 'none';
              updateAnnotationDisplayToggleBtnStyle();
              if(menuAnnoDrawingToggle) menuAnnoDrawingToggle.classList.remove('active');
          }
          showMessage("메모 추가 모드 활성화. 내용을 클릭하여 메모를 추가하세요.", "success", 2500);
      } else {
          showMessage("메모 추가 모드 비활성화.", "success", 1500);
      }
  }


  contentArea.addEventListener('click', function(event) {
    if (isMemoModeActive && document.body.classList.contains('true-fullscreen-active')) {
        if (event.target.closest('[data-editable-type], .text-annotation-memo, button, a, input, select, textarea, .item-controls, .resizable-image-wrapper')) {
            return;
        }
        if (event.detail === 0 && event.clientX === 0 && event.clientY === 0) {
            return;
        }

        const rect = contentArea.getBoundingClientRect();
        const x = event.clientX - rect.left + contentArea.scrollLeft;
        const y = event.clientY - rect.top + contentArea.scrollTop;

        createMemoAnnotation(x, y);
    }
  });

  function createMemoAnnotation(x, y) {
    const memoWrapper = document.createElement('div');
    memoWrapper.className = 'text-annotation-memo';
    memoWrapper.style.left = Math.max(0, x - 10) + 'px';
    memoWrapper.style.top = Math.max(0, y - 10) + 'px';

    const memoContent = document.createElement('div');
    memoContent.setAttribute('contenteditable', 'true');
    memoContent.textContent = '메모 입력...';
    
    const deleteBtn = document.createElement('span');
    deleteBtn.innerHTML = '×';
    deleteBtn.className = 'memo-delete-btn';
    deleteBtn.title = '메모 삭제';
    deleteBtn.setAttribute('contenteditable', 'false');

    memoWrapper.appendChild(memoContent);
    memoWrapper.appendChild(deleteBtn);

    contentArea.appendChild(memoWrapper);
    makeMemoDraggable(memoWrapper);

    setTimeout(() => {
        memoContent.focus();
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(memoContent);
        selection.removeAllRanges();
        selection.addRange(range);
    }, 0);
  }
  
  contentArea.addEventListener('click', function(event) {
      const deleteBtn = event.target.closest('.memo-delete-btn');
      if (deleteBtn) {
          event.stopPropagation();
          const memoWrapper = deleteBtn.closest('.text-annotation-memo');
          if (memoWrapper) {
              memoWrapper.remove();
          }
      }
  });

  function makeMemoDraggable(memoElement) {
    let currentX, currentY, initialMouseX, initialMouseY, isDraggingMemo = false;

    memoElement.addEventListener('mousedown', (e) => {
        if (e.target.closest('.memo-delete-btn') || memoElement.contains(document.activeElement)) {
            if (e.target.closest('[contenteditable="true"]')) {
              return;
            }
        }

        isDraggingMemo = true;
        memoElement.style.cursor = 'grabbing';
        currentX = memoElement.offsetLeft;
        currentY = memoElement.offsetTop;
        initialMouseX = e.clientX;
        initialMouseY = e.clientY;

        document.addEventListener('mousemove', onMemoDrag);
        document.addEventListener('mouseup', onMemoDragEnd);
        e.stopPropagation();
    });

    function onMemoDrag(e) {
        if (!isDraggingMemo) return;
        e.preventDefault();

        let deltaX = e.clientX - initialMouseX;
        let deltaY = e.clientY - initialMouseY;

        let newLeft = currentX + deltaX;
        let newTop = currentY + deltaY;

        newLeft = Math.max(0, Math.min(newLeft, contentArea.scrollWidth - memoElement.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, contentArea.scrollHeight - memoElement.offsetHeight));


        memoElement.style.left = newLeft + 'px';
        memoElement.style.top = newTop + 'px';
    }

    function onMemoDragEnd() {
        if (!isDraggingMemo) return;
        isDraggingMemo = false;
        memoElement.style.cursor = 'move';
        document.removeEventListener('mousemove', onMemoDrag);
        document.removeEventListener('mouseup', onMemoDragEnd);
    }
}


  function initializeAnnotationCanvasListeners() {
    annotationCanvas.addEventListener('mousedown', startAnnotationDrawing);
    annotationCanvas.addEventListener('mousemove', drawAnnotation);
    annotationCanvas.addEventListener('mouseup', stopAnnotationDrawing);
    annotationCanvas.addEventListener('mouseout', (e) => {
      if (isDrawingAnnotation) {
          stopAnnotationDrawing(e);
      }
    });
    annotationCanvas.addEventListener('touchstart', (e) => { if(e.touches.length===1){e.preventDefault(); startAnnotationDrawing(e.touches[0]);}}, {passive:false});
    annotationCanvas.addEventListener('touchmove', (e) => { if(e.touches.length===1){e.preventDefault(); drawAnnotation(e.touches[0]);}}, {passive:false});
    annotationCanvas.addEventListener('touchend', (e) => { if(e.changedTouches.length===1){e.preventDefault(); stopAnnotationDrawing(e.changedTouches[0]);}});
    annotationCanvas.addEventListener('touchcancel', () => {
        if (isDrawingAnnotation) {
            if (previewImageData) { annotationCtx.putImageData(previewImageData, 0, 0); previewImageData = null; }
            isDrawingAnnotation = false; currentStroke = null;
        }
    });
  }
  
  function handleScreensaverPauseToggle() {
    isScreensaverPaused = pauseScreensaverCheckbox.checked;
    if (isScreensaverPaused) {
        if (isScreensaverActive) {
            stopScreensaver(); 
        }
        clearTimeout(idleTimer); 
        showMessage("화면 보호기가 일시 정지되었습니다.", "success");
    } else {
        resetIdleTimer();
        showMessage("화면 보호기가 다시 활성화되었습니다.", "success");
    }
  }
  
  function initializeCollapsibleElements() {
    contentArea.querySelectorAll('.insert-area').forEach(area => {
        addCollapseToggle(area);
        if (area.dataset.collapsed === 'true') {
            area.classList.add('collapsed');
            const btn = area.querySelector('.insert-area-toggle-btn');
            if (btn) btn.textContent = '▼';
        }
    });
    contentArea.querySelectorAll('.box').forEach(box => {
        addBoxCollapseToggle(box);
        if (box.dataset.boxCollapsed === 'true') {
            box.classList.add('box-collapsed');
            const btn = box.querySelector('.box-toggle-btn');
            if (btn) btn.textContent = '▶';
        }
    });
  }

  function addCollapseToggle(area) {
      if (!area.classList.contains('insert-area') || area.querySelector('.insert-area-toggle-btn')) return;
      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'insert-area-toggle-btn';
      toggleBtn.setAttribute('contenteditable', 'false');
      toggleBtn.setAttribute('title', '내용 접기/펴기');
      toggleBtn.textContent = '▲';
      area.insertBefore(toggleBtn, area.firstChild);
  }

  function addBoxCollapseToggle(box) {
      if (!box.classList.contains('box') || box.querySelector('.box-toggle-btn')) return;
      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'box-toggle-btn';
      toggleBtn.setAttribute('contenteditable', 'false');
      toggleBtn.setAttribute('title', '항목 그룹 접기/펴기');
      toggleBtn.textContent = '▼';
      box.insertBefore(toggleBtn, box.firstChild);
  }
  
  function insertStatusTag(status, text) {
      const className = `status-tag status-${status}`;
      const html = `&nbsp;<span class="${className}" data-editable-type="status-tag" contenteditable="true">${text}</span>&nbsp;`;
      executeFormatCommand('insertHTML', html);
  }

  function initializeEventListeners() {
    if(exitTrueFullscreenBtnActual) exitTrueFullscreenBtnActual.addEventListener('click', exitTrueFullscreen);
    if(trueFullscreenBtn) trueFullscreenBtn.addEventListener('click', toggleTrueFullscreen);
    
    document.addEventListener('fullscreenchange', fullscreenChangeHandler);
    document.addEventListener('webkitfullscreenchange', fullscreenChangeHandler);
    document.addEventListener('mozfullscreenchange', fullscreenChangeHandler);
    document.addEventListener('MSFullscreenChange', fullscreenChangeHandler);
    
    if(floatingMenuToggleBtn) floatingMenuToggleBtn.addEventListener('click', togglePanel);
    if(closeMenuPanelBtn) closeMenuPanelBtn.addEventListener('click', handleCloseMenuPanel);
    if(menuPanel) {
        menuPanel.addEventListener('mousedown', handlePanelDragStart);
        initializePanelResizing();
        initializeTabPanel();
    }

    document.addEventListener('mousemove', handlePanelDragMove);
    document.addEventListener('mouseup', handlePanelDragEnd);

    if (pauseScreensaverCheckbox) {
        pauseScreensaverCheckbox.addEventListener('change', handleScreensaverPauseToggle);
    }

    const applyDateUpdateBtn = document.getElementById('applyDateUpdateBtn');
    if (applyDateUpdateBtn) {
        applyDateUpdateBtn.addEventListener('click', () => {
             applyDynamicDateUpdates();
             showMessage('날짜가 수동으로 업데이트되었습니다.', 'success');
        });
    }
    
    document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && !selection.isCollapsed && contentArea.contains(selection.anchorNode)) {
             savedRange = selection.getRangeAt(0).cloneRange();
        }
        updateAllFormattingUIs();
    });
    
    menuPanel.addEventListener('mousedown', (e) => {
        if (!e.target.closest('input, button, label, select, .emoji-dropdown')) {
            e.preventDefault();
        }
    });

    multiZoomTriggerBtn.addEventListener('click', handleMultiZoomTrigger);
    selectionZoomOverlay.addEventListener('click', handleSelectionZoomOverlayClick);
    const closeZoomBtn = document.getElementById('closeSelectionZoomBtn');
    if (closeZoomBtn) closeZoomBtn.addEventListener('click', closeSelectionZoom);
    
    appContainer.addEventListener('click', handleAppContainerClick);
    document.addEventListener('click', handleDocumentClick);
    
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    window.addEventListener('blur', () => {
        document.body.classList.remove('ctrl-pressed');
        isShiftKeyDown = false;
    });
    
    document.querySelectorAll('input[name="editIconsMode"]').forEach(radio => {
        radio.addEventListener('change', (e) => toggleEditIconsVisibility(e.target.value));
    });
    
    const formatButtons = {
        'formatPainterBtn': toggleFormatPainter, 'applyBoldBtn': () => executeFormatCommand('bold'),
        'applyItalicBtn': () => executeFormatCommand('italic'), 'applyUnderlineBtn': () => executeFormatCommand('underline'),
        'applyStrikethroughBtn': () => executeFormatCommand('strikeThrough'), 'applySuperscriptBtn': () => executeFormatCommand('superscript'),
        'applySubscriptBtn': () => executeFormatCommand('subscript'), 'alignLeftBtn': alignLeft, 'alignVcenterBtn': alignVcenter,
        'alignCenterBtn': alignCenter, 'alignRightBtn': alignRight,
        'insertUnorderedListBtn': () => executeFormatCommand('insertUnorderedList'), 'insertOrderedListBtn': () => executeFormatCommand('insertOrderedList'),
        'applyLinkBtn': applyLink, 'removeLinkBtn': removeLink,
        'lineHeightBtn': () => document.getElementById('lineHeightInput').focus(), 'insertCharFromInputBtn': insertCharacterFromInput
    };
    for (const [id, handler] of Object.entries(formatButtons)) {
        const button = document.getElementById(id);
        if (button) {
            button.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    savedRange = selection.getRangeAt(0).cloneRange();
                }
                handler();
            });
        }
    }
    
    const formatInputs = {
        'fontSizeInput': (e) => changeFontSize(e.target.value),
        'lineHeightInput': (e) => changeLineHeight(e.target.value),
        'fontColorSelector': (e) => changeFontColor(e.target.value),
        'backColorSelector': (e) => changeBackColor(e.target.value)
    };
    for (const [id, handler] of Object.entries(formatInputs)) {
        const input = document.getElementById(id);
        if(input) {
            input.addEventListener('mousedown', (e) => {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    savedRange = selection.getRangeAt(0).cloneRange();
                }
            });
            input.addEventListener('input', handler);
        }
    }

    document.getElementById('addOrUpdateActionItemBtn').addEventListener('click', addOrUpdateActionItem);
    document.getElementById('toggleKeyDecisionBtn').addEventListener('click', toggleKeyDecision);
    document.getElementById('addPollWidgetBtn').addEventListener('click', addPollWidget);

    document.getElementById('status-tag-grid').addEventListener('click', (e) => {
        const button = e.target.closest('.status-tag');
        if (button && button.dataset.status) {
            insertStatusTag(button.dataset.status, button.textContent);
        }
    });

    const emojiPalette = document.getElementById('emojiPalette');
    if (emojiPalette) {
        const emojis = ['😀', '😂', '😊', '😍', '🤔', '👍', '👎', '⭐', '❤️', '✔', '❌', '✨', '🎉', '👀', '👉', '💡', '❓', '❗', '➡️', '⬅️'];
        emojis.forEach(emoji => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'emoji-btn';
            btn.textContent = emoji;
            emojiPalette.appendChild(btn);
        });
        emojiPalette.addEventListener('click', handleEmojiPaletteButtonClick);
    }
    document.getElementById('emojiDropdownBtn').addEventListener('click', toggleEmojiPalette);
    document.addEventListener('click', handleGlobalEmojiPaletteClick);
    document.getElementById('insertCharFromInputBtn').addEventListener('click', insertCharacterFromInput);

    document.getElementById('saveHtmlBtn').addEventListener('click', saveHTML);
    document.getElementById('printPdfBtn').addEventListener('click', printPDF);
    document.getElementById('saveSkippedMonthsBtn').addEventListener('click', saveSkippedMonthsConfig);
    
    annotationDisplayToggleBtn.addEventListener('click', toggleDrawingFeature);
    annotationSettingsToggleBtn.addEventListener('click', toggleAnnotationSettingsPanel);
    memoAnnotationToggleBtn.addEventListener('click', handleMemoToggleClick);
    
    closeAnnotationSettingsBtn.addEventListener('click', handleCloseAnnotationSettings);
    annoColorPicker.addEventListener('input', (e) => {
      if (panelUISettings.tool === 'highlighter') { panelUISettings.highlighterColor = e.target.value; }
      else { panelUISettings.penColor = e.target.value; }
      applySettingsToContext(panelUISettings);
    });
    annoLineWidthSlider.addEventListener('input', (e) => {
        const newWidth = e.target.value;
        if (panelUISettings.tool === 'highlighter') { panelUISettings.highlighterLineWidth = newWidth; }
        else if (['pen', 'circle', 'ellipse', 'orthoLine', 'eraser'].includes(panelUISettings.tool)) { panelUISettings.penLineWidth = newWidth; }
        applySettingsToContext(panelUISettings);
    });
    annoHighlighterOpacitySlider.addEventListener('input', (e) => {
        panelUISettings.highlighterOpacity = e.target.value;
        applySettingsToContext(panelUISettings);
    });
    annoKeepDrawingsVisibleCheckbox.addEventListener('change', (e) => handleMenuKeepDrawingsToggle(e.target.checked));
    annoClearCanvasBtn.addEventListener('click', handleClearCanvasClick);
    [annoToolPenBtn, annoToolHighlighterBtn, annoToolCircleBtn, annoToolEllipseBtn, annoToolOrthoLineBtn, annoToolEraserBtn].forEach(btn => {
        if (btn) btn.addEventListener('click', handleAnnotationToolClick);
    });
    
    menuAnnoKeepDrawingsVisible.addEventListener('change', (e) => handleMenuKeepDrawingsToggle(e.target.checked));
    menuAnnoDrawingToggle.addEventListener('click', toggleDrawingFeature);
    menuAnnoSettingsPanelToggle.addEventListener('click', toggleAnnotationSettingsPanel);
    menuMemoAnnotationBtn.addEventListener('click', handleMenuMemoToggleClick);

    compareModeToggleBtn.addEventListener('click', () => toggleCompareMode());
    closeComparisonViewBtn.addEventListener('click', closeComparisonView);

    initializeAnnotationCanvasListeners();
    
    document.getElementById('info-date').addEventListener('click', toggleCalendar);
    document.getElementById('calendar-prev-month').addEventListener('click', () => handleCalendarNavigation(-1));
    document.getElementById('calendar-next-month').addEventListener('click', () => handleCalendarNavigation(1));

    const activityEvents = ['mousemove', 'mousedown', 'keydown', 'scroll', 'touchstart'];
    activityEvents.forEach(event => {
        window.addEventListener(event, resetIdleTimer, true);
    });

    document.getElementById('futureMeetingBlocker').addEventListener('click', hideFutureMeetingBlocker);
    
    // --- START: 이미지 관련 기능 이벤트 리스너 (주간 코드에서 이식) ---
    const imageFileInput = document.getElementById('imageFileInput');
    const imageWidthInput = document.getElementById('imageWidthInput');
    const insertImageBtn = document.getElementById('insertImageBtn');
    let imagesToInsert = [];
    const COMPRESSION_THRESHOLD = 200 * 1024;
    const MAX_DIMENSION = 1600;
    const COMPRESSION_QUALITY = 0.7;
   
   // 붙여넣기된 이미지 자동 래핑 및 초기화 함수
   function processPastedImages(scope) {
       if (!scope) return;
       const imgs = scope.querySelectorAll('img');
       imgs.forEach(img => {
           let wrapper = img.closest('.resizable-image-wrapper');
           if (!wrapper) {
               const parent = img.parentNode;
               if (!parent) return;
               const newWrapper = document.createElement('div');
               newWrapper.className = 'resizable-image-wrapper';
               newWrapper.setAttribute('contenteditable', 'false');
               parent.insertBefore(newWrapper, img);
               newWrapper.appendChild(img);
               ensureImageWrapperStructure(newWrapper);
               makeImageDraggable(newWrapper);
               generateItemControls(newWrapper);
           } else {
               ensureImageWrapperStructure(wrapper);
               makeImageDraggable(wrapper);
               generateItemControls(wrapper);
           }
       });
   }

    function compressImage(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    let width = img.width;
                    let height = img.height;
                    if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                        if (width > height) {
                            height = Math.round((height * MAX_DIMENSION) / width);
                            width = MAX_DIMENSION;
                        } else {
                            width = Math.round((width * MAX_DIMENSION) / height);
                            height = MAX_DIMENSION;
                        }
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob(blob => {
                        if (blob) {
                             const reader = new FileReader();
                             reader.onloadend = () => resolve(reader.result);
                             reader.onerror = reject;
                             reader.readAsDataURL(blob);
                        } else {
                             resolve(canvas.toDataURL('image/jpeg', COMPRESSION_QUALITY));
                        }
                    }, 'image/webp', COMPRESSION_QUALITY);
                };
                img.onerror = reject;
                img.src = event.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    if (imageFileInput) {
      imageFileInput.addEventListener('change', async (event) => {
          const files = event.target.files;
          if (files.length === 0) { imagesToInsert = []; return; }
          imagesToInsert = [];
          showMessage(`${files.length}개 이미지 처리 중...`, 'info', 5000);
          const processingPromises = Array.from(files).map(file => {
              return new Promise(async (resolve) => {
                  if (file.size > COMPRESSION_THRESHOLD) {
                      try { resolve(await compressImage(file)); }
                      catch (error) {
                          console.error('Image compression failed:', error);
                          const reader = new FileReader();
                          reader.onload = (e) => resolve(e.target.result);
                          reader.readAsDataURL(file);
                      }
                  } else {
                      const reader = new FileReader();
                      reader.onload = (e) => resolve(e.target.result);
                      reader.readAsDataURL(file);
                  }
              });
          });
          imagesToInsert = await Promise.all(processingPromises);
          showMessage(`${imagesToInsert.length}개 이미지가 삽입 준비되었습니다.`, 'success');
      });
    }
  
    if (insertImageBtn) {
        insertImageBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const selection = window.getSelection();
            if (selection.rangeCount > 0 && contentArea.contains(selection.anchorNode)) {
                savedRange = selection.getRangeAt(0).cloneRange();
            } else {
                 showMessage('이미지를 삽입할 위치를 먼저 클릭해주세요.', 'warning');
                 return;
            }

            if (imagesToInsert.length === 0) {
                showMessage('삽입할 이미지를 파일로 선택해주세요.', 'error');
                return;
            }

            if (savedRange) {
                selection.removeAllRanges();
                selection.addRange(savedRange);
            } else {
                return; 
            }
            
            const imageWidth = imageWidthInput ? imageWidthInput.value : '300';
            imagesToInsert.forEach(imageSrc => {
                const wrapper = document.createElement('div');
                wrapper.className = 'resizable-image-wrapper';
                wrapper.setAttribute('contenteditable', 'false');
                wrapper.dataset.editableType = 'image-wrapper';
                wrapper.style.width = `${imageWidth}px`;
                wrapper.innerHTML = `
                    <img src="${imageSrc}" alt="사용자 삽입 이미지">
                    <div class="resize-handle-img rh-top-left"></div>
                    <div class="resize-handle-img rh-top-right"></div>
                    <div class="resize-handle-img rh-bottom-left"></div>
                    <div class="resize-handle-img rh-bottom-right"></div>
                `;
                
                savedRange.insertNode(wrapper);
                savedRange.setStartAfter(wrapper);
                savedRange.collapse(true);
                
                setTimeout(() => {
                    ensureImageWrapperStructure(wrapper);
                    makeImageDraggable(wrapper);
                    generateItemControls(wrapper);
                    const active = document.querySelector('.resizable-image-wrapper.active');
                    if (active && active !== wrapper) active.classList.remove('active');
                    wrapper.classList.add('active');
                    currentlyActiveItemControlsElement = wrapper;
                }, 0);
            });
            if(imageFileInput) imageFileInput.value = '';
            imagesToInsert = [];
        });
    }

    const imageZoomOverlay = document.getElementById('imageZoomOverlay');
    if (imageZoomOverlay) {
        imageZoomOverlay.addEventListener('click', (e) => {
            if (e.target === imageZoomOverlay || e.target.closest('.close-image-zoom-btn')) {
                closeImageZoom();
            }
        });
    }
    // 붙여넣기 이벤트: 새로 들어온 <img> 요소를 자동 래핑 및 초기화(중복 없이 단일 처리)
    contentArea.addEventListener('paste', () => {
        requestAnimationFrame(() => processPastedImages(contentArea));
    });
   
    // --- END: 이미지 관련 기능 이벤트 리스너 (주간 코드에서 이식) ---
  }

  window.addEventListener('DOMContentLoaded', () => {
    document.body.classList.add('meeting-cursor');
    window.addEventListener('beforeunload', () => {
        document.body.classList.remove('meeting-cursor');
    });

    if (pageTitle) {
        let titleText = pageTitle.innerHTML;
        document.title = titleText.includes('(') ? titleText.substring(0, titleText.indexOf('(')).trim() : titleText;
        const editableTitleMeta = document.querySelector('meta[name="editable-title"]');
        if (editableTitleMeta) {
            editableTitleMeta.content = document.title;
        }
    }

    let parsedState = null;
    const stateScript = document.getElementById('app-state-data');
    if (stateScript && stateScript.textContent) {
        try {
            if (stateScript.textContent.trim().startsWith('window.__SAVED_APP_STATE__')) {
                eval(stateScript.textContent);
                parsedState = window.__SAVED_APP_STATE__;
            } else {
                 parsedState = JSON.parse(stateScript.textContent);
            }
        } catch(e) {
            console.error("저장된 상태를 파싱하는데 실패했습니다: ", e);
            parsedState = null;
        }
    }
    
    if (parsedState) {
        try {
            if (parsedState.panelState) panelState = parsedState.panelState;
            if (parsedState.meetingStartTimestamp) meetingStartTime = new Date(parsedState.meetingStartTimestamp);
            if (parsedState.monthlyNavigatorConfig) {
                monthlyNavigatorConfig = parsedState.monthlyNavigatorConfig;
                if (!monthlyNavigatorConfig.skippedMonths) monthlyNavigatorConfig.skippedMonths = [];
            }
            isDrawingFeatureActive = parsedState.isDrawingFeatureActive || false;
            drawingSettings = parsedState.drawingSettings || drawingSettings;
            panelUISettings = parsedState.panelUISettings || { ...drawingSettings };
            keepDrawingsVisibleOnDeactivate = parsedState.keepDrawingsVisibleOnDeactivate !== undefined ? parsedState.keepDrawingsVisibleOnDeactivate : true;
            drawnStrokes = parsedState.drawnStrokes || [];
            isAnnotationPanelOpen = parsedState.isAnnotationPanelOpen || false;
            isMemoModeActive = parsedState.isMemoModeActive || false;
            isScreensaverPaused = parsedState.isScreensaverPaused !== undefined ? parsedState.isScreensaverPaused : true;
            if (pauseScreensaverCheckbox) pauseScreensaverCheckbox.checked = isScreensaverPaused;
            const savedEditMode = parsedState.editIconsMode || 'off';
            const radioToCheck = document.querySelector(`input[name="editIconsMode"][value="${savedEditMode}"]`);
            if (radioToCheck) {
                radioToCheck.checked = true;
                toggleEditIconsVisibility(savedEditMode);
            }
        } catch (e) {
            console.error("저장된 상태를 적용하는 중 오류 발생:", e);
            setAnnotationDefaults();
        }
    } else {
        let shouldUpdateDate = false;
        const titleText = pageTitle.textContent || '';
        const match = titleText.match(/(\d{4})년\s*(\d{1,2})월/);

        if (/YYYY|MM/.test(titleText)) {
            shouldUpdateDate = true;
        } else if (match) {
            const docYear = parseInt(match[1], 10);
            const docMonth = parseInt(match[2], 10) - 1;
            const docDate = new Date(docYear, docMonth, 1);
            
            const now = new Date();
            const currentMonthDate = new Date(now.getFullYear(), now.getMonth(), 1);

            if (docDate < currentMonthDate) {
                shouldUpdateDate = true;
            }
        }

        if (shouldUpdateDate) {
            applyDynamicDateUpdates();
            showMessage('회의록 양식을 현재 날짜 기준으로 업데이트합니다.', 'success', 4000);
        }

        const currentDocYear = new Date().getFullYear();
        if(!monthlyNavigatorConfig.skippedMonths || monthlyNavigatorConfig.skippedMonths.length === 0){
             populateInitialSkippedMonths(currentDocYear);
        }
        setAnnotationDefaults();
        if (pauseScreensaverCheckbox) {
           pauseScreensaverCheckbox.checked = true;
           handleScreensaverPauseToggle();
        }
        const radioOff = document.getElementById('editIconsModeOff');
        if(radioOff) radioOff.checked = true;
        toggleEditIconsVisibility('off');
    }
    
    if(document.body.classList.contains('is-in-iframe')) {
        // iframe specific initializations can go here
    } else {
        initializeEventListeners();
        resetIdleTimer();
    }
    
    initializeMonthlyNavigator();
    
    initializeSkippedMonthControls();
    initializeHeaderInfoDisplay();
    initializeCollapsibleElements();
    
    document.querySelectorAll('.resizable-image-wrapper').forEach(wrapper => {
      makeImageDraggable(wrapper);
      // Migration for old format and standard loading
      const img = wrapper.querySelector('img');
      let stateJson = wrapper.dataset.transformState || (img ? img.dataset.transformState : null);
      if (stateJson) {
          const state = JSON.parse(stateJson);
          applyImageTransforms(wrapper, state);
          // Ensure state is on wrapper and not on img
          if (!wrapper.dataset.transformState) {
              wrapper.dataset.transformState = stateJson;
          }
          if (img && img.dataset.transformState) {
              delete img.dataset.transformState;
          }
      }
    });
    initializeImageResizeFeature();
    initializeCropTool();

    elementsForMultiZoom = [];
    updateMultiZoomTriggerVisibility();
    adjustContainerPadding();

    if (pageTitle) { 
        generateItemControls(pageTitle); 
        if(pageTitle.dataset.listenerAttached !== 'true') {
            pageTitle.addEventListener('input', () => { 
                requestAnimationFrame(adjustContainerPadding); 
                initializeMonthlyNavigator();
            }); 
            pageTitle.dataset.listenerAttached = 'true';
        }
    }
    contentArea.querySelectorAll('[data-editable-type]:not(.text-annotation-memo), .resizable-image-wrapper').forEach(el => generateItemControls(el));
    contentArea.querySelectorAll('.text-annotation-memo').forEach(makeMemoDraggable);
   
   // 초기 로드 시 붙여넣기 등으로 남아있는 <img>를 자동 래핑해 안정화
   processPastedImages(contentArea);

    updateAnnotationDisplayToggleBtnStyle();
    if(memoAnnotationToggleBtn) memoAnnotationToggleBtn.classList.toggle('active', isMemoModeActive);

    if (document.fonts) {
        document.fonts.ready.then(() => {
            adjustContainerPadding();
            setupAnnotationCanvas();
        });
    } else {
        adjustContainerPadding();
        setupAnnotationCanvas();
    }
    fullscreenChangeHandler();
  });

  window.addEventListener('resize', () => {
    adjustContainerPadding();
    setupAnnotationCanvas();
  });
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>테이블 작성 양식 - 이미지 포함</title>
    <style type="text/css">
        /* --- 기본 및 기능 구현 스타일 --- */
        body { font-family: "Malgun Gothic", sans-serif; user-select: none; }
        .grid-container { padding: 10px; }
        /* --- 개선사항 1: 상단 메뉴 배치 변경 --- */
        .title-container { display: flex; justify-content: flex-start; align-items: center; flex-wrap: nowrap; gap: 15px; padding: 5px; margin-bottom: 10px; }
        .s0 { font-weight: bold; font-size: 24pt; flex-shrink: 0; }
        
        #main-table {
            table-layout: fixed;
            width: 100%;
            border-collapse: collapse;
            border: 1px solid #999;
            position: relative; /* 캔버스와의 명확한 스택 분리 */
            z-index: 1;
        }

        #main-table th, #main-table td {
            border: 1px solid #cccccc;
            padding: 8px 5px;
            font-size: 10pt;
            white-space: normal;
            word-wrap: break-word;
            position: relative;
        }
        
        #main-table td {
            vertical-align: middle;
            text-align: left;
        }

        #main-table td a {
            color: #0000ee;
            text-decoration: underline;
            cursor: pointer;
        }
        
        #main-table tbody tr:nth-child(even) { background-color: #f8f9fa; }
        #main-table .no-cell, #main-table thead th:not(:first-child) { cursor: grab; }
        #main-table .no-cell { text-align: center; vertical-align: middle; user-select: none; }
        #main-table .checkbox-cell { text-align: center; font-weight: bold; font-size: 14pt; cursor: pointer; user-select: none; }
        /* .currency-cell의 기본 정렬은 JS에서 처리하여 동적 변경이 가능하도록 함 */
        #main-table tbody tr { position: relative; }
        .dragging-row { opacity: 0.7; background-color: #d9eaff; }
        .dragging-col { opacity: 0.7; background-color: #d9eaff !important; }
        .drop-indicator-row-before { border-top: 2px solid #1a73e8; }
        .drop-indicator-row-after { border-bottom: 2px solid #1a73e8; }
        .drop-indicator-col-before { border-left: 2px solid #1a73e8; }
        .drop-indicator-col-after { border-right: 2px solid #1a73e8; }

        #main-table thead th {
            background-color: #deeaf6; text-align: center; vertical-align: middle; font-weight: bold;
            font-size: 11pt; border: 1px solid #999999; user-select: none;
        }
        
        /* --- 개선사항 1: 상단 메뉴 배치 변경 --- */
        #main-toolbar { display: flex; align-items: center; flex-wrap: nowrap; gap: 8px; margin-left: auto; overflow: hidden; }
        #main-toolbar .button-group { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
        #main-toolbar button { background-color: #f0f0f0; border: 1px solid #cccccc; padding: 5px 12px; font-family: "Malgun Gothic", sans-serif; font-size: 10pt; cursor: pointer; border-radius: 4px; font-weight: bold; color: #333; }
        #main-toolbar button:hover { background-color: #e0e0e0; border-color: #999999; }
        #main-toolbar button:disabled { background-color: #e9ecef; color: #6c757d; cursor: not-allowed; }
        #main-toolbar button.active { background-color: #1a73e8; color: #fff; border-color: #1a73e8; }
        [contenteditable] { -webkit-user-select: text; user-select: text; }
        [contenteditable]:focus { outline: 2px solid #4d90fe; outline-offset: -2px; }
        #main-toolbar .editor-group { display: inline-flex; align-items: center; gap: 5px; background-color: #fff; border: 1px solid #ccc; border-radius: 6px; padding: 4px 6px; flex-shrink: 1; }
        #main-toolbar .editor-group button { background-color: transparent; border: none; color: #333; cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        #main-toolbar .editor-group button svg { width: 18px; height: 18px; fill: #333; }
        #main-toolbar .editor-group button:hover, #main-toolbar .editor-group button.active { background-color: #e9e9e9; }
        #main-toolbar .editor-group select, #main-toolbar .editor-group input[type="color"] { background-color: #fff; color: #333; border: 1px solid #ccc; border-radius: 4px; padding: 2px; font-family: "Malgun Gothic", sans-serif; font-size: 10pt; height: 28px; }
        #main-toolbar .editor-group input[type="color"] { padding: 1px; width: 28px; border: 1px solid #ccc; cursor: pointer; }
        #main-toolbar .editor-separator { width: 1px; height: 20px; background-color: #ccc; margin: 0 4px; flex-shrink: 0; }
        .cell-selected { background-color: #d9eaff !important; outline: 2px solid #1a73e8 !important; outline-offset: -2px; }

        /* 화면이 좁아질 때 메뉴 크기 약간 축소 */
        @media (max-width: 1500px) {
            #main-toolbar button { padding: 5px 8px; font-size: 9pt; }
            #main-toolbar .editor-group button svg { width: 16px; height: 16px; }
            #main-toolbar .editor-group select, #main-toolbar .editor-group input[type="color"] { height: 26px; font-size: 9pt; }
        }

        .resizer-col { position: absolute; top: 0; right: -4px; width: 8px; height: 100%; cursor: col-resize; z-index: 10; }
        .resizer-row { position: absolute; left: 0; bottom: -4px; width: 100%; height: 8px; cursor: row-resize; z-index: 10; }

        #context-menu {
            display: none; position: absolute; z-index: 1000; background-color: #f9f9f9;
            border: 1px solid #ccc; border-radius: 5px; box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
            padding: 5px 0; font-family: "Malgun Gothic", sans-serif; font-size: 10pt;
        }
        #context-menu ul { list-style: none; margin: 0; padding: 0; }
        #context-menu li { padding: 8px 15px; cursor: pointer; }
        #context-menu li:hover { background-color: #e0e0e0; }
        #context-menu .separator { height: 1px; background-color: #ccc; margin: 4px 0; }
        
        #image-overlay-container { position: relative; overflow: visible; }
        /* 문서 최상단 절대 오버레이로 배치하여 스크롤과 함께 이동하며, 어떤 요소 위에도 렌더링 */
        /* UI 팝업과의 상호작용을 위해 최댓값보다 약간 낮게 설정 */
        .canvas-container { position: absolute; top: 0; left: 0; z-index: 2147483600; pointer-events: none; }
        /* 이미지 캔버스가 테이블 위에 정확히 겹치도록 절대 배치 및 z-index 보장 */
        /* 기본은 pointer-events: none 으로 테이블 편집을 방해하지 않음 */
        #overlay-canvas { position: absolute; top: 0; left: 0; z-index: 2147483600; pointer-events: none; }
        /* Fabric 상단 이벤트 캔버스가 항상 최상단에 위치하도록 보장 */
        .upper-canvas { z-index: 2147483601 !important; }

        /* 이미지 도구 팝업 */
        #image-tools-popup { position: fixed; top: 64px; left: 20px; z-index: 2147483647; display: none; flex-direction: column; background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.2); padding: 10px; width: 520px; height: 360px; min-width: 260px; min-height: 160px; pointer-events: auto; user-select: none; font-size: 9pt; /* 패널 전체 기본 폰트 크기 설정 */ }
        #image-tools-popup .popup-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        /* 리사이즈에 대응하는 유연한 콘텐츠 영역 */
        #image-tools-popup .popup-content-area { display: flex; flex-wrap: wrap; align-content: flex-start; gap: 8px; flex: 1 1 auto; overflow: auto; }
        #image-tools-popup .popup-header .title { font-weight: 700; }
        #image-tools-popup .popup-header { cursor: move; user-select: none; }
        #image-tools-popup .popup-section {
            margin-bottom: 0; /* gap으로 대체 */
            border: 1px solid #e8e8e8;
            padding: 6px 8px;
            border-radius: 6px;
            flex: 1 1 150px; /* 3단 그리드 레이아웃을 위한 flex 설정 */
            box-sizing: border-box; /* 패딩과 테두리를 너비에 포함 */
        }
        #image-tools-popup .popup-section-title {
            font-size: 1em; /* 부모 폰트 크기 상속 (9pt) */
            font-weight: bold; /* 제목 강조 */
            color: #555;
            margin-bottom: 4px;
        }
        #image-tools-popup .btn-row { display: flex; flex-wrap: wrap; gap: 6px; }
        #image-tools-popup button { background-color: #f7f7f7; border: 1px solid #ccc; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 1em; /* 부모 폰트 크기 상속 (9pt) */ }
        #image-tools-popup #compression-options label {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 2px 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        #image-tools-popup #compression-options label:has(input:checked) { background-color: #e0e8f8; }
        #image-tools-popup button:hover { background-color: #eee; }
        #toggleImageToolsBtn.active { background-color: #1a73e8; color: #fff; border-color: #1a73e8; }
        /* 인라인 이미지 도구 버튼 숨김 (팝업으로 대체) */
        .inline-image-tool { display: none; }
        #toggleImageToolsBtn { display: none; }
        /* 팝업 리사이즈 핸들 */
        #image-tools-popup .resize-handle { position: absolute; width: 12px; height: 12px; background: rgba(26,115,232,0.9); border-radius: 2px; pointer-events: auto; }
        #image-tools-popup .resize-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        #image-tools-popup .resize-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        #image-tools-popup .resize-handle.e { right: -5px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
        #image-tools-popup .resize-handle.w { left: -5px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
        #image-tools-popup .resize-handle.ne { right: -5px; top: -5px; cursor: nesw-resize; }
        #image-tools-popup .resize-handle.nw { left: -5px; top: -5px; cursor: nwse-resize; }
        #image-tools-popup .resize-handle.se { right: -5px; bottom: -5px; cursor: nwse-resize; }
        #image-tools-popup .resize-handle.sw { left: -5px; bottom: -5px; cursor: nesw-resize; }
        /* 드래그/리사이즈 캡처 오버레이 */
        #ui-drag-overlay { position: fixed; inset: 0; background: transparent; z-index: 2147483646; display: none; cursor: default; pointer-events: all; }
        /* 상단 이벤트 캔버스 포인터 이벤트는 런타임에서 토글로 제어 */

        /* --- 개선사항: 이미지 툴팁 및 확대 보기 --- */
        #image-tooltip {
            display: none;
            position: absolute;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 10pt;
            z-index: 2147483647; /* Always on top */
            pointer-events: none; /* Pass clicks through */
            white-space: nowrap;
        }
        #image-zoom-overlay {
            display: none; /* JS will toggle this */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2147483647; /* Max z-index */
            justify-content: center; align-items: center;
        }
        #image-zoom-overlay.visible { display: flex; }
        #image-zoom-close {
            position: absolute; top: 15px; right: 35px;
            color: #f1f1f1; font-size: 40px; font-weight: bold;
            cursor: pointer; transition: color 0.3s;
        }
        #image-zoom-close:hover { color: #bbb; }
        #image-zoom-content {
            max-width: 90vw; max-height: 90vh;
            object-fit: contain; animation: zoom-in 0.3s ease-out;
        }
        @keyframes zoom-in {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* --- 개선사항: 테이블 전체 화면 보기 --- */
        #fullscreen-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background-color: #ffffff;
            z-index: 2147483645; /* 팝업보다는 아래에 위치 */
            padding: 20px;
            box-sizing: border-box;
            overflow: auto; /* 테이블이 클 경우 스크롤 허용 */
        }
        #fullscreen-close-btn {
            position: fixed;
            top: 15px;
            right: 20px;
            font-size: 40px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            z-index: 2147483646; /* 내용물보다 위에 위치 */
            transition: color 0.3s;
        }
        #fullscreen-close-btn:hover { color: #000; }
        #toggleFullscreenBtn svg { width: 18px; height: 18px; fill: #333; }
        #toggleFullscreenBtn { padding: 5px; } /* 아이콘 버튼이므로 텍스트 버튼과 패딩 다르게 설정 */

        /* --- 개선사항: 주석 UI 위치 및 스타일 --- */
        #toggleAnnotationBtn {
            display: none; /* 평상시 숨김 */
            position: fixed;
            top: 24px;
            left: 20px;
            z-index: 2147483646;
            background-color: #f0f0f0;
            border: 1px solid #cccccc;
            padding: 5px;
            cursor: pointer;
            border-radius: 4px;
        }
         #toggleAnnotationBtn:hover { background-color: #e0e0e0; border-color: #999999; }
         #toggleAnnotationBtn.active { background-color: #1a73e8; color: #fff; border-color: #1a73e8; }
         #toggleAnnotationBtn.active svg { fill: #fff; }
         #toggleAnnotationBtn svg { width: 18px; height: 18px; fill: #333; }

        #annotation-tools-popup {
            display: none;
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 2147483647;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
            user-select: none;
            min-width: 230px; /* 드래그/리사이즈를 위한 최소 크기 설정 */
            min-height: 150px;
        }
        #annotation-tools-popup .popup-header {
            cursor: move;
            padding: 5px 8px;
            background-color: #f7f7f7;
            border-bottom: 1px solid #ddd;
            border-top-left-radius: 7px; /* Match parent */
            border-top-right-radius: 7px;
            margin: -8px -8px 8px -8px; /* Absorb parent padding */
        }
        #annotation-tools-popup .popup-header .title {
            font-weight: bold;
            font-size: 10pt;
            color: #333;
        }
        #annotation-tools-popup .tool-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: wrap;
        }
        #annotation-tools-popup button {
            background-color: #f7f7f7;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }
        #annotation-tools-popup button:hover { background-color: #eee; }
        #annotation-tools-popup button.active { background-color: #d9eaff; border-color: #1a73e8; }
        #annotation-tools-popup button svg { width: 20px; height: 20px; fill: #333; }
        #annotation-tools-popup input[type="color"] {
            width: 32px; height: 32px; border: 1px solid #ccc; padding: 2px;
            box-sizing: border-box; cursor: pointer; border-radius: 4px;
        }
        #annotation-tools-popup .tool-separator {
            width: 1px;
            height: 25px;
            background-color: #ddd;
            margin: 0 4px;
        }
        .upper-canvas { cursor: default; } /* 기본 커서 설정 */

    </style>
</head>
<body>

<div class="grid-container">
    <div class="title-container">
        <span class="s0" contenteditable="true">테이블 작성 양식</span>
        <!-- 개선사항 1: 상단 메뉴 1단 배치 (HTML 순서 변경) -->
        <div id="main-toolbar">
            <div class="editor-group">
                <button id="editor-bold" title="굵게"><svg viewBox="0 0 24 24"><path d="M15.6,10.79c.97-.67,1.65-1.77,1.65-2.79,0-2.26-1.75-4-4.25-4H7v14h7.04c2.1,0,3.71-1.7,3.71-3.78,0-1.52-.86-2.82-2.15-3.43Zm-5.6-4.79h3.4c1.14,0,2.1.92,2.1,2.05,0,1.13-.96,2.05-2.1,2.05h-3.4V6Zm3.54,9H9.5V13h3.04c1.14,0,2.06.92,2.06,2.05,0,1.13-.92,2.04-2.06,2.04Z"></path></svg></button>
                <button id="editor-italic" title="기울임"><svg viewBox="0 0 24 24"><path d="M10,4v3h2.21l-3.42,8H6v3h8v-3h-2.21l3.42-8H18V4Z"></path></svg></button>
                <button id="editor-underline" title="밑줄"><svg viewBox="0 0 24 24"><path d="M12,17c3.31,0,6-2.69,6-6V3h-2.5v8c0,1.93-1.57,3.5-3.5,3.5S8.5,12.93,8.5,11V3H6v8c0,3.31,2.69,6,6,6Zm-7,2v2h14v-2Z"></path></svg></button>
                <button id="editor-link" title="링크 삽입"><svg viewBox="0 0 24 24"><path d="M3.9,12c0-1.71,1.39-3.1,3.1-3.1h4V7H7c-2.76,0-5,2.24-5,5s2.24,5,5,5h4v-1.9H7C5.29,15.1,3.9,13.71,3.9,12z M8,13h8v-2H8V13z M17,7h-4v1.9h4c1.71,0,3.1,1.39,3.1,3.1s-1.39,3.1-3.1,3.1h-4V17h4c2.76,0,5-2.24,5-5S19.76,7,17,7z"></path></svg></button>
                <button id="editor-unlink" title="링크 제거"><svg viewBox="0 0 24 24"><path d="M17,7h-4v1.9h4c1.71,0,3.1,1.39,3.1,3.1s-1.39,3.1-3.1,3.1h-4V17h4c2.76,0,5-2.24,5-5S19.76,7,17,7z M10.1,14.5l-1.5-1.5L14.5,7H17v2.5l-4.4,4.4V17h-2.5L10.1,14.5z M7,15.1c-1.71,0-3.1-1.39-3.1-3.1s1.39-3.1,3.1-3.1h4V7H7c-2.76,0-5,2.24-5,5s2.24,5,5,5h4v-1.9H7z"></path></svg></button>
            </div>
            <div class="editor-separator"></div>
            <div class="editor-group">
                <select id="editor-fontsize" title="글자 크기"><option value="">기본</option><option value="10pt">10pt</option><option value="11pt">11pt</option><option value="12pt">12pt</option><option value="14pt">14pt</option><option value="16pt">16pt</option><option value="18pt">18pt</option><option value="24pt">24pt</option><option value="36pt">36pt</option><option value="48pt">48pt</option><option value="72pt">72pt</option></select>
                <input type="color" id="editor-color" title="글자 색" value="#000000">
                <button id="editor-format-number" title="숫자 서식 (세 자리 쉼표)"><svg viewBox="0 0 24 24"><path d="M7,13V11H21V13H7M7,19V17H21V19H7M7,7V5H21V7H7M3,8V5H6V8H3M3,14V11H6V14H3M3,20V17H6V20H3Z"></path></svg></button>
            </div>
            <div class="editor-separator"></div>
            <div class="editor-group" id="align-h-group">
                <button id="align-left" title="왼쪽 정렬"><svg viewBox="0 0 24 24"><path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"></path></svg></button>
                <button id="align-center" title="가운데 정렬"><svg viewBox="0 0 24 24"><path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"></path></svg></button>
                <button id="align-right" title="오른쪽 정렬"><svg viewBox="0 0 24 24"><path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"></path></svg></button>
            </div>
             <div class="editor-separator"></div>
            <div class="editor-group" id="align-v-group">
                <button id="align-top" title="위쪽 정렬"><svg viewBox="0 0 24 24"><path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"></path></svg></button>
                <button id="align-middle" title="중간 정렬"><svg viewBox="0 0 24 24"><path d="M8 15h3v4h2v-4h3l-4-4-4 4zM4 11v2h16v-2H4zM8 9h3V5h2v4h3l-4 4-4-4z"></path></svg></button>
                <button id="align-bottom" title="아래쪽 정렬"><svg viewBox="0 0 24 24"><path d="M8 13h3V3h2v10h3l-4 4-4-4zM4 21v-2h16v2H4z"></path></svg></button>
            </div>
            <div class="editor-separator"></div>
             <div class="button-group">
                <button id="toggleImageEditBtn" title="이미지 편집 모드 전환">이미지 편집: 끔</button>
                <input type="file" id="excel-file-input" accept=".xls, .xlsx" style="display: none;">
                <button id="importExcelBtn">엑셀 매핑</button>
                <button id="exportExcelBtn">엑셀 추출</button>
                <button id="saveHtmlBtn">HTML 저장</button>
                <button id="toggleFullscreenBtn" title="전체 화면"><svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg></button>
            </div>
        </div>
    </div>

    <div id="ui-drag-overlay"></div>
    
    <div id="image-overlay-container">
        <table id="main-table">
            <colgroup>
                <col style="width: 5%;"> <col style="width: 4%;"> <col style="width: 8%;"> <col style="width: 28%;">
                <col style="width: 7%;"> <col style="width: 7%;"> <col style="width: 5%;"> <col style="width: 31%;">
                <col style="width: 5%;">
            </colgroup>
            <thead>
                <tr>
                    <th title="클릭 후 드래그하여 행 이동">NO.</th><th contenteditable="true" title="클릭 후 드래그하여 열 이동">적용</th><th contenteditable="true" title="클릭 후 드래그하여 열 이동">구분</th><th contenteditable="true" title="클릭 후 드래그하여 열 이동">공사명</th><th contenteditable="true" title="클릭 후 드래그하여 열 이동">투자금액<br>(천원)</th><th contenteditable="true" title="클릭 후 드래그하여 열 이동">입고월<br>(예정)</th><th contenteditable="true" title="클릭 후 드래그하여 열 이동">공종</th><th contenteditable="true" title="클릭 후 드래그하여 열 이동">투자목적 및 기대효과</th><th contenteditable="true" title="클릭 후 드래그하여 열 이동">비고</th>
                </tr>
            </thead>
            <tbody>
                <tr><td class="no-cell" title="클릭 후 드래그하여 행 이동"></td><td class="checkbox-cell"></td><td contenteditable="true"></td><td contenteditable="true"></td><td class="currency-cell" contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td></tr>
            </tbody>
        </table>
        <canvas id="overlay-canvas"></canvas>
    </div>
    <!-- 이미지 도구 팝업: 순서 재배치(선택 → 정렬 → 크기/배치 → 레이어 → 스냅설정) -->
    <div id="image-tools-popup" role="dialog" aria-modal="true" aria-labelledby="image-tools-title" tabindex="0">
        <div class="popup-header">
            <span class="title" id="image-tools-title">이미지 도구</span>
            <button id="closeImageToolsBtn" title="닫기">닫기</button>
        </div>
        <div class="popup-content-area">
             <div class="popup-section">
                <div class="popup-section-title">이미지 추가</div>
                <div class="btn-row">
                     <input type="file" id="image-file-input" accept="image/*" multiple style="display: none;"> <button id="addImageBtn">이미지 추가</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">이미지 업로드 설정</div>
                <div class="btn-row" id="compression-options">
                    <label><input type="radio" name="compression-level" value="high"> 고화질</label>
                    <label><input type="radio" name="compression-level" value="medium"> 표준</label>
                    <label><input type="radio" name="compression-level" value="low" checked> 저용량</label>
                </div>
                <div id="compression-status" style="font-size: 9pt; color: #666; margin-top: 4px; min-height: 1.2em;"></div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">선택</div>
                <div class="btn-row">
                    <button id="selectAllImagesBtn">모든 이미지 선택</button>
                    <button id="clearSelectionBtn">선택 해제</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">정렬</div>
                <div class="btn-row">
                    <button id="imgAlignLeft">좌</button>
                    <button id="imgAlignCenterH">가중</button>
                    <button id="imgAlignRight">우</button>
                    <button id="imgAlignTop">상</button>
                    <button id="imgAlignMiddleV">세중</button>
                    <button id="imgAlignBottom">하</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">레이어 순서</div>
                <div class="btn-row">
                    <button id="bringToFrontBtn">맨 앞으로</button>
                    <button id="bringForwardBtn">앞으로</button>
                    <button id="sendBackwardsBtn">뒤로</button>
                    <button id="sendToBackBtn">맨 뒤로</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">크기 / 배치</div>
                <div class="btn-row">
                    <button id="sameWidthBtn">폭 동일</button>
                    <button id="sameHeightBtn">높이 동일</button>
                    <button id="sameSizeBtn">크기 동일</button>
                    <button id="distributeHBtn">간격 균등 가로</button>
                    <button id="distributeVBtn">간격 균등 세로</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">셀 연동</div>
                <div class="btn-row">
                    <button id="attachToCellBtn" title="선택한 이미지를 선택한 표의 셀에 맞춥니다.">선택 셀에 맞춤</button>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">스냅/가이드 설정</div>
                <div class="btn-row">
                    <label>스냅(px) <input type="number" id="snapGridInput" value="5" min="0" style="width:64px"></label>
                    <label>허용오차(px) <input type="number" id="guideToleranceInput" value="4" min="0" style="width:64px"></label>
                    <label>가이드색 <input type="color" id="guideColorInput" value="#ff0000"></label>
                </div>
            </div>
            <div class="popup-section">
                <div class="popup-section-title">잠금</div>
                <div class="btn-row">
                    <button id="lockLayerBtn">선택 잠금</button>
                    <button id="unlockLayerBtn">전체 해제</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="context-menu">
    <ul>
        <li id="insert-row-above">위에 행 삽입</li> <li id="insert-row-below">아래에 행 삽입</li> <li id="delete-row">행 삭제</li>
        <li class="separator"></li>
        <li id="insert-col-left">왼쪽에 열 삽입</li> <li id="insert-col-right">오른쪽에 열 삽입</li> <li id="delete-col">열 삭제</li>
        <li class="separator"></li>
        <li id="set-row-height">행 높이 설정...</li>
        <li id="set-col-width">열 너비 설정...</li>
    </ul>
</div>

<!-- 개선사항: 이미지 확대 보기용 오버레이 -->
<div id="image-zoom-overlay">
    <span id="image-zoom-close" title="닫기">&times;</span>
    <img id="image-zoom-content" src="">
</div>
<!-- 개선사항: 이미지 호버 툴팁 -->
<div id="image-tooltip"></div>

<!-- 개선사항: 테이블 전체 화면 보기용 오버레이 -->
<div id="fullscreen-overlay">
    <!-- 주석 토글 버튼을 전체화면 오버레이 안으로 이동 -->
    <button id="toggleAnnotationBtn" title="주석 모드"><svg viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z"></path></svg></button>
    <span id="fullscreen-close-btn" title="닫기">&times;</span>
    <div id="fullscreen-content"></div>
</div>

<!-- 개선사항: 주석 및 메모 기능용 도구 팝업 -->
<div id="annotation-tools-popup">
    <div class="popup-header">
        <span class="title">주석 도구</span>
    </div>
    <div class="tool-group">
        <button id="anno-select" title="이동/선택"><svg viewBox="0 0 24 24"><path d="M13.5,4.2C13.5,4.2 13.5,4.2 13.5,4.2L15.6,8.4L20.2,9L16.8,12.3L17.7,16.8L13.5,14.5L9.3,16.8L10.2,12.3L6.8,9L11.4,8.4L13.5,4.2M13.5,2L11,7.5L5,8.5L9.5,12.5L8,18.5L13.5,15.5L19,18.5L17.5,12.5L22,8.5L16,7.5L13.5,2Z"></path></svg></button>
        <button id="anno-pen" title="펜"><svg viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z"></path></svg></button>
        <button id="anno-line" title="직선"><svg viewBox="0 0 24 24"><path d="M4,11V13H19.95L18.47,15.47L19.88,16.88L23.71,12L19.88,7.12L18.47,8.53L19.95,11H4Z" transform="rotate(45 12 12)" /></svg></button>
        <button id="anno-arrow" title="화살표"><svg viewBox="0 0 24 24"><path d="M5,17.59L15.59,7H9V5H19V15H17V8.41L6.41,19L5,17.59Z"></path></svg></button>
        <button id="anno-rect" title="사각형"><svg viewBox="0 0 24 24"><path d="M19,3H5C3.89,3 3,3.89 3,5V19C3,20.11 3.9,21 5,21H19C20.11,21 21,20.11 21,19V5C21,3.89 20.11,3 19,3M19,19H5V5H19V19Z"></path></svg></button>
        <button id="anno-circle" title="원"><svg viewBox="0 0 24 24"><path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20Z"></path></svg></button>
    </div>
    <div class="tool-group">
        <input type="color" id="anno-color" title="선 색상" value="#FF0000">
        <input type="range" id="anno-width" title="선 굵기" min="1" max="30" value="5" style="width: 120px;">
    </div>
    <div class="tool-group">
        <button id="anno-memo" title="메모 삽입"><svg viewBox="0 0 24 24"><path d="M20,2H4C2.9,2 2,2.9 2,4V22L6,18H20C21.1,18 22,17.1 22,16V4C22,2.9 21.1,2 20,2M20,16H5.2L4,17.2V4H20V16Z"></path></svg></button>
        <div class="tool-separator"></div>
        <button id="anno-eraser" title="지우개 (객체 클릭)"><svg viewBox="0 0 24 24"><path d="M16.24,3.56L21.19,8.5C21.58,8.89 21.58,9.5 21.19,9.9L12.1,19H3V9.9L16.24,3.56M9.9,17H5V11.9L14.09,2.8L19.2,7.9L9.9,17Z"></path></svg></button>
        <button id="anno-clear" title="모두 지우기"><svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19C6,20.1 6.9,21 8,21H16C17.1,21 18,20.1 18,19V7H6V19Z"></path></svg></button>
    </div>
</div>


<script id="canvas-data" type="application/json"></script>

<!-- 라이브러리 로드 -->
<script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.1/dist/browser-image-compression.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- 1. 요소 및 변수 초기화 ---
    const table = document.getElementById('main-table');
    const imageOverlayContainer = document.getElementById('image-overlay-container');
    // --- 이미지 편집 상태 변수 ---
    let isImageEditMode = false;
    let isCropping = false;
    let cropTargetImage = null;
    let cropRect = null;    const fabricCanvas = new fabric.Canvas('overlay-canvas', {
        enableRetinaScaling: false,
        objectCaching: false,
        selection: true,
        preserveObjectStacking: true,
        willReadFrequently: true, // Canvas2D 성능 경고 해결
    });
    // 기본 모드에서는 상단 이벤트 캔버스가 테이블 편집을 방해하지 않도록 포인터 이벤트 비활성화
    if (fabricCanvas && fabricCanvas.upperCanvasEl) {
        fabricCanvas.upperCanvasEl.style.pointerEvents = 'none';
    }
    const addImageBtn = document.getElementById('addImageBtn');
    const imageFileInput = document.getElementById('image-file-input');
    const lockLayerBtn = document.getElementById('lockLayerBtn');
    const unlockLayerBtn = document.getElementById('unlockLayerBtn');

    function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
    }
    let _clipboard = null;
    let selectedCells = [], contextTargetCell = null, currencyColIndex = -1, checkboxColIndex = -1;

    function findSpecialColumns() {
        const headers = Array.from(table.querySelectorAll('thead th'));
        currencyColIndex = headers.findIndex(th => th.innerText.includes('투자금액'));
        checkboxColIndex = headers.findIndex(th => th.innerText.includes('적용'));
    }

    // --- 2 & 3. 셀 선택, 텍스트 편집 (기존과 동일) ---
    function clearSelection() { selectedCells.forEach(cell => cell.classList.remove('cell-selected')); selectedCells = []; updateEditorUI(); }
    function addCellToSelection(cell) { if (!selectedCells.includes(cell) && !cell.classList.contains('no-cell') && cell.tagName === 'TD') { selectedCells.push(cell); cell.classList.add('cell-selected'); } }
    function updateEditorUI() {
        document.querySelectorAll('#main-toolbar .editor-group button.active').forEach(b => b.classList.remove('active'));
        if (selectedCells.length === 0) return;
        const firstCell = selectedCells[0]; const style = window.getComputedStyle(firstCell);
        document.querySelector(`#align-${style.textAlign}`)?.classList.add('active');
        document.querySelector(`#align-${style.verticalAlign}`)?.classList.add('active');
        if (style.fontWeight === '700' || style.fontWeight === 'bold') document.getElementById('editor-bold').classList.add('active');
        if (style.fontStyle === 'italic') document.getElementById('editor-italic').classList.add('active');
        if (style.textDecorationLine.includes('underline')) document.getElementById('editor-underline').classList.add('active');

        const fontSizeSelect = document.getElementById('editor-fontsize');
        // 셀에 직접 적용된 스타일('pt' 단위)을 우선적으로 반영합니다.
        if (firstCell.style.fontSize && Array.from(fontSizeSelect.options).some(opt => opt.value === firstCell.style.fontSize)) {
            fontSizeSelect.value = firstCell.style.fontSize;
        } else {
            // 직접 적용된 스타일이 없으면, 계산된 스타일(px)을 가장 가까운 pt 옵션으로 변환하여 반영합니다.
            const pxSize = parseFloat(style.fontSize);
            const ptSize = Math.round(pxSize * 0.75); // px to pt 근사치 변환
            let closestVal = "";
            let minDiff = Infinity;
            for (const opt of fontSizeSelect.options) {
                if (opt.value) {
                    const optPt = parseInt(opt.value, 10);
                    const diff = Math.abs(optPt - ptSize);
                    if (diff < minDiff) { minDiff = diff; closestVal = opt.value; }
                }
            }
            // 근사치가 1pt 이내일 경우에만 값으로 인정하여 UI에 반영합니다.
            fontSizeSelect.value = minDiff <= 1 ? closestVal : "";
        }
        document.getElementById('editor-color').value = firstCell.style.color ? rgbToHex(firstCell.style.color) : rgbToHex(style.color);
    }
    table.addEventListener('click', function(e) {
        if (isAnnotationMode) return; // [개선] 주석 모드일 때는 테이블 셀 선택/편집 로직을 실행하지 않음
        const link = e.target.closest('a');
        if (link && link.href) { e.preventDefault(); e.stopPropagation(); window.open(link.href, '_blank', 'noopener,noreferrer'); return; }
        const headerCell = e.target.closest('th'); const targetCell = e.target.closest('td');
        if (targetCell && targetCell.classList.contains('checkbox-cell')) { e.preventDefault(); targetCell.innerText = targetCell.innerText === '✓' ? '' : '✓'; return; }
        if (headerCell) {
            e.preventDefault(); clearSelection(); const colIndex = headerCell.cellIndex;
            if (colIndex === 0) { table.querySelectorAll('tbody td:not(.no-cell)').forEach(cell => addCellToSelection(cell)); } 
            else { table.querySelectorAll('tbody tr').forEach(row => { if (row.cells[colIndex]) addCellToSelection(row.cells[colIndex]); }); }
            updateEditorUI(); return;
        }
        if (targetCell && targetCell.classList.contains('no-cell')) { e.preventDefault(); clearSelection(); const row = targetCell.closest('tr'); Array.from(row.cells).forEach(cell => addCellToSelection(cell)); updateEditorUI(); return; }
        if (targetCell) {
             if (!e.ctrlKey && !e.metaKey && !e.shiftKey) { clearSelection(); addCellToSelection(targetCell); } 
             else if (e.ctrlKey || e.metaKey) {
                if (selectedCells.includes(targetCell)) { targetCell.classList.remove('cell-selected'); selectedCells = selectedCells.filter(c => c !== targetCell); } 
                else { addCellToSelection(targetCell); }
            } else if (e.shiftKey && selectedCells.length > 0) {
                const allCells = Array.from(table.querySelectorAll('td:not(.no-cell)'));
                const firstIndex = allCells.indexOf(selectedCells[0]); const lastIndex = allCells.indexOf(targetCell);
                clearSelection();
                const start = Math.min(firstIndex, lastIndex), end = Math.max(firstIndex, lastIndex);
                for (let i = start; i <= end; i++) { addCellToSelection(allCells[i]); }
            }
            updateEditorUI();
        }
    });
    function applyStyle(style, value) {
        // 브라우저가 <font> 태그 대신 <span style="...">을 사용하도록 강제합니다.
        // 이렇게 하면 스타일을 여러 번 변경해도 안정적으로 적용됩니다.
        document.execCommand('styleWithCSS', false, true);

        const selection = window.getSelection();
        const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
        
        // 사용자가 특정 텍스트를 선택했는지, 그리고 그 선택이 테이블 셀 안에 있는지 확인합니다.
        const isTextSelectedInCell = range && !range.collapsed && range.commonAncestorContainer.parentElement.closest('td[contenteditable="true"]');

        if (isTextSelectedInCell) {
            // fontSize, foreColor는 execCommand의 신뢰도가 낮아, 중첩 스타일링 문제를 피하기 위해 fontName 핵을 사용합니다.
            if (style === 'fontSize' || style === 'foreColor') {
                const cssProperty = style === 'fontSize' ? 'fontSize' : 'color';
                const dummyFont = `_dummy_${Date.now()}`;
                document.execCommand('fontName', false, dummyFont);
                
                const fonts = table.querySelectorAll(`font[face="${dummyFont}"]`);
                fonts.forEach(font => {
                    const span = document.createElement('span');
                    span.style[cssProperty] = value;
                    while (font.firstChild) {
                        span.appendChild(font.firstChild);
                    }
                    font.parentNode.replaceChild(span, font);
                });
            } else {
                // bold, italic, underline 등은 execCommand가 비교적 안정적으로 토글됩니다.
                document.execCommand(style, false, value);
            }
        } else if (selectedCells.length > 0) {
            // 특정 텍스트 선택 없이 셀만 선택된 경우, 선택된 모든 셀에 스타일을 적용합니다.
            selectedCells.forEach(cell => {
                // fontSize와 foreColor는 셀 자체에 스타일을 적용하는 것이 가장 안정적입니다.
                if (style === 'fontSize') {
                    cell.style.fontSize = value;
                } else if (style === 'foreColor') {
                    cell.style.color = value;
                } else {
                    // bold, italic 등은 execCommand를 사용해야 셀 내부의 부분적인 스타일을 토글할 수 있습니다.
                    const tempRange = document.createRange();
                    tempRange.selectNodeContents(cell);
                    selection.removeAllRanges();
                    selection.addRange(tempRange);
                    document.execCommand(style, false, value);
                }
            });
            if (selection) selection.removeAllRanges();
        }
        updateEditorUI();
    }
    function applyAlignment(property, value) { if (selectedCells.length === 0) { alert("정렬할 셀을 먼저 선택해주세요."); return; } selectedCells.forEach(cell => { cell.style[property] = value; }); updateEditorUI(); }
    
    // 숫자 서식 적용/제거 시 HTML 태그(스타일)를 보존하기 위해 DOM 순회 방식 사용
    function removeNumberFormatting(cell) {
        function unformatNode(node) {
            if (node.nodeType === 3) { // Node.TEXT_NODE
                node.nodeValue = node.nodeValue.replace(/,/g, '');
            } else if (node.nodeType === 1 && node.childNodes) { // Node.ELEMENT_NODE
                node.childNodes.forEach(unformatNode);
            }
        }
        unformatNode(cell);
    }
    function updateNumberFormatting(cell) {
        function formatNode(node) {
            if (node.nodeType === 3) { // Node.TEXT_NODE
                const num = parseFloat(node.nodeValue.replace(/,/g, ''));
                if (!isNaN(num)) {
                    node.nodeValue = num.toLocaleString('en-US');
                }
            } else if (node.nodeType === 1 && node.childNodes) { // Node.ELEMENT_NODE
                node.childNodes.forEach(formatNode);
            }
        }
        formatNode(cell);
    }
    table.addEventListener('focusin', (e) => { if (e.target.matches('.currency-cell')) { removeNumberFormatting(e.target); } });
    table.addEventListener('focusout', (e) => { if (e.target.matches('.currency-cell')) { updateNumberFormatting(e.target); } });
    function formatAllCurrencyCells() { if (currencyColIndex === -1) return; table.querySelectorAll(`tbody td:nth-child(${currencyColIndex + 1})`).forEach(cell => { updateNumberFormatting(cell); }); }

    // 에디터 버튼 리스너를 통합 관리하고, mousedown에서 preventDefault를 호출하여
    // 버튼 클릭 시 테이블의 텍스트 선택이 해제되는 것을 방지합니다.
    function addEditorButtonListener(id, event, callback) {
        const element = document.getElementById(id);
        if (!element) return;
        // 버튼 요소에만 mousedown 기본 동작을 막아 포커스 이동을 방지합니다.
        // select, input 요소는 기본 동작(드롭다운 열기, 색상 선택기 열기)이 필요하므로 예외 처리합니다.
        if (element.tagName === 'BUTTON') {
            element.addEventListener('mousedown', e => e.preventDefault());
        }
        element.addEventListener(event, callback);
    }

    addEditorButtonListener('editor-bold', 'click', () => applyStyle('bold'));
    addEditorButtonListener('editor-italic', 'click', () => applyStyle('italic'));
    addEditorButtonListener('editor-underline', 'click', () => applyStyle('underline'));
    addEditorButtonListener('editor-fontsize', 'change', (e) => applyStyle('fontSize', e.target.value));
    addEditorButtonListener('editor-color', 'input', (e) => applyStyle('foreColor', e.target.value));
    addEditorButtonListener('editor-format-number', 'click', () => {
        if (selectedCells.length === 0) { alert("서식을 적용할 셀을 먼저 선택해주세요."); return; }

        // 첫 번째 선택된 셀을 기준으로 모든 셀에 동일한 작업을 수행합니다.
        const isCurrency = selectedCells[0].classList.contains('currency-cell');

        if (isCurrency) {
            // 현재 숫자 서식이 적용된 셀이므로, 서식을 해제합니다.
            selectedCells.forEach(cell => { cell.classList.remove('currency-cell'); removeNumberFormatting(cell); });
        } else {
            // 일반 셀이므로, 숫자 서식을 적용합니다.
            selectedCells.forEach(cell => { cell.classList.add('currency-cell'); updateNumberFormatting(cell); });
        }
    });
    addEditorButtonListener('align-left', 'click', () => applyAlignment('textAlign', 'left'));
    addEditorButtonListener('align-center', 'click', () => applyAlignment('textAlign', 'center'));
    addEditorButtonListener('align-right', 'click', () => applyAlignment('textAlign', 'right'));
    addEditorButtonListener('align-top', 'click', () => applyAlignment('verticalAlign', 'top'));
    addEditorButtonListener('align-middle', 'click', () => applyAlignment('verticalAlign', 'middle'));
    addEditorButtonListener('align-bottom', 'click', () => applyAlignment('verticalAlign', 'bottom'));

    function addLinkButtonListener(buttonId, command, promptMessage = null) {
        document.getElementById(buttonId).addEventListener('mousedown', (e) => {
            e.preventDefault(); const selection = window.getSelection(); if (selection.rangeCount === 0) return; let value = null;
            if (promptMessage) {
                const range = selection.getRangeAt(0);
                if (range.collapsed && command === 'createLink') { alert("링크를 적용할 텍스트를 먼저 드래그하여 선택해주세요."); return; }
                value = prompt(promptMessage, "https://"); if (!value) return; 
            }
            document.execCommand(command, false, value);
        });
    }
    addLinkButtonListener('editor-link', 'createLink', '링크할 URL을 입력하세요:');
    addLinkButtonListener('editor-unlink', 'unlink');
    function rgbToHex(rgb) {
        if (!rgb || !/^rgb/.test(rgb)) return '#000000';
        let parts = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/); if (!parts) return '#000000';
        delete(parts[0]); let hex = "#";
        for (let i = 1; i <= 3; ++i) { let part = parseInt(parts[i]).toString(16); hex += (part.length == 1) ? '0' + part : part; }
        return hex;
    }

    // --- 4. 파일 I/O (기존과 동일) ---
    document.getElementById('saveHtmlBtn').addEventListener('click', async () => {
        // 저장 직전 최신 크기와 상태 반영
        syncCanvasSize();
        const clonedDoc = document.documentElement.cloneNode(true);
        clonedDoc.querySelectorAll('.cell-selected').forEach(cell => cell.classList.remove('cell-selected'));
        const canvasDataScript = clonedDoc.querySelector('#canvas-data');
        if (canvasDataScript) { canvasDataScript.textContent = JSON.stringify(fabricCanvas.toJSON(['persistentTop'])); } // persistentTop 속성 저장

        // 외부 스크립트를 인라인으로 치환하여 '단일 HTML'로 동작하도록 처리
        const externalScripts = Array.from(clonedDoc.querySelectorAll('script[src]'));
        if (externalScripts.length > 0) {
            try {
                const fetched = await Promise.all(externalScripts.map(async (s) => {
                    try {
                        const res = await fetch(s.src, { cache: 'no-cache' });
                        const code = await res.text();
                        return { node: s, code };
                    } catch (err) {
                        console.warn('스크립트 인라인 실패:', s.src, err);
                        return { node: s, code: null };
                    }
                }));
                fetched.forEach(item => {
                    const { node, code } = item;
                    if (!code) return; // 실패 시 원본 src 유지(네트워크 환경에 따라)
                    node.removeAttribute('src');
                    node.textContent = code;
                });
            } catch (e) {
                console.warn('외부 스크립트 인라인 과정에서 예외 발생:', e);
            }
        }

        const pageHTML = '<!DOCTYPE html>\n' + clonedDoc.outerHTML;
        const blob = new Blob([pageHTML], { type: 'text/html;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); a.download = '테이블_양식_이미지포함.html'; a.click(); URL.revokeObjectURL(a.href);
    });

    document.getElementById('exportExcelBtn').addEventListener('click', () => {
        const wb = XLSX.utils.table_to_book(table, { sheet: "테이블 양식" });
        XLSX.writeFile(wb, "테이블_양식.xlsx");
    });
    document.getElementById('importExcelBtn').addEventListener('click', () => document.getElementById('excel-file-input').click());
    document.getElementById('excel-file-input').addEventListener('change', (e) => {
        const file = e.target.files[0]; if (!file) return; const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = new Uint8Array(event.target.result); const workbook = XLSX.read(data, { type: 'array' });
                const sheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                populateTableWithData(jsonData); alert('엑셀 데이터를 성공적으로 매핑했습니다.');
            } catch (error) { console.error("엑셀 파일 처리 중 오류:", error); alert('엑셀 파일을 처리하는 중 오류가 발생했습니다.'); } 
            finally { e.target.value = ''; }
        };
        reader.readAsArrayBuffer(file);
    });
     function populateTableWithData(data) {
        if (!data || data.length < 1) { alert('매핑할 데이터가 없습니다.'); return; }
        const thead = table.tHead, tbody = table.tBodies[0];
        const excelHeaders = data[0].map(h => String(h).replace(/\n/g, ' ').trim());
        const tableHeaders = Array.from(thead.rows[0].cells);

        const columnIndexMap = new Array(tableHeaders.length);
        const matchedHeaders = [];
        const unmatchedTableHeaders = [];

        // 1. 엑셀 헤더와 테이블 헤더를 비교하여 매핑 정보를 생성합니다.
        tableHeaders.forEach((th, tableIndex) => {
            if (tableIndex === 0) { columnIndexMap[tableIndex] = -1; return; } // 'NO.' 열은 건너뜀
            const tableHeaderText = th.innerText.replace(/\n/g, ' ').trim();
            const excelIndex = excelHeaders.findIndex(eh => eh === tableHeaderText);
            columnIndexMap[tableIndex] = excelIndex; // 찾지 못하면 -1이 저장됨
            if (excelIndex !== -1) { matchedHeaders.push(tableHeaderText); } 
            else { unmatchedTableHeaders.push(tableHeaderText); }
        });

        // 2. 매핑된 헤더가 하나도 없으면 사용자에게 알리고 중단합니다.
        if (matchedHeaders.length === 0) {
            alert('일치하는 헤더가 하나도 없어 매핑을 중단합니다.\n엑셀 파일의 헤더를 확인해주세요.');
            return;
        }

        // 3. 매핑 정보를 기반으로 테이블 데이터를 채웁니다.
        tbody.innerHTML = '';
        const dataRows = data.slice(1);
        dataRows.forEach(rowData => {
            const newRow = tbody.insertRow();
            tableHeaders.forEach((th, tableIndex) => {
                const cell = newRow.insertCell(tableIndex);
                if (tableIndex === 0) { cell.classList.add('no-cell'); return; }
                const excelIndex = columnIndexMap[tableIndex];
                const cellValue = (excelIndex !== -1 && rowData[excelIndex] !== undefined) ? rowData[excelIndex] : '';
                if (tableIndex === checkboxColIndex) { cell.classList.add('checkbox-cell'); cell.innerText = cellValue === '✓' ? '✓' : ''; } 
                else {
                    cell.contentEditable = 'true';
                    // 엑셀의 줄바꿈(\n)을 HTML의 줄바꿈(<br>)으로 변환하여 매핑합니다.
                    cell.innerHTML = String(cellValue).replace(/\n/g, '<br>');
                    if (tableIndex === currencyColIndex) { cell.classList.add('currency-cell'); }
                }
            });
        });

        // 4. 테이블 상태를 업데이트하고 사용자에게 결과를 요약하여 알립니다.
        updateRowNumbers(); updateCellIds(); initializeResizableTable(); formatAllCurrencyCells(); clearSelection(); updateAllAttachedImages();
        let summaryMessage = '엑셀 데이터 매핑이 완료되었습니다.\n';
        if (matchedHeaders.length > 0) { summaryMessage += `\n- 매핑된 열 (${matchedHeaders.length}개): \n  ${matchedHeaders.join(', ')}`; }
        if (unmatchedTableHeaders.length > 0) { summaryMessage += `\n\n- 헤더 불일치로 건너뛴 열 (${unmatchedTableHeaders.length}개): \n  ${unmatchedTableHeaders.join(', ')}`; }
        alert(summaryMessage);
    }
    
    // --- 5, 6, 7. 테이블/행/열/컨텍스트 메뉴 관리 (기존과 동일) ---
    function attachColResizer(th, colIndex) {
        if (th.querySelector('.resizer-col')) th.querySelector('.resizer-col').remove();
        const resizer = document.createElement('div'); resizer.className = 'resizer-col'; th.appendChild(resizer);
        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault(); e.stopPropagation(); let startX = e.pageX; const colElement = table.querySelector('colgroup').children[colIndex]; let startWidth = colElement.offsetWidth;
            const onMouseMove = (moveEvent) => { const newWidth = startWidth + (moveEvent.pageX - startX); if (newWidth > 30) { colElement.style.width = newWidth + 'px'; updateAllAttachedImages(); } };
            const onMouseUp = () => document.removeEventListener('mousemove', onMouseMove); document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp, { once: true });
        });
    }
    function attachRowResizer(row) {
        if (row.querySelector('.resizer-row')) row.querySelector('.resizer-row').remove();
        const resizer = document.createElement('div'); resizer.className = 'resizer-row'; row.appendChild(resizer);
        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault(); e.stopPropagation(); let startY = e.pageY; let startHeight = row.offsetHeight;
            const onMouseMove = (moveEvent) => { const newHeight = startHeight + (moveEvent.pageY - startY); if (newHeight > 30) { row.style.height = newHeight + 'px'; updateAllAttachedImages(); } };
            const onMouseUp = () => document.removeEventListener('mousemove', onMouseMove); document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp, { once: true });
        });
    }
    function initializeResizableTable() { table.querySelectorAll('thead th').forEach((th, i) => attachColResizer(th, i)); table.querySelectorAll('tbody tr').forEach(row => attachRowResizer(row)); ensureCanvasOnTop(); }
    function updateRowNumbers() { table.querySelectorAll('tbody tr').forEach((row, index) => { const noCell = row.cells[0]; if (noCell) { noCell.innerText = index + 1; } }); }
    function insertRow(index, above = true) { const tbody = table.tBodies[0]; const colCount = table.rows[0].cells.length; const targetIndex = above ? index : index + 1; const newRow = tbody.insertRow(targetIndex);
    const noCell = newRow.insertCell(0);
    noCell.classList.add('no-cell');
    noCell.title = '클릭 후 드래그하여 행 이동';
    for (let i = 1; i < colCount; i++) { const newCell = newRow.insertCell(i); if (i === checkboxColIndex) { newCell.classList.add('checkbox-cell'); } else { newCell.contentEditable = 'true'; if (i === currencyColIndex) { newCell.classList.add('currency-cell'); } } } attachRowResizer(newRow); updateRowNumbers(); syncCanvasSize(); ensureCanvasOnTop(); updateOverlayPosition(); }
    function deleteRow(index) { if (table.tBodies[0].rows.length > 1) { table.tBodies[0].deleteRow(index); updateRowNumbers(); updateCellIds(); syncCanvasSize(); ensureCanvasOnTop(); updateOverlayPosition(); updateAllAttachedImages(); } else { alert("마지막 행은 삭제할 수 없습니다."); } }
    function insertColumn(index, before = true) { if (index === 0 && before) { alert("'NO.' 열의 왼쪽에 열을 추가할 수 없습니다."); return; } const targetIndex = before ? index : index + 1; table.querySelector('colgroup').children[targetIndex-1].insertAdjacentHTML('afterend', '<col style="width: 10%;">'); table.tHead.rows[0].cells[targetIndex-1].insertAdjacentHTML('afterend', '<th contenteditable="true">새 항목</th>'); Array.from(table.tBodies[0].rows).forEach(row => { row.cells[targetIndex-1].insertAdjacentHTML('afterend', '<td contenteditable="true"></td>'); }); findSpecialColumns(); updateCellIds(); initializeResizableTable(); syncCanvasSize(); ensureCanvasOnTop(); updateOverlayPosition(); updateAllAttachedImages(); }
    function deleteColumn(index) { if (index === 0) { alert("'NO.' 열은 삭제할 수 없습니다."); return; } if (table.rows[0].cells.length > 2) { table.querySelector('colgroup').children[index].remove(); Array.from(table.rows).forEach(row => row.deleteCell(index)); findSpecialColumns(); updateCellIds(); initializeResizableTable(); syncCanvasSize(); ensureCanvasOnTop(); updateOverlayPosition(); updateAllAttachedImages(); } else { alert("마지막 항목 열은 삭제할 수 없습니다."); } }
    const contextMenu = document.getElementById('context-menu'); table.addEventListener('contextmenu', (e) => {
        e.preventDefault(); const target = e.target.closest('td, th'); if (!target) return;
        contextTargetCell = target;
        const isNoColumn = contextTargetCell.cellIndex === 0;
        const isTbody = contextTargetCell.closest('tbody');
        document.getElementById('delete-col').style.display = isNoColumn ? 'none' : 'block'; document.getElementById('insert-col-left').style.display = isNoColumn ? 'none' : 'block';
        document.getElementById('set-row-height').style.display = isTbody ? 'block' : 'none'; document.getElementById('set-col-width').style.display = !isNoColumn ? 'block' : 'none';
        contextMenu.style.display = 'block'; contextMenu.style.left = `${e.pageX}px`; contextMenu.style.top = `${e.pageY}px`; ensureCanvasOnTop(); updateOverlayPosition();
    });
    document.addEventListener('click', (e) => {
        if (!contextMenu.contains(e.target) && !e.target.closest('#main-toolbar')) { contextMenu.style.display = 'none'; }
        const clickedInsideOverlay = fabricCanvas.upperCanvasEl && fabricCanvas.upperCanvasEl.contains(e.target);
        const clickedInsideImageTools = !!e.target.closest('#image-tools-popup') || !!e.target.closest('#toggleImageEditBtn');
        const clickedInsideAnnotationTools = !!e.target.closest('#annotation-tools-popup') || !!e.target.closest('#toggleAnnotationBtn');
        if (!table.contains(e.target)
            && !document.getElementById('main-toolbar').contains(e.target)
            && !contextMenu.contains(e.target)
            && !clickedInsideOverlay
            && !clickedInsideImageTools
            && !clickedInsideAnnotationTools) {
            clearSelection(); fabricCanvas.discardActiveObject().renderAll();
        }
    });
    contextMenu.addEventListener('click', (e) => {
        if (!contextTargetCell) return; const cellIndex = contextTargetCell.cellIndex; const tr = contextTargetCell.closest('tr'); const rowIndex = Array.from(tr.parentNode.children).indexOf(tr);
        switch (e.target.id) {
            case 'insert-row-above': if (tr.parentNode.tagName === 'TBODY') insertRow(rowIndex, true); break;
            case 'insert-row-below': if (tr.parentNode.tagName === 'TBODY') insertRow(rowIndex, false); break;
            case 'delete-row': if (contextTargetCell.tagName === 'TD') deleteRow(rowIndex); break;
            case 'insert-col-left': insertColumn(cellIndex, true); break;
            case 'insert-col-right': insertColumn(cellIndex, false); break;
            case 'delete-col': deleteColumn(cellIndex); break;
            case 'set-row-height':
                if (tr && tr.parentNode.tagName === 'TBODY') {
                    const currentHeight = tr.offsetHeight; const newHeightStr = prompt('새로운 행 높이를 입력하세요 (px 단위):', currentHeight);
                    if (newHeightStr) { const newHeight = parseFloat(newHeightStr); if (!isNaN(newHeight) && newHeight > 0) { tr.style.height = newHeight + 'px'; updateAllAttachedImages(); } else { alert('유효한 숫자를 입력해주세요.'); } }
                } break;
            case 'set-col-width':
                if (cellIndex > 0) {
                    const colElement = table.querySelector('colgroup').children[cellIndex]; const currentWidth = colElement.offsetWidth; const newWidthStr = prompt('새로운 열 너비를 입력하세요 (px 단위):', currentWidth);
                    if (newWidthStr) { const newWidth = parseFloat(newWidthStr); if (!isNaN(newWidth) && newWidth > 0) { colElement.style.width = newWidth + 'px'; updateAllAttachedImages(); } else { alert('유효한 숫자를 입력해주세요.'); } }
                } break;
        }
        contextMenu.style.display = 'none';
    });

    // ★★★★★ 수정 및 개선된 부분: 이미지 오버레이 기능 구현 ★★★★★

    // 모든 셀에 고유 ID 부여 (행/열 변경 시 호출 필요)
    function updateCellIds() {
        table.querySelectorAll('tbody tr').forEach((row, rowIndex) => {
            row.querySelectorAll('td').forEach((cell, colIndex) => {
                cell.id = `cell-${rowIndex}-${colIndex}`;
            });
        });
    }
    function ensureCanvasOnTop() {
        // [개선] 캔버스 요소를 body로 옮기지 않고, 부모 컨테이너(imageOverlayContainer) 내에 유지합니다.
        // 이렇게 하면 전체 화면 모드에서 캔버스가 테이블과 함께 올바르게 이동하여 주석 기능이 정상 작동합니다.
        // 캔버스의 z-index는 CSS에서 이미 높게 설정되어 있어 대부분의 경우 충분합니다.
        // 캔버스의 위치는 updateOverlayPosition에서 관리합니다.
        updateOverlayPosition(); // 위치 업데이트는 계속 호출합니다.
    }

    function ensureToolsPopupOnTop() {
        const popup = document.getElementById('image-tools-popup');
        if (!popup) return;
        if (popup.parentNode !== document.body) {
            document.body.appendChild(popup);
        }
        popup.style.zIndex = '2147483647';
        popup.style.pointerEvents = 'auto';
    }

    function updateOverlayPosition() {
        // [개선] 캔버스(.canvas-container)가 imageOverlayContainer 내부에 위치하므로,
        // 부모를 기준으로 top: 0, left: 0으로 설정하여 위치를 맞춥니다.
        // 캔버스의 절대적인 화면 위치는 부모인 imageOverlayContainer에 의해 결정됩니다.
        const wrapper = fabricCanvas.getElement().parentNode;
        if (wrapper) {
            wrapper.style.left = '0px';
            wrapper.style.top = '0px';
        }
        // calcOffset()은 캔버스의 절대 위치와 오프셋을 다시 계산하여 마우스 이벤트를 정확하게 처리하도록 합니다.
        // 전체 화면 전환, 스크롤 등 캔버스의 화면상 위치가 바뀔 때마다 호출되어야 합니다.
        fabricCanvas.calcOffset();
    }
    function syncCanvasSize() {
        // 테이블의 크기가 변경될 때마다 캔버스 크기를 동기화합니다.
        // 스크롤 가능한 전체 높이를 반영하기 위해 table.scrollHeight를 사용합니다.
        const rect = table.getBoundingClientRect();
        const width = Math.ceil(Math.max(rect.width, document.documentElement.clientWidth));
        // scrollHeight가 0 또는 비정상일 경우를 대비하여 안전한 최대 높이 계산
        const bodyScrollH = Math.max(
            document.body.scrollHeight,
            document.documentElement.scrollHeight,
            document.body.offsetHeight,
            document.documentElement.offsetHeight,
            document.body.clientHeight,
            document.documentElement.clientHeight
        );
        const height = Math.max(table.scrollHeight, table.offsetHeight, rect.height, bodyScrollH);
        // Fabric 권장 방식: setDimensions로 래퍼(.canvas-container)까지 함께 갱신
        fabricCanvas.setDimensions({ width, height });
        const wrapper = fabricCanvas.getElement().parentNode;
        if (wrapper && wrapper.classList && wrapper.classList.contains('canvas-container')) {
            // 테이블 컨테이너 영역만 덮도록 정확히 맞춤
            wrapper.style.width = width + 'px';
            wrapper.style.height = height + 'px';
        }
        fabricCanvas.renderAll();
    }
    // ResizeObserver를 사용하여 테이블 크기 변경을 감지하고 캔버스 크기를 동기화합니다.
    if (typeof ResizeObserver !== 'undefined') {
        const resizeObserver = new ResizeObserver(() => { syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); });
        resizeObserver.observe(table);
    } else {
        // 폴백: 테이블 DOM 변경을 감지하여 캔버스 크기 동기화
        const mutationObserver = new MutationObserver(() => {
            syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions();
        });
        mutationObserver.observe(table, { attributes: true, childList: true, subtree: true });
    }
    
    // --- 개선사항: 테이블 전체 화면 보기 기능 ---
    const toggleFullscreenBtn = document.getElementById('toggleFullscreenBtn');
    const fullscreenOverlay = document.getElementById('fullscreen-overlay');
    const fullscreenContent = document.getElementById('fullscreen-content');
    const fullscreenCloseBtn = document.getElementById('fullscreen-close-btn');
    const uiDragOverlay = document.getElementById('ui-drag-overlay');
    const toggleAnnotationBtn = document.getElementById('toggleAnnotationBtn');

    // window의 resize 이벤트에도 동기화를 연결하여 브라우저 창 크기 변경에 대응합니다.
    window.addEventListener('scroll', () => { updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); });
    window.addEventListener('resize', () => { syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); updateAnnotationPositions(); });

    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    // ★★★★★        핵심 개선 사항: 전체화면 스크롤 감지     ★★★★★
    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    // 전체 화면 오버레이 DIV 자체의 스크롤 이벤트를 감지하여 주석 위치를 실시간으로 업데이트합니다.
    // (기존 window.scroll로는 DIV 내부 스크롤을 감지할 수 없었던 문제를 해결)
    fullscreenOverlay.addEventListener('scroll', updateAnnotationPositions);


    addImageBtn.addEventListener('click', () => imageFileInput.click());
    // 이미지 편집 모드 토글: 상단 이벤트 캔버스만 포인터 이벤트를 제어 (테이블 편집은 기본적으로 가능)
    const toggleImageEditBtn = document.getElementById('toggleImageEditBtn');
    function setEditMode(on) {
        if (on && isAnnotationMode) setAnnotationMode(false); // 주석 모드와 동시 활성화 방지
        isImageEditMode = !!on;
        const label = `이미지 편집: ${isImageEditMode ? '켬' : '끔'}`;
        if (toggleImageEditBtn) {
            toggleImageEditBtn.textContent = label;
            toggleImageEditBtn.classList.toggle('active', isImageEditMode);
        }
        if (imageToolsPopup) { imageToolsPopup.style.display = isImageEditMode ? 'flex' : 'none'; }

        // 레이아웃/레이어 보정 후 포인터 이벤트 전환
        syncCanvasSize();
        ensureCanvasOnTop();
        updateOverlayPosition();

        const upperCanvas = fabricCanvas.upperCanvasEl;
        if (upperCanvas) upperCanvas.style.pointerEvents = 'auto';
        fabricCanvas.skipTargetFind = false;
        
        if (isImageEditMode) {
             fabricCanvas.getObjects().forEach(o => { if (o.isAnnotation) o.evented = false; else o.evented = true; });
        } else {
            if (isCropping) cancelCrop();
            fabricCanvas.discardActiveObject().requestRenderAll();
        }
    }
    const imageToolsPopup = document.getElementById('image-tools-popup');
    const closeImageToolsBtn = document.getElementById('closeImageToolsBtn');
    const popupHeaderEl = imageToolsPopup.querySelector('.popup-header');
    toggleImageEditBtn.addEventListener('click', () => { setEditMode(!isImageEditMode); ensureToolsPopupOnTop(); });
    closeImageToolsBtn.addEventListener('click', () => {
        imageToolsPopup.style.display = 'none';
        setEditMode(false);
    });

    lockLayerBtn.addEventListener('click', () => { lockSelected(); lockLayerBtn.classList.add('active'); setTimeout(() => lockLayerBtn.classList.remove('active'), 200); });
    unlockLayerBtn.addEventListener('click', () => { unlockAll(); unlockLayerBtn.classList.add('active'); setTimeout(() => unlockLayerBtn.classList.remove('active'), 200); });

    // 이미지 정렬 버튼
    const imgAlignLeft = document.getElementById('imgAlignLeft');
    const imgAlignCenterH = document.getElementById('imgAlignCenterH');
    const imgAlignRight = document.getElementById('imgAlignRight');
    const imgAlignTop = document.getElementById('imgAlignTop');
    const imgAlignMiddleV = document.getElementById('imgAlignMiddleV');
    const imgAlignBottom = document.getElementById('imgAlignBottom');

    function getSelectionImages() {
        const active = fabricCanvas.getActiveObject();
        if (!active) return [];
        if (active.type === 'activeSelection') return active.getObjects().filter(o => o.type === 'image');
        return active.type === 'image' ? [active] : [];
    }
    function getAllImages() { return fabricCanvas.getObjects().filter(o => o.type === 'image'); }
    function alignSelected(horizontal, vertical) {
        const images = getSelectionImages(); if (images.length === 0) return;
        const canvasWidth = fabricCanvas.getWidth();
        const canvasHeight = fabricCanvas.getHeight();
        images.forEach(img => {
            const halfW = img.getScaledWidth() / 2;
            const halfH = img.getScaledHeight() / 2;
            if (horizontal === 'left') img.left = halfW;
            if (horizontal === 'center') img.left = canvasWidth / 2;
            if (horizontal === 'right') img.left = canvasWidth - halfW;
            if (vertical === 'top') img.top = halfH;
            if (vertical === 'middle') img.top = canvasHeight / 2;
            if (vertical === 'bottom') img.top = canvasHeight - halfH;
            img.setCoords();
        });
        fabricCanvas.requestRenderAll();
    }
    imgAlignLeft.addEventListener('click', () => { alignSelected('left'); imgAlignLeft.classList.add('active'); setTimeout(() => imgAlignLeft.classList.remove('active'), 200); });
    imgAlignCenterH.addEventListener('click', () => { alignSelected('center'); imgAlignCenterH.classList.add('active'); setTimeout(() => imgAlignCenterH.classList.remove('active'), 200); });
    imgAlignRight.addEventListener('click', () => { alignSelected('right'); imgAlignRight.classList.add('active'); setTimeout(() => imgAlignRight.classList.remove('active'), 200); });
    imgAlignTop.addEventListener('click', () => { alignSelected(undefined, 'top'); imgAlignTop.classList.add('active'); setTimeout(() => imgAlignTop.classList.remove('active'), 200); });
    imgAlignMiddleV.addEventListener('click', () => { alignSelected(undefined, 'middle'); imgAlignMiddleV.classList.add('active'); setTimeout(() => imgAlignMiddleV.classList.remove('active'), 200); });
    imgAlignBottom.addEventListener('click', () => { alignSelected(undefined, 'bottom'); imgAlignBottom.classList.add('active'); setTimeout(() => imgAlignBottom.classList.remove('active'), 200); });

    // 레이어 순서
    function forEachSelection(cb) { const images = getSelectionImages(); if (images.length === 0) return; images.forEach(cb); fabricCanvas.requestRenderAll(); }
    document.getElementById('bringToFrontBtn').addEventListener('click', () => forEachSelection(o => o.bringToFront && o.bringToFront()));
    document.getElementById('bringForwardBtn').addEventListener('click', () => forEachSelection(o => o.bringForward && o.bringForward()));
    document.getElementById('sendBackwardsBtn').addEventListener('click', () => forEachSelection(o => o.sendBackwards && o.sendBackwards()));
    document.getElementById('sendToBackBtn').addEventListener('click', () => forEachSelection(o => o.sendToBack && o.sendToBack()));

    // 크기 동일화
    function sameWidth() { const images = getSelectionImages(); if (images.length < 2) return; const w = images[0].getScaledWidth(); images.forEach((img, i) => { if (i === 0) return; const scale = w / img.getScaledWidth(); img.scaleX *= scale; img.scaleY *= scale; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    function sameHeight() { const images = getSelectionImages(); if (images.length < 2) return; const h = images[0].getScaledHeight(); images.forEach((img, i) => { if (i === 0) return; const scale = h / img.getScaledHeight(); img.scaleX *= scale; img.scaleY *= scale; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    function sameSize() { const images = getSelectionImages(); if (images.length < 2) return; const w = images[0].getScaledWidth(); const h = images[0].getScaledHeight(); images.forEach((img, i) => { if (i === 0) return; const scaleX = w / img.getScaledWidth(); const scaleY = h / img.getScaledHeight(); img.scaleX *= scaleX; img.scaleY *= scaleY; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    document.getElementById('sameWidthBtn').addEventListener('click', () => sameWidth());
    document.getElementById('sameHeightBtn').addEventListener('click', () => sameHeight());
    document.getElementById('sameSizeBtn').addEventListener('click', () => sameSize());

    // 균등 분배
    function distributeHorizontally() { const images = getSelectionImages(); if (images.length < 3) return; const sorted = [...images].sort((a,b) => a.left - b.left); const leftMost = sorted[0]; const rightMost = sorted[sorted.length-1]; const totalWidth = rightMost.left - leftMost.left; const step = totalWidth / (sorted.length - 1); sorted.forEach((img, idx) => { img.left = leftMost.left + step * idx; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    function distributeVertically() { const images = getSelectionImages(); if (images.length < 3) return; const sorted = [...images].sort((a,b) => a.top - b.top); const topMost = sorted[0]; const bottomMost = sorted[sorted.length-1]; const totalHeight = bottomMost.top - topMost.top; const step = totalHeight / (sorted.length - 1); sorted.forEach((img, idx) => { img.top = topMost.top + step * idx; img.setCoords(); }); fabricCanvas.requestRenderAll(); }
    document.getElementById('distributeHBtn').addEventListener('click', () => distributeHorizontally());
    document.getElementById('distributeVBtn').addEventListener('click', () => distributeVertically());

    // 셀 연동 기능
    function syncImageToCell(image) {
        if (!image.attachedCellId) return;
        const cell = document.getElementById(image.attachedCellId);
        const canvasContainer = imageOverlayContainer;
        if (!cell) { // 셀이 삭제되었거나 ID가 변경된 경우
            image.attachedCellId = null;
            image.set({ stroke: null, strokeWidth: 0 });
            return;
        }
        const cellRect = cell.getBoundingClientRect();
        const containerRect = canvasContainer.getBoundingClientRect();
        const left = cellRect.left - containerRect.left;
        const top = cellRect.top - containerRect.top;
        const width = cellRect.width;
        const height = cellRect.height;
        const padding = 4; // 셀 내부 여백 (기존 10에서 줄여서 더 꽉 차게 보이도록 함)
        const targetWidth = Math.max(1, width - padding);
        const targetHeight = Math.max(1, height - padding);

        // [개선] 이미지의 가로세로 비율을 무시하고 셀의 크기에 정확히 맞추도록 scaleX와 scaleY를 각각 계산합니다.
        const scaleX = targetWidth / image.width;
        const scaleY = targetHeight / image.height;

        image.set({
            scaleX: scaleX,
            scaleY: scaleY,
            left: left + width / 2,
            top: top + height / 2,
            originX: 'center',
            originY: 'center'
        });
        image.setCoords();
    }
    function updateAllAttachedImages() {
        fabricCanvas.getObjects().forEach(obj => {
            if (obj.attachedCellId) {
                syncImageToCell(obj);
            }
        });
        fabricCanvas.renderAll();
    }
    function attachImageToCell() {
        const images = getSelectionImages();
        if (images.length !== 1) { alert('하나의 이미지를 선택해주세요.'); return; }
        if (selectedCells.length !== 1) { alert('하나의 표 셀을 선택해주세요.'); return; }
        const image = images[0];
        const cell = selectedCells[0];
        if (!cell.id) { updateCellIds(); }
        if (!cell.id) { alert('셀을 식별할 수 없습니다. 다시 시도해주세요.'); return; }
        image.attachedCellId = cell.id;
        image.set({ stroke: 'rgba(26,115,232,0.8)', strokeWidth: 3 }); // 부착 시각적 표시
        syncImageToCell(image);
        fabricCanvas.requestRenderAll();
        captureCurrentSelection();
    }
    document.getElementById('attachToCellBtn').addEventListener('click', attachImageToCell);


    // 선택 도우미 + 삭제
    document.getElementById('selectAllImagesBtn').addEventListener('click', () => { const imgs = getAllImages(); if (imgs.length === 0) return; fabricCanvas.setActiveObject(new fabric.ActiveSelection(imgs, { canvas: fabricCanvas })); fabricCanvas.requestRenderAll(); });
    document.getElementById('clearSelectionBtn').addEventListener('click', () => { allowManualClear = true; fabricCanvas.discardActiveObject().requestRenderAll(); });
    function deleteSelection() {
        if (isCropping) return; // 자르기 모드에서는 삭제 방지
        const active = fabricCanvas.getActiveObject(); if (!active) return;
        if (active.type === 'activeSelection') {
            active.getObjects().forEach(o => fabricCanvas.remove(o));
        } else { fabricCanvas.remove(active); }
        persistentSelection = null;
        fabricCanvas.discardActiveObject().requestRenderAll();
    }
    // 단축키 Delete/Backspace는 기존 구현 그대로 유지되며, 팝업 삭제용으로도 제공 가능

    // 파일 선택 이벤트 핸들러: '2단계 분리 처리' 및 '정확한 좌표 계산' 방식으로 최종 개선
    imageFileInput.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        if (isCropping) return;
        if (files.length === 0) return;

        // 처리 시작 전 사용자 피드백
        document.body.style.cursor = 'wait';
        addImageBtn.disabled = true;
        
        try {
            // 테이블 및 캔버스 최신 크기 반영
            syncCanvasSize();
            // --- 1단계: 데이터 준비 (모든 파일을 먼저 병렬로 처리) ---
            const selectedLevel = document.querySelector('input[name="compression-level"]:checked')?.value || 'medium';
            const compressionStatusEl = document.getElementById('compression-status');
            if (compressionStatusEl) compressionStatusEl.textContent = '이미지 압축 중...';

            const compressionPresets = {
                high:   { maxSizeMB: 2.0, initialQuality: 0.9, maxWidthOrHeight: 2560 },
                medium: { maxSizeMB: 0.8, initialQuality: 0.8, maxWidthOrHeight: 1920 },
                low:    { maxSizeMB: 0.3, initialQuality: 0.6, maxWidthOrHeight: 1280 }
            };
            const baseOptions = compressionPresets[selectedLevel];
            let totalOriginalSize = 0;
            let totalCompressedSize = 0;

            const imageProcessingPromises = files.map(async (file) => {
                totalOriginalSize += file.size;
                const compressionOptions = {
                    ...baseOptions,
                    useWebWorker: true,
                    maxIteration: 10,
                    alwaysKeepResolution: false,
                };
                try {
                    const compressedFile = await imageCompression(file, compressionOptions);
                    totalCompressedSize += compressedFile.size;
                    return await imageCompression.getDataUrlFromFile(compressedFile);
                } catch (error) {
                    console.warn(`'${file.name}' 압축 실패, 캔버스 폴백 시도:`, error);
                    // 폴백: 브라우저 캔버스로 리사이즈하여 DataURL 생성
                    try {
                        const dataUrl = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => {
                                const img = new Image();
                                img.onload = () => {
                                    const max = 1920;
                                    let { width, height } = img;
                                    const scale = Math.min(1, max / Math.max(width, height));
                                    width = Math.round(width * scale);
                                    height = Math.round(height * scale);
                                    const canvas = document.createElement('canvas');
                                    canvas.width = width; canvas.height = height;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(img, 0, 0, width, height);
                                    resolve(canvas.toDataURL('image/jpeg', 0.85));
                                };
                                img.onerror = reject;
                                img.src = reader.result;
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                        return dataUrl;
                    } catch (err2) {
                        console.error(`'${file.name}' 폴백까지 실패:`, err2);
                        return null;
                    }
                }
            });

            const imageDataUrls = await Promise.all(imageProcessingPromises);
            
            if (compressionStatusEl) {
                const reduction = totalOriginalSize > 0 ? ((1 - totalCompressedSize / totalOriginalSize) * 100).toFixed(1) : 0;
                compressionStatusEl.textContent = `압축: ${formatBytes(totalOriginalSize)} → ${formatBytes(totalCompressedSize)} (${reduction}%↓)`;
            }
            const validUrls = imageDataUrls.filter(url => url !== null);

            // --- 2단계: 캔버스 렌더링 (준비된 데이터로 순차 추가) ---
            // 2-1. 준비된 URL로부터 Fabric.Image 객체를 병렬로 생성합니다.
            const imageLoadingPromises = validUrls.map(url =>
                new Promise((resolve, reject) => {
                    fabric.Image.fromURL(url, img => {
                        if (img) resolve(img);
                        else reject(new Error('데이터 URL로부터 이미지를 로드하지 못했습니다.'));
                    }, { crossOrigin: 'anonymous' });
                })
            );
            let fabricImages = await Promise.all(imageLoadingPromises);
            // 선택 가능한 상태 및 스택 순서 보장
            fabricImages.forEach((img, i) => {
                img.selectable = true; img.evented = true; img.perPixelTargetFind = true; img.bringToFront();
                img.set({ globalCompositeOperation: 'source-over' });
            });

            // 2-2. 생성된 모든 이미지 객체를 캔버스에 추가합니다.
            fabricImages.forEach((img, index) => {
                // ★★★★★ 최종 개선: 이미지 위치를 '현재 보이는 화면 중앙' 기준으로 정밀하게 계산 ★★★★★

                // 1. 캔버스 요소의 현재 화면상 위치(뷰포트 기준)를 가져옵니다.
        const canvasRect = fabricCanvas.upperCanvasEl.getBoundingClientRect();

                // 2. 현재 뷰포트(보이는 화면)의 중앙 좌표를 계산합니다.
                const viewportCenterX = (window.innerWidth / 2);
                const viewportCenterY = (window.innerHeight / 2);

                // 3. 뷰포트 중앙 좌표를 캔버스 내부 좌표로 변환합니다.
                //    이것이 바로 캔버스 내부에서의 '보이는 화면 중앙'의 좌표가 됩니다.
                // getBoundingClientRect는 뷰포트 기준이므로 스크롤 보정 필요 없음
                let targetLeft = viewportCenterX - canvasRect.left;
                let targetTop = viewportCenterY - canvasRect.top;

                // 4. 여러 이미지가 겹치지 않도록 인덱스를 이용해 위치를 살짝 조정합니다.
                //    새로 추가되는 이미지 그룹이 전체적으로 중앙에 오도록 계산합니다.
                const offset = (index - (fabricImages.length - 1) / 2) * 40;
                targetLeft += offset;
                targetTop += offset;

                // 5. 이미지 속성을 설정하고 캔버스에 추가합니다.
                //    originX/Y를 'center'로 설정하여 계산된 좌표에 이미지의 중심이 오도록 합니다.
                // 먼저 합리적 크기로 스케일 후 좌표 계산이 일관되도록 함
                const targetWidth = Math.min(480, img.width || 480);
                img.scaleToWidth(targetWidth);

                img.set({
                    left: targetLeft,
                    top: targetTop,
                    originX: 'center',
                    originY: 'center',
                    angle: 0,
                    padding: 10,
                    cornerSize: 10,
                    hasRotatingPoint: true,
                });
                // 화면 밖으로 벗어나지 않도록 1차 클램프
                const halfW = (img.getScaledWidth() || 200) / 2;
                const halfH = (img.getScaledHeight() || 200) / 2;
                img.left = Math.max(halfW, Math.min(fabricCanvas.width - halfW, img.left));
                img.top = Math.max(halfH, Math.min(fabricCanvas.height - halfH, img.top));
                fabricCanvas.add(img);
                img.bringToFront();
            });

            if (validUrls.length < files.length) {
                 alert('일부 이미지 처리 중 오류가 발생했습니다. 자세한 내용은 개발자 콘솔을 확인해주세요.');
            }

            // 모든 이미지를 추가한 후, 마지막 이미지를 활성화하고 캔버스를 다시 그립니다.
            if (fabricImages.length > 0) {
                // 편집 모드가 켜져 있으면 즉시 선택 가능하도록 upper-canvas 이벤트 열어줌
                const upperCanvas = fabricCanvas.upperCanvasEl;
                if (upperCanvas) upperCanvas.style.pointerEvents = isImageEditMode ? 'auto' : 'none';
                // 개별 선택 우선: 가장 마지막 추가 이미지만 선택
                setTimeout(() => {
                    try {
                        const lastImg = fabricImages[fabricImages.length - 1];
                        if (lastImg) fabricCanvas.setActiveObject(lastImg);
                        fabricCanvas.requestRenderAll();
                    } catch (e) { console.warn('selection 구성 중 경고:', e); }
                }, 0);
                ensureCanvasOnTop();
                updateOverlayPosition();
            }
            fabricCanvas.renderAll();

        } catch (error) {
            console.error("이미지 처리 과정에서 예기치 않은 오류 발생:", error);
            alert("이미지를 처리하는 중 심각한 오류가 발생했습니다.");
        } finally {
            // --- 최종 정리 ---
            document.body.style.cursor = 'default';
            addImageBtn.disabled = false;
            e.target.value = ''; 
            ensureCanvasOnTop();
        }
    });


    // (커스텀 컨트롤 및 키보드 이벤트 관련 코드는 기존과 동일)
    const deleteIcon="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='0 0 595.275 595.275' enable-background='new 0 0 595.275 595.275' xml:space='preserve'%3E%3Cg%3E%3Cpath d='M354.724,297.636l227.16-227.16c9.763-9.763,9.763-25.592,0-35.355L544.51,0l-227.16,227.16L89.675-0.002 L48.3,35.353c-9.763,9.763-9.763,25.592,0,35.355l227.69,227.69L48.3,524.801c-9.763,9.763-9.763,25.592,0,35.355 l37.375,37.375c9.763,9.763,25.592,9.763,35.355,0l227.16-227.16l227.16,227.16c9.763,9.763,25.592,9.763,35.355,0 l37.375-37.375c9.763-9.763,9.763-25.592,0-35.355L354.724,297.636z'/%3E%3C/g%3E%3C/svg%3E";
    const cloneIcon="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='iso-8859-1'%3F%3E%3Csvg version='1.1' id='Capa_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 35.635 35.635' style='enable-background:new 0 0 35.635 35.635;' xml:space='preserve'%3E%3Cg%3E%3Cpath d='M34.135,0H9.762c-0.828,0-1.5,0.672-1.5,1.5v4.323H1.5c-0.828,0-1.5,0.672-1.5,1.5v26.812c0,0.828,0.672,1.5,1.5,1.5 h24.373c0.828,0,1.5-0.672,1.5-1.5v-4.323h6.762c0.828,0,1.5-0.672,1.5-1.5V1.5C35.635,0.672,34.963,0,34.135,0z M24.373,32.635 H3V8.823h21.373V32.635z M32.635,28.312h-5.262V7.323c0-0.828-0.672-1.5-1.5-1.5H9.762V3h22.873V28.312z'/%3E%3C/g%3E%3C/svg%3E";
    const flipIcon="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='122.879px' height='104.918px' viewBox='0 0 122.879 104.918' enable-background='new 0 0 122.879 104.918' xml:space='preserve'%3E%3Cg%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M99.951,104.918H69.419c-3.172,0-5.742-2.57-5.742-5.742V5.742 c0-3.172,2.57-5.742,5.742-5.742h30.532c3.171,0,5.741,2.57,5.741,5.742v93.435C105.692,102.348,103.122,104.918,99.951,104.918z M53.46,5.742v93.435c0,3.172-2.57,5.742-5.742,5.742H22.936c-3.171,0-5.742-2.57-5.742-5.742V5.742c0-3.172,2.571-5.742,5.742-5.742 h24.782C50.89,0,53.46,2.57,53.46,5.742z M99.951,104.918'/%3E%3C/g%3E%3C/svg%3E";
    const cropIcon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M17 15h2V7c0-1.1-.9-2-2-2H9v2h8v8zM7 17V1H5v4H1v2h4v10c0 1.1.9 2 2 2h10v4h2v-4h4v-2H7z' fill='%23333'%3E%3C/path%3E%3C/svg%3E";
    const applyCropIcon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z' fill='white'%3E%3C/path%3E%3C/svg%3E";
    const cancelCropIcon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z' fill='white'%3E%3C/path%3E%3C/svg%3E";
    
    // --- 개선사항 2.2: 아이콘 렌더링 함수 개선 (배경 추가 옵션) ---
    function renderIcon(icon, withBg = false) {
        return function renderIcon(ctx, left, top, styleOverride, fabricObject) {
            const size = this.cornerSize;
            ctx.save();
            ctx.translate(left, top);
            ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            if (withBg) {
                ctx.beginPath();
                ctx.arc(0, 0, size / 2, 0, Math.PI * 2, false);
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fill();
            }
            ctx.drawImage(icon, -size / 2, -size / 2, size, size);
            ctx.restore();
        }
    }
    const deleteImg = document.createElement('img'); deleteImg.src = deleteIcon; const cloneImg = document.createElement('img'); cloneImg.src = cloneIcon; const flipImg = document.createElement('img'); flipImg.src = flipIcon;
    const cropImg = document.createElement('img'); cropImg.src = cropIcon;
    const applyCropImg = document.createElement('img'); applyCropImg.src = applyCropIcon;
    const cancelCropImg = document.createElement('img'); cancelCropImg.src = cancelCropIcon;
    
    fabric.Object.prototype.transparentCorners = false; fabric.Object.prototype.cornerColor = 'rgba(102,153,255,0.8)'; fabric.Object.prototype.cornerStyle = 'circle'; fabric.Object.prototype.borderColor = 'rgba(102,153,255,0.8)'; fabric.Object.prototype.borderScaleFactor = 2;
    // 스냅/가이드라인 설정
    fabricCanvas.snapToGrid = 5;
    fabricCanvas.on('object:moving', function(e) {
        const obj = e.target; if (!obj) return;
        if(isAnnotationMode) return; // 주석 모드에서는 스냅 비활성화
        obj.left = Math.round(obj.left / fabricCanvas.snapToGrid) * fabricCanvas.snapToGrid;
        obj.top = Math.round(obj.top / fabricCanvas.snapToGrid) * fabricCanvas.snapToGrid;
        drawGuides(obj);
    });
    fabricCanvas.on('object:modified', function(e) {
        const obj = e.target;
        if (obj && obj.isAnnotation) {
            obj.persistentTop = obj.top;
            obj.bringToFront();
        }
        if (obj && obj.attachedCellId) {
            if (isCropping) return;
            // 사용자가 수동으로 조작하면 셀 연동 해제
            obj.attachedCellId = null;
            obj.set({ stroke: null, strokeWidth: 0 });
        }
        clearGuides(); captureCurrentSelection(); });
    

    // 선택 유지 로직: 이미지 도구 패널 조작 시 선택이 풀리는 것을 방지하고, 캔버스 배경 클릭 시에는 정상적으로 선택 해제되도록 수정.
    let allowManualClear = false;
    let persistentSelection = null;
    let mousedownOnToolsPopup = false;

    function captureCurrentSelection() { const active = fabricCanvas.getActiveObject(); if (active) { persistentSelection = active; } }
    fabricCanvas.on('before:transform', captureCurrentSelection); // 변형 시작 전에도 캡처
    fabricCanvas.on('selection:created', captureCurrentSelection);
    fabricCanvas.on('selection:updated', captureCurrentSelection);

    document.addEventListener('mousedown', (e) => {
        if (!isImageEditMode) return;
        // 캡처 단계에서 마우스 다운이 도구 팝업에서 발생했는지 기록합니다.
        mousedownOnToolsPopup = !!e.target.closest('#image-tools-popup');
    }, true);

    fabricCanvas.on('selection:cleared', function() {
        if (isCropping) return;
        if (!isImageEditMode) return;
        // '선택 해제' 버튼을 통한 명시적 해제는 항상 허용합니다.
        if (allowManualClear) { allowManualClear = false; persistentSelection = null; return; }

        // 마우스 다운이 도구 팝업에서 발생했다면, 실수로 인한 선택 해제로 간주하고 복구합니다.
        // 캔버스 배경 클릭(mousedownOnToolsPopup=false) 시에는 이 로직이 실행되지 않아 정상적으로 선택 해제됩니다.
        if (mousedownOnToolsPopup && persistentSelection) {
            // setTimeout을 사용하여 다른 이벤트 핸들러가 완료된 후 비동기적으로 복구합니다.
            setTimeout(() => {
                try {
                    let objs = [];
                    if (persistentSelection.type === 'activeSelection') {
                        objs = persistentSelection.getObjects().filter(o => fabricCanvas.getObjects().includes(o));
                    } else if (fabricCanvas.getObjects().includes(persistentSelection)) {
                        objs = [persistentSelection];
                    }
                    if (objs.length > 0) {
                        const selectionToRestore = objs.length === 1 ? objs[0] : new fabric.ActiveSelection(objs, { canvas: fabricCanvas });
                        fabricCanvas.setActiveObject(selectionToRestore).requestRenderAll();
                    }
                } catch (e) { console.warn("Could not restore selection", e); }
            }, 0);
        }
    });
    // 1) 선택 유지: 편집 모드에서 외부 클릭으로 선택 해제되지 않도록 방지
    document.addEventListener('mousedown', (e) => {
        if (!isImageEditMode || isCropping) return;
        const upper = fabricCanvas.upperCanvasEl;
        const clickedOnOverlay = upper && upper.contains(e.target);
        const clickedOnToolsPopup = !!e.target.closest('#image-tools-popup');

        if (!clickedOnOverlay && !clickedOnToolsPopup) {
            // 편집 모드에서 캔버스나 도구 팝업 외부를 클릭하면 이벤트 전파를 중지하여
            // 의도치 않은 동작(예: 테이블 셀 선택)을 방지합니다.
            e.stopPropagation();
        }
    }, true);

    // 사용자 설정 반영
    const snapGridInputEl = document.getElementById('snapGridInput');
    const guideToleranceInputEl = document.getElementById('guideToleranceInput');
    const guideColorInputEl = document.getElementById('guideColorInput');
    if (snapGridInputEl) snapGridInputEl.addEventListener('change', () => { const v = parseInt(snapGridInputEl.value, 10); if (!isNaN(v) && v >= 0) fabricCanvas.snapToGrid = v; });
    if (guideToleranceInputEl) guideToleranceInputEl.addEventListener('change', () => { const v = parseInt(guideToleranceInputEl.value, 10); if (!isNaN(v) && v >= 0) guideTolerance = v; });
    if (guideColorInputEl) guideColorInputEl.addEventListener('input', () => { guideColor = guideColorInputEl.value || '#ff0000'; });

    // 팝업 이동/리사이즈 (사방 핸들)
    (function enablePopupDragAndResize() {
        const popup = imageToolsPopup;
        const header = popupHeaderEl;
        const uiOverlay = document.getElementById('ui-drag-overlay');
        let drag = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
        let resizing = false, rsDir = '', rsStartX = 0, rsStartY = 0, rsStartW = 0, rsStartH = 0, rsStartL = 0, rsStartT = 0;

        // 팝업 활성화 상태에서만 핸들 보이기
        function setPopupActive(active) {
            const handles = popup.querySelectorAll('.resize-handle');
            handles.forEach(h => h.style.display = active ? 'block' : 'none');
            popup.classList.toggle('active', active);
        }

        // 이미지 편집 켬 시 팝업 열리므로 활성화
        const observer = new MutationObserver(() => {
            const isShown = popup.style.display !== 'none';
            if (isShown) { ensureToolsPopupOnTop(); setPopupActive(false); popup.focus(); }
        });
        observer.observe(popup, { attributes: true, attributeFilter: ['style'] });

        function startOverlay() { if (uiOverlay) uiOverlay.style.display = 'block'; }
        function stopOverlay() { if (uiOverlay) uiOverlay.style.display = 'none'; }

        // 드래그 시작 (헤더)
        header.addEventListener('mousedown', (e) => {
            // 헤더 내 버튼 클릭 시 드래그 방지
            if (e.target.closest('button')) return;
            drag = true;
            startOverlay();
            startX = e.clientX;
            startY = e.clientY;
            const rect = popup.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            document.body.style.userSelect = 'none';
            e.preventDefault();
            e.stopPropagation();
            setPopupActive(true);
            popup.focus({ preventScroll: true });
        });

        // 비인터랙티브 영역에서도 드래그 허용 (버튼/입력/핸들 제외)
        function isInteractive(el) { return !!el.closest('button, input, select, textarea, label, .resize-handle'); }

        // 리사이즈 핸들 삽입
        ['n','s','e','w','ne','nw','se','sw'].forEach(dir => {
            const h = document.createElement('div'); h.className = 'resize-handle ' + dir; popup.appendChild(h);
        });

        // 팝업의 mousedown은 드래그 시작(빈 공간) 또는 리사이즈 시작(핸들)을 처리
        popup.addEventListener('mousedown', (e) => {
            setPopupActive(true); // 패널 클릭 시 핸들 표시

            if (e.target.classList.contains('resize-handle')) {
                // 리사이즈 시작
                e.preventDefault(); e.stopPropagation();
                resizing = true;
                rsDir = [...e.target.classList].find(c => c.length <= 2 && c !== 'resize-handle');
                const rect = popup.getBoundingClientRect();
                rsStartX = e.clientX; rsStartY = e.clientY; rsStartW = rect.width; rsStartH = rect.height; rsStartL = rect.left; rsStartT = rect.top;
                document.body.style.userSelect = 'none';
                startOverlay();
            } else if (!isInteractive(e.target) && !drag && !resizing) {
                // 빈 공간 드래그 시작
                drag = true; startOverlay();
                startX = e.clientX; startY = e.clientY;
                const rect = popup.getBoundingClientRect();
                startLeft = rect.left; startTop = rect.top;
                document.body.style.userSelect = 'none';
                e.preventDefault();
                popup.focus({ preventScroll: true });
            }
        });

        // 패널 외부 클릭 시 활성 해제
        document.addEventListener('mousedown', (e) => {
            if (!e.target.closest('#image-tools-popup')) { setPopupActive(false); }
        });

        // 통합된 MouseMove 이벤트 핸들러
        document.addEventListener('mousemove', (e) => {
            if (drag) {
                e.preventDefault();
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                popup.style.left = Math.max(0, startLeft + dx) + 'px';
                popup.style.top = Math.max(0, startTop + dy) + 'px';
            } else if (resizing) {
                e.preventDefault();
                let dx = e.clientX - rsStartX; let dy = e.clientY - rsStartY;
                let newW = rsStartW, newH = rsStartH, newL = rsStartL, newT = rsStartT;
                if (rsDir.includes('e')) newW = Math.max(260, rsStartW + dx);
                if (rsDir.includes('s')) newH = Math.max(160, rsStartH + dy);
                if (rsDir.includes('w')) { newW = Math.max(260, rsStartW - dx); newL = rsStartL + dx; }
                if (rsDir.includes('n')) { newH = Math.max(160, rsStartH - dy); newT = rsStartT + dy; }
                popup.style.width = newW + 'px';
                popup.style.height = newH + 'px';
                popup.style.left = Math.max(0, newL) + 'px';
                popup.style.top = Math.max(0, newT) + 'px';
            }
        });

        // 통합된 MouseUp 이벤트 핸들러
        document.addEventListener('mouseup', () => {
            if (drag || resizing) {
                drag = false;
                resizing = false;
                stopOverlay();
                document.body.style.userSelect = '';
            }
        });
    })();

    let guideLines = [];
    let guideColor = '#ff0000';
    let guideTolerance = 4;
    function clearGuides() { guideLines.forEach(l => fabricCanvas.remove(l)); guideLines = []; fabricCanvas.requestRenderAll(); }
    function drawGuides(obj) {
        clearGuides();
        const objects = fabricCanvas.getObjects().filter(o => o !== obj && o.type === 'image');
        const tolerance = guideTolerance; // px
        const objBounds = obj.getBoundingRect(true);
        objects.forEach(o => {
            const b = o.getBoundingRect(true);
            // 수직 정렬: left, centerX, right
            const candidatesX = [b.left, b.left + b.width / 2, b.left + b.width];
            const currentX = [objBounds.left, objBounds.left + objBounds.width / 2, objBounds.left + objBounds.width];
            candidatesX.forEach(cx => currentX.forEach(ox => {
                if (Math.abs(cx - ox) <= tolerance) {
                    guideLines.push(new fabric.Line([cx, 0, cx, fabricCanvas.height], { stroke: guideColor, strokeOpacity: 0.5, selectable: false, evented: false }));
                }
            }));
            // 수평 정렬: top, centerY, bottom
            const candidatesY = [b.top, b.top + b.height / 2, b.top + b.height];
            const currentY = [objBounds.top, objBounds.top + objBounds.height / 2, objBounds.top + objBounds.height];
            candidatesY.forEach(cy => currentY.forEach(oy => {
                if (Math.abs(cy - oy) <= tolerance) {
                    guideLines.push(new fabric.Line([0, cy, fabricCanvas.width, cy], { stroke: guideColor, strokeOpacity: 0.5, selectable: false, evented: false }));
                }
            }));
        });
        guideLines.forEach(l => fabricCanvas.add(l));
        guideLines.forEach(l => l.bringToFront && l.bringToFront());
        fabricCanvas.requestRenderAll();
    }
    fabric.Object.prototype.controls.deleteControl = new fabric.Control({ x: 0.5, y: -0.5, offset: {x: 15, y: -15}, cursorStyle: 'pointer', mouseUpHandler: deleteObject, render: renderIcon(deleteImg), cornerSize: 24 });
    fabric.Object.prototype.controls.cloneControl = new fabric.Control({ x: -0.5, y: -0.5, offset: {x: -15, y: -15}, cursorStyle: 'pointer', mouseUpHandler: cloneObject, render: renderIcon(cloneImg), cornerSize: 24 });
    fabric.Object.prototype.controls.flipControl = new fabric.Control({ x: -0.5, y: 0.5, offset: {x: -15, y: 15}, cursorStyle: 'pointer', mouseUpHandler: flipObject, render: renderIcon(flipImg), cornerSize: 24 });
    // [개선] 이미지 객체에 자르기 시작 컨트롤 추가
    fabric.Object.prototype.controls.cropControl = new fabric.Control({
        x: 0.5, y: 0,
        offset: { x: 20, y: 0 },
        cursorStyle: 'pointer',
        mouseUpHandler: startCrop, // 클릭 시 startCrop 함수 실행
        render: renderIcon(cropImg),
        cornerSize: 24,
        visible: function() { return this.type === 'image' && !isCropping; }
    });

    function deleteObject(eventData, transform) { const target = transform.target; const canvas = target.canvas; canvas.remove(target); canvas.requestRenderAll(); }
    function cloneObject(eventData, transform) { const target = transform.target; const canvas = target.canvas; target.clone(function(cloned) { cloned.left += 20; cloned.top += 20; cloned.bringToFront && cloned.bringToFront(); canvas.add(cloned); canvas.setActiveObject(cloned); canvas.requestRenderAll(); }); }
    function flipObject(eventData, transform) { const target = transform.target; target.toggle('flipX'); target.canvas.requestRenderAll(); }
    // 레이어 잠금/해제 (선택 객체만)
    function setLockedVisual(o, locked) { o.opacity = locked ? 0.6 : 1.0; o.borderColor = locked ? 'rgba(200,0,0,0.8)' : 'rgba(102,153,255,0.8)'; o.cornerColor = locked ? 'rgba(200,0,0,0.6)' : 'rgba(102,153,255,0.8)'; }
    function lockSelected() { const obj = fabricCanvas.getActiveObject(); if (!obj) return; const setLock = (o, v) => { o.lockMovementX = v; o.lockMovementY = v; o.lockScalingX = v; o.lockScalingY = v; o.lockRotation = v; o.selectable = !v; setLockedVisual(o, v); }; if (obj.type === 'activeSelection') { obj.getObjects().forEach(o => setLock(o, true)); } else { setLock(obj, true); } fabricCanvas.discardActiveObject().requestRenderAll(); }
    function unlockAll() { fabricCanvas.getObjects().forEach(o => { o.lockMovementX = o.lockMovementY = o.lockScalingX = o.lockScalingY = o.lockRotation = false; o.selectable = true; setLockedVisual(o, false); }); fabricCanvas.requestRenderAll(); }
    
    window.addEventListener('keydown', (e) => {
        if (isCropping) {
            if (e.key === 'Escape') cancelCrop();
            if (e.key === 'Enter') applyCrop();
            return;
        }
        if (e.target.closest('[contenteditable="true"]')) return; const activeObject = fabricCanvas.getActiveObject(); if (!activeObject) return;
        if (e.key === 'Delete' || e.key === 'Backspace') { deleteSelection(); }
        if ((e.ctrlKey || e.metaKey) && e.key === 'c') { activeObject.clone(function(cloned) { _clipboard = cloned; }); }
        if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
            if (!_clipboard) return;
            _clipboard.clone(function(clonedObj) {
                fabricCanvas.discardActiveObject();
                clonedObj.set({ left: clonedObj.left + 20, top: clonedObj.top + 20, evented: true, });
                if (clonedObj.type === 'activeSelection') {
                    clonedObj.canvas = fabricCanvas; clonedObj.forEachObject(function(obj) { fabricCanvas.add(obj); }); clonedObj.setCoords();
                } else { fabricCanvas.add(clonedObj); }
                _clipboard.top += 20; _clipboard.left += 20;
                fabricCanvas.setActiveObject(clonedObj); clonedObj.bringToFront && clonedObj.bringToFront(); ensureCanvasOnTop(); updateOverlayPosition(); fabricCanvas.requestRenderAll();
            });
        }
    });

    function loadCanvasData() {
        const canvasDataScript = document.getElementById('canvas-data');
        if (canvasDataScript && canvasDataScript.textContent) {
            try {
                const jsonData = JSON.parse(canvasDataScript.textContent);
                fabricCanvas.loadFromJSON(jsonData, () => {
                    updateCellIds();
                    updateAllAttachedImages();
                    updateAnnotationPositions();
                    fabricCanvas.getObjects().forEach(obj => {
                        if (obj.attachedCellId) {
                            obj.set({ stroke: 'rgba(26,115,232,0.8)', strokeWidth: 3 });
                        }
                    });
                    fabricCanvas.renderAll();
                });
            } catch (e) { console.error("캔버스 데이터 로드 실패:", e); }
        }
    }

    function initializeDraggableTable() {
        let draggingElement = null;
        let dragType = null; // 'row' or 'col'
        let dropTarget = null;

        table.addEventListener('mousedown', (e) => {
            // [개선] 주석 모드일 때는 행/열 드래그 이동을 방지
            if (isImageEditMode || isAnnotationMode || e.button !== 0) return;
            const th = e.target.closest('th');
            const noCell = e.target.closest('.no-cell');
            if ((!th && !noCell) || e.target.closest('.resizer-col, .resizer-row')) return;

            if (th && th.cellIndex > 0) {
                e.preventDefault();
                dragType = 'col';
                draggingElement = { index: th.cellIndex, element: th };
                document.body.style.cursor = 'grabbing';
                setColumnDragging(draggingElement.index, true);
            } else if (noCell) {
                e.preventDefault();
                dragType = 'row';
                const row = noCell.closest('tr');
                draggingElement = { element: row };
                row.classList.add('dragging-row');
                document.body.style.cursor = 'grabbing';
            } else { return; }

            if (draggingElement) {
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp, { once: true });
            }
        });

        function onMouseMove(e) {
            if (!draggingElement) return;
            
            const currentOver = e.target.closest(dragType === 'row' ? 'tr' : 'th');
            document.querySelectorAll('.drop-indicator-row-before, .drop-indicator-row-after, .drop-indicator-col-before').forEach(el => 
                el.classList.remove('drop-indicator-row-before', 'drop-indicator-row-after', 'drop-indicator-col-before'));

            if (currentOver && currentOver !== draggingElement.element) {
                dropTarget = { element: currentOver };
                if (dragType === 'row') {
                    const rect = currentOver.getBoundingClientRect();
                    const isAfter = e.clientY > rect.top + rect.height / 2;
                    currentOver.classList.add(isAfter ? 'drop-indicator-row-after' : 'drop-indicator-row-before');
                    dropTarget.position = isAfter ? 'after' : 'before';
                } else { // col
                    const targetIndex = currentOver.cellIndex;
                    if (targetIndex > 0) {
                        currentOver.classList.add('drop-indicator-col-before');
                        dropTarget.index = targetIndex;
                    } else { dropTarget = null; }
                }
            } else { dropTarget = null; }
        }

        function onMouseUp() {
            if (draggingElement && dropTarget) {
                if (dragType === 'row') {
                    const dragEl = draggingElement.element;
                    const dropEl = dropTarget.element;
                    if (dropTarget.position === 'after') dropEl.parentNode.insertBefore(dragEl, dropEl.nextSibling);
                    else dropEl.parentNode.insertBefore(dragEl, dropEl);
                    updateRowNumbers(); updateCellIds(); updateAllAttachedImages();
                } else { // col
                    const fromIndex = draggingElement.index;
                    const toIndex = dropTarget.index;
                    if (fromIndex !== toIndex) moveColumn(fromIndex, toIndex);
                }
            }
            if (draggingElement?.element) draggingElement.element.classList.remove('dragging-row');
            setColumnDragging(draggingElement?.index, false);
            document.querySelectorAll('.drop-indicator-row-before, .drop-indicator-row-after, .drop-indicator-col-before').forEach(el => 
                el.classList.remove('drop-indicator-row-before', 'drop-indicator-row-after', 'drop-indicator-col-before'));
            document.removeEventListener('mousemove', onMouseMove);
            document.body.style.cursor = '';
            draggingElement = null; dropTarget = null; dragType = null;
        }

        function moveColumn(fromIndex, toIndex) {
            Array.from(table.rows).forEach(row => {
                const cellToMove = row.cells[fromIndex];
                if (cellToMove) row.insertBefore(cellToMove, row.cells[toIndex]);
            });
            const colgroup = table.querySelector('colgroup');
            colgroup.insertBefore(colgroup.children[fromIndex], colgroup.children[toIndex]);
            findSpecialColumns(); updateCellIds(); initializeResizableTable(); updateAllAttachedImages();
        }

        function setColumnDragging(colIndex, isDragging) {
            if (colIndex === undefined || colIndex < 1) return;
            Array.from(table.rows).forEach(row => {
                if (row.cells[colIndex]) {
                    row.cells[colIndex].classList.toggle('dragging-col', isDragging);
                }
            });
        }
    }

    function initializeAutoFit() {
        table.addEventListener('dblclick', (e) => {
            const th = e.target.closest('th');
            const noCell = e.target.closest('.no-cell');

            if (th && th.cellIndex > 0) {
                // 열 너비 자동 맞춤
                const colIndex = th.cellIndex;
                let maxWidth = 0;
                Array.from(table.rows).forEach(row => {
                    const cell = row.cells[colIndex];
                    if (cell) {
                        // scrollWidth는 셀의 실제 콘텐츠 너비를 측정합니다.
                        maxWidth = Math.max(maxWidth, cell.scrollWidth);
                    }
                });
                const colElement = table.querySelector('colgroup').children[colIndex];
                colElement.style.width = (maxWidth + 10) + 'px'; // 약간의 여백 추가
                updateAllAttachedImages();
            } else if (noCell) {
                // 행 높이 자동 맞춤
                const row = noCell.closest('tr');
                row.style.height = 'auto';
                updateAllAttachedImages();
            }
        });
    }

    // --- 개선사항: 이미지 자르기 기능 (UI 통합) ---
    function startCrop(eventData, transform) {
        if (isCropping) return;
        const targetImage = transform.target;
        if (!targetImage || targetImage.type !== 'image') return;

        isCropping = true;
        cropTargetImage = targetImage;
        cropTargetImage.hasControls = false;

        fabricCanvas.getObjects().forEach(obj => {
            if (obj === cropTargetImage) {
                obj.set({ opacity: 0.7, evented: false, selectable: false });
            } else {
                obj.set({ evented: false, selectable: false });
            }
        });

        fabricCanvas.discardActiveObject();

        const bounds = cropTargetImage.getBoundingRect();
        cropRect = new fabric.Rect({
            left: bounds.left, top: bounds.top, width: bounds.width, height: bounds.height,
            fill: 'rgba(0, 0, 0, 0.3)', stroke: '#4d90fe', strokeWidth: 2, strokeDashArray: [5, 5],
            hasRotatingPoint: false, cornerColor: '#4d90fe', cornerStyle: 'circle',
            transparentCorners: false, borderColor: '#4d90fe', evented: true, selectable: true,
        });

        cropRect.controls.apply = new fabric.Control({
            x: 0.5, y: -0.5, offset: { x: 0, y: -30 }, cursorStyle: 'pointer',
            mouseUpHandler: applyCrop, render: renderIcon(applyCropImg, true), cornerSize: 24
        });
        cropRect.controls.cancel = new fabric.Control({
            x: -0.5, y: -0.5, offset: { x: 0, y: -30 }, cursorStyle: 'pointer',
            mouseUpHandler: () => cancelCrop(), render: renderIcon(cancelCropImg, true), cornerSize: 24
        });

        fabricCanvas.add(cropRect);
        fabricCanvas.setActiveObject(cropRect);
        fabricCanvas.renderAll();
    }

    function applyCrop() {
        if (!isCropping || !cropTargetImage || !cropRect) return;
        const img = cropTargetImage;
        const invertedMatrix = fabric.util.invertTransform(img.calcTransformMatrix());
        const cropPoints = cropRect.getCoords();
        const transformedPoints = cropPoints.map(p => fabric.util.transformPoint(p, invertedMatrix));
        const minX = fabric.util.array.min(transformedPoints, 'x');
        const minY = fabric.util.array.min(transformedPoints, 'y');
        const maxX = fabric.util.array.max(transformedPoints, 'x');
        const maxY = fabric.util.array.max(transformedPoints, 'y');
        const cropWidthLocal = maxX - minX;
        const cropHeightLocal = maxY - minY;
        const finalCropX = (img.cropX || 0) + minX + (img.width / 2);
        const finalCropY = (img.cropY || 0) + minY + (img.height / 2);

        img.width = cropWidthLocal;
        img.height = cropHeightLocal;
        img.cropX = finalCropX;
        img.cropY = finalCropY;
        img.left = cropRect.getCenterPoint().x;
        img.top = cropRect.getCenterPoint().y;
        img.scaleX = cropRect.getScaledWidth() / cropWidthLocal;
        img.scaleY = cropRect.getScaledHeight() / cropHeightLocal;
        img.setCoords();

        cancelCrop(true);
        fabricCanvas.setActiveObject(img);
        fabricCanvas.requestRenderAll();
    }
    
    function cancelCrop(silent = false) {
        if (!isCropping) return;
        if (cropTargetImage) { cropTargetImage.hasControls = true; }
        isCropping = false;
        if (cropRect) fabricCanvas.remove(cropRect);
        cropRect = null;
        fabricCanvas.getObjects().forEach(obj => { obj.set({ opacity: 1.0, evented: true, selectable: true }); });
        if (!silent && cropTargetImage) { fabricCanvas.setActiveObject(cropTargetImage); }
        cropTargetImage = null;
        fabricCanvas.requestRenderAll();
    }


    // --- 개선사항: 이미지 확대 보기 기능 ---
    const imageTooltip = document.getElementById('image-tooltip');
    const imageZoomOverlay = document.getElementById('image-zoom-overlay');
    const imageZoomContent = document.getElementById('image-zoom-content');
    const imageZoomClose = document.getElementById('image-zoom-close');

    function showZoomModal(imgObject) {
        if (!imgObject) return;
        const dataURL = imgObject.getSrc();
        imageZoomContent.src = dataURL;
        imageZoomOverlay.classList.add('visible'); 
    }

    function hideZoomModal() {
        imageZoomOverlay.classList.remove('visible');
        imageZoomContent.src = '';
    }

    imageZoomClose.addEventListener('click', hideZoomModal);
    imageZoomOverlay.addEventListener('click', (e) => {
        if (e.target === imageZoomOverlay) { hideZoomModal(); }
    });
    
    function enterFullscreen() {
        fullscreenContent.appendChild(imageOverlayContainer);
        fullscreenOverlay.style.display = 'block';
        fullscreenOverlay.appendChild(toggleAnnotationBtn); // 버튼을 오버레이로 이동
        toggleAnnotationBtn.style.display = 'flex'; // 버튼 표시
        setTimeout(() => {
            syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); initializeResizableTable(); updateAnnotationPositions();
        }, 0);
    }

    function exitFullscreen() {
        uiDragOverlay.insertAdjacentElement('afterend', imageOverlayContainer);
        fullscreenOverlay.style.display = 'none';
        toggleAnnotationBtn.style.display = 'none'; // 버튼 숨김
        setAnnotationMode(false);
        setTimeout(() => {
            syncCanvasSize(); updateOverlayPosition(); updateAllAttachedImages(); initializeResizableTable(); updateAnnotationPositions();
        }, 0);
    }

    toggleFullscreenBtn.addEventListener('click', enterFullscreen);
    fullscreenCloseBtn.addEventListener('click', exitFullscreen);

    // --- 개선사항: 주석 및 메모 기능 ---
    const annotationToolsPopup = document.getElementById('annotation-tools-popup');
    let isAnnotationMode = false;
    let annotationDrawingTool = 'select';
    let drawingShape = null, startPoint = null;

    function setAnnotationMode(on) {
        if (on && isImageEditMode) setEditMode(false);
        isAnnotationMode = !!on;
        toggleAnnotationBtn.classList.toggle('active', on);
        annotationToolsPopup.style.display = on ? 'flex' : 'none';
        
        const upperCanvas = fabricCanvas.upperCanvasEl;
        if (upperCanvas) upperCanvas.style.pointerEvents = on ? 'auto' : 'none';

        if (on) {
            fabricCanvas.getObjects().forEach(o => { o.evented = !!o.isAnnotation; });
            updateAnnotationTool();
        } else {
            fabricCanvas.isDrawingMode = false;
            fabricCanvas.selection = true;
            fabricCanvas.getObjects().forEach(o => { o.evented = true; });
            if(upperCanvas) upperCanvas.style.cursor = 'default';
        }
        fabricCanvas.requestRenderAll();
    }

    function updateAnnotationTool() {
        if (!isAnnotationMode) return;
        document.querySelectorAll('#annotation-tools-popup button').forEach(btn => btn.classList.remove('active'));
        const currentToolBtn = document.getElementById(`anno-${annotationDrawingTool}`);
        if(currentToolBtn) currentToolBtn.classList.add('active');
        
        fabricCanvas.isDrawingMode = (annotationDrawingTool === 'pen');
        fabricCanvas.selection = (annotationDrawingTool === 'select' || annotationDrawingTool === 'eraser');
        
        const upperCanvas = fabricCanvas.upperCanvasEl;
        if (upperCanvas) {
            upperCanvas.style.cursor = (annotationDrawingTool === 'eraser') ? 'crosshair' : 'default';
        }
        
        if (fabricCanvas.isDrawingMode) {
            fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
            fabricCanvas.freeDrawingBrush.color = document.getElementById('anno-color').value;
            fabricCanvas.freeDrawingBrush.width = parseInt(document.getElementById('anno-width').value, 10);
        }
    }

    function updateAnnotationPositions() {
        const scrollOffset = fullscreenOverlay.style.display === 'block' ? fullscreenOverlay.scrollTop : window.scrollY;
        fabricCanvas.getObjects().forEach(obj => {
            if (obj.persistentTop !== undefined) {
                obj.top = obj.persistentTop - scrollOffset;
                obj.setCoords();
            }
        });
        fabricCanvas.renderAll();
    }
    
    fabricCanvas.on('path:created', function(e) {
        if (isAnnotationMode) {
            e.path.isAnnotation = true;
            e.path.bringToFront();
            e.path.persistentTop = e.path.top;
        }
    });
    
    // 통합 이벤트 핸들러
    fabricCanvas.on('mouse:down', function (o) {
        if (isAnnotationMode) {
            o.e.stopPropagation();

            if (annotationDrawingTool === 'eraser') {
                if (o.target && o.target.isAnnotation) {
                    fabricCanvas.remove(o.target).requestRenderAll();
                }
                return;
            }
            if (fabricCanvas.isDrawingMode || annotationDrawingTool === 'select') return;
            startPoint = fabricCanvas.getPointer(o.e);
            const color = document.getElementById('anno-color').value;
            const width = parseInt(document.getElementById('anno-width').value, 10);
            switch(annotationDrawingTool) {
                case 'line': drawingShape = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], { stroke: color, strokeWidth: width, isAnnotation: true, evented: false }); break;
                case 'arrow': 
                    const line = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], { stroke: color, strokeWidth: width });
                    const arrowhead = new fabric.Triangle({ left: startPoint.x, top: startPoint.y, width: width * 3, height: width * 3, fill: color, angle: -90, originX: 'center', originY: 'center' });
                    drawingShape = new fabric.Group([line, arrowhead], { isAnnotation: true, evented: false });
                    break;
                case 'rect': drawingShape = new fabric.Rect({ left: startPoint.x, top: startPoint.y, width: 0, height: 0, stroke: color, strokeWidth: width, fill: 'transparent', isAnnotation: true, evented: false }); break;
                case 'circle': drawingShape = new fabric.Ellipse({ left: startPoint.x, top: startPoint.y, rx: 0, ry: 0, stroke: color, strokeWidth: width, fill: 'transparent', isAnnotation: true, evented: false }); break;
            }
            if (drawingShape) {
                fabricCanvas.add(drawingShape);
                drawingShape.bringToFront();
            }

        } else if (isImageEditMode || isCropping) {
            // 이미지 편집 로직
        } else {
            // 기본 모드 로직
            if (o.target && o.target.type === 'image' && o.e.shiftKey) {
                o.e.preventDefault(); o.e.stopPropagation(); showZoomModal(o.target); return;
            }
            if (!o.target) {
                const upperCanvas = fabricCanvas.upperCanvasEl;
                upperCanvas.style.pointerEvents = 'none';
                const underlyingElement = document.elementFromPoint(o.e.clientX, o.e.clientY);
                upperCanvas.style.pointerEvents = 'auto';
                if (underlyingElement) {
                    const isResizer = underlyingElement.classList.contains('resizer-col') || underlyingElement.classList.contains('resizer-row');
                    if (isResizer) {
                        const mouseDownEvent = new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window, clientX: o.e.clientX, clientY: o.e.clientY, button: o.e.button });
                        underlyingElement.dispatchEvent(mouseDownEvent);
                    } else { underlyingElement.click(); }
                }
            }
        }
    });


    fabricCanvas.on('mouse:move', function (o) {
        if (!isAnnotationMode || !drawingShape || !startPoint) return;
        const pointer = fabricCanvas.getPointer(o.e);
        let endX = pointer.x;
        let endY = pointer.y;

        if (o.e.shiftKey) {
            const dx = Math.abs(endX - startPoint.x);
            const dy = Math.abs(endY - startPoint.y);
            if (dx > dy) {
                endY = startPoint.y;
            } else {
                endX = startPoint.x;
            }
        }

        switch(annotationDrawingTool) {
            case 'line': drawingShape.set({ x2: endX, y2: endY }); break;
            case 'arrow':
                const line = drawingShape._objects[0];
                const arrowhead = drawingShape._objects[1];
                line.set({ x2: endX, y2: endY });
                
                const finalDx = endX - startPoint.x;
                const finalDy = endY - startPoint.y;
                const angle = Math.atan2(finalDy, finalDx) * 180 / Math.PI;
                arrowhead.set({ left: endX, top: endY, angle: angle + 90 }).setCoords();
                break;
            case 'rect': drawingShape.set({ width: Math.abs(endX - startPoint.x), height: Math.abs(endY - startPoint.y), left: endX > startPoint.x ? startPoint.x : endX, top: endY > startPoint.y ? startPoint.y : endY }); break;
            case 'circle': drawingShape.set({ rx: Math.abs(endX - startPoint.x) / 2, ry: Math.abs(endY - startPoint.y) / 2, left: endX > startPoint.x ? startPoint.x : endX, top: endY > startPoint.y ? startPoint.y : endY, originX: 'left', originY: 'top' }); break;
        }
        fabricCanvas.renderAll();
    });

    fabricCanvas.on('mouse:up', function (o) {
        if (isAnnotationMode && drawingShape) {
            drawingShape.set({ evented: true }); 
            drawingShape.persistentTop = drawingShape.top;
            if(drawingShape.type === 'group') {
                const groupTop = drawingShape.top;
                drawingShape.getObjects().forEach(obj => obj.persistentTop = groupTop + obj.top);
            }
            drawingShape = null;
            startPoint = null;
        }
    });

    toggleAnnotationBtn.addEventListener('click', () => setAnnotationMode(!isAnnotationMode));

    document.querySelectorAll('#annotation-tools-popup button[id^="anno-"]').forEach(btn => {
        btn.addEventListener('click', () => {
            const tool = btn.id.replace('anno-', '');
            if (['select','pen','line','arrow','rect','circle','eraser'].includes(tool)) {
                annotationDrawingTool = tool;
                updateAnnotationTool();
            }
        });
    });
    
    document.getElementById('anno-color').addEventListener('input', updateAnnotationTool);
    document.getElementById('anno-width').addEventListener('input', updateAnnotationTool);

    document.getElementById('anno-memo').addEventListener('click', () => {
        const canvasRect = fabricCanvas.upperCanvasEl.getBoundingClientRect();
        const viewportCenterX = window.innerWidth / 2;
        const viewportCenterY = window.innerHeight / 2;
        const targetLeft = viewportCenterX - canvasRect.left;
        const targetTop = viewportCenterY - canvasRect.top;

        const memo = new fabric.Textbox('메모 입력...', {
            left: targetLeft,
            top: targetTop,
            width: 150,
            fontSize: 16,
            fill: '#333',
            backgroundColor: '#ffffa8',
            borderColor: '#e6e696',
            cornerColor: '#1a73e8',
            padding: 10,
            splitByGrapheme: true,
            editable: true,
            isAnnotation: true,
            originX: 'center',
            originY: 'center'
        });
        memo.persistentTop = memo.top;
        fabricCanvas.add(memo);
        memo.bringToFront();
        fabricCanvas.setActiveObject(memo).renderAll();
    });

    document.getElementById('anno-clear').addEventListener('click', () => {
        const objectsToRemove = fabricCanvas.getObjects().filter(obj => obj.isAnnotation);
        if (objectsToRemove.length > 0 && confirm('모든 주석과 메모를 삭제하시겠습니까?')) {
            objectsToRemove.forEach(obj => fabricCanvas.remove(obj));
            fabricCanvas.renderAll();
        }
    });

    // --- 개선사항: 주석 도구 팝업 이동 및 리사이즈 기능 ---
    (function enableAnnotationPopupDragAndResize() {
        const popup = document.getElementById('annotation-tools-popup');
        const header = popup.querySelector('.popup-header');
        const uiOverlay = document.getElementById('ui-drag-overlay');
        let drag = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
        let resizing = false, rsDir = '', rsStartX = 0, rsStartY = 0, rsStartW = 0, rsStartH = 0, rsStartL = 0, rsStartT = 0;

        function startOverlay() { if (uiOverlay) uiOverlay.style.display = 'block'; }
        function stopOverlay() { if (uiOverlay) uiOverlay.style.display = 'none'; }

        // 드래그 시작 (헤더)
        header.addEventListener('mousedown', (e) => {
            if (e.target.closest('button')) return;
            drag = true;
            startOverlay();
            startX = e.clientX;
            startY = e.clientY;
            const rect = popup.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            document.body.style.userSelect = 'none';
            e.preventDefault();
            e.stopPropagation();
            popup.focus({ preventScroll: true });
        });

        // 리사이즈 핸들 삽입
        ['n','s','e','w','ne','nw','se','sw'].forEach(dir => {
            const h = document.createElement('div'); h.className = 'resize-handle ' + dir; popup.appendChild(h);
        });

        popup.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('resize-handle')) {
                e.preventDefault(); e.stopPropagation();
                resizing = true;
                rsDir = [...e.target.classList].find(c => c.length <= 2 && c !== 'resize-handle');
                const rect = popup.getBoundingClientRect();
                rsStartX = e.clientX; rsStartY = e.clientY; rsStartW = rect.width; rsStartH = rect.height; rsStartL = rect.left; rsStartT = rect.top;
                document.body.style.userSelect = 'none';
                startOverlay();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (drag) {
                e.preventDefault();
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                popup.style.left = Math.max(0, startLeft + dx) + 'px';
                popup.style.top = Math.max(0, startTop + dy) + 'px';
            } else if (resizing) {
                e.preventDefault();
                let dx = e.clientX - rsStartX; let dy = e.clientY - rsStartY;
                let newW = rsStartW, newH = rsStartH, newL = rsStartL, newT = rsStartT;
                if (rsDir.includes('e')) newW = Math.max(230, rsStartW + dx);
                if (rsDir.includes('s')) newH = Math.max(150, rsStartH + dy);
                if (rsDir.includes('w')) { newW = Math.max(230, rsStartW - dx); newL = rsStartL + dx; }
                if (rsDir.includes('n')) { newH = Math.max(150, rsStartH - dy); newT = rsStartT + dy; }
                popup.style.width = newW + 'px'; popup.style.height = newH + 'px';
                popup.style.left = Math.max(0, newL) + 'px'; popup.style.top = Math.max(0, newT) + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (drag || resizing) { drag = false; resizing = false; stopOverlay(); document.body.style.userSelect = ''; }
        });
    })();

    // --- 8. 최종 초기화 실행 ---
    findSpecialColumns();
    updateCellIds(); // 초기 셀 ID 부여
    initializeResizableTable();
    updateRowNumbers();
    formatAllCurrencyCells();
    clearSelection();
    initializeAutoFit();
    initializeDraggableTable();
    syncCanvasSize();
    ensureCanvasOnTop();
    loadCanvasData();
});
</script>

</body>
</html>
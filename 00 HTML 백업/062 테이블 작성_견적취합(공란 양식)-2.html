<!doctype html>
<html lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>테이블 작성 양식 - 이미지 포함</title>
    <style type="text/css">
      /* --- 기본 및 기능 구현 스타일 --- */
      body {
        font-family: "Malgun Gothic", sans-serif;
        user-select: none;
      }

      .grid-container {
        padding: 10px;
      }

      .title-container {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        flex-wrap: nowrap;
        gap: 15px;
        padding: 5px;
        margin-bottom: 10px;
      }

      .s0 {
        font-weight: bold;
        font-size: 24pt;
        flex-shrink: 0;
      }

      #main-table {
        table-layout: fixed;
        width: 100%;
        border-collapse: collapse;
        border: 1px solid #999;
        position: relative;
        z-index: 1;
      }

      #main-table th,
      #main-table td {
        border: 1px solid #cccccc;
        padding: 8px 5px;
        font-size: 10pt;
        white-space: normal;
        word-wrap: break-word;
        position: relative;
      }

      #main-table td {
        vertical-align: middle;
        text-align: left;
      }

      #main-table td a {
        color: #0000ee;
        text-decoration: underline;
        cursor: pointer;
      }

      #main-table tbody tr:nth-child(even) {
        background-color: #f8f9fa;
      }

      #main-table .no-cell,
      #main-table thead th:not(:first-child) {
        cursor: grab;
      }

      #main-table .no-cell {
        text-align: center;
        vertical-align: middle;
        user-select: none;
      }

      #main-table .checkbox-cell {
        text-align: center;
        font-weight: bold;
        font-size: 14pt;
        cursor: pointer;
        user-select: none;
      }

      #main-table tbody tr {
        position: relative;
      }

      .dragging-row {
        opacity: 0.7;
        background-color: #d9eaff;
      }

      .dragging-col {
        opacity: 0.7;
        background-color: #d9eaff !important;
      }

      .drop-indicator-row-before {
        border-top: 2px solid #1a73e8;
      }

      .drop-indicator-row-after {
        border-bottom: 2px solid #1a73e8;
      }

      .drop-indicator-col-before {
        border-left: 2px solid #1a73e8;
      }

      .drop-indicator-col-after {
        border-right: 2px solid #1a73e8;
      }

      #main-table thead th {
        background-color: #deeaf6;
        text-align: center;
        vertical-align: middle;
        font-weight: bold;
        font-size: 11pt;
        border: 1px solid #999999;
        user-select: none;
      }

      #main-toolbar {
        display: flex;
        align-items: center;
        flex-wrap: nowrap;
        gap: 8px;
        margin-left: auto;
        overflow: hidden;
      }

      #main-toolbar .button-group {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-shrink: 0;
      }

      #main-toolbar button {
        background-color: #f0f0f0;
        border: 1px solid #cccccc;
        padding: 5px 12px;
        font-family: "Malgun Gothic", sans-serif;
        font-size: 10pt;
        cursor: pointer;
        border-radius: 4px;
        font-weight: bold;
        color: #333;
      }

      #main-toolbar button:hover {
        background-color: #e0e0e0;
        border-color: #999999;
      }

      #main-toolbar button:disabled {
        background-color: #e9ecef;
        color: #6c757d;
        cursor: not-allowed;
      }

      #main-toolbar button.active {
        background-color: #1a73e8;
        color: #fff;
        border-color: #1a73e8;
      }

      [contenteditable] {
        -webkit-user-select: text;
        user-select: text;
      }

      [contenteditable]:focus {
        outline: 2px solid #4d90fe;
        outline-offset: -2px;
      }

      #main-toolbar .editor-group {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 4px 6px;
        flex-shrink: 1;
      }

      #main-toolbar .editor-group button {
        background-color: transparent;
        border: none;
        color: #333;
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #main-toolbar .editor-group button svg {
        width: 18px;
        height: 18px;
        fill: #333;
      }

      #main-toolbar .editor-group button:hover,
      #main-toolbar .editor-group button.active {
        background-color: #e9e9e9;
      }

      #main-toolbar .editor-group select,
      #main-toolbar .editor-group input[type="color"] {
        background-color: #fff;
        color: #333;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 2px;
        font-family: "Malgun Gothic", sans-serif;
        font-size: 10pt;
        height: 28px;
      }

      #main-toolbar .editor-group input[type="color"] {
        padding: 1px;
        width: 28px;
        border: 1px solid #ccc;
        cursor: pointer;
      }

      #main-toolbar .editor-separator {
        width: 1px;
        height: 20px;
        background-color: #ccc;
        margin: 0 4px;
        flex-shrink: 0;
      }

      .cell-selected {
        outline: 2px solid #1a73e8 !important;
        outline-offset: -2px;
      }

      #main-table tbody tr.row-focused:nth-child(even),
      #main-table tbody tr.row-focused:nth-child(odd) {
        background-color: #eaf6ff !important;
      }

      @media (max-width: 1500px) {
        #main-toolbar button {
          padding: 5px 8px;
          font-size: 9pt;
        }

        #main-toolbar .editor-group button svg {
          width: 16px;
          height: 16px;
        }

        #main-toolbar .editor-group select,
        #main-toolbar .editor-group input[type="color"] {
          height: 26px;
          font-size: 9pt;
        }
      }

      #context-menu {
        display: none;
        position: absolute;
        z-index: 1000;
        background-color: #f9f9f9;
        border: 1px solid #ccc;
        border-radius: 5px;
        box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.2);
        padding: 5px 0;
        font-family: "Malgun Gothic", sans-serif;
        font-size: 10pt;
      }

      #context-menu ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }

      #context-menu li {
        padding: 8px 15px;
        cursor: pointer;
      }

      #context-menu li:hover {
        background-color: #e0e0e0;
      }

      #context-menu .separator {
        height: 1px;
        background-color: #ccc;
        margin: 4px 0;
      }

      #image-overlay-container {
        position: relative;
        overflow: visible;
      }

      .canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2147483600;
        pointer-events: none;
      }

      #overlay-canvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2147483600;
        pointer-events: none;
      }

      .upper-canvas {
        z-index: 2147483601 !important;
      }

      #image-tools-popup {
        position: fixed;
        top: 64px;
        left: 20px;
        z-index: 2147483647;
        display: none;
        flex-direction: column;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
        padding: 10px;
        width: 520px;
        height: 360px;
        min-width: 260px;
        min-height: 160px;
        pointer-events: auto;
        user-select: none;
        font-size: 9pt;
      }

      #image-tools-popup .popup-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      #image-tools-popup .popup-content-area {
        display: flex;
        flex-wrap: wrap;
        align-content: flex-start;
        gap: 8px;
        flex: 1 1 auto;
        overflow: auto;
      }

      #image-tools-popup .popup-header .title {
        font-weight: 700;
      }

      #image-tools-popup .popup-header {
        cursor: move;
        user-select: none;
      }

      #image-tools-popup .popup-section {
        margin-bottom: 0;
        border: 1px solid #e8e8e8;
        padding: 6px 8px;
        border-radius: 6px;
        flex: 1 1 150px;
        box-sizing: border-box;
      }

      #image-tools-popup .popup-section-title {
        font-size: 1em;
        font-weight: bold;
        color: #555;
        margin-bottom: 4px;
      }

      #image-tools-popup .btn-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      #image-tools-popup button {
        background-color: #f7f7f7;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 1em;
      }

      #image-tools-popup #compression-options label {
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 3px;
        padding: 2px 4px;
        border-radius: 4px;
        transition: background-color 0.2s;
      }

      #image-tools-popup #compression-options label:has(input:checked) {
        background-color: #e0e8f8;
      }

      #image-tools-popup button:hover {
        background-color: #eee;
      }

      #toggleImageToolsBtn.active {
        background-color: #1a73e8;
        color: #fff;
        border-color: #1a73e8;
      }

      .inline-image-tool {
        display: none;
      }

      #toggleImageToolsBtn {
        display: none;
      }

      #image-tools-popup .resize-handle {
        position: absolute;
        width: 12px;
        height: 12px;
        background: rgba(26, 115, 232, 0.9);
        border-radius: 2px;
        pointer-events: auto;
      }

      #image-tools-popup .resize-handle.n {
        top: -5px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }

      #image-tools-popup .resize-handle.s {
        bottom: -5px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }

      #image-tools-popup .resize-handle.e {
        right: -5px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }

      #image-tools-popup .resize-handle.w {
        left: -5px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }

      #image-tools-popup .resize-handle.ne {
        right: -5px;
        top: -5px;
        cursor: nesw-resize;
      }

      #image-tools-popup .resize-handle.nw {
        left: -5px;
        top: -5px;
        cursor: nwse-resize;
      }

      #image-tools-popup .resize-handle.se {
        right: -5px;
        bottom: -5px;
        cursor: nwse-resize;
      }

      #image-tools-popup .resize-handle.sw {
        left: -5px;
        bottom: -5px;
        cursor: nesw-resize;
      }

      #ui-drag-overlay {
        position: fixed;
        inset: 0;
        background: transparent;
        z-index: 2147483646;
        display: none;
        cursor: default;
        pointer-events: all;
      }

      #image-tooltip {
        display: none;
        position: absolute;
        background: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 6px 12px;
        border-radius: 5px;
        font-size: 10pt;
        z-index: 2147483647;
        pointer-events: none;
        white-space: nowrap;
      }

      #image-zoom-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 2147483647;
        justify-content: center;
        align-items: center;
      }

      #image-zoom-overlay.visible {
        display: flex;
      }

      #image-zoom-close {
        position: absolute;
        top: 15px;
        right: 35px;
        color: #f1f1f1;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        transition: color 0.3s;
      }

      #image-zoom-close:hover {
        color: #bbb;
      }

      #image-zoom-content {
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
        animation: zoom-in 0.3s ease-out;
      }

      @keyframes zoom-in {
        from {
          transform: scale(0.8);
          opacity: 0;
        }

        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      #fullscreen-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background-color: #ffffff;
        z-index: 2147483645;
        padding: 20px;
        box-sizing: border-box;
        overflow: auto;
      }

      #fullscreen-close-btn {
        position: fixed;
        top: 15px;
        right: 20px;
        font-size: 40px;
        font-weight: bold;
        color: #333;
        cursor: pointer;
        z-index: 2147483646;
        transition: color 0.3s;
      }

      #fullscreen-close-btn:hover {
        color: #000;
      }

      #toggleFullscreenBtn svg {
        width: 18px;
        height: 18px;
        fill: #333;
      }

      #toggleFullscreenBtn {
        padding: 5px;
      }

      #toggleAnnotationBtn {
        display: none;
        position: fixed;
        top: 24px;
        left: 20px;
        z-index: 2147483646;
        background-color: #f0f0f0;
        border: 1px solid #cccccc;
        padding: 5px;
        cursor: pointer;
        border-radius: 4px;
      }

      #toggleAnnotationBtn:hover {
        background-color: #e0e0e0;
        border-color: #999999;
      }

      #toggleAnnotationBtn.active {
        background-color: #1a73e8;
        color: #fff;
        border-color: #1a73e8;
      }

      #toggleAnnotationBtn.active svg {
        fill: #fff;
      }

      #toggleAnnotationBtn svg {
        width: 18px;
        height: 18px;
        fill: #333;
      }

      #annotation-tools-popup {
        display: none;
        position: fixed;
        top: 80px;
        left: 20px;
        z-index: 2147483647;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 8px;
        flex-direction: column;
        gap: 8px;
        pointer-events: auto;
        user-select: none;
        min-width: 230px;
        min-height: 150px;
      }

      #annotation-tools-popup .popup-header {
        cursor: move;
        padding: 5px 8px;
        background-color: #f7f7f7;
        border-bottom: 1px solid #ddd;
        border-top-left-radius: 7px;
        border-top-right-radius: 7px;
        margin: -8px -8px 8px -8px;
      }

      #annotation-tools-popup .popup-header .title {
        font-weight: bold;
        font-size: 10pt;
        color: #333;
      }

      #annotation-tools-popup .tool-group {
        display: flex;
        align-items: center;
        gap: 5px;
        flex-wrap: wrap;
      }

      #annotation-tools-popup button {
        background-color: #f7f7f7;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 5px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
      }

      #annotation-tools-popup button:hover {
        background-color: #eee;
      }

      #annotation-tools-popup button.active {
        background-color: #d9eaff;
        border-color: #1a73e8;
      }

      #annotation-tools-popup button svg {
        width: 20px;
        height: 20px;
        fill: #333;
      }

      #annotation-tools-popup input[type="color"] {
        width: 32px;
        height: 32px;
        border: 1px solid #ccc;
        padding: 2px;
        box-sizing: border-box;
        cursor: pointer;
        border-radius: 4px;
      }

      #annotation-tools-popup .tool-separator {
        width: 1px;
        height: 25px;
        background-color: #ddd;
        margin: 0 4px;
      }

      .upper-canvas {
        cursor: default;
      }

      #main-table thead th {
        position: relative;
      }

      .th-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
      }

      .th-title {
        flex-grow: 1;
        min-width: 0;
        /* Allows the title to shrink */
        text-align: center;
        cursor: text;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: inline-block;
        /* ADDED: Ensures outline fits content */
      }

      .th-tools {
        flex-shrink: 0;
        /* Prevents tools from shrinking */
        display: flex;
        align-items: center;
        gap: 2px;
        margin-left: auto;
        /* Pushes tools to the right */
      }

      .sort-controls {
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .sort-arrow {
        font-size: 8px;
        line-height: 1;
        cursor: pointer;
        color: #888;
        padding: 1px 0;
        transition: color 0.2s;
      }

      .sort-arrow:hover {
        color: #333;
      }

      .sort-arrow.active {
        color: #1a73e8;
      }

      .filter-btn {
        cursor: pointer;
        font-size: 16px;
        opacity: 0.6;
        transition:
          opacity 0.2s,
          color 0.2s;
        user-select: none;
      }

      .filter-btn:hover {
        opacity: 1;
      }

      .filter-btn.active {
        opacity: 1;
        color: #1a73e8;
      }

      #filter-popup {
        display: none;
        position: absolute;
        z-index: 1010;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        font-family: "Malgun Gothic", sans-serif;
        font-size: 10pt;
        width: 250px;
      }

      #filter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background-color: #f7f7f7;
        border-bottom: 1px solid #ddd;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
      }

      #filter-title {
        font-weight: bold;
      }

      #close-filter-popup {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
      }

      .filter-search-wrapper {
        padding: 5px 10px;
        border-bottom: 1px solid #eee;
      }

      #filter-search-input {
        width: 100%;
        box-sizing: border-box;
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }

      #filter-options {
        max-height: 200px;
        overflow-y: auto;
        padding: 5px 0;
      }

      #filter-options-list {
        padding: 0 10px;
      }

      #filter-options label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #filter-select-all-wrapper {
        padding: 5px 10px;
        border-bottom: 1px solid #eee;
      }

      #filter-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        padding: 10px;
        border-top: 1px solid #ddd;
      }

      #filter-buttons button {
        padding: 5px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        font-size: 9pt;
      }

      #apply-filter-btn {
        background-color: #1a73e8;
        color: white;
        border-color: #1a73e8;
      }

      /* ═══════════════════════════════════════════════════════════════════════════════
       CUSTOM CURSOR SYSTEM (PRD COMPLIANT - ABSOLUTE ENFORCEMENT v2.0)
       ═══════════════════════════════════════════════════════════════════════════════ */
      :root {
        --cursor-default:
          url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='39' height='39' viewBox='0 0 32 32'%3E%3Cpath d='M17 2a2 2 0 0 0-2 2v11l-1.4-1.4a2.1 2.1 0 0 0-3 0 2.1 2.1 0 0 0 0 3L17 23v6h10v-6l3-8.5a2 2 0 0 0-1.1-2.6 2 2 0 0 0-2.6 1.1L25 16V4a2 2 0 0 0-4 0v8h-2V4a2 2 0 0 0-2-2z' fill='%23f4c030' stroke='%23d4a017' stroke-width='0.5'/%3E%3C/svg%3E")
            13 3,
          auto !important;
        --cursor-active:
          url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='39' height='39' viewBox='0 0 32 32'%3E%3Cpath d='M10 14a2 2 0 0 1 2-2h1a2 2 0 0 1 2 2v0a2 2 0 0 1 2-2h1a2 2 0 0 1 2 2v0a2 2 0 0 1 2-2h1a2 2 0 0 1 2 2v7c0 5-3 8-7 8h-3c-4 0-7-3-7-8v-3a2 2 0 0 1 2-2z' fill='%23f4c030' stroke='%23d4a017' stroke-width='0.5'/%3E%3C/svg%3E")
            13 10,
          auto !important;
      }

      /* 1. Base Enforcement: Absolute override on all elements */
      html,
      body,
      *,
      *::before,
      *::after {
        cursor: var(--cursor-default) !important;
      }

      /* 2. Exceptions: Text input areas */
      input,
      textarea,
      [contenteditable="true"],
      [contenteditable="true"] *,
      .select-text,
      .select-text * {
        cursor: text !important;
      }

      button:disabled,
      .not-allowed {
        cursor: not-allowed !important;
      }

      /* 3. Explicit Function Cursors */
      [style*="cursor: nwse-resize"],
      [class*="top-left"],
      [class*="bottom-right"] {
        cursor: nwse-resize !important;
      }

      [style*="cursor: nesw-resize"],
      [class*="top-right"],
      [class*="bottom-left"] {
        cursor: nesw-resize !important;
      }

      [style*="cursor: ns-resize"],
      [class*="ch-top"],
      [class*="ch-bottom"] {
        cursor: ns-resize !important;
      }

      [style*="cursor: ew-resize"],
      [class*="ch-left"],
      [class*="ch-right"] {
        cursor: ew-resize !important;
      }

      [style*="cursor: se-resize"] {
        cursor: se-resize !important;
      }

      [style*="cursor: col-resize"],
      .resizer {
        cursor: col-resize !important;
      }

      [style*="cursor: move"],
      .image-annotation-text,
      #cropBox {
        cursor: move !important;
      }

      [style*="cursor: grabbing"],
      [style*="cursor: grab"] {
        cursor: grab !important;
      }

      [style*="cursor: copy"] {
        cursor: copy !important;
      }

      [style*="cursor: crosshair"],
      .resize-handle-img,
      .ghost-image {
        cursor: crosshair !important;
      }

      [style*="cursor: zoom-in"] {
        cursor: zoom-in !important;
      }

      [style*="cursor: zoom-out"] {
        cursor: zoom-out !important;
      }

      [style*="cursor: help"],
      .tooltip-source-cell {
        cursor: help !important;
      }

      /* 4. Clicking state: Highest Priority Universal Override */
      body.is-clicking,
      body.is-clicking * {
        cursor: var(--cursor-active) !important;
      }
    </style>
  </head>

  <body>
    <div class="grid-container">
      <div class="title-container">
        <span class="s0" contenteditable="true">테이블 작성 양식</span>
        <div id="main-toolbar">
          <div class="editor-group">
            <button id="editor-bold" title="굵게">
              <svg viewBox="0 0 24 24">
                <path
                  d="M15.6,10.79c.97-.67,1.65-1.77,1.65-2.79,0-2.26-1.75-4-4.25-4H7v14h7.04c2.1,0,3.71-1.7,3.71-3.78,0-1.52-.86-2.82-2.15-3.43Zm-5.6-4.79h3.4c1.14,0,2.1.92,2.1,2.05,0,1.13-.96,2.05-2.1,2.05h-3.4V6Zm3.54,9H9.5V13h3.04c1.14,0,2.06.92,2.06,2.05,0,1.13-.92,2.04-2.06,2.04Z"
                ></path>
              </svg>
            </button>
            <button id="editor-italic" title="기울임">
              <svg viewBox="0 0 24 24">
                <path
                  d="M10,4v3h2.21l-3.42,8H6v3h8v-3h-2.21l3.42-8H18V4Z"
                ></path>
              </svg>
            </button>
            <button id="editor-underline" title="밑줄">
              <svg viewBox="0 0 24 24">
                <path
                  d="M12,17c3.31,0,6-2.69,6-6V3h-2.5v8c0,1.93-1.57,3.5-3.5,3.5S8.5,12.93,8.5,11V3H6v8c0,3.31,2.69,6,6,6Zm-7,2v2h14v-2Z"
                ></path>
              </svg>
            </button>
            <button id="editor-link" title="링크 삽입">
              <svg viewBox="0 0 24 24">
                <path
                  d="M3.9,12c0-1.71,1.39-3.1,3.1-3.1h4V7H7c-2.76,0-5,2.24-5,5s2.24,5,5,5h4v-1.9H7C5.29,15.1,3.9,13.71,3.9,12z M8,13h8v-2H8V13z M17,7h-4v1.9h4c1.71,0,3.1,1.39,3.1,3.1s-1.39,3.1-3.1,3.1h-4V17h4c2.76,0,5-2.24,5-5S19.76,7,17,7z"
                ></path>
              </svg>
            </button>
            <button id="editor-unlink" title="링크 제거">
              <svg viewBox="0 0 24 24">
                <path
                  d="M17,7h-4v1.9h4c1.71,0,3.1,1.39,3.1,3.1s-1.39,3.1-3.1,3.1h-4V17h4c2.76,0,5-2.24,5-5S19.76,7,17,7z M10.1,14.5l-1.5-1.5L14.5,7H17v2.5l-4.4,4.4V17h-2.5L10.1,14.5z M7,15.1c-1.71,0-3.1-1.39-3.1-3.1s1.39-3.1,3.1-3.1h4V7H7c-2.76,0-5,2.24-5,5s2.24,5,5,5h4v-1.9H7z"
                ></path>
              </svg>
            </button>
          </div>
          <div class="editor-separator"></div>
          <div class="editor-group">
            <select id="editor-fontsize" title="글자 크기">
              <option value="">기본</option>
              <option value="10pt">10pt</option>
              <option value="11pt">11pt</option>
              <option value="12pt">12pt</option>
              <option value="14pt">14pt</option>
              <option value="16pt">16pt</option>
              <option value="18pt">18pt</option>
              <option value="24pt">24pt</option>
              <option value="36pt">36pt</option>
              <option value="48pt">48pt</option>
              <option value="72pt">72pt</option>
            </select>
            <input
              type="color"
              id="editor-color"
              title="글자 색"
              value="#000000"
            />
            <button id="editor-format-number" title="숫자 서식 (세 자리 쉼표)">
              <svg viewBox="0 0 24 24">
                <path
                  d="M7,13V11H21V13H7M7,19V17H21V19H7M7,7V5H21V7H7M3,8V5H6V8H3M3,14V11H6V14H3M3,20V17H6V20H3Z"
                ></path>
              </svg>
            </button>
          </div>
          <div class="editor-separator"></div>
          <div class="editor-group" id="align-h-group">
            <button id="align-left" title="왼쪽 정렬">
              <svg viewBox="0 0 24 24">
                <path
                  d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"
                ></path>
              </svg>
            </button>
            <button id="align-center" title="가운데 정렬">
              <svg viewBox="0 0 24 24">
                <path
                  d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"
                ></path>
              </svg>
            </button>
            <button id="align-right" title="오른쪽 정렬">
              <svg viewBox="0 0 24 24">
                <path
                  d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"
                ></path>
              </svg>
            </button>
          </div>
          <div class="editor-separator"></div>
          <div class="editor-group" id="align-v-group">
            <button id="align-top" title="위쪽 정렬">
              <svg viewBox="0 0 24 24">
                <path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"></path>
              </svg>
            </button>
            <button id="align-middle" title="중간 정렬">
              <svg viewBox="0 0 24 24">
                <path
                  d="M8 15h3v4h2v-4h3l-4-4-4 4zM4 11v2h16v-2H4zM8 9h3V5h2v4h3l-4 4-4-4z"
                ></path>
              </svg>
            </button>
            <button id="align-bottom" title="아래쪽 정렬">
              <svg viewBox="0 0 24 24">
                <path d="M8 13h3V3h2v10h3l-4 4-4-4zM4 21v-2h16v2H4z"></path>
              </svg>
            </button>
          </div>
          <div class="editor-separator"></div>
          <div class="button-group">
            <button id="toggleImageEditBtn" title="이미지 편집 모드 전환">
              이미지 편집: 끔
            </button>
            <input
              type="file"
              id="excel-file-input"
              accept=".xls, .xlsx"
              style="display: none"
            />
            <button id="importExcelBtn">엑셀 매핑</button>
            <button id="exportExcelBtn">엑셀 추출</button>
            <button id="saveHtmlBtn">HTML 저장</button>
            <button id="toggleFullscreenBtn" title="전체 화면">
              <svg viewBox="0 0 24 24">
                <path
                  d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"
                ></path>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <div id="ui-drag-overlay"></div>

      <div id="image-overlay-container">
        <table id="main-table">
          <colgroup>
            <col style="width: 5%" />
            <col style="width: 4%" />
            <col style="width: 8%" />
            <col style="width: 28%" />
            <col style="width: 7%" />
            <col style="width: 7%" />
            <col style="width: 7%" />
            <col style="width: 5%" />
            <col style="width: 24%" />
            <col style="width: 5%" />
          </colgroup>
          <thead>
            <tr>
              <th title="클릭 후 드래그하여 행 이동">NO.</th>
              <th title="클릭 후 드래그하여 열 이동">적용</th>
              <th title="클릭 후 드래그하여 열 이동">구분</th>
              <th title="클릭 후 드래그하여 열 이동">공사명</th>
              <th title="클릭 후 드래그하여 열 이동">매입 금액</th>
              <th title="클릭 후 드래그하여 열 이동">PO금액</th>
              <th title="클릭 후 드래그하여 열 이동">입고월<br />(예정)</th>
              <th title="클릭 후 드래그하여 열 이동">공종</th>
              <th title="클릭 후 드래그하여 열 이동">주요 사항</th>
              <th title="클릭 후 드래그하여 열 이동">비고</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="no-cell" title="클릭 후 드래그하여 행 이동"></td>
              <td class="checkbox-cell"></td>
              <td contenteditable="true"></td>
              <td contenteditable="true"></td>
              <td class="currency-cell" contenteditable="true"></td>
              <td class="currency-cell" contenteditable="true"></td>
              <td contenteditable="true"></td>
              <td contenteditable="true"></td>
              <td contenteditable="true"></td>
              <td contenteditable="true"></td>
            </tr>
          </tbody>
        </table>
        <canvas id="overlay-canvas"></canvas>
      </div>
      <div
        id="image-tools-popup"
        role="dialog"
        aria-modal="true"
        aria-labelledby="image-tools-title"
        tabindex="0"
      >
        <div class="popup-header">
          <span class="title" id="image-tools-title">이미지 도구</span>
          <button id="closeImageToolsBtn" title="닫기">닫기</button>
        </div>
        <div class="popup-content-area">
          <div class="popup-section">
            <div class="popup-section-title">이미지 추가</div>
            <div class="btn-row">
              <input
                type="file"
                id="image-file-input"
                accept="image/*"
                multiple
                style="display: none"
              />
              <button id="addImageBtn">이미지 추가</button>
            </div>
          </div>
          <div class="popup-section">
            <div class="popup-section-title">이미지 업로드 설정</div>
            <div class="btn-row" id="compression-options">
              <label
                ><input type="radio" name="compression-level" value="high" />
                고화질</label
              >
              <label
                ><input type="radio" name="compression-level" value="medium" />
                표준</label
              >
              <label
                ><input
                  type="radio"
                  name="compression-level"
                  value="low"
                  checked
                />
                저용량</label
              >
            </div>
            <div
              id="compression-status"
              style="
                font-size: 9pt;
                color: #666;
                margin-top: 4px;
                min-height: 1.2em;
              "
            ></div>
          </div>
          <div class="popup-section">
            <div class="popup-section-title">선택</div>
            <div class="btn-row">
              <button id="selectAllImagesBtn">모든 이미지 선택</button>
              <button id="clearSelectionBtn">선택 해제</button>
            </div>
          </div>
          <div class="popup-section">
            <div class="popup-section-title">정렬</div>
            <div class="btn-row">
              <button id="imgAlignLeft">좌</button>
              <button id="imgAlignCenterH">가중</button>
              <button id="imgAlignRight">우</button>
              <button id="imgAlignTop">상</button>
              <button id="imgAlignMiddleV">세중</button>
              <button id="imgAlignBottom">하</button>
            </div>
          </div>
          <div class="popup-section">
            <div class="popup-section-title">레이어 순서</div>
            <div class="btn-row">
              <button id="bringToFrontBtn">맨 앞으로</button>
              <button id="bringForwardBtn">앞으로</button>
              <button id="sendBackwardsBtn">뒤로</button>
              <button id="sendToBackBtn">맨 뒤로</button>
            </div>
          </div>
          <div class="popup-section">
            <div class="popup-section-title">크기 / 배치</div>
            <div class="btn-row">
              <button id="sameWidthBtn">폭 동일</button>
              <button id="sameHeightBtn">높이 동일</button>
              <button id="sameSizeBtn">크기 동일</button>
              <button id="distributeHBtn">간격 균등 가로</button>
              <button id="distributeVBtn">간격 균등 세로</button>
            </div>
          </div>
          <div class="popup-section">
            <div class="popup-section-title">셀 연동</div>
            <div class="btn-row">
              <button
                id="attachToCellBtn"
                title="선택한 이미지를 선택한 표의 셀에 맞춥니다."
              >
                선택 셀에 맞춤
              </button>
            </div>
          </div>
          <div class="popup-section">
            <div class="popup-section-title">스냅/가이드 설정</div>
            <div class="btn-row">
              <label
                >스냅(px)
                <input
                  type="number"
                  id="snapGridInput"
                  value="5"
                  min="0"
                  style="width: 64px"
              /></label>
              <label
                >허용오차(px)
                <input
                  type="number"
                  id="guideToleranceInput"
                  value="4"
                  min="0"
                  style="width: 64px"
              /></label>
              <label
                >가이드색
                <input type="color" id="guideColorInput" value="#ff0000"
              /></label>
            </div>
          </div>
          <div class="popup-section">
            <div class="popup-section-title">잠금</div>
            <div class="btn-row">
              <button id="lockLayerBtn">선택 잠금</button>
              <button id="unlockLayerBtn">전체 해제</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="context-menu">
      <ul>
        <li id="insert-row-above">위에 행 삽입</li>
        <li id="insert-row-below">아래에 행 삽입</li>
        <li id="delete-row">행 삭제</li>
        <li class="separator"></li>
        <li id="insert-col-left">왼쪽에 열 삽입</li>
        <li id="insert-col-right">오른쪽에 열 삽입</li>
        <li id="delete-col">열 삭제</li>
        <li class="separator"></li>
        <li id="set-row-height">행 높이 설정...</li>
        <li id="set-col-width">열 너비 설정...</li>
      </ul>
    </div>

    <div id="image-zoom-overlay">
      <span id="image-zoom-close" title="닫기">&times;</span>
      <img id="image-zoom-content" src="" />
    </div>
    <div id="image-tooltip"></div>

    <div id="fullscreen-overlay">
      <button id="toggleAnnotationBtn" title="주석 모드">
        <svg viewBox="0 0 24 24">
          <path
            d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z"
          ></path>
        </svg>
      </button>
      <span id="fullscreen-close-btn" title="닫기">&times;</span>
      <div id="fullscreen-content"></div>
    </div>

    <div id="annotation-tools-popup">
      <div class="popup-header">
        <span class="title">주석 도구</span>
      </div>
      <div class="tool-group">
        <button id="anno-select" title="이동/선택">
          <svg viewBox="0 0 24 24">
            <path
              d="M13.5,4.2C13.5,4.2 13.5,4.2 13.5,4.2L15.6,8.4L20.2,9L16.8,12.3L17.7,16.8L13.5,14.5L9.3,16.8L10.2,12.3L6.8,9L11.4,8.4L13.5,4.2M13.5,2L11,7.5L5,8.5L9.5,12.5L8,18.5L13.5,15.5L19,18.5L17.5,12.5L22,8.5L16,7.5L13.5,2Z"
            ></path>
          </svg>
        </button>
        <button id="anno-pen" title="펜">
          <svg viewBox="0 0 24 24">
            <path
              d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z"
            ></path>
          </svg>
        </button>
        <button id="anno-line" title="직선">
          <svg viewBox="0 0 24 24">
            <path
              d="M4,11V13H19.95L18.47,15.47L19.88,16.88L23.71,12L19.88,7.12L18.47,8.53L19.95,11H4Z"
              transform="rotate(45 12 12)"
            />
          </svg>
        </button>
        <button id="anno-arrow" title="화살표">
          <svg viewBox="0 0 24 24">
            <path
              d="M5,17.59L15.59,7H9V5H19V15H17V8.41L6.41,19L5,17.59Z"
            ></path>
          </svg>
        </button>
        <button id="anno-rect" title="사각형">
          <svg viewBox="0 0 24 24">
            <path
              d="M19,3H5C3.89,3 3,3.89 3,5V19C3,20.11 3.9,21 5,21H19C20.11,21 21,20.11 21,19V5C21,3.89 20.11,3 19,3M19,19H5V5H19V19Z"
            ></path>
          </svg>
        </button>
        <button id="anno-circle" title="원">
          <svg viewBox="0 0 24 24">
            <path
              d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20Z"
            ></path>
          </svg>
        </button>
      </div>
      <div class="tool-group">
        <input type="color" id="anno-color" title="선 색상" value="#FF0000" />
        <input
          type="range"
          id="anno-width"
          title="선 굵기"
          min="1"
          max="30"
          value="5"
          style="width: 120px"
        />
      </div>
      <div class="tool-group">
        <button id="anno-memo" title="메모 삽입">
          <svg viewBox="0 0 24 24">
            <path
              d="M20,2H4C2.9,2 2,2.9 2,4V22L6,18H20C21.1,18 22,17.1 22,16V4C22,2.9 21.1,2 20,2M20,16H5.2L4,17.2V4H20V16Z"
            ></path>
          </svg>
        </button>
        <div class="tool-separator"></div>
        <button id="anno-eraser" title="지우개 (객체 클릭)">
          <svg viewBox="0 0 24 24">
            <path
              d="M16.24,3.56L21.19,8.5C21.58,8.89 21.58,9.5 21.19,9.9L12.1,19H3V9.9L16.24,3.56M9.9,17H5V11.9L14.09,2.8L19.2,7.9L9.9,17Z"
            ></path>
          </svg>
        </button>
        <button id="anno-clear" title="모두 지우기">
          <svg viewBox="0 0 24 24">
            <path
              d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19C6,20.1 6.9,21 8,21H16C17.1,21 18,20.1 18,19V7H6V19Z"
            ></path>
          </svg>
        </button>
      </div>
    </div>

    <div id="filter-popup">
      <div id="filter-header">
        <span id="filter-title">필터</span>
        <button id="close-filter-popup" title="닫기">&times;</button>
      </div>
      <div class="filter-search-wrapper">
        <input
          type="text"
          id="filter-search-input"
          placeholder="목록 검색..."
        />
      </div>
      <div id="filter-options">
        <div id="filter-select-all-wrapper">
          <label
            ><input type="checkbox" id="filter-select-all" /> (모두 선택)</label
          >
        </div>
        <div id="filter-options-list"></div>
      </div>
      <div id="filter-buttons">
        <button id="clear-filter-btn">필터 초기화</button>
        <button id="apply-filter-btn">적용</button>
      </div>
    </div>

    <script id="canvas-data" type="application/json"></script>

    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.1/dist/browser-image-compression.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const table = document.getElementById("main-table");
        const imageOverlayContainer = document.getElementById(
          "image-overlay-container",
        );
        let isImageEditMode = false;
        let isCropping = false;
        let cropTargetImage = null;
        let cropRect = null;
        const fabricCanvas = new fabric.Canvas("overlay-canvas", {
          enableRetinaScaling: false,
          objectCaching: false,
          selection: true,
          preserveObjectStacking: true,
          willReadFrequently: true,
        });
        if (fabricCanvas && fabricCanvas.upperCanvasEl) {
          fabricCanvas.upperCanvasEl.style.pointerEvents = "none";
        }
        const addImageBtn = document.getElementById("addImageBtn");
        const imageFileInput = document.getElementById("image-file-input");
        const lockLayerBtn = document.getElementById("lockLayerBtn");
        const unlockLayerBtn = document.getElementById("unlockLayerBtn");

        function formatBytes(bytes, decimals = 2) {
          if (!+bytes) return "0 Bytes";
          const k = 1024;
          const dm = decimals < 0 ? 0 : decimals;
          const sizes = [
            "Bytes",
            "KB",
            "MB",
            "GB",
            "TB",
            "PB",
            "EB",
            "ZB",
            "YB",
          ];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
        }
        let _clipboard = null;
        let selectedCells = [],
          contextTargetCell = null,
          currencyColIndices = [],
          checkboxColIndex = -1;
        let activeFilters = {};
        let currentFilterColumn = -1;

        function findSpecialColumns() {
          const headers = Array.from(table.querySelectorAll("thead th"));
          currencyColIndices = headers
            .map((th, i) =>
              th.innerText.includes("매입 금액") ||
              th.innerText.includes("PO금액")
                ? i
                : -1,
            )
            .filter((i) => i !== -1);
          checkboxColIndex = headers.findIndex((th) =>
            th.innerText.includes("적용"),
          );
        }

        function clearSelection() {
          selectedCells.forEach((cell) =>
            cell.classList.remove("cell-selected"),
          );
          selectedCells = [];
          updateEditorUI();
        }

        function addCellToSelection(cell) {
          if (
            !selectedCells.includes(cell) &&
            !cell.classList.contains("no-cell") &&
            cell.tagName === "TD"
          ) {
            selectedCells.push(cell);
            cell.classList.add("cell-selected");
          }
        }

        function updateEditorUI() {
          document
            .querySelectorAll("#main-toolbar .editor-group button.active")
            .forEach((b) => b.classList.remove("active"));
          if (selectedCells.length === 0) return;
          const firstCell = selectedCells[0];
          const style = window.getComputedStyle(firstCell);
          document
            .querySelector(`#align-${style.textAlign}`)
            ?.classList.add("active");
          document
            .querySelector(`#align-${style.verticalAlign}`)
            ?.classList.add("active");
          if (style.fontWeight === "700" || style.fontWeight === "bold")
            document.getElementById("editor-bold").classList.add("active");
          if (style.fontStyle === "italic")
            document.getElementById("editor-italic").classList.add("active");
          if (style.textDecorationLine.includes("underline"))
            document.getElementById("editor-underline").classList.add("active");

          const fontSizeSelect = document.getElementById("editor-fontsize");
          if (
            firstCell.style.fontSize &&
            Array.from(fontSizeSelect.options).some(
              (opt) => opt.value === firstCell.style.fontSize,
            )
          ) {
            fontSizeSelect.value = firstCell.style.fontSize;
          } else {
            const pxSize = parseFloat(style.fontSize);
            const ptSize = Math.round(pxSize * 0.75);
            let closestVal = "";
            let minDiff = Infinity;
            for (const opt of fontSizeSelect.options) {
              if (opt.value) {
                const optPt = parseInt(opt.value, 10);
                const diff = Math.abs(optPt - ptSize);
                if (diff < minDiff) {
                  minDiff = diff;
                  closestVal = opt.value;
                }
              }
            }
            fontSizeSelect.value = minDiff <= 1 ? closestVal : "";
          }
          document.getElementById("editor-color").value = firstCell.style.color
            ? rgbToHex(firstCell.style.color)
            : rgbToHex(style.color);
        }

        table.addEventListener("click", function (e) {
          if (isAnnotationMode) return;
          const link = e.target.closest("a");
          if (link && link.href) {
            e.preventDefault();
            e.stopPropagation();
            window.open(link.href, "_blank", "noopener,noreferrer");
            return;
          }

          const targetCell = e.target.closest("td");

          document
            .querySelectorAll(".row-focused")
            .forEach((r) => r.classList.remove("row-focused"));
          if (targetCell) {
            const row = targetCell.closest("tr");
            if (row) row.classList.add("row-focused");
          }

          if (targetCell && targetCell.classList.contains("checkbox-cell")) {
            e.preventDefault();
            targetCell.innerText = targetCell.innerText === "✓" ? "" : "✓";
            return;
          }

          if (targetCell && targetCell.classList.contains("no-cell")) {
            e.preventDefault();
            clearSelection();
            const row = targetCell.closest("tr");
            Array.from(row.cells).forEach((cell) => addCellToSelection(cell));
            updateEditorUI();
            return;
          }

          if (targetCell) {
            if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
              clearSelection();
              addCellToSelection(targetCell);
            } else if (e.ctrlKey || e.metaKey) {
              if (selectedCells.includes(targetCell)) {
                targetCell.classList.remove("cell-selected");
                selectedCells = selectedCells.filter((c) => c !== targetCell);
              } else {
                addCellToSelection(targetCell);
              }
            } else if (e.shiftKey && selectedCells.length > 0) {
              const allCells = Array.from(
                table.querySelectorAll("td:not(.no-cell)"),
              );
              const firstIndex = allCells.indexOf(selectedCells[0]);
              const lastIndex = allCells.indexOf(targetCell);
              clearSelection();
              const start = Math.min(firstIndex, lastIndex);
              const end = Math.max(firstIndex, lastIndex);
              for (let i = start; i <= end; i++) {
                addCellToSelection(allCells[i]);
              }
            }
            updateEditorUI();
          }
        });

        function applyStyle(style, value) {
          document.execCommand("styleWithCSS", false, true);
          const selection = window.getSelection();
          const range =
            selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
          const isTextSelectedInCell =
            range &&
            !range.collapsed &&
            range.commonAncestorContainer.parentElement.closest(
              'td[contenteditable="true"], th[contenteditable="true"]',
            );

          if (isTextSelectedInCell) {
            if (style === "fontSize" || style === "foreColor") {
              const cssProperty = style === "fontSize" ? "fontSize" : "color";
              const dummyFont = `_dummy_${Date.now()}`;
              document.execCommand("fontName", false, dummyFont);
              const fonts = table.querySelectorAll(`font[face="${dummyFont}"]`);
              fonts.forEach((font) => {
                const span = document.createElement("span");
                span.style[cssProperty] = value;
                while (font.firstChild) {
                  span.appendChild(font.firstChild);
                }
                font.parentNode.replaceChild(span, font);
              });
            } else {
              document.execCommand(style, false, value);
            }
          } else if (selectedCells.length > 0) {
            selectedCells.forEach((cell) => {
              const tempRange = document.createRange();
              tempRange.selectNodeContents(cell);
              selection.removeAllRanges();
              selection.addRange(tempRange);
              if (style === "fontSize") cell.style.fontSize = value;
              else if (style === "foreColor") cell.style.color = value;
              else document.execCommand(style, false, value);
            });
            if (selection) selection.removeAllRanges();
          }
          updateEditorUI();
        }

        function applyAlignment(property, value) {
          if (selectedCells.length === 0) {
            alert("정렬할 셀을 먼저 선택해주세요.");
            return;
          }
          selectedCells.forEach((cell) => {
            cell.style[property] = value;
          });
          updateEditorUI();
        }

        function removeNumberFormatting(cell) {
          function unformatNode(node) {
            if (node.nodeType === 3) {
              node.nodeValue = node.nodeValue.replace(/,/g, "");
            } else if (node.nodeType === 1 && node.childNodes) {
              node.childNodes.forEach(unformatNode);
            }
          }
          unformatNode(cell);
        }
        function updateNumberFormatting(cell) {
          function formatNode(node) {
            if (node.nodeType === 3) {
              const num = parseFloat(node.nodeValue.replace(/,/g, ""));
              if (!isNaN(num)) {
                node.nodeValue = num.toLocaleString("en-US");
              }
            } else if (node.nodeType === 1 && node.childNodes) {
              node.childNodes.forEach(formatNode);
            }
          }
          formatNode(cell);
        }
        table.addEventListener("focusin", (e) => {
          if (e.target.matches(".currency-cell")) {
            removeNumberFormatting(e.target);
          }
        });
        table.addEventListener("focusout", (e) => {
          if (e.target.matches(".currency-cell")) {
            updateNumberFormatting(e.target);
          }
          if (e.target.matches("th")) {
            findSpecialColumns();
          }
        });
        function formatAllCurrencyCells() {
          if (currencyColIndices.length === 0) return;
          currencyColIndices.forEach((colIndex) => {
            table
              .querySelectorAll(`tbody td:nth-child(${colIndex + 1})`)
              .forEach((cell) => {
                updateNumberFormatting(cell);
              });
          });
        }

        function addEditorButtonListener(id, event, callback) {
          const element = document.getElementById(id);
          if (!element) return;
          if (element.tagName === "BUTTON") {
            element.addEventListener("mousedown", (e) => e.preventDefault());
          }
          element.addEventListener(event, callback);
        }

        addEditorButtonListener("editor-bold", "click", () =>
          applyStyle("bold"),
        );
        addEditorButtonListener("editor-italic", "click", () =>
          applyStyle("italic"),
        );
        addEditorButtonListener("editor-underline", "click", () =>
          applyStyle("underline"),
        );
        addEditorButtonListener("editor-fontsize", "change", (e) =>
          applyStyle("fontSize", e.target.value),
        );
        addEditorButtonListener("editor-color", "input", (e) =>
          applyStyle("foreColor", e.target.value),
        );
        addEditorButtonListener("editor-format-number", "click", () => {
          if (selectedCells.length === 0) {
            alert("서식을 적용할 셀을 먼저 선택해주세요.");
            return;
          }
          selectedCells.forEach((cell) => {
            const isCurrency = cell.classList.contains("currency-cell");
            if (isCurrency) {
              cell.classList.remove("currency-cell");
              removeNumberFormatting(cell);
            } else {
              cell.classList.add("currency-cell");
              updateNumberFormatting(cell);
            }
          });
        });
        addEditorButtonListener("align-left", "click", () =>
          applyAlignment("textAlign", "left"),
        );
        addEditorButtonListener("align-center", "click", () =>
          applyAlignment("textAlign", "center"),
        );
        addEditorButtonListener("align-right", "click", () =>
          applyAlignment("textAlign", "right"),
        );
        addEditorButtonListener("align-top", "click", () =>
          applyAlignment("verticalAlign", "top"),
        );
        addEditorButtonListener("align-middle", "click", () =>
          applyAlignment("verticalAlign", "middle"),
        );
        addEditorButtonListener("align-bottom", "click", () =>
          applyAlignment("verticalAlign", "bottom"),
        );

        function addLinkButtonListener(
          buttonId,
          command,
          promptMessage = null,
        ) {
          document
            .getElementById(buttonId)
            .addEventListener("mousedown", (e) => {
              e.preventDefault();
              const selection = window.getSelection();
              if (selection.rangeCount === 0) return;
              let value = null;
              if (promptMessage) {
                const range = selection.getRangeAt(0);
                if (range.collapsed && command === "createLink") {
                  alert("링크를 적용할 텍스트를 먼저 드래그하여 선택해주세요.");
                  return;
                }
                value = prompt(promptMessage, "https://");
                if (!value) return;
              }
              document.execCommand(command, false, value);
            });
        }
        addLinkButtonListener(
          "editor-link",
          "createLink",
          "링크할 URL을 입력하세요:",
        );
        addLinkButtonListener("editor-unlink", "unlink");
        function rgbToHex(rgb) {
          if (!rgb || !/^rgb/.test(rgb)) return "#000000";
          let parts = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
          if (!parts) return "#000000";
          delete parts[0];
          let hex = "#";
          for (let i = 1; i <= 3; ++i) {
            let part = parseInt(parts[i]).toString(16);
            hex += part.length == 1 ? "0" + part : part;
          }
          return hex;
        }

        document
          .getElementById("saveHtmlBtn")
          .addEventListener("click", async () => {
            syncCanvasSize();
            const clonedDoc = document.documentElement.cloneNode(true);
            clonedDoc
              .querySelectorAll(".cell-selected, .row-focused")
              .forEach((el) =>
                el.classList.remove("cell-selected", "row-focused"),
              );
            const canvasDataScript = clonedDoc.querySelector("#canvas-data");
            if (canvasDataScript) {
              canvasDataScript.textContent = JSON.stringify(
                fabricCanvas.toJSON(["persistentTop"]),
              );
            }

            const externalScripts = Array.from(
              clonedDoc.querySelectorAll("script[src]"),
            );
            if (externalScripts.length > 0) {
              try {
                const fetched = await Promise.all(
                  externalScripts.map(async (s) => {
                    try {
                      const res = await fetch(s.src, { cache: "no-cache" });
                      const code = await res.text();
                      return { node: s, code };
                    } catch (err) {
                      console.warn("스크립트 인라인 실패:", s.src, err);
                      return { node: s, code: null };
                    }
                  }),
                );
                fetched.forEach((item) => {
                  const { node, code } = item;
                  if (!code) return;
                  node.removeAttribute("src");
                  node.textContent = code;
                });
              } catch (e) {
                console.warn("외부 스크립트 인라인 과정에서 예외 발생:", e);
              }
            }
            const pageHTML = "<!DOCTYPE html>\n" + clonedDoc.outerHTML;
            const blob = new Blob([pageHTML], {
              type: "text/html;charset=utf-8",
            });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "테이블_양식_이미지포함.html";
            a.click();
            URL.revokeObjectURL(a.href);
          });

        document
          .getElementById("exportExcelBtn")
          .addEventListener("click", () => {
            const wb = XLSX.utils.table_to_book(table, {
              sheet: "테이블 양식",
            });
            XLSX.writeFile(wb, "테이블_양식.xlsx");
          });
        document
          .getElementById("importExcelBtn")
          .addEventListener("click", () =>
            document.getElementById("excel-file-input").click(),
          );
        document
          .getElementById("excel-file-input")
          .addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                const data = new Uint8Array(event.target.result);
                const workbook = XLSX.read(data, { type: "array" });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                  header: 1,
                });
                populateTableWithData(jsonData);
                alert("엑셀 데이터를 성공적으로 매핑했습니다.");
              } catch (error) {
                console.error("엑셀 파일 처리 중 오류:", error);
                alert("엑셀 파일을 처리하는 중 오류가 발생했습니다.");
              } finally {
                e.target.value = "";
              }
            };
            reader.readAsArrayBuffer(file);
          });
        function populateTableWithData(data) {
          if (!data || data.length < 1) {
            alert("매핑할 데이터가 없습니다.");
            return;
          }
          const thead = table.tHead,
            tbody = table.tBodies[0];
          const excelHeaders = data[0].map((h) =>
            String(h).replace(/\n/g, " ").trim(),
          );
          const tableHeaders = Array.from(thead.rows[0].cells).map(
            (th) =>
              th
                .querySelector(".th-title")
                ?.innerText.replace(/\n/g, " ")
                .trim() || th.innerText.replace(/\n/g, " ").trim(),
          );
          const columnIndexMap = new Array(tableHeaders.length);
          const matchedHeaders = [],
            unmatchedTableHeaders = [];

          tableHeaders.forEach((tableHeaderText, tableIndex) => {
            if (tableIndex === 0 || tableIndex === 1) {
              columnIndexMap[tableIndex] = -1;
              return;
            }
            const excelIndex = excelHeaders.findIndex(
              (eh) => eh === tableHeaderText,
            );
            columnIndexMap[tableIndex] = excelIndex;
            if (excelIndex !== -1) {
              matchedHeaders.push(tableHeaderText);
            } else {
              unmatchedTableHeaders.push(tableHeaderText);
            }
          });

          if (matchedHeaders.length === 0) {
            alert(
              "일치하는 헤더가 하나도 없어 매핑을 중단합니다.\n엑셀 파일의 헤더를 확인해주세요.",
            );
            return;
          }
          tbody.innerHTML = "";
          const dataRows = data.slice(1);
          dataRows.forEach((rowData) => {
            const newRow = tbody.insertRow();
            tableHeaders.forEach((thText, tableIndex) => {
              const cell = newRow.insertCell(tableIndex);
              if (tableIndex === 0) {
                cell.classList.add("no-cell");
                return;
              }
              const excelIndex = columnIndexMap[tableIndex];
              const cellValue =
                excelIndex !== -1 && rowData[excelIndex] !== undefined
                  ? rowData[excelIndex]
                  : "";
              if (tableIndex === checkboxColIndex) {
                cell.classList.add("checkbox-cell");
                cell.innerText = cellValue === "✓" ? "✓" : "";
              } else {
                cell.contentEditable = "true";
                cell.innerHTML = String(cellValue).replace(/\n/g, "<br>");
                if (currencyColIndices.includes(tableIndex)) {
                  cell.classList.add("currency-cell");
                }
              }
            });
          });
          updateRowNumbers();
          updateCellIds();
          initializeResizableTable();
          formatAllCurrencyCells();
          clearSelection();
          updateAllAttachedImages();
          let summaryMessage = "엑셀 데이터 매핑이 완료되었습니다.\n";
          if (matchedHeaders.length > 0) {
            summaryMessage += `\n- 매핑된 열 (${matchedHeaders.length}개): \n  ${matchedHeaders.join(", ")}`;
          }
          if (unmatchedTableHeaders.length > 0) {
            summaryMessage += `\n\n- 헤더 불일치로 건너뛴 열 (${unmatchedTableHeaders.length}개): \n  ${unmatchedTableHeaders.join(", ")}`;
          }
          alert(summaryMessage);
        }

        function updateRowNumbers() {
          let visibleIndex = 1;
          table.querySelectorAll("tbody tr").forEach((row, index) => {
            const noCell = row.cells[0];
            if (noCell) {
              if (!row.dataset.originalIndex) {
                row.dataset.originalIndex = index;
              }
              if (row.style.display !== "none") {
                noCell.innerText = visibleIndex++;
              }
            }
          });
        }

        function insertRow(index, above = true) {
          const tbody = table.tBodies[0];
          const colCount = table.rows[0].cells.length;
          const targetIndex = above ? index : index + 1;
          const newRow = tbody.insertRow(targetIndex);
          const noCell = newRow.insertCell(0);
          noCell.classList.add("no-cell");
          noCell.title = "클릭 후 드래그하여 행 이동";
          for (let i = 1; i < colCount; i++) {
            const newCell = newRow.insertCell(i);
            if (i === checkboxColIndex) {
              newCell.classList.add("checkbox-cell");
            } else {
              newCell.contentEditable = "true";
              if (currencyColIndices.includes(i)) {
                newCell.classList.add("currency-cell");
              }
            }
          }
          updateRowNumbers();
          syncCanvasSize();
          ensureCanvasOnTop();
          updateOverlayPosition();
        }

        function deleteRow(index) {
          if (table.tBodies[0].rows.length > 1) {
            table.tBodies[0].deleteRow(index);
            updateRowNumbers();
            updateCellIds();
            syncCanvasSize();
            ensureCanvasOnTop();
            updateOverlayPosition();
            updateAllAttachedImages();
          } else {
            alert("마지막 행은 삭제할 수 없습니다.");
          }
        }

        function insertColumn(index, before = true) {
          if (index === 0 && before) {
            alert("'NO.' 열의 왼쪽에 열을 추가할 수 없습니다.");
            return;
          }
          const targetIndex = before ? index : index + 1;
          table
            .querySelector("colgroup")
            .children[
              targetIndex - 1
            ].insertAdjacentHTML("afterend", '<col style="width: 10%;">');
          const newTh = document.createElement("th");
          table.tHead.rows[0].insertBefore(
            newTh,
            table.tHead.rows[0].cells[targetIndex],
          );
          Array.from(table.tBodies[0].rows).forEach((row) => {
            row.cells[targetIndex - 1].insertAdjacentHTML(
              "afterend",
              '<td contenteditable="true"></td>',
            );
          });
          initializeSortAndFilter();
          findSpecialColumns();
          updateCellIds();
          syncCanvasSize();
          ensureCanvasOnTop();
          updateOverlayPosition();
          updateAllAttachedImages();
        }

        function deleteColumn(index) {
          if (index === 0) {
            alert("'NO.' 열은 삭제할 수 없습니다.");
            return;
          }
          if (table.rows[0].cells.length > 2) {
            table.querySelector("colgroup").children[index].remove();
            Array.from(table.rows).forEach((row) => row.deleteCell(index));
            initializeSortAndFilter();
            findSpecialColumns();
            updateCellIds();
            syncCanvasSize();
            ensureCanvasOnTop();
            updateOverlayPosition();
            updateAllAttachedImages();
          } else {
            alert("마지막 항목 열은 삭제할 수 없습니다.");
          }
        }
        const contextMenu = document.getElementById("context-menu");
        table.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          const target = e.target.closest("td, th");
          if (!target) return;
          contextTargetCell = target;
          const isNoColumn = contextTargetCell.cellIndex === 0;
          const isTbody = contextTargetCell.closest("tbody");
          document.getElementById("delete-col").style.display = isNoColumn
            ? "none"
            : "block";
          document.getElementById("insert-col-left").style.display = isNoColumn
            ? "none"
            : "block";
          document.getElementById("set-row-height").style.display = isTbody
            ? "block"
            : "none";
          document.getElementById("set-col-width").style.display = !isNoColumn
            ? "block"
            : "none";
          contextMenu.style.display = "block";
          contextMenu.style.left = `${e.pageX}px`;
          contextMenu.style.top = `${e.pageY}px`;
          ensureCanvasOnTop();
          updateOverlayPosition();
        });
        document.addEventListener("click", (e) => {
          if (
            !contextMenu.contains(e.target) &&
            !e.target.closest("#main-toolbar")
          ) {
            contextMenu.style.display = "none";
          }
          if (
            !e.target.closest("#filter-popup") &&
            filterPopup.style.display === "block"
          ) {
            if (!e.target.classList.contains("filter-btn"))
              filterPopup.style.display = "none";
          }
          const clickedInsideOverlay =
            fabricCanvas.upperCanvasEl &&
            fabricCanvas.upperCanvasEl.contains(e.target);
          const clickedInsideImageTools =
            !!e.target.closest("#image-tools-popup") ||
            !!e.target.closest("#toggleImageEditBtn");
          const clickedInsideAnnotationTools =
            !!e.target.closest("#annotation-tools-popup") ||
            !!e.target.closest("#toggleAnnotationBtn");
          if (
            !table.contains(e.target) &&
            !document.getElementById("main-toolbar").contains(e.target) &&
            !contextMenu.contains(e.target) &&
            !clickedInsideOverlay &&
            !clickedInsideImageTools &&
            !clickedInsideAnnotationTools &&
            !e.target.closest("#filter-popup")
          ) {
            clearSelection();
            fabricCanvas.discardActiveObject().renderAll();
          }
        });
        contextMenu.addEventListener("click", (e) => {
          if (!contextTargetCell) return;
          const cellIndex = contextTargetCell.cellIndex;
          const tr = contextTargetCell.closest("tr");
          const rowIndex = Array.from(tr.parentNode.children).indexOf(tr);
          switch (e.target.id) {
            case "insert-row-above":
              if (tr.parentNode.tagName === "TBODY") insertRow(rowIndex, true);
              break;
            case "insert-row-below":
              if (tr.parentNode.tagName === "TBODY") insertRow(rowIndex, false);
              break;
            case "delete-row":
              if (contextTargetCell.tagName === "TD") deleteRow(rowIndex);
              break;
            case "insert-col-left":
              insertColumn(cellIndex, true);
              break;
            case "insert-col-right":
              insertColumn(cellIndex, false);
              break;
            case "delete-col":
              deleteColumn(cellIndex);
              break;
            case "set-row-height":
              if (tr && tr.parentNode.tagName === "TBODY") {
                const currentHeight = tr.offsetHeight;
                const newHeightStr = prompt(
                  "새로운 행 높이를 입력하세요 (px 단위):",
                  currentHeight,
                );
                if (newHeightStr) {
                  const newHeight = parseFloat(newHeightStr);
                  if (!isNaN(newHeight) && newHeight > 0) {
                    tr.style.height = newHeight + "px";
                    updateAllAttachedImages();
                  } else {
                    alert("유효한 숫자를 입력해주세요.");
                  }
                }
              }
              break;
            case "set-col-width":
              if (cellIndex > 0) {
                const colElement =
                  table.querySelector("colgroup").children[cellIndex];
                const currentWidth = colElement.offsetWidth;
                const newWidthStr = prompt(
                  "새로운 열 너비를 입력하세요 (px 단위):",
                  currentWidth,
                );
                if (newWidthStr) {
                  const newWidth = parseFloat(newWidthStr);
                  if (!isNaN(newWidth) && newWidth > 0) {
                    colElement.style.width = newWidth + "px";
                    updateAllAttachedImages();
                  } else {
                    alert("유효한 숫자를 입력해주세요.");
                  }
                }
              }
              break;
          }
          contextMenu.style.display = "none";
        });

        function updateCellIds() {
          table.querySelectorAll("tbody tr").forEach((row, rowIndex) => {
            row.querySelectorAll("td").forEach((cell, colIndex) => {
              cell.id = `cell-${rowIndex}-${colIndex}`;
            });
          });
        }
        function ensureCanvasOnTop() {
          updateOverlayPosition();
        }
        function ensureToolsPopupOnTop() {
          const popup = document.getElementById("image-tools-popup");
          if (!popup) return;
          if (popup.parentNode !== document.body) {
            document.body.appendChild(popup);
          }
          popup.style.zIndex = "2147483647";
          popup.style.pointerEvents = "auto";
        }
        function updateOverlayPosition() {
          const wrapper = fabricCanvas.getElement().parentNode;
          if (wrapper) {
            wrapper.style.left = "0px";
            wrapper.style.top = "0px";
          }
          fabricCanvas.calcOffset();
        }
        function syncCanvasSize() {
          const rect = table.getBoundingClientRect();
          const width = Math.ceil(
            Math.max(rect.width, document.documentElement.clientWidth),
          );
          const bodyScrollH = Math.max(
            document.body.scrollHeight,
            document.documentElement.scrollHeight,
            document.body.offsetHeight,
            document.documentElement.offsetHeight,
            document.body.clientHeight,
            document.documentElement.clientHeight,
          );
          const height = Math.max(
            table.scrollHeight,
            table.offsetHeight,
            rect.height,
            bodyScrollH,
          );
          fabricCanvas.setDimensions({ width, height });
          const wrapper = fabricCanvas.getElement().parentNode;
          if (
            wrapper &&
            wrapper.classList &&
            wrapper.classList.contains("canvas-container")
          ) {
            wrapper.style.width = width + "px";
            wrapper.style.height = height + "px";
          }
          fabricCanvas.renderAll();
        }
        if (typeof ResizeObserver !== "undefined") {
          const resizeObserver = new ResizeObserver(() => {
            syncCanvasSize();
            updateOverlayPosition();
            updateAllAttachedImages();
            updateAnnotationPositions();
          });
          resizeObserver.observe(table);
        } else {
          const mutationObserver = new MutationObserver(() => {
            syncCanvasSize();
            updateOverlayPosition();
            updateAllAttachedImages();
            updateAnnotationPositions();
          });
          mutationObserver.observe(table, {
            attributes: true,
            childList: true,
            subtree: true,
          });
        }

        const toggleFullscreenBtn = document.getElementById(
          "toggleFullscreenBtn",
        );
        const fullscreenOverlay = document.getElementById("fullscreen-overlay");
        const fullscreenContent = document.getElementById("fullscreen-content");
        const fullscreenCloseBtn = document.getElementById(
          "fullscreen-close-btn",
        );
        const uiDragOverlay = document.getElementById("ui-drag-overlay");
        const toggleAnnotationBtn = document.getElementById(
          "toggleAnnotationBtn",
        );

        window.addEventListener("scroll", () => {
          updateOverlayPosition();
          updateAllAttachedImages();
          updateAnnotationPositions();
        });
        window.addEventListener("resize", () => {
          syncCanvasSize();
          updateOverlayPosition();
          updateAllAttachedImages();
          updateAnnotationPositions();
        });
        fullscreenOverlay.addEventListener("scroll", updateAnnotationPositions);

        addImageBtn.addEventListener("click", () => imageFileInput.click());
        const toggleImageEditBtn =
          document.getElementById("toggleImageEditBtn");
        function setEditMode(on) {
          if (on && isAnnotationMode) setAnnotationMode(false);
          isImageEditMode = !!on;
          const label = `이미지 편집: ${isImageEditMode ? "켬" : "끔"}`;
          if (toggleImageEditBtn) {
            toggleImageEditBtn.textContent = label;
            toggleImageEditBtn.classList.toggle("active", isImageEditMode);
          }
          if (imageToolsPopup) {
            imageToolsPopup.style.display = isImageEditMode ? "flex" : "none";
          }
          syncCanvasSize();
          ensureCanvasOnTop();
          updateOverlayPosition();
          const upperCanvas = fabricCanvas.upperCanvasEl;
          if (upperCanvas) upperCanvas.style.pointerEvents = "auto";
          fabricCanvas.skipTargetFind = false;
          if (isImageEditMode) {
            fabricCanvas.getObjects().forEach((o) => {
              if (o.isAnnotation) o.evented = false;
              else o.evented = true;
            });
          } else {
            if (isCropping) cancelCrop();
            fabricCanvas.discardActiveObject().requestRenderAll();
          }
        }
        const imageToolsPopup = document.getElementById("image-tools-popup");
        const closeImageToolsBtn =
          document.getElementById("closeImageToolsBtn");
        const popupHeaderEl = imageToolsPopup.querySelector(".popup-header");
        toggleImageEditBtn.addEventListener("click", () => {
          setEditMode(!isImageEditMode);
          ensureToolsPopupOnTop();
        });
        closeImageToolsBtn.addEventListener("click", () => {
          imageToolsPopup.style.display = "none";
          setEditMode(false);
        });
        lockLayerBtn.addEventListener("click", () => {
          lockSelected();
          lockLayerBtn.classList.add("active");
          setTimeout(() => lockLayerBtn.classList.remove("active"), 200);
        });
        unlockLayerBtn.addEventListener("click", () => {
          unlockAll();
          unlockLayerBtn.classList.add("active");
          setTimeout(() => unlockLayerBtn.classList.remove("active"), 200);
        });
        const imgAlignLeft = document.getElementById("imgAlignLeft");
        const imgAlignCenterH = document.getElementById("imgAlignCenterH");
        const imgAlignRight = document.getElementById("imgAlignRight");
        const imgAlignTop = document.getElementById("imgAlignTop");
        const imgAlignMiddleV = document.getElementById("imgAlignMiddleV");
        const imgAlignBottom = document.getElementById("imgAlignBottom");

        function getSelectionImages() {
          const active = fabricCanvas.getActiveObject();
          if (!active) return [];
          if (active.type === "activeSelection")
            return active.getObjects().filter((o) => o.type === "image");
          return active.type === "image" ? [active] : [];
        }
        function getAllImages() {
          return fabricCanvas.getObjects().filter((o) => o.type === "image");
        }
        function alignSelected(horizontal, vertical) {
          const images = getSelectionImages();
          if (images.length === 0) return;
          const canvasWidth = fabricCanvas.getWidth();
          const canvasHeight = fabricCanvas.getHeight();
          images.forEach((img) => {
            const halfW = img.getScaledWidth() / 2,
              halfH = img.getScaledHeight() / 2;
            if (horizontal === "left") img.left = halfW;
            if (horizontal === "center") img.left = canvasWidth / 2;
            if (horizontal === "right") img.left = canvasWidth - halfW;
            if (vertical === "top") img.top = halfH;
            if (vertical === "middle") img.top = canvasHeight / 2;
            if (vertical === "bottom") img.top = canvasHeight - halfH;
            img.setCoords();
          });
          fabricCanvas.requestRenderAll();
        }
        imgAlignLeft.addEventListener("click", () => {
          alignSelected("left");
          imgAlignLeft.classList.add("active");
          setTimeout(() => imgAlignLeft.classList.remove("active"), 200);
        });
        imgAlignCenterH.addEventListener("click", () => {
          alignSelected("center");
          imgAlignCenterH.classList.add("active");
          setTimeout(() => imgAlignCenterH.classList.remove("active"), 200);
        });
        imgAlignRight.addEventListener("click", () => {
          alignSelected("right");
          imgAlignRight.classList.add("active");
          setTimeout(() => imgAlignRight.classList.remove("active"), 200);
        });
        imgAlignTop.addEventListener("click", () => {
          alignSelected(undefined, "top");
          imgAlignTop.classList.add("active");
          setTimeout(() => imgAlignTop.classList.remove("active"), 200);
        });
        imgAlignMiddleV.addEventListener("click", () => {
          alignSelected(undefined, "middle");
          imgAlignMiddleV.classList.add("active");
          setTimeout(() => imgAlignMiddleV.classList.remove("active"), 200);
        });
        imgAlignBottom.addEventListener("click", () => {
          alignSelected(undefined, "bottom");
          imgAlignBottom.classList.add("active");
          setTimeout(() => imgAlignBottom.classList.remove("active"), 200);
        });
        function forEachSelection(cb) {
          const images = getSelectionImages();
          if (images.length === 0) return;
          images.forEach(cb);
          fabricCanvas.requestRenderAll();
        }
        document
          .getElementById("bringToFrontBtn")
          .addEventListener("click", () =>
            forEachSelection((o) => o.bringToFront && o.bringToFront()),
          );
        document
          .getElementById("bringForwardBtn")
          .addEventListener("click", () =>
            forEachSelection((o) => o.bringForward && o.bringForward()),
          );
        document
          .getElementById("sendBackwardsBtn")
          .addEventListener("click", () =>
            forEachSelection((o) => o.sendBackwards && o.sendBackwards()),
          );
        document
          .getElementById("sendToBackBtn")
          .addEventListener("click", () =>
            forEachSelection((o) => o.sendToBack && o.sendToBack()),
          );
        function sameWidth() {
          const images = getSelectionImages();
          if (images.length < 2) return;
          const w = images[0].getScaledWidth();
          images.forEach((img, i) => {
            if (i === 0) return;
            const scale = w / img.getScaledWidth();
            img.scaleX *= scale;
            img.scaleY *= scale;
            img.setCoords();
          });
          fabricCanvas.requestRenderAll();
        }
        function sameHeight() {
          const images = getSelectionImages();
          if (images.length < 2) return;
          const h = images[0].getScaledHeight();
          images.forEach((img, i) => {
            if (i === 0) return;
            const scale = h / img.getScaledHeight();
            img.scaleX *= scale;
            img.scaleY *= scale;
            img.setCoords();
          });
          fabricCanvas.requestRenderAll();
        }
        function sameSize() {
          const images = getSelectionImages();
          if (images.length < 2) return;
          const w = images[0].getScaledWidth(),
            h = images[0].getScaledHeight();
          images.forEach((img, i) => {
            if (i === 0) return;
            const scaleX = w / img.getScaledWidth(),
              scaleY = h / img.getScaledHeight();
            img.scaleX *= scaleX;
            img.scaleY *= scaleY;
            img.setCoords();
          });
          fabricCanvas.requestRenderAll();
        }
        document
          .getElementById("sameWidthBtn")
          .addEventListener("click", () => sameWidth());
        document
          .getElementById("sameHeightBtn")
          .addEventListener("click", () => sameHeight());
        document
          .getElementById("sameSizeBtn")
          .addEventListener("click", () => sameSize());
        function distributeHorizontally() {
          const images = getSelectionImages();
          if (images.length < 3) return;
          const sorted = [...images].sort((a, b) => a.left - b.left);
          const leftMost = sorted[0],
            rightMost = sorted[sorted.length - 1];
          const totalWidth = rightMost.left - leftMost.left;
          const step = totalWidth / (sorted.length - 1);
          sorted.forEach((img, idx) => {
            img.left = leftMost.left + step * idx;
            img.setCoords();
          });
          fabricCanvas.requestRenderAll();
        }
        function distributeVertically() {
          const images = getSelectionImages();
          if (images.length < 3) return;
          const sorted = [...images].sort((a, b) => a.top - b.top);
          const topMost = sorted[0],
            bottomMost = sorted[sorted.length - 1];
          const totalHeight = bottomMost.top - topMost.top;
          const step = totalHeight / (sorted.length - 1);
          sorted.forEach((img, idx) => {
            img.top = topMost.top + step * idx;
            img.setCoords();
          });
          fabricCanvas.requestRenderAll();
        }
        document
          .getElementById("distributeHBtn")
          .addEventListener("click", () => distributeHorizontally());
        document
          .getElementById("distributeVBtn")
          .addEventListener("click", () => distributeVertically());
        function syncImageToCell(image) {
          if (!image.attachedCellId) return;
          const cell = document.getElementById(image.attachedCellId);
          const canvasContainer = imageOverlayContainer;
          if (!cell) {
            image.attachedCellId = null;
            image.set({ stroke: null, strokeWidth: 0 });
            return;
          }
          const cellRect = cell.getBoundingClientRect(),
            containerRect = canvasContainer.getBoundingClientRect();
          const left = cellRect.left - containerRect.left,
            top = cellRect.top - containerRect.top;
          const width = cellRect.width,
            height = cellRect.height,
            padding = 4;
          const targetWidth = Math.max(1, width - padding),
            targetHeight = Math.max(1, height - padding);
          const scaleX = targetWidth / image.width,
            scaleY = targetHeight / image.height;
          image.set({
            scaleX,
            scaleY,
            left: left + width / 2,
            top: top + height / 2,
            originX: "center",
            originY: "center",
          });
          image.setCoords();
        }
        function updateAllAttachedImages() {
          fabricCanvas.getObjects().forEach((obj) => {
            if (obj.attachedCellId) {
              syncImageToCell(obj);
            }
          });
          fabricCanvas.renderAll();
        }
        function attachImageToCell() {
          const images = getSelectionImages();
          if (images.length !== 1) {
            alert("하나의 이미지를 선택해주세요.");
            return;
          }
          if (selectedCells.length !== 1) {
            alert("하나의 표 셀을 선택해주세요.");
            return;
          }
          const image = images[0],
            cell = selectedCells[0];
          if (!cell.id) {
            updateCellIds();
          }
          if (!cell.id) {
            alert("셀을 식별할 수 없습니다. 다시 시도해주세요.");
            return;
          }
          image.attachedCellId = cell.id;
          image.set({ stroke: "rgba(26,115,232,0.8)", strokeWidth: 3 });
          syncImageToCell(image);
          fabricCanvas.requestRenderAll();
          captureCurrentSelection();
        }
        document
          .getElementById("attachToCellBtn")
          .addEventListener("click", attachImageToCell);
        document
          .getElementById("selectAllImagesBtn")
          .addEventListener("click", () => {
            const imgs = getAllImages();
            if (imgs.length === 0) return;
            fabricCanvas.setActiveObject(
              new fabric.ActiveSelection(imgs, { canvas: fabricCanvas }),
            );
            fabricCanvas.requestRenderAll();
          });
        document
          .getElementById("clearSelectionBtn")
          .addEventListener("click", () => {
            allowManualClear = true;
            fabricCanvas.discardActiveObject().requestRenderAll();
          });
        function deleteSelection() {
          if (isCropping) return;
          const active = fabricCanvas.getActiveObject();
          if (!active) return;
          if (active.type === "activeSelection") {
            active.getObjects().forEach((o) => fabricCanvas.remove(o));
          } else {
            fabricCanvas.remove(active);
          }
          persistentSelection = null;
          fabricCanvas.discardActiveObject().requestRenderAll();
        }

        imageFileInput.addEventListener("change", async (e) => {
          const files = Array.from(e.target.files);
          if (isCropping || files.length === 0) return;
          document.body.style.cursor = "wait";
          addImageBtn.disabled = true;
          try {
            syncCanvasSize();
            const selectedLevel =
              document.querySelector('input[name="compression-level"]:checked')
                ?.value || "medium";
            const compressionStatusEl =
              document.getElementById("compression-status");
            if (compressionStatusEl)
              compressionStatusEl.textContent = "이미지 압축 중...";
            const compressionPresets = {
              high: {
                maxSizeMB: 2.0,
                initialQuality: 0.9,
                maxWidthOrHeight: 2560,
              },
              medium: {
                maxSizeMB: 0.8,
                initialQuality: 0.8,
                maxWidthOrHeight: 1920,
              },
              low: {
                maxSizeMB: 0.3,
                initialQuality: 0.6,
                maxWidthOrHeight: 1280,
              },
            };
            const baseOptions = compressionPresets[selectedLevel];
            let totalOriginalSize = 0,
              totalCompressedSize = 0;
            const imageProcessingPromises = files.map(async (file) => {
              totalOriginalSize += file.size;
              const compressionOptions = {
                ...baseOptions,
                useWebWorker: true,
                maxIteration: 10,
                alwaysKeepResolution: false,
              };
              try {
                const compressedFile = await imageCompression(
                  file,
                  compressionOptions,
                );
                totalCompressedSize += compressedFile.size;
                return await imageCompression.getDataUrlFromFile(
                  compressedFile,
                );
              } catch (error) {
                console.warn(
                  `'${file.name}' 압축 실패, 캔버스 폴백 시도:`,
                  error,
                );
                try {
                  return await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                      const img = new Image();
                      img.onload = () => {
                        const max = 1920;
                        let { width, height } = img;
                        const scale = Math.min(
                          1,
                          max / Math.max(width, height),
                        );
                        width = Math.round(width * scale);
                        height = Math.round(height * scale);
                        const canvas = document.createElement("canvas");
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext("2d");
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL("image/jpeg", 0.85));
                      };
                      img.onerror = reject;
                      img.src = reader.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                  });
                } catch (err2) {
                  console.error(`'${file.name}' 폴백까지 실패:`, err2);
                  return null;
                }
              }
            });
            const imageDataUrls = await Promise.all(imageProcessingPromises);
            if (compressionStatusEl) {
              const reduction =
                totalOriginalSize > 0
                  ? (
                      (1 - totalCompressedSize / totalOriginalSize) *
                      100
                    ).toFixed(1)
                  : 0;
              compressionStatusEl.textContent = `압축: ${formatBytes(totalOriginalSize)} → ${formatBytes(totalCompressedSize)} (${reduction}%↓)`;
            }
            const validUrls = imageDataUrls.filter((url) => url !== null);
            const imageLoadingPromises = validUrls.map(
              (url) =>
                new Promise((resolve, reject) => {
                  fabric.Image.fromURL(
                    url,
                    (img) => {
                      if (img) resolve(img);
                      else
                        reject(
                          new Error(
                            "데이터 URL로부터 이미지를 로드하지 못했습니다.",
                          ),
                        );
                    },
                    { crossOrigin: "anonymous" },
                  );
                }),
            );
            let fabricImages = await Promise.all(imageLoadingPromises);
            fabricImages.forEach((img, i) => {
              img.selectable = true;
              img.evented = true;
              img.perPixelTargetFind = true;
              img.bringToFront();
              img.set({ globalCompositeOperation: "source-over" });
            });
            fabricImages.forEach((img, index) => {
              const canvasRect =
                fabricCanvas.upperCanvasEl.getBoundingClientRect();
              const viewportCenterX = window.innerWidth / 2,
                viewportCenterY = window.innerHeight / 2;
              let targetLeft = viewportCenterX - canvasRect.left,
                targetTop = viewportCenterY - canvasRect.top;
              const offset = (index - (fabricImages.length - 1) / 2) * 40;
              targetLeft += offset;
              targetTop += offset;
              const targetWidth = Math.min(480, img.width || 480);
              img.scaleToWidth(targetWidth);
              img.set({
                left: targetLeft,
                top: targetTop,
                originX: "center",
                originY: "center",
                angle: 0,
                padding: 10,
                cornerSize: 10,
                hasRotatingPoint: true,
              });
              const halfW = (img.getScaledWidth() || 200) / 2,
                halfH = (img.getScaledHeight() || 200) / 2;
              img.left = Math.max(
                halfW,
                Math.min(fabricCanvas.width - halfW, img.left),
              );
              img.top = Math.max(
                halfH,
                Math.min(fabricCanvas.height - halfH, img.top),
              );
              fabricCanvas.add(img);
              img.bringToFront();
            });
            if (validUrls.length < files.length) {
              alert(
                "일부 이미지 처리 중 오류가 발생했습니다. 자세한 내용은 개발자 콘솔을 확인해주세요.",
              );
            }
            if (fabricImages.length > 0) {
              const upperCanvas = fabricCanvas.upperCanvasEl;
              if (upperCanvas)
                upperCanvas.style.pointerEvents = isImageEditMode
                  ? "auto"
                  : "none";
              setTimeout(() => {
                try {
                  const lastImg = fabricImages[fabricImages.length - 1];
                  if (lastImg) fabricCanvas.setActiveObject(lastImg);
                  fabricCanvas.requestRenderAll();
                } catch (e) {
                  console.warn("selection 구성 중 경고:", e);
                }
              }, 0);
              ensureCanvasOnTop();
              updateOverlayPosition();
            }
            fabricCanvas.renderAll();
          } catch (error) {
            console.error("이미지 처리 과정에서 예기치 않은 오류 발생:", error);
            alert("이미지를 처리하는 중 심각한 오류가 발생했습니다.");
          } finally {
            document.body.style.cursor = "default";
            addImageBtn.disabled = false;
            e.target.value = "";
            ensureCanvasOnTop();
          }
        });

        const deleteIcon =
          "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='0 0 595.275 595.275' enable-background='new 0 0 595.275 595.275' xml:space='preserve'%3E%3Cg%3E%3Cpath d='M354.724,297.636l227.16-227.16c9.763-9.763,9.763-25.592,0-35.355L544.51,0l-227.16,227.16L89.675-0.002 L48.3,35.353c-9.763,9.763-9.763,25.592,0,35.355l227.69,227.69L48.3,524.801c-9.763,9.763-9.763,25.592,0,35.355 l37.375,37.375c9.763,9.763,25.592,9.763,35.355,0l227.16-227.16l227.16,227.16c9.763,9.763,25.592,9.763,35.355,0 l37.375-37.375c9.763-9.763,9.763-25.592,0-35.355L354.724,297.636z'/%3E%3C/g%3E%3C/svg%3E";
        const cloneIcon =
          "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='iso-8859-1'%3F%3E%3Csvg version='1.1' id='Capa_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 35.635 35.635' style='enable-background:new 0 0 35.635 35.635;' xml:space='preserve'%3E%3Cg%3E%3Cpath d='M34.135,0H9.762c-0.828,0-1.5,0.672-1.5,1.5v4.323H1.5c-0.828,0-1.5,0.672-1.5,1.5v26.812c0,0.828,0.672,1.5,1.5,1.5 h24.373c0.828,0,1.5-0.672,1.5-1.5v-4.323h6.762c0.828,0,1.5-0.672,1.5-1.5V1.5C35.635,0.672,34.963,0,34.135,0z M24.373,32.635 H3V8.823h21.373V32.635z M32.635,28.312h-5.262V7.323c0-0.828-0.672-1.5-1.5-1.5H9.762V3h22.873V28.312z'/%3E%3C/g%3E%3C/svg%3E";
        const flipIcon =
          "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='122.879px' height='104.918px' viewBox='0 0 122.879 104.918' enable-background='new 0 0 122.879 104.918' xml:space='preserve'%3E%3Cg%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M99.951,104.918H69.419c-3.172,0-5.742-2.57-5.742-5.742V5.742 c0-3.172,2.57-5.742,5.742-5.742h30.532c3.171,0,5.741,2.57,5.741,5.742v93.435C105.692,102.348,103.122,104.918,99.951,104.918z M53.46,5.742v93.435c0,3.172-2.57,5.742-5.742,5.742H22.936c-3.171,0-5.742-2.57-5.742-5.742V5.742c0-3.172,2.571-5.742,5.742-5.742 h24.782C50.89,0,53.46,2.57,53.46,5.742z M99.951,104.918'/%3E%3C/g%3E%3C/svg%3E";
        const cropIcon =
          "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M17 15h2V7c0-1.1-.9-2-2-2H9v2h8v8zM7 17V1H5v4H1v2h4v10c0 1.1.9 2 2 2h10v4h2v-4h4v-2H7z' fill='%23333'%3E%3C/path%3E%3C/svg%3E";
        const applyCropIcon =
          "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z' fill='white'%3E%3C/path%3E%3C/svg%3E";
        const cancelCropIcon =
          "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z' fill='white'%3E%3C/path%3E%3C/svg%3E";

        function renderIcon(icon, withBg = false) {
          return function renderIcon(
            ctx,
            left,
            top,
            styleOverride,
            fabricObject,
          ) {
            const size = this.cornerSize;
            ctx.save();
            ctx.translate(left, top);
            ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            if (withBg) {
              ctx.beginPath();
              ctx.arc(0, 0, size / 2, 0, Math.PI * 2, false);
              ctx.fillStyle = "rgba(0,0,0,0.7)";
              ctx.fill();
            }
            ctx.drawImage(icon, -size / 2, -size / 2, size, size);
            ctx.restore();
          };
        }
        const deleteImg = document.createElement("img");
        deleteImg.src = deleteIcon;
        const cloneImg = document.createElement("img");
        cloneImg.src = cloneIcon;
        const flipImg = document.createElement("img");
        flipImg.src = flipIcon;
        const cropImg = document.createElement("img");
        cropImg.src = cropIcon;
        const applyCropImg = document.createElement("img");
        applyCropImg.src = applyCropIcon;
        const cancelCropImg = document.createElement("img");
        cancelCropImg.src = cancelCropIcon;

        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.cornerColor = "rgba(102,153,255,0.8)";
        fabric.Object.prototype.cornerStyle = "circle";
        fabric.Object.prototype.borderColor = "rgba(102,153,255,0.8)";
        fabric.Object.prototype.borderScaleFactor = 2;
        fabricCanvas.snapToGrid = 5;
        fabricCanvas.on("object:moving", function (e) {
          const obj = e.target;
          if (!obj) return;
          if (isAnnotationMode) return;
          obj.left =
            Math.round(obj.left / fabricCanvas.snapToGrid) *
            fabricCanvas.snapToGrid;
          obj.top =
            Math.round(obj.top / fabricCanvas.snapToGrid) *
            fabricCanvas.snapToGrid;
          drawGuides(obj);
        });
        fabricCanvas.on("object:modified", function (e) {
          const obj = e.target;
          if (obj && obj.isAnnotation) {
            obj.persistentTop = obj.top;
            obj.bringToFront();
          }
          if (obj && obj.attachedCellId) {
            if (isCropping) return;
            obj.attachedCellId = null;
            obj.set({ stroke: null, strokeWidth: 0 });
          }
          clearGuides();
          captureCurrentSelection();
        });

        let allowManualClear = false,
          persistentSelection = null,
          mousedownOnToolsPopup = false;
        function captureCurrentSelection() {
          const active = fabricCanvas.getActiveObject();
          if (active) {
            persistentSelection = active;
          }
        }
        fabricCanvas.on("before:transform", captureCurrentSelection);
        fabricCanvas.on("selection:created", captureCurrentSelection);
        fabricCanvas.on("selection:updated", captureCurrentSelection);
        document.addEventListener(
          "mousedown",
          (e) => {
            if (!isImageEditMode) return;
            mousedownOnToolsPopup = !!e.target.closest("#image-tools-popup");
          },
          true,
        );
        fabricCanvas.on("selection:cleared", function () {
          if (isCropping || !isImageEditMode) return;
          if (allowManualClear) {
            allowManualClear = false;
            persistentSelection = null;
            return;
          }
          if (mousedownOnToolsPopup && persistentSelection) {
            setTimeout(() => {
              try {
                let objs = [];
                if (persistentSelection.type === "activeSelection") {
                  objs = persistentSelection
                    .getObjects()
                    .filter((o) => fabricCanvas.getObjects().includes(o));
                } else if (
                  fabricCanvas.getObjects().includes(persistentSelection)
                ) {
                  objs = [persistentSelection];
                }
                if (objs.length > 0) {
                  const selectionToRestore =
                    objs.length === 1
                      ? objs[0]
                      : new fabric.ActiveSelection(objs, {
                          canvas: fabricCanvas,
                        });
                  fabricCanvas
                    .setActiveObject(selectionToRestore)
                    .requestRenderAll();
                }
              } catch (e) {
                console.warn("Could not restore selection", e);
              }
            }, 0);
          }
        });
        document.addEventListener(
          "mousedown",
          (e) => {
            if (!isImageEditMode || isCropping) return;
            const upper = fabricCanvas.upperCanvasEl;
            const clickedOnOverlay = upper && upper.contains(e.target);
            const clickedOnToolsPopup =
              !!e.target.closest("#image-tools-popup");
            if (!clickedOnOverlay && !clickedOnToolsPopup) {
              e.stopPropagation();
            }
          },
          true,
        );
        const snapGridInputEl = document.getElementById("snapGridInput");
        const guideToleranceInputEl = document.getElementById(
          "guideToleranceInput",
        );
        const guideColorInputEl = document.getElementById("guideColorInput");
        if (snapGridInputEl)
          snapGridInputEl.addEventListener("change", () => {
            const v = parseInt(snapGridInputEl.value, 10);
            if (!isNaN(v) && v >= 0) fabricCanvas.snapToGrid = v;
          });
        if (guideToleranceInputEl)
          guideToleranceInputEl.addEventListener("change", () => {
            const v = parseInt(guideToleranceInputEl.value, 10);
            if (!isNaN(v) && v >= 0) guideTolerance = v;
          });
        if (guideColorInputEl)
          guideColorInputEl.addEventListener("input", () => {
            guideColor = guideColorInputEl.value || "#ff0000";
          });
        (function enablePopupDragAndResize() {
          const popup = imageToolsPopup;
          const header = popupHeaderEl;
          const uiOverlay = document.getElementById("ui-drag-overlay");
          let drag = false,
            startX = 0,
            startY = 0,
            startLeft = 0,
            startTop = 0;
          let resizing = false,
            rsDir = "",
            rsStartX = 0,
            rsStartY = 0,
            rsStartW = 0,
            rsStartH = 0,
            rsStartL = 0,
            rsStartT = 0;
          function setPopupActive(active) {
            const handles = popup.querySelectorAll(".resize-handle");
            handles.forEach(
              (h) => (h.style.display = active ? "block" : "none"),
            );
            popup.classList.toggle("active", active);
          }
          const observer = new MutationObserver(() => {
            const isShown = popup.style.display !== "none";
            if (isShown) {
              ensureToolsPopupOnTop();
              setPopupActive(false);
              popup.focus();
            }
          });
          observer.observe(popup, {
            attributes: true,
            attributeFilter: ["style"],
          });
          function startOverlay() {
            if (uiOverlay) uiOverlay.style.display = "block";
          }
          function stopOverlay() {
            if (uiOverlay) uiOverlay.style.display = "none";
          }
          header.addEventListener("mousedown", (e) => {
            if (e.target.closest("button")) return;
            drag = true;
            startOverlay();
            startX = e.clientX;
            startY = e.clientY;
            const rect = popup.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            document.body.style.userSelect = "none";
            e.preventDefault();
            e.stopPropagation();
            setPopupActive(true);
            popup.focus({ preventScroll: true });
          });
          function isInteractive(el) {
            return !!el.closest(
              "button, input, select, textarea, label, .resize-handle",
            );
          }
          ["n", "s", "e", "w", "ne", "nw", "se", "sw"].forEach((dir) => {
            const h = document.createElement("div");
            h.className = "resize-handle " + dir;
            popup.appendChild(h);
          });
          popup.addEventListener("mousedown", (e) => {
            setPopupActive(true);
            if (e.target.classList.contains("resize-handle")) {
              e.preventDefault();
              e.stopPropagation();
              resizing = true;
              rsDir = [...e.target.classList].find(
                (c) => c.length <= 2 && c !== "resize-handle",
              );
              const rect = popup.getBoundingClientRect();
              rsStartX = e.clientX;
              rsStartY = e.clientY;
              rsStartW = rect.width;
              rsStartH = rect.height;
              rsStartL = rect.left;
              rsStartT = rect.top;
              document.body.style.userSelect = "none";
              startOverlay();
            } else if (!isInteractive(e.target) && !drag && !resizing) {
              drag = true;
              startOverlay();
              startX = e.clientX;
              startY = e.clientY;
              const rect = popup.getBoundingClientRect();
              startLeft = rect.left;
              startTop = rect.top;
              document.body.style.userSelect = "none";
              e.preventDefault();
              popup.focus({ preventScroll: true });
            }
          });
          document.addEventListener("mousedown", (e) => {
            if (!e.target.closest("#image-tools-popup")) {
              setPopupActive(false);
            }
          });
          document.addEventListener("mousemove", (e) => {
            if (drag) {
              e.preventDefault();
              const dx = e.clientX - startX,
                dy = e.clientY - startY;
              popup.style.left = Math.max(0, startLeft + dx) + "px";
              popup.style.top = Math.max(0, startTop + dy) + "px";
            } else if (resizing) {
              e.preventDefault();
              let dx = e.clientX - rsStartX,
                dy = e.clientY - rsStartY;
              let newW = rsStartW,
                newH = rsStartH,
                newL = rsStartL,
                newT = rsStartT;
              if (rsDir.includes("e")) newW = Math.max(260, rsStartW + dx);
              if (rsDir.includes("s")) newH = Math.max(160, rsStartH + dy);
              if (rsDir.includes("w")) {
                newW = Math.max(260, rsStartW - dx);
                newL = rsStartL + dx;
              }
              if (rsDir.includes("n")) {
                newH = Math.max(160, rsStartH - dy);
                newT = rsStartT + dy;
              }
              popup.style.width = newW + "px";
              popup.style.height = newH + "px";
              popup.style.left = Math.max(0, newL) + "px";
              popup.style.top = Math.max(0, newT) + "px";
            }
          });
          document.addEventListener("mouseup", () => {
            if (drag || resizing) {
              drag = false;
              resizing = false;
              stopOverlay();
              document.body.style.userSelect = "";
            }
          });
        })();

        let guideLines = [];
        let guideColor = "#ff0000";
        let guideTolerance = 4;
        function clearGuides() {
          guideLines.forEach((l) => fabricCanvas.remove(l));
          guideLines = [];
          fabricCanvas.requestRenderAll();
        }
        function drawGuides(obj) {
          clearGuides();
          const objects = fabricCanvas
            .getObjects()
            .filter((o) => o !== obj && o.type === "image");
          const tolerance = guideTolerance;
          const objBounds = obj.getBoundingRect(true);
          objects.forEach((o) => {
            const b = o.getBoundingRect(true);
            const candidatesX = [
              b.left,
              b.left + b.width / 2,
              b.left + b.width,
            ];
            const currentX = [
              objBounds.left,
              objBounds.left + objBounds.width / 2,
              objBounds.left + objBounds.width,
            ];
            candidatesX.forEach((cx) =>
              currentX.forEach((ox) => {
                if (Math.abs(cx - ox) <= tolerance) {
                  guideLines.push(
                    new fabric.Line([cx, 0, cx, fabricCanvas.height], {
                      stroke: guideColor,
                      strokeOpacity: 0.5,
                      selectable: false,
                      evented: false,
                    }),
                  );
                }
              }),
            );
            const candidatesY = [b.top, b.top + b.height / 2, b.top + b.height];
            const currentY = [
              objBounds.top,
              objBounds.top + objBounds.height / 2,
              objBounds.top + objBounds.height,
            ];
            candidatesY.forEach((cy) =>
              currentY.forEach((oy) => {
                if (Math.abs(cy - oy) <= tolerance) {
                  guideLines.push(
                    new fabric.Line([0, cy, fabricCanvas.width, cy], {
                      stroke: guideColor,
                      strokeOpacity: 0.5,
                      selectable: false,
                      evented: false,
                    }),
                  );
                }
              }),
            );
          });
          guideLines.forEach((l) => fabricCanvas.add(l));
          guideLines.forEach((l) => l.bringToFront && l.bringToFront());
          fabricCanvas.requestRenderAll();
        }
        fabric.Object.prototype.controls.deleteControl = new fabric.Control({
          x: 0.5,
          y: -0.5,
          offset: { x: 15, y: -15 },
          cursorStyle: "pointer",
          mouseUpHandler: deleteObject,
          render: renderIcon(deleteImg),
          cornerSize: 24,
        });
        fabric.Object.prototype.controls.cloneControl = new fabric.Control({
          x: -0.5,
          y: -0.5,
          offset: { x: -15, y: -15 },
          cursorStyle: "pointer",
          mouseUpHandler: cloneObject,
          render: renderIcon(cloneImg),
          cornerSize: 24,
        });
        fabric.Object.prototype.controls.flipControl = new fabric.Control({
          x: -0.5,
          y: 0.5,
          offset: { x: -15, y: 15 },
          cursorStyle: "pointer",
          mouseUpHandler: flipObject,
          render: renderIcon(flipImg),
          cornerSize: 24,
        });
        fabric.Object.prototype.controls.cropControl = new fabric.Control({
          x: 0.5,
          y: 0,
          offset: { x: 20, y: 0 },
          cursorStyle: "pointer",
          mouseUpHandler: startCrop,
          render: renderIcon(cropImg),
          cornerSize: 24,
          visible: function () {
            return this.type === "image" && !isCropping;
          },
        });
        function deleteObject(eventData, transform) {
          const target = transform.target;
          const canvas = target.canvas;
          canvas.remove(target);
          canvas.requestRenderAll();
        }
        function cloneObject(eventData, transform) {
          const target = transform.target;
          const canvas = target.canvas;
          target.clone(function (cloned) {
            cloned.left += 20;
            cloned.top += 20;
            cloned.bringToFront && cloned.bringToFront();
            canvas.add(cloned);
            canvas.setActiveObject(cloned);
            canvas.requestRenderAll();
          });
        }
        function flipObject(eventData, transform) {
          const target = transform.target;
          target.toggle("flipX");
          target.canvas.requestRenderAll();
        }
        function setLockedVisual(o, locked) {
          o.opacity = locked ? 0.6 : 1.0;
          o.borderColor = locked
            ? "rgba(200,0,0,0.8)"
            : "rgba(102,153,255,0.8)";
          o.cornerColor = locked
            ? "rgba(200,0,0,0.6)"
            : "rgba(102,153,255,0.8)";
        }
        function lockSelected() {
          const obj = fabricCanvas.getActiveObject();
          if (!obj) return;
          const setLock = (o, v) => {
            o.lockMovementX = v;
            o.lockMovementY = v;
            o.lockScalingX = v;
            o.lockScalingY = v;
            o.lockRotation = v;
            o.selectable = !v;
            setLockedVisual(o, v);
          };
          if (obj.type === "activeSelection") {
            obj.getObjects().forEach((o) => setLock(o, true));
          } else {
            setLock(obj, true);
          }
          fabricCanvas.discardActiveObject().requestRenderAll();
        }
        function unlockAll() {
          fabricCanvas.getObjects().forEach((o) => {
            o.lockMovementX =
              o.lockMovementY =
              o.lockScalingX =
              o.lockScalingY =
              o.lockRotation =
                false;
            o.selectable = true;
            setLockedVisual(o, false);
          });
          fabricCanvas.requestRenderAll();
        }
        window.addEventListener("keydown", (e) => {
          if (isCropping) {
            if (e.key === "Escape") cancelCrop();
            if (e.key === "Enter") applyCrop();
            return;
          }
          if (e.target.closest('[contenteditable="true"]')) return;
          const activeObject = fabricCanvas.getActiveObject();
          if (!activeObject) return;
          if (e.key === "Delete" || e.key === "Backspace") {
            deleteSelection();
          }
          if ((e.ctrlKey || e.metaKey) && e.key === "c") {
            activeObject.clone(function (cloned) {
              _clipboard = cloned;
            });
          }
          if ((e.ctrlKey || e.metaKey) && e.key === "v") {
            if (!_clipboard) return;
            _clipboard.clone(function (clonedObj) {
              fabricCanvas.discardActiveObject();
              clonedObj.set({
                left: clonedObj.left + 20,
                top: clonedObj.top + 20,
                evented: true,
              });
              if (clonedObj.type === "activeSelection") {
                clonedObj.canvas = fabricCanvas;
                clonedObj.forEachObject(function (obj) {
                  fabricCanvas.add(obj);
                });
                clonedObj.setCoords();
              } else {
                fabricCanvas.add(clonedObj);
              }
              _clipboard.top += 20;
              _clipboard.left += 20;
              fabricCanvas.setActiveObject(clonedObj);
              clonedObj.bringToFront && clonedObj.bringToFront();
              ensureCanvasOnTop();
              updateOverlayPosition();
              fabricCanvas.requestRenderAll();
            });
          }
        });

        function loadCanvasData() {
          const canvasDataScript = document.getElementById("canvas-data");
          if (canvasDataScript && canvasDataScript.textContent) {
            try {
              const jsonData = JSON.parse(canvasDataScript.textContent);
              fabricCanvas.loadFromJSON(jsonData, () => {
                updateCellIds();
                updateAllAttachedImages();
                updateAnnotationPositions();
                fabricCanvas.getObjects().forEach((obj) => {
                  if (obj.attachedCellId) {
                    obj.set({ stroke: "rgba(26,115,232,0.8)", strokeWidth: 3 });
                  }
                });
                fabricCanvas.renderAll();
              });
            } catch (e) {
              console.error("캔버스 데이터 로드 실패:", e);
            }
          }
        }

        function initializeDraggableTable() {
          let draggingElement = null,
            dragType = null,
            dropTarget = null;
          table.addEventListener("mousedown", (e) => {
            if (isImageEditMode || isAnnotationMode || e.button !== 0) return;
            if (table.style.cursor.includes("resize")) return;
            const th = e.target.closest("th"),
              noCell = e.target.closest(".no-cell");
            if (e.target.closest('.th-tools, [contenteditable="true"]')) return;
            if (th && th.cellIndex > 0) {
              e.preventDefault();
              dragType = "col";
              draggingElement = { index: th.cellIndex, element: th };
              document.body.style.cursor = "grabbing";
              setColumnDragging(draggingElement.index, true);
            } else if (noCell) {
              e.preventDefault();
              dragType = "row";
              const row = noCell.closest("tr");
              draggingElement = { element: row };
              row.classList.add("dragging-row");
              document.body.style.cursor = "grabbing";
            } else {
              return;
            }
            if (draggingElement) {
              document.addEventListener("mousemove", onMouseMove);
              document.addEventListener("mouseup", onMouseUp, { once: true });
            }
          });
          function onMouseMove(e) {
            if (!draggingElement) return;
            const currentOver = e.target.closest(
              dragType === "row" ? "tr" : "th",
            );
            document
              .querySelectorAll(
                ".drop-indicator-row-before, .drop-indicator-row-after, .drop-indicator-col-before",
              )
              .forEach((el) =>
                el.classList.remove(
                  "drop-indicator-row-before",
                  "drop-indicator-row-after",
                  "drop-indicator-col-before",
                ),
              );
            if (currentOver && currentOver !== draggingElement.element) {
              dropTarget = { element: currentOver };
              if (dragType === "row") {
                const rect = currentOver.getBoundingClientRect();
                const isAfter = e.clientY > rect.top + rect.height / 2;
                currentOver.classList.add(
                  isAfter
                    ? "drop-indicator-row-after"
                    : "drop-indicator-row-before",
                );
                dropTarget.position = isAfter ? "after" : "before";
              } else {
                const targetIndex = currentOver.cellIndex;
                if (targetIndex > 0) {
                  currentOver.classList.add("drop-indicator-col-before");
                  dropTarget.index = targetIndex;
                } else {
                  dropTarget = null;
                }
              }
            } else {
              dropTarget = null;
            }
          }
          function onMouseUp() {
            if (draggingElement && dropTarget) {
              if (dragType === "row") {
                const dragEl = draggingElement.element,
                  dropEl = dropTarget.element;
                if (dropTarget.position === "after")
                  dropEl.parentNode.insertBefore(dragEl, dropEl.nextSibling);
                else dropEl.parentNode.insertBefore(dragEl, dropEl);
                updateRowNumbers();
                updateCellIds();
                updateAllAttachedImages();
              } else {
                const fromIndex = draggingElement.index,
                  toIndex = dropTarget.index;
                if (fromIndex !== toIndex) moveColumn(fromIndex, toIndex);
              }
            }
            if (draggingElement?.element)
              draggingElement.element.classList.remove("dragging-row");
            setColumnDragging(draggingElement?.index, false);
            document
              .querySelectorAll(
                ".drop-indicator-row-before, .drop-indicator-row-after, .drop-indicator-col-before",
              )
              .forEach((el) =>
                el.classList.remove(
                  "drop-indicator-row-before",
                  "drop-indicator-row-after",
                  "drop-indicator-col-before",
                ),
              );
            document.removeEventListener("mousemove", onMouseMove);
            document.body.style.cursor = "";
            draggingElement = null;
            dropTarget = null;
            dragType = null;
          }
          function moveColumn(fromIndex, toIndex) {
            Array.from(table.rows).forEach((row) => {
              const cellToMove = row.cells[fromIndex];
              if (cellToMove) row.insertBefore(cellToMove, row.cells[toIndex]);
            });
            const colgroup = table.querySelector("colgroup");
            colgroup.insertBefore(
              colgroup.children[fromIndex],
              colgroup.children[toIndex],
            );
            findSpecialColumns();
            updateCellIds();
            updateAllAttachedImages();
          }
          function setColumnDragging(colIndex, isDragging) {
            if (colIndex === undefined || colIndex < 1) return;
            Array.from(table.rows).forEach((row) => {
              if (row.cells[colIndex]) {
                row.cells[colIndex].classList.toggle(
                  "dragging-col",
                  isDragging,
                );
              }
            });
          }
        }

        function initializeAutoFit() {
          table.addEventListener("dblclick", (e) => {
            const th = e.target.closest("th"),
              noCell = e.target.closest(".no-cell");
            if (th && th.cellIndex > 0) {
              const colIndex = th.cellIndex;
              let maxWidth = 0;
              Array.from(table.rows).forEach((row) => {
                const cell = row.cells[colIndex];
                if (cell) {
                  maxWidth = Math.max(maxWidth, cell.scrollWidth);
                }
              });
              const colElement =
                table.querySelector("colgroup").children[colIndex];
              colElement.style.width = maxWidth + 10 + "px";
              updateAllAttachedImages();
            } else if (noCell) {
              const row = noCell.closest("tr");
              row.style.height = "auto";
              updateAllAttachedImages();
            }
          });
        }

        function startCrop(eventData, transform) {
          if (isCropping) return;
          const targetImage = transform.target;
          if (!targetImage || targetImage.type !== "image") return;
          isCropping = true;
          cropTargetImage = targetImage;
          cropTargetImage.hasControls = false;
          fabricCanvas.getObjects().forEach((obj) => {
            if (obj === cropTargetImage) {
              obj.set({ opacity: 0.7, evented: false, selectable: false });
            } else {
              obj.set({ evented: false, selectable: false });
            }
          });
          fabricCanvas.discardActiveObject();
          const bounds = cropTargetImage.getBoundingRect();
          cropRect = new fabric.Rect({
            left: bounds.left,
            top: bounds.top,
            width: bounds.width,
            height: bounds.height,
            fill: "rgba(0, 0, 0, 0.3)",
            stroke: "#4d90fe",
            strokeWidth: 2,
            strokeDashArray: [5, 5],
            hasRotatingPoint: false,
            cornerColor: "#4d90fe",
            cornerStyle: "circle",
            transparentCorners: false,
            borderColor: "#4d90fe",
            evented: true,
            selectable: true,
          });
          cropRect.controls.apply = new fabric.Control({
            x: 0.5,
            y: -0.5,
            offset: { x: 0, y: -30 },
            cursorStyle: "pointer",
            mouseUpHandler: applyCrop,
            render: renderIcon(applyCropImg, true),
            cornerSize: 24,
          });
          cropRect.controls.cancel = new fabric.Control({
            x: -0.5,
            y: -0.5,
            offset: { x: 0, y: -30 },
            cursorStyle: "pointer",
            mouseUpHandler: () => cancelCrop(),
            render: renderIcon(cancelCropImg, true),
            cornerSize: 24,
          });
          fabricCanvas.add(cropRect);
          fabricCanvas.setActiveObject(cropRect);
          fabricCanvas.renderAll();
        }

        function applyCrop() {
          if (!isCropping || !cropTargetImage || !cropRect) return;
          const img = cropTargetImage;
          const invertedMatrix = fabric.util.invertTransform(
            img.calcTransformMatrix(),
          );
          const cropPoints = cropRect.getCoords();
          const transformedPoints = cropPoints.map((p) =>
            fabric.util.transformPoint(p, invertedMatrix),
          );
          const minX = fabric.util.array.min(transformedPoints, "x"),
            minY = fabric.util.array.min(transformedPoints, "y");
          const maxX = fabric.util.array.max(transformedPoints, "x"),
            maxY = fabric.util.array.max(transformedPoints, "y");
          const cropWidthLocal = maxX - minX,
            cropHeightLocal = maxY - minY;
          const finalCropX = (img.cropX || 0) + minX + img.width / 2,
            finalCropY = (img.cropY || 0) + minY + img.height / 2;
          img.width = cropWidthLocal;
          img.height = cropHeightLocal;
          img.cropX = finalCropX;
          img.cropY = finalCropY;
          img.left = cropRect.getCenterPoint().x;
          img.top = cropRect.getCenterPoint().y;
          img.scaleX = cropRect.getScaledWidth() / cropWidthLocal;
          img.scaleY = cropRect.getScaledHeight() / cropHeightLocal;
          img.setCoords();
          cancelCrop(true);
          fabricCanvas.setActiveObject(img);
          fabricCanvas.requestRenderAll();
        }

        function cancelCrop(silent = false) {
          if (!isCropping) return;
          if (cropTargetImage) {
            cropTargetImage.hasControls = true;
          }
          isCropping = false;
          if (cropRect) fabricCanvas.remove(cropRect);
          cropRect = null;
          fabricCanvas.getObjects().forEach((obj) => {
            obj.set({ opacity: 1.0, evented: true, selectable: true });
          });
          if (!silent && cropTargetImage) {
            fabricCanvas.setActiveObject(cropTargetImage);
          }
          cropTargetImage = null;
          fabricCanvas.requestRenderAll();
        }

        const imageZoomOverlay = document.getElementById("image-zoom-overlay");
        const imageZoomContent = document.getElementById("image-zoom-content");
        const imageZoomClose = document.getElementById("image-zoom-close");
        function showZoomModal(imgObject) {
          if (!imgObject) return;
          const dataURL = imgObject.getSrc();
          imageZoomContent.src = dataURL;
          imageZoomOverlay.classList.add("visible");
        }
        function hideZoomModal() {
          imageZoomOverlay.classList.remove("visible");
          imageZoomContent.src = "";
        }
        imageZoomClose.addEventListener("click", hideZoomModal);
        imageZoomOverlay.addEventListener("click", (e) => {
          if (e.target === imageZoomOverlay) {
            hideZoomModal();
          }
        });

        function enterFullscreen() {
          fullscreenContent.appendChild(imageOverlayContainer);
          fullscreenOverlay.style.display = "block";
          fullscreenOverlay.appendChild(toggleAnnotationBtn);
          toggleAnnotationBtn.style.display = "flex";
          setTimeout(() => {
            syncCanvasSize();
            updateOverlayPosition();
            updateAllAttachedImages();
            updateAnnotationPositions();
          }, 0);
        }

        function exitFullscreen() {
          uiDragOverlay.insertAdjacentElement(
            "afterend",
            imageOverlayContainer,
          );
          fullscreenOverlay.style.display = "none";
          toggleAnnotationBtn.style.display = "none";
          setAnnotationMode(false);
          setTimeout(() => {
            syncCanvasSize();
            updateOverlayPosition();
            updateAllAttachedImages();
            updateAnnotationPositions();
          }, 0);
        }

        toggleFullscreenBtn.addEventListener("click", enterFullscreen);
        fullscreenCloseBtn.addEventListener("click", exitFullscreen);
        const annotationToolsPopup = document.getElementById(
          "annotation-tools-popup",
        );
        let isAnnotationMode = false,
          annotationDrawingTool = "select",
          drawingShape = null,
          startPoint = null;
        function setAnnotationMode(on) {
          if (on && isImageEditMode) setEditMode(false);
          isAnnotationMode = !!on;
          toggleAnnotationBtn.classList.toggle("active", on);
          annotationToolsPopup.style.display = on ? "flex" : "none";
          const upperCanvas = fabricCanvas.upperCanvasEl;
          if (upperCanvas)
            upperCanvas.style.pointerEvents = on ? "auto" : "none";
          if (on) {
            fabricCanvas.getObjects().forEach((o) => {
              o.evented = !!o.isAnnotation;
            });
            updateAnnotationTool();
          } else {
            fabricCanvas.isDrawingMode = false;
            fabricCanvas.selection = true;
            fabricCanvas.getObjects().forEach((o) => {
              o.evented = true;
            });
            if (upperCanvas) upperCanvas.style.cursor = "default";
          }
          fabricCanvas.renderAll();
        }

        function updateAnnotationTool() {
          if (!isAnnotationMode) return;
          document
            .querySelectorAll("#annotation-tools-popup button")
            .forEach((btn) => btn.classList.remove("active"));
          const currentToolBtn = document.getElementById(
            `anno-${annotationDrawingTool}`,
          );
          if (currentToolBtn) currentToolBtn.classList.add("active");
          fabricCanvas.isDrawingMode = annotationDrawingTool === "pen";
          fabricCanvas.selection =
            annotationDrawingTool === "select" ||
            annotationDrawingTool === "eraser";
          const upperCanvas = fabricCanvas.upperCanvasEl;
          if (upperCanvas) {
            upperCanvas.style.cursor =
              annotationDrawingTool === "eraser" ? "crosshair" : "default";
          }
          if (fabricCanvas.isDrawingMode) {
            fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(
              fabricCanvas,
            );
            fabricCanvas.freeDrawingBrush.color =
              document.getElementById("anno-color").value;
            fabricCanvas.freeDrawingBrush.width = parseInt(
              document.getElementById("anno-width").value,
              10,
            );
          }
        }

        function updateAnnotationPositions() {
          const scrollOffset =
            fullscreenOverlay.style.display === "block"
              ? fullscreenOverlay.scrollTop
              : window.scrollY;
          fabricCanvas.getObjects().forEach((obj) => {
            if (obj.persistentTop !== undefined) {
              obj.top = obj.persistentTop - scrollOffset;
              obj.setCoords();
            }
          });
          fabricCanvas.renderAll();
        }

        fabricCanvas.on("path:created", function (e) {
          if (isAnnotationMode) {
            e.path.isAnnotation = true;
            e.path.bringToFront();
            e.path.persistentTop = e.path.top;
          }
        });
        fabricCanvas.on("mouse:down", function (o) {
          if (isAnnotationMode) {
            o.e.stopPropagation();
            if (annotationDrawingTool === "eraser") {
              if (o.target && o.target.isAnnotation) {
                fabricCanvas.remove(o.target).requestRenderAll();
              }
              return;
            }
            if (
              fabricCanvas.isDrawingMode ||
              annotationDrawingTool === "select"
            )
              return;
            startPoint = fabricCanvas.getPointer(o.e);
            const color = document.getElementById("anno-color").value;
            const width = parseInt(
              document.getElementById("anno-width").value,
              10,
            );
            switch (annotationDrawingTool) {
              case "line":
                drawingShape = new fabric.Line(
                  [startPoint.x, startPoint.y, startPoint.x, startPoint.y],
                  {
                    stroke: color,
                    strokeWidth: width,
                    isAnnotation: true,
                    evented: false,
                  },
                );
                break;
              case "arrow":
                const line = new fabric.Line(
                  [startPoint.x, startPoint.y, startPoint.x, startPoint.y],
                  { stroke: color, strokeWidth: width },
                );
                const arrowhead = new fabric.Triangle({
                  left: startPoint.x,
                  top: startPoint.y,
                  width: width * 3,
                  height: width * 3,
                  fill: color,
                  angle: -90,
                  originX: "center",
                  originY: "center",
                });
                drawingShape = new fabric.Group([line, arrowhead], {
                  isAnnotation: true,
                  evented: false,
                });
                break;
              case "rect":
                drawingShape = new fabric.Rect({
                  left: startPoint.x,
                  top: startPoint.y,
                  width: 0,
                  height: 0,
                  stroke: color,
                  strokeWidth: width,
                  fill: "transparent",
                  isAnnotation: true,
                  evented: false,
                });
                break;
              case "circle":
                drawingShape = new fabric.Ellipse({
                  left: startPoint.x,
                  top: startPoint.y,
                  rx: 0,
                  ry: 0,
                  stroke: color,
                  strokeWidth: width,
                  fill: "transparent",
                  isAnnotation: true,
                  evented: false,
                });
                break;
            }
            if (drawingShape) {
              fabricCanvas.add(drawingShape);
              drawingShape.bringToFront();
            }
          } else if (!isImageEditMode && !isCropping) {
            if (o.target && o.target.type === "image" && o.e.shiftKey) {
              o.e.preventDefault();
              o.e.stopPropagation();
              showZoomModal(o.target);
              return;
            }
            if (!o.target) {
              const upperCanvas = fabricCanvas.upperCanvasEl;
              upperCanvas.style.pointerEvents = "none";
              const underlyingElement = document.elementFromPoint(
                o.e.clientX,
                o.e.clientY,
              );
              upperCanvas.style.pointerEvents = "auto";
              if (underlyingElement) {
                if (table.contains(underlyingElement)) {
                  const isResizeHandle = table.style.cursor.includes("resize");
                  if (isResizeHandle) {
                    const mouseDownEvent = new MouseEvent("mousedown", {
                      bubbles: true,
                      cancelable: true,
                      view: window,
                      clientX: o.e.clientX,
                      clientY: o.e.clientY,
                      button: o.e.button,
                    });
                    underlyingElement.dispatchEvent(mouseDownEvent);
                  } else {
                    underlyingElement.click();
                  }
                } else {
                  underlyingElement.click();
                }
              }
            }
          }
        });

        fabricCanvas.on("mouse:move", function (o) {
          if (!isAnnotationMode || !drawingShape || !startPoint) return;
          const pointer = fabricCanvas.getPointer(o.e);
          let endX = pointer.x,
            endY = pointer.y;
          if (o.e.shiftKey) {
            const dx = Math.abs(endX - startPoint.x),
              dy = Math.abs(endY - startPoint.y);
            if (dx > dy) {
              endY = startPoint.y;
            } else {
              endX = startPoint.x;
            }
          }
          switch (annotationDrawingTool) {
            case "line":
              drawingShape.set({ x2: endX, y2: endY });
              break;
            case "arrow":
              const line = drawingShape._objects[0],
                arrowhead = drawingShape._objects[1];
              line.set({ x2: endX, y2: endY });
              const finalDx = endX - startPoint.x,
                finalDy = endY - startPoint.y;
              const angle = (Math.atan2(finalDy, finalDx) * 180) / Math.PI;
              arrowhead
                .set({ left: endX, top: endY, angle: angle + 90 })
                .setCoords();
              break;
            case "rect":
              drawingShape.set({
                width: Math.abs(endX - startPoint.x),
                height: Math.abs(endY - startPoint.y),
                left: endX > startPoint.x ? startPoint.x : endX,
                top: endY > startPoint.y ? startPoint.y : endY,
              });
              break;
            case "circle":
              drawingShape.set({
                rx: Math.abs(endX - startPoint.x) / 2,
                ry: Math.abs(endY - startPoint.y) / 2,
                left: endX > startPoint.x ? startPoint.x : endX,
                top: endY > startPoint.y ? startPoint.y : endY,
                originX: "left",
                originY: "top",
              });
              break;
          }
          fabricCanvas.renderAll();
        });

        fabricCanvas.on("mouse:up", function (o) {
          if (isAnnotationMode && drawingShape) {
            drawingShape.set({ evented: true });
            drawingShape.persistentTop = drawingShape.top;
            if (drawingShape.type === "group") {
              const groupTop = drawingShape.top;
              drawingShape
                .getObjects()
                .forEach((obj) => (obj.persistentTop = groupTop + obj.top));
            }
            drawingShape = null;
            startPoint = null;
          }
        });

        toggleAnnotationBtn.addEventListener("click", () =>
          setAnnotationMode(!isAnnotationMode),
        );
        document
          .querySelectorAll('#annotation-tools-popup button[id^="anno-"]')
          .forEach((btn) => {
            btn.addEventListener("click", () => {
              const tool = btn.id.replace("anno-", "");
              if (
                [
                  "select",
                  "pen",
                  "line",
                  "arrow",
                  "rect",
                  "circle",
                  "eraser",
                ].includes(tool)
              ) {
                annotationDrawingTool = tool;
                updateAnnotationTool();
              }
            });
          });
        document
          .getElementById("anno-color")
          .addEventListener("input", updateAnnotationTool);
        document
          .getElementById("anno-width")
          .addEventListener("input", updateAnnotationTool);
        document.getElementById("anno-memo").addEventListener("click", () => {
          const canvasRect = fabricCanvas.upperCanvasEl.getBoundingClientRect();
          const viewportCenterX = window.innerWidth / 2,
            viewportCenterY = window.innerHeight / 2;
          const targetLeft = viewportCenterX - canvasRect.left,
            targetTop = viewportCenterY - canvasRect.top;
          const memo = new fabric.Textbox("메모 입력...", {
            left: targetLeft,
            top: targetTop,
            width: 150,
            fontSize: 16,
            fill: "#333",
            backgroundColor: "#ffffa8",
            borderColor: "#e6e696",
            cornerColor: "#1a73e8",
            padding: 10,
            splitByGrapheme: true,
            editable: true,
            isAnnotation: true,
            originX: "center",
            originY: "center",
          });
          memo.persistentTop = memo.top;
          fabricCanvas.add(memo);
          memo.bringToFront();
          fabricCanvas.setActiveObject(memo).renderAll();
        });
        document.getElementById("anno-clear").addEventListener("click", () => {
          const objectsToRemove = fabricCanvas
            .getObjects()
            .filter((obj) => obj.isAnnotation);
          if (
            objectsToRemove.length > 0 &&
            confirm("모든 주석과 메모를 삭제하시겠습니까?")
          ) {
            objectsToRemove.forEach((obj) => fabricCanvas.remove(obj));
            fabricCanvas.renderAll();
          }
        });

        (function enableAnnotationPopupDragAndResize() {
          const popup = document.getElementById("annotation-tools-popup");
          const header = popup.querySelector(".popup-header");
          const uiOverlay = document.getElementById("ui-drag-overlay");
          let drag = false,
            startX = 0,
            startY = 0,
            startLeft = 0,
            startTop = 0;
          let resizing = false,
            rsDir = "",
            rsStartX = 0,
            rsStartY = 0,
            rsStartW = 0,
            rsStartH = 0,
            rsStartL = 0,
            rsStartT = 0;
          function startOverlay() {
            if (uiOverlay) uiOverlay.style.display = "block";
          }
          function stopOverlay() {
            if (uiOverlay) uiOverlay.style.display = "none";
          }
          header.addEventListener("mousedown", (e) => {
            if (e.target.closest("button")) return;
            drag = true;
            startOverlay();
            startX = e.clientX;
            startY = e.clientY;
            const rect = popup.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            document.body.style.userSelect = "none";
            e.preventDefault();
            e.stopPropagation();
            popup.focus({ preventScroll: true });
          });
          ["n", "s", "e", "w", "ne", "nw", "se", "sw"].forEach((dir) => {
            const h = document.createElement("div");
            h.className = "resize-handle " + dir;
            popup.appendChild(h);
          });
          popup.addEventListener("mousedown", (e) => {
            if (e.target.classList.contains("resize-handle")) {
              e.preventDefault();
              e.stopPropagation();
              resizing = true;
              rsDir = [...e.target.classList].find(
                (c) => c.length <= 2 && c !== "resize-handle",
              );
              const rect = popup.getBoundingClientRect();
              rsStartX = e.clientX;
              rsStartY = e.clientY;
              rsStartW = rect.width;
              rsStartH = rect.height;
              rsStartL = rect.left;
              rsStartT = rect.top;
              document.body.style.userSelect = "none";
              startOverlay();
            }
          });
          document.addEventListener("mousemove", (e) => {
            if (drag) {
              e.preventDefault();
              const dx = e.clientX - startX,
                dy = e.clientY - startY;
              popup.style.left = Math.max(0, startLeft + dx) + "px";
              popup.style.top = Math.max(0, startTop + dy) + "px";
            } else if (resizing) {
              e.preventDefault();
              let dx = e.clientX - rsStartX,
                dy = e.clientY - rsStartY;
              let newW = rsStartW,
                newH = rsStartH,
                newL = rsStartL,
                newT = rsStartT;
              if (rsDir.includes("e")) newW = Math.max(230, rsStartW + dx);
              if (rsDir.includes("s")) newH = Math.max(150, rsStartH + dy);
              if (rsDir.includes("w")) {
                newW = Math.max(230, rsStartW - dx);
                newL = rsStartL + dx;
              }
              if (rsDir.includes("n")) {
                newH = Math.max(150, rsStartH - dy);
                newT = rsStartT + dy;
              }
              popup.style.width = newW + "px";
              popup.style.height = newH + "px";
              popup.style.left = Math.max(0, newL) + "px";
              popup.style.top = Math.max(0, newT) + "px";
            }
          });
          document.addEventListener("mouseup", () => {
            if (drag || resizing) {
              drag = false;
              resizing = false;
              stopOverlay();
              document.body.style.userSelect = "";
            }
          });
        })();

        function initializeResizableTable() {
          let resizing = false;
          let resizeInfo = {};

          table.addEventListener("mousedown", (e) => {
            if (e.button !== 0) return;

            const cell = e.target.closest("th, td");
            if (!cell) return;

            const rect = cell.getBoundingClientRect();
            const threshold = 5;

            const atRightBorder = Math.abs(e.clientX - rect.right) < threshold;
            const atLeftBorder = Math.abs(e.clientX - rect.left) < threshold;
            const atBottomBorder =
              Math.abs(e.clientY - rect.bottom) < threshold;

            if (
              atRightBorder &&
              cell.cellIndex < table.rows[0].cells.length - 1
            ) {
              resizing = true;
              e.preventDefault();
              e.stopPropagation();

              const colElement =
                table.querySelector("colgroup").children[cell.cellIndex];
              resizeInfo = {
                type: "col",
                element: colElement,
                startX: e.pageX,
                startWidth: colElement.offsetWidth,
              };
            } else if (atLeftBorder && cell.cellIndex > 0) {
              resizing = true;
              e.preventDefault();
              e.stopPropagation();

              const colElement =
                table.querySelector("colgroup").children[cell.cellIndex - 1];
              resizeInfo = {
                type: "col",
                element: colElement,
                startX: e.pageX,
                startWidth: colElement.offsetWidth,
                isLeft: true,
              };
            } else if (
              atBottomBorder &&
              cell.closest("tr").parentNode.tagName === "TBODY"
            ) {
              resizing = true;
              e.preventDefault();
              e.stopPropagation();

              const rowElement = cell.closest("tr");
              resizeInfo = {
                type: "row",
                element: rowElement,
                startY: e.pageY,
                startHeight: rowElement.offsetHeight,
              };
            }

            if (resizing) {
              document.addEventListener("mousemove", onMouseMove);
              document.addEventListener("mouseup", onMouseUp, { once: true });
            }
          });

          table.addEventListener("mousemove", (e) => {
            if (resizing) return;
            const cell = e.target.closest("th, td");
            if (!cell) {
              table.style.cursor = "";
              return;
            }

            const rect = cell.getBoundingClientRect();
            const threshold = 5;

            const atRightBorder = Math.abs(e.clientX - rect.right) < threshold;
            const atLeftBorder = Math.abs(e.clientX - rect.left) < threshold;
            const atBottomBorder =
              Math.abs(e.clientY - rect.bottom) < threshold;

            if (
              (atRightBorder &&
                cell.cellIndex < table.rows[0].cells.length - 1) ||
              (atLeftBorder && cell.cellIndex > 0)
            ) {
              table.style.cursor = "col-resize";
            } else if (
              atBottomBorder &&
              cell.closest("tr").parentNode.tagName === "TBODY"
            ) {
              table.style.cursor = "row-resize";
            } else {
              table.style.cursor = "";
            }
          });

          function onMouseMove(e) {
            if (!resizing) return;
            if (resizeInfo.type === "col") {
              const deltaX = e.pageX - resizeInfo.startX;
              const newWidth = resizeInfo.isLeft
                ? resizeInfo.startWidth - deltaX
                : resizeInfo.startWidth + deltaX;
              if (newWidth > 30) {
                resizeInfo.element.style.width = newWidth + "px";
                updateAllAttachedImages();
              }
            } else if (resizeInfo.type === "row") {
              const newHeight =
                resizeInfo.startHeight + (e.pageY - resizeInfo.startY);
              if (newHeight > 30) {
                resizeInfo.element.style.height = newHeight + "px";
                updateAllAttachedImages();
              }
            }
          }

          function onMouseUp() {
            resizing = false;
            resizeInfo = {};
            table.style.cursor = "";
            document.removeEventListener("mousemove", onMouseMove);
          }
        }

        function initializeSortAndFilter() {
          const headers = table.querySelectorAll("thead th");
          headers.forEach((th, colIndex) => {
            if (colIndex === 0 || colIndex === 1) {
              th.style.cursor = "not-allowed";
              return;
            }
            if (th.querySelector(".th-content")) {
              return;
            }

            const originalContent = th.innerHTML;
            th.innerHTML = "";
            th.removeAttribute("contenteditable");
            const contentDiv = document.createElement("div");
            contentDiv.className = "th-content";
            const titleSpan = document.createElement("span");
            titleSpan.className = "th-title";
            titleSpan.contentEditable = true;
            titleSpan.innerHTML = originalContent;
            const toolsDiv = document.createElement("div");
            toolsDiv.className = "th-tools";
            const sortContainer = document.createElement("div");
            sortContainer.className = "sort-controls";
            const sortUp = document.createElement("span");
            sortUp.className = "sort-arrow sort-up";
            sortUp.innerHTML = "▲";
            sortUp.title = "오름차순 정렬";
            const sortDown = document.createElement("span");
            sortDown.className = "sort-arrow sort-down";
            sortDown.innerHTML = "▼";
            sortDown.title = "내림차순 정렬";
            sortContainer.appendChild(sortUp);
            sortContainer.appendChild(sortDown);
            const filterBtn = document.createElement("span");
            filterBtn.className = "filter-btn";
            filterBtn.innerHTML = "&#128269;";
            filterBtn.title = "필터";
            toolsDiv.appendChild(sortContainer);
            toolsDiv.appendChild(filterBtn);
            contentDiv.appendChild(titleSpan);
            contentDiv.appendChild(toolsDiv);
            th.appendChild(contentDiv);
            sortUp.addEventListener("click", (e) => {
              e.stopPropagation();
              sortTable(colIndex, "asc");
            });
            sortDown.addEventListener("click", (e) => {
              e.stopPropagation();
              sortTable(colIndex, "desc");
            });
            filterBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              showFilterPopup(colIndex, filterBtn);
            });
          });
        }

        function sortTable(colIndex, newDirection) {
          const tbody = table.tBodies[0];
          const rows = Array.from(tbody.rows);
          const th = table.querySelector(`thead th:nth-child(${colIndex + 1})`);
          const currentDir = th.dataset.sortDir;
          document.querySelectorAll("thead th").forEach((otherTh) => {
            if (otherTh !== th) {
              delete otherTh.dataset.sortDir;
              otherTh
                .querySelectorAll(".sort-arrow")
                .forEach((arrow) => arrow.classList.remove("active"));
            }
          });
          const nextDir = currentDir === newDirection ? "none" : newDirection;
          th.dataset.sortDir = nextDir;
          th.querySelectorAll(".sort-arrow").forEach((arrow) =>
            arrow.classList.remove("active"),
          );
          if (nextDir === "asc") {
            th.querySelector(".sort-up").classList.add("active");
          } else if (nextDir === "desc") {
            th.querySelector(".sort-down").classList.add("active");
          }
          if (nextDir === "none") {
            rows.sort(
              (a, b) =>
                parseInt(a.dataset.originalIndex, 10) -
                parseInt(b.dataset.originalIndex, 10),
            );
          } else {
            const direction = nextDir === "asc" ? 1 : -1;
            rows.sort((a, b) => {
              let valA = a.cells[colIndex].innerText.trim(),
                valB = b.cells[colIndex].innerText.trim();
              if (currencyColIndices.includes(colIndex)) {
                valA = parseFloat(valA.replace(/,/g, "")) || 0;
                valB = parseFloat(valB.replace(/,/g, "")) || 0;
              }
              if (typeof valA === "string" && typeof valB === "string") {
                return (
                  valA.localeCompare(valB, undefined, { numeric: true }) *
                  direction
                );
              }
              if (valA < valB) return -1 * direction;
              if (valA > valB) return 1 * direction;
              return 0;
            });
          }
          rows.forEach((row) => tbody.appendChild(row));
          applyFilters();
        }

        const filterPopup = document.getElementById("filter-popup");
        const filterOptionsList = document.getElementById(
          "filter-options-list",
        );
        const filterTitle = document.getElementById("filter-title");
        const applyFilterBtn = document.getElementById("apply-filter-btn");
        const clearFilterBtn = document.getElementById("clear-filter-btn");
        const closeFilterPopupBtn =
          document.getElementById("close-filter-popup");
        const selectAllCheckbox = document.getElementById("filter-select-all");
        const filterSearchInput = document.getElementById(
          "filter-search-input",
        );

        function showFilterPopup(colIndex, btnElement) {
          currentFilterColumn = colIndex;
          const headerText = table.querySelector(
            `thead th:nth-child(${colIndex + 1}) .th-title`,
          ).innerText;
          filterTitle.innerText = `'${headerText}' 필터`;
          const values = new Set();
          table.querySelectorAll("tbody tr").forEach((row) => {
            const cell = row.cells[colIndex];
            if (cell) {
              const value = cell.innerText.trim();
              if (value) values.add(value);
            }
          });
          filterOptionsList.innerHTML = "";
          const sortedValues = Array.from(values).sort((a, b) =>
            a.localeCompare(b, undefined, { numeric: true }),
          );
          const currentFilters = activeFilters[colIndex];
          sortedValues.forEach((value) => {
            const div = document.createElement("div"),
              label = document.createElement("label"),
              checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = value;
            checkbox.checked =
              !currentFilters || currentFilters.includes(value);
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(" " + value));
            div.appendChild(label);
            filterOptionsList.appendChild(div);
          });
          updateSelectAllState();
          const rect = btnElement.getBoundingClientRect();
          filterPopup.style.left = `${Math.max(5, rect.left)}px`;
          filterPopup.style.top = `${rect.bottom + 5}px`;
          filterPopup.style.display = "block";
          filterSearchInput.value = "";
          filterSearchInput.focus();
        }

        function applyFilters() {
          const rows = table.querySelectorAll("tbody tr");
          rows.forEach((row) => {
            let isVisible = true;
            for (const colIndex in activeFilters) {
              const allowedValues = activeFilters[colIndex];
              if (allowedValues && allowedValues.length > 0) {
                const cellValue = row.cells[colIndex].innerText.trim();
                if (!allowedValues.includes(cellValue)) {
                  isVisible = false;
                  break;
                }
              }
            }
            row.style.display = isVisible ? "" : "none";
          });
          updateRowNumbers();
        }

        function updateSelectAllState() {
          const allCheckboxes = filterOptionsList.querySelectorAll(
            'input[type="checkbox"]',
          );
          const checkedCount = filterOptionsList.querySelectorAll(
            'input[type="checkbox"]:checked',
          ).length;
          selectAllCheckbox.checked =
            allCheckboxes.length > 0 && checkedCount === allCheckboxes.length;
          selectAllCheckbox.indeterminate =
            checkedCount > 0 && checkedCount < allCheckboxes.length;
        }

        filterOptionsList.addEventListener("change", updateSelectAllState);
        applyFilterBtn.addEventListener("click", () => {
          const allValues = Array.from(
            filterOptionsList.querySelectorAll('input[type="checkbox"]'),
          ).map((cb) => cb.value);
          const selectedValues = Array.from(
            filterOptionsList.querySelectorAll(
              'input[type="checkbox"]:checked',
            ),
          ).map((cb) => cb.value);
          const headerBtn = table.querySelector(
            `thead th:nth-child(${currentFilterColumn + 1}) .filter-btn`,
          );
          if (selectedValues.length === allValues.length) {
            delete activeFilters[currentFilterColumn];
            headerBtn.classList.remove("active");
          } else {
            activeFilters[currentFilterColumn] = selectedValues;
            headerBtn.classList.add("active");
          }
          applyFilters();
          filterPopup.style.display = "none";
        });
        clearFilterBtn.addEventListener("click", () => {
          const headerBtn = table.querySelector(
            `thead th:nth-child(${currentFilterColumn + 1}) .filter-btn`,
          );
          delete activeFilters[currentFilterColumn];
          headerBtn.classList.remove("active");
          applyFilters();
          filterPopup.style.display = "none";
        });
        closeFilterPopupBtn.addEventListener("click", () => {
          filterPopup.style.display = "none";
        });
        selectAllCheckbox.addEventListener("change", (e) => {
          const isChecked = e.target.checked;
          filterOptionsList
            .querySelectorAll('input[type="checkbox"]')
            .forEach((cb) => {
              if (cb.closest("div").style.display !== "none") {
                cb.checked = isChecked;
              }
            });
        });
        filterSearchInput.addEventListener("input", (e) => {
          const searchTerm = e.target.value.toLowerCase();
          filterOptionsList.querySelectorAll("label").forEach((label) => {
            const text = label.innerText.toLowerCase();
            const parentDiv = label.parentElement;
            if (text.includes(searchTerm)) {
              parentDiv.style.display = "block";
            } else {
              parentDiv.style.display = "none";
            }
          });
        });

        findSpecialColumns();
        updateCellIds();
        initializeResizableTable();
        updateRowNumbers();
        formatAllCurrencyCells();
        clearSelection();
        initializeAutoFit();
        initializeDraggableTable();
        initializeSortAndFilter();
        syncCanvasSize();
        ensureCanvasOnTop();
        loadCanvasData();
      });

      // ═══════════════════════════════════════════════════════════════════════════════
      // GLOBAL INTERACTION HANDLERS (Custom Cursor Tracker)
      // ═══════════════════════════════════════════════════════════════════════════════
      document.addEventListener("mousedown", () => {
        document.body.classList.add("is-clicking");
      });

      document.addEventListener("mouseup", () => {
        document.body.classList.remove("is-clicking");
      });
    </script>
  </body>
</html>

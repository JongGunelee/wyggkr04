<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏûîÏó¨ Í≥µÏÇ¨ Í≥µÏ†ïÍ¥ÄÎ¶¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
        }

        
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .gantt-titles .header,
        .gantt-titles .group-header,
        .gantt-titles .title-item {
            letter-spacing: -0.04em;
        }
        .gantt-titles .toggle-col-btn,
        .gantt-titles .group-toggle {
            letter-spacing: normal;
        }
        .gantt-chart-container {
            display: flex;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            height: 100%;
        }
        .gantt-titles {
            flex-shrink: 0;
            border-right: 1px solid #e2e8f0;
            background-color: #f8fafc;
            position: relative;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            --po-col-width: 120px;
            --dates-col-width: 170px;
            --progress-col-width: 70px;
            --name-padding: 55px;
            isolation: isolate;
        }
        .gantt-titles-body-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }
        .resizer {
            position: absolute;
            top: 0;
            right: -2.5px;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            z-index: 12;
        }
        .resizer:hover {
            background: rgba(100, 116, 139, 0.25);
        }
        .gantt-titles .header {
            font-weight: 700;
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            height: 88px;
            display: flex;
            align-items: center;
            background-color: #fff;
            position: sticky;
            top: 0;
            z-index: 12;
            flex-shrink: 0;
            box-sizing: border-box;
            width: 100%;
        }
        .gantt-titles .group-header {
            font-weight: 600;
            padding: 0 12px;
            height: 32px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            background-color: #f1f5f9;
            font-size: 14px;
        }
        .gantt-titles .group-header:hover {
            background-color: #e2e8f0;
        }
        .gantt-titles .group-toggle {
            display: inline-block;
            width: 20px;
            text-align: center;
        }
        .gantt-titles .title-item {
            padding: 0 12px;
            height: 32px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            border-bottom: 1px solid #f1f5f9;
            white-space: nowrap;
            font-size: 14px;
            box-sizing: border-box;
            width: 100%;
            position: relative;
        }
        .title-item .project-name {
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1 0 auto;
            padding-right: 10px;
            padding-left: 43px;
            box-sizing: border-box;
            width: calc(100% - var(--po-col-width) - var(--dates-col-width) - var(--progress-col-width));
            min-width: 0;
        }
        .title-item .project-po, .title-item .project-progress {
            text-align: right;
            padding-right: 10px;
            font-weight: 500;
            color: #64748b;
            flex-shrink: 0;
        }
        .title-item .project-dates {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            flex-shrink: 0;
            font-size: 13px;
            color: #475569;
        }
        .date-editor, .progress-editor {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .date-editor:hover, .progress-editor:hover {
            background-color: #e0e7ff;
        }
        .date-input {
            width: 130px;
            font-size: 13px;
            padding: 2px;
            border: 1px solid #6366f1;
            border-radius: 4px;
            text-align: center;
        }
        .progress-input { width: 60px; }
        .gantt-timeline-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            contain: strict;
        }
        .gantt-timeline-header-wrapper {
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
            position: relative; /* Today Marker positioning context */
            contain: layout style paint;
            will-change: transform;
        }
        .gantt-timeline-body-wrapper {
            overflow: auto;
            flex-grow: 1;
            contain: layout style paint;
            will-change: transform;
        }
        .gantt-timeline-header {
            z-index: 11;
            background-color: #fff;
            position: sticky;
            top: 0;
            height: 88px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            width: 100%;
            contain: layout style;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
            -webkit-font-smoothing: antialiased;
        }
        .gantt-year-month-header, .gantt-day-header, .gantt-weekday-header {
            display: flex;
            font-size: 12px;
            font-weight: 500;
            border-bottom: 1px solid #e2e8f0;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        .gantt-weekday-header {
            font-size: 11px;
             color: #64748b;
        }

        .gantt-month, .gantt-day, .gantt-weekday {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-right: 1px solid #e2e8f0;
            box-sizing: border-box;
            position: relative;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
            contain: layout style paint;
        }
        .gantt-month { height: 32px; }
        .gantt-day { height: 32px; }
        .gantt-weekday { height: 24px; }

        .gantt-body {
            position: relative;
        }
        .gantt-bar-row {
            height: 32px;
            border-bottom: 1px solid #f1f5f9;
            position: relative;
            z-index: 2;
            box-sizing: border-box;
            width: 100%;
        }
        .gantt-grid-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 0;
            border-left: 1px solid #e2e8f0;
            z-index: 1;
            pointer-events: none;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
        }
        .gantt-today-marker-container {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 15;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        .gantt-today-marker {
            width: 0;
            height: 100%;
            border-left: 3px dashed #1d4ed8;
            will-change: transform;
            transform: translateZ(0);
        }
        .gantt-today-label {
            position: absolute;
            top: 5px;
            background-color: #1d4ed8;
            color: white;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 4px;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transform: translateZ(0);
        }
        .gantt-bar {
            position: absolute;
            top: 4px;
            height: 24px;
            border-radius: 4px;
            opacity: 0.8;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            overflow: hidden;
            white-space: nowrap;
            z-index: 9;
        }
         .gantt-bar-progress {
            position: absolute;
            top: 11px;
            height: 10px;
            border-radius: 2px;
            background-color: rgba(0, 0, 0, 0.35);
            box-shadow: inset 0 1px 1px rgba(0,0,0,0.2);
            z-index: 10;
            pointer-events: none;
            transition: width 0.3s ease-in-out;
        }
        .gantt-bar.hidden, .title-item.hidden {
            display: none;
        }
        .gantt-bar:hover {
            opacity: 1;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .tooltip {
            visibility: hidden;
            background-color: #1f2937;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 20;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            width: 220px;
            font-size: 12px;
        }
        .gantt-bar:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex; justify-content: center; align-items: center;
            z-index: 50;
        }
        .modal-content {
            background-color: white;
            padding: 0;
            border-radius: 0.5rem;
            width: 400px;
            height: auto;
            min-height: 400px;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            resize: both;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
            border-radius: 50%; border-left-color: #4f46e5;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .summary-card {
             cursor: pointer;
             transition: transform 0.2s;
        }
        .summary-card:hover {
            transform: translateY(-4px);
        }
        .row-hover {
            background-color: #fef08a;
        }
        .fullscreen-modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
        }
        .resizable-modal-content {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            position: relative;
            width: 95vw;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .resizable-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e5e7eb;
            flex-shrink: 0;
        }
        .resizable-modal-body {
            flex-grow: 1;
            padding: 1rem;
            overflow: auto;
            display: flex; /* Added for fullscreen layout */
            flex-direction: column; /* Added for fullscreen layout */
        }
        #ganttViewContent {
             height: 100%;
             display: flex;
             flex-direction: column;
        }
        #ganttChartWrapper {
            flex-grow: 1;
             min-height: 0; /* Added for flex grow in column */
        }
        #ganttChartWrapper .gantt-chart-container {
            height: 100%;
        }
        .resizer-handle {
            position: absolute;
            background: transparent;
            z-index: 101;
        }
        .resizer-handle.n { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-handle.s { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-handle.e { top: 0; bottom: 0; right: -5px; width: 10px; cursor: ew-resize; }
        .resizer-handle.w { top: 0; bottom: 0; left: -5px; width: 10px; cursor: ew-resize; }
        .resizer-handle.ne { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-handle.sw { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-handle.nw { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; }
        .resizer-handle.se { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; }

        .header-col {
            display: flex;
            align-items: center;
        }
        .col-resizer {
            flex-shrink: 0;
            width: 6px;
            height: 40px;
            cursor: col-resize;
            background-color: transparent;
            z-index: 13;
            border-left: 1px solid transparent;
            border-right: 1px solid transparent;
            transition: background-color 0.2s;
        }
        .col-resizer:hover {
            background-color: rgba(100, 116, 139, 0.25);
            border-left: 1px solid #cbd5e1;
            border-right: 1px solid #cbd5e1;
        }
        #dataPanel.hidden {
            display: none;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        /* Ensure accordions start collapsed */
        .accordion-item:not(.open) .accordion-content {
            max-height: 0 !important;
            overflow: hidden !important;
        }
        .accordion-item:not(.open) .accordion-content,
        .sub-accordion-item:not(.open) .sub-accordion-content { /* Added sub-accordion */
             max-height: 0;
             overflow: hidden;
             padding-top: 0;
             padding-bottom: 0;
        }
        .accordion-item.open > .accordion-content,
        .sub-accordion-item.open > .sub-accordion-content { /* Added sub-accordion */
            max-height: 5000px; /* Allow expansion */
            transition: max-height 0.5s ease-in;
             /* Padding moved to content grid for sub-accordion */
        }

        /* [MODIFIED] Padding moved from sub-accordion-content.open to the grid inside it */
        .sub-accordion-item.open > .sub-accordion-content > .grid {
             padding-top: 1rem;
             padding-bottom: 1rem;
        }


        .accordion-item.open > .accordion-content.flex-grow {
            max-height: none;
        }
        .accordion-icon, .sub-accordion-icon, .control-section-icon { /* Added sub-accordion and control */
            transition: transform 0.3s ease;
        }
        .accordion-item.open > .accordion-header .accordion-icon,
        .sub-accordion-item.open > .sub-accordion-header .sub-accordion-icon, /* Added sub-accordion */
        .control-section-header.open .control-section-icon { /* Added control */
            transform: rotate(180deg);
        }

        /* Styles for sub-accordion in Settlement section */
        .sub-accordion-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0; /* Adjust padding as needed */
        }
        .sub-accordion-content {
             max-height: 0;
             overflow: hidden;
             transition: max-height 0.3s ease-out;
             /* Removed padding-top/bottom here, handled by .open */
        }
        /* End of sub-accordion styles */
        
        /* Main settlement accordion styles */
        .main-settlement-accordion-item {
            transition: all 0.3s ease;
        }
        
        .main-settlement-header {
            transition: background-color 0.2s ease;
        }
        
        .main-settlement-icon {
            transition: transform 0.3s ease;
        }
        
        .main-settlement-accordion-item.expanded .main-settlement-icon {
            transform: rotate(180deg);
        }
        
        .main-settlement-accordion-item.collapsed .main-settlement-icon {
            transform: rotate(0deg);
        }
        
        /* Settlement section scroll behavior
           Use available viewport space (subtract header/controls chrome) so the inner
           container can always show a scrollbar when content overflows even when
           the overall page scrolling is prevented (body { overflow: hidden }). */
        .settlement-scrollable {
            max-height: calc(100vh - 220px);
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }
        
        /* Enhanced scroll behavior for settlement section */
        .settlement-scrollable:hover {
            overflow-y: auto;
        }
        
        /* Ensure scrollbar is always visible when content overflows */
        .settlement-scrollable:not(:hover) {
            overflow-y: auto;
        }
        
        .settlement-scrollable::-webkit-scrollbar {
            width: 8px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Styles for control section toggles */
        .control-section-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 0.5rem;
        }
         .control-section-header h3 {
             margin-bottom: 0; /* Remove default margin */
         }
        .control-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding-top: 0;
            padding-bottom: 0;
        }
        .control-section-header.open + .control-section-content {
            max-height: 1000px; /* Adjust as needed */
            transition: max-height 0.5s ease-in, padding 0.5s ease-in;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        /* End control section styles */


        .milestone-track {
            height: 40px;
            position: relative;
            border-bottom: 1px solid #e2e8f0;
        }
        .milestone-marker {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 20px;
            height: 20px;
            background-color: #e11d48;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            cursor: pointer;
            z-index: 15;
        }
         .milestone-marker .tooltip {
            transform: translate(-50%, 0) rotate(-45deg);
            bottom: 25px;
        }
        #progressPopup {
            /* [FIX] Increased z-index to appear above fullscreen modal */
            z-index: 150 !important;
        }
        #progressPopup button.progress-val-btn {
            width: 100%;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 0.375rem;
            transition: all 0.2s;
            background-color: #f3f4f6;
            color: #374151;
        }
        #progressPopup button.progress-val-btn:hover {
            background-color: #6366f1;
            color: white;
        }
        #progressPopup button.progress-val-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        #progressPopup .progress-input-area {
            grid-column: span 4 / span 4;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-top: 0.5rem;
            border-top-width: 1px;
            margin-top: 0.25rem;
        }
        #progressPopup .progress-input-area input {
            width: 100%;
            padding: 0.25rem;
            border-width: 1px;
            border-radius: 0.25rem;
        }
        #progressPopup .progress-input-area button {
            padding: 0.25rem 0.75rem;
            background-color: #6366f1;
            color: white;
            border-radius: 0.25rem;
            font-size: 0.75rem;
        }
        #progressPopup .progress-input-area button:hover {
            background-color: #4f46e5;
        }
        .search-highlight {
            background-color: #fde047;
            border-radius: 2px;
        }
        #mappingPreviewContainer table, #errorCorrectionContainer table {
            font-size: 0.8rem;
        }
        #mappingPreviewContainer th, #mappingPreviewContainer td,
        #errorCorrectionContainer th, #errorCorrectionContainer td {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            padding: 0.5rem;
        }
        #mappingPreviewContainer th, #errorCorrectionContainer th {
            position: sticky;
            top: 0;
            background: #f3f4f6;
        }
        #mappingPreviewContainer select {
            width: 100%;
            font-size: 0.75rem;
        }
        .error-input {
            border-color: #ef4444 !important; /* red-500 */
            box-shadow: 0 0 0 1px #ef4444;
        }
        /* Improved Toast Container */
        #toast-container {
            position: fixed;
            bottom: 1.25rem;
            right: 1.25rem;
            display: flex;
            flex-direction: column-reverse;
            gap: 0.75rem;
            z-index: 1000;
            max-height: 100vh;
            overflow-y: auto;
            padding: 1rem;
            pointer-events: none;
        }
        
        .toast {
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            color: white;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
            min-width: 300px;
            max-width: 500px;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .toast:hover {
            transform: translateX(-5px);
            box-shadow: 0 15px 20px -3px rgba(0, 0, 0, 0.15), 0 6px 8px -2px rgba(0, 0, 0, 0.1);
        }
        
        .toast-success { 
            background-color: #22c55e;
            border-left: 4px solid #16a34a;
        }
        
        .toast-error { 
            background-color: #ef4444;
            border-left: 4px solid #dc2626;
        }
        
        .toast-info { 
            background-color: #3b82f6;
            border-left: 4px solid #2563eb;
        }
        
        .toast-warning { 
            background-color: #f97316;
            border-left: 4px solid #ea580c;
        }

        .scrollable-accordion.open > .accordion-content {
            /* Keep explicit display to satisfy linters; actual scroll behavior handled elsewhere */
            display: block;
        }

        /* Improvement: Styles for focused accordion item */
        .accordion-item.is-focused {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        /* [REPLACED] - Start of accordion scroll fix */
        /* Focused content that should FILL the space (e.g., Gantt) */
        .accordion-item.is-focused > .accordion-content.flex-grow {
            flex-grow: 1;
            overflow-y: auto; /* Changed from hidden to auto */
            max-height: none !important;
        }

        /* Focused content that should SCROLL (e.g., Overview, Settlement) */
        .accordion-item.is-focused > .accordion-content.scrollable-content {
            flex-grow: 1; /* Grow to fill the 'is-focused' item's space */
            overflow-y: auto; /* Enable vertical scrolling */
            max-height: 100%; /* IMPORTANT: Constrain height to the container */
        }

        /* Fallback for any other focused content (though all should be one of the above) */
        .accordion-item.is-focused > .accordion-content:not(.flex-grow):not(.scrollable-content) {
            flex-grow: 1;
            overflow-y: auto;
        }
        /* [REPLACED] - End of accordion scroll fix */

        /* Fullscreen Legend Style */
        #fullscreenModalBody > .controls-section {
             background-color: white;
             padding: 1rem;
             border-radius: 0.5rem;
             box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
             margin-bottom: 1rem;
             flex-shrink: 0;
        }
        
        /* Í∞úÏÑ† ÏÇ¨Ìï≠ 1: Î∞îÎ°úÍ∞ÄÍ∏∞ Î©îÎâ¥ Ïä§ÌÉÄÏùº */
        .pinnable-control-wrapper {
            position: relative;
        }
        .pin-shortcut-btn {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background-color: #e5e7eb;
            color: #6b7280;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.5;
            z-index: 10;
        }
        .pinnable-control-wrapper:hover .pin-shortcut-btn {
            opacity: 1;
        }
        .pin-shortcut-btn.pinned {
            background-color: #4f46e5;
            color: white;
            opacity: 1;
        }
        #shortcutContainer {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 0.75rem;
            flex-wrap: wrap;
        }
        #shortcutContainer > * {
            flex-shrink: 0;
        }
        #shortcutContainer .shortcut-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin-right: 0.5rem;
            transition: transform 0.15s ease;
        }
        .shortcut-item:hover {
            transform: translateY(-1px);
        }
        #shortcutContainer .shortcut-item select,
        #shortcutContainer .shortcut-item input,
        #shortcutContainer .shortcut-item button {
             font-size: 0.8rem;
             padding: 2px 6px;
             min-height: 24px;
             border-radius: 4px;
             border: 1px solid #e5e7eb;
             transition: all 0.2s ease;
        }
        #shortcutContainer .shortcut-item select:hover,
        #shortcutContainer .shortcut-item input:hover,
        #shortcutContainer .shortcut-item button:hover {
            border-color: #6366f1;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #shortcutContainer .shortcut-item select:focus,
        #shortcutContainer .shortcut-item input:focus,
        #shortcutContainer .shortcut-item button:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(99,102,241,0.2);
        }
        #shortcutContainer .shortcut-item input[type="text"] {
             width: 150px;
        }
        #shortcutContainer .shortcut-item button.js-zoom-btn {
            background-color: #f3f4f6;
            color: #4b5563;
            font-weight: 500;
        }
        #shortcutContainer .shortcut-item button.js-zoom-btn:hover {
            background-color: #e5e7eb;
            color: #1f2937;
        }

    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="w-full h-full p-4 md:p-8 flex flex-col">
        <!-- Main content area -->
        <main id="dashboardContent" class="flex flex-col flex-grow min-h-0 space-y-4">

            <!-- Accordion 1: Ï¥ùÍ¥Ñ -->
            <div class="accordion-item bg-white rounded-lg shadow-sm flex-shrink-0">
                <div class="accordion-header p-4 cursor-pointer flex justify-between items-center border-b">
                    <h2 class="text-2xl font-bold">üìä Ï¥ùÍ¥Ñ</h2>
                    <svg class="accordion-icon w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                 <!-- Improvement: Added scrollable-content class -->
                <div class="accordion-content p-4 scrollable-content">
                    <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-4">
                        <div class="summary-card bg-slate-100 border-l-4 border-slate-500 text-slate-700 p-4 rounded-lg shadow" data-filter-type="progress" data-filter-value="overall">
                            <div class="font-bold text-lg">Ï¥ùÍ¥Ñ Í≥µÏ†ïÏú®</div>
                            <div id="overallProgress" class="text-3xl font-extrabold">0%</div>
                            <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                                <div id="overallProgressBar" class="bg-slate-600 h-2.5 rounded-full" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="summary-card bg-sky-100 border-l-4 border-sky-500 text-sky-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="all">
                            <div class="font-bold text-lg">Ï†ÑÏ≤¥</div><div id="totalProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="Í≥µÏÇ¨Ï§ë">
                            <div class="font-bold text-lg">ÏßÑÌñâÏ§ë</div><div id="inProgressProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-gray-100 border-l-4 border-gray-500 text-gray-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="Ï∞©Í≥µÏ†Ñ">
                            <div class="font-bold text-lg">Ï∞©Í≥µÏ†Ñ</div><div id="beforeStartProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="ÏßÄÏó∞">
                            <div class="font-bold text-lg">ÏßÄÏó∞</div><div id="delayedProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                         <div class="summary-card bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="ÏôÑÎ£å">
                            <div class="font-bold text-lg">ÏôÑÎ£å</div><div id="completedProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                    </div>
                    <!-- ÌòÑÏû¨ ÏöîÏïΩÏù¥ Ïñ¥Îñ§ ÌïÑÌÑ∞(Ïòà: Í≥†Í∞ùÏÇ¨) Í∏∞Ï§ÄÏù∏ÏßÄ ÏïåÎ†§Ï£ºÎäî ÎùºÎ≤® (ÎààÏóê ÌäÄÏßÄ ÏïäÎèÑÎ°ù Ïó∞Ìïú ÏÉâÏÉÅ) -->
                    <div id="summaryFilterLabel" class="mt-2 text-sm text-gray-500">ÌïÑÌÑ∞: Ï†ÑÏ≤¥</div>
                    <div id="overview-group-summaries" class="mt-4 space-y-4"></div>
                </div>
            </div>

            <!-- Accordion 2: Ï†ïÏÇ∞ -->
            <div class="accordion-item bg-white rounded-lg shadow-sm flex-shrink-0">
                <div class="accordion-header p-4 cursor-pointer flex items-center border-b">
                    <h2 class="text-2xl font-bold">üí∞ Ï†ïÏÇ∞</h2>
                    <div id="settlement-header-summaries" class="ml-auto text-right text-xl font-semibold text-gray-600"></div>
                    <svg class="accordion-icon w-6 h-6 flex-shrink-0 ml-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                 <!-- Improvement: Added scrollable-content class -->
                <div class="accordion-content p-4 scrollable-content settlement-scrollable">
                    <div id="poSummary" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4"></div>
                    <div id="settlement-group-summaries" class="mt-4 space-y-4"></div> <!-- Added space-y-4 -->
                </div>
            </div>

            <!-- Accordion 3: ÏùºÏ†ï -->
            <div id="projectView" class="accordion-item bg-white rounded-lg shadow-sm flex flex-col flex-grow min-h-0">
                 <div class="accordion-header p-4 cursor-pointer flex justify-between items-center border-b">
                     <div class="flex items-center flex-grow">
                        <h2 class="text-2xl font-bold">üóìÔ∏è ÏùºÏ†ï</h2>
                        <button id="milestoneBtn" class="px-3 py-1 bg-rose-500 text-white text-sm rounded hover:bg-rose-600 ml-4">ÎßàÏùºÏä§ÌÜ§</button>
                        <button id="fullscreenBtn" class="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 ml-2">Ï†ÑÏ≤¥ ÌôîÎ©¥</button>
                        <!-- Í∞úÏÑ† ÏÇ¨Ìï≠: ÏÑ§Ï†ï ÏïÑÏù¥ÏΩò Î≤ÑÌäº Ï∂îÍ∞Ä -->
                        <button id="openControlsPanelBtn" class="p-2 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 ml-2" title="ÌïÑÌÑ∞ Î∞è ÌÉÄÏûÑÎùºÏù∏ ÏÑ§Ï†ï">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.532 1.532 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.532 1.532 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                            </svg>
                        </button>
                        <!-- Í∞úÏÑ† ÏÇ¨Ìï≠ 1: Î∞îÎ°úÍ∞ÄÍ∏∞ Î©îÎâ¥Í∞Ä ÌëúÏãúÎê† Ïª®ÌÖåÏù¥ÎÑà -->
                        <div id="shortcutContainer"></div>
                     </div>
                     <svg class="accordion-icon w-6 h-6 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                 </div>
                  <!-- Marked as flex-grow for layout -->
                 <div class="accordion-content flex-grow flex flex-col min-h-0">
                    <div class="p-4 flex-grow flex flex-col min-h-0">
                        <div id="ganttViewContent" class="flex flex-col flex-grow min-h-0 h-full">
                            <!-- Í∞úÏÑ† ÏÇ¨Ìï≠: Î≤îÎ°Ä(Legend) ÏÑπÏÖòÏùÑ Ïª®Ìä∏Î°§ Ìå®ÎÑê Î∞ñÏúºÎ°ú Ïù¥Îèô -->
                            <div id="legendSection" class="legend-section flex items-center gap-x-6 gap-y-2 border p-4 mb-4 rounded-lg shadow-md bg-white w-full flex-wrap">
                                <h3 class="text-lg font-semibold flex-shrink-0">Î≤îÎ°Ä</h3>
                                <div class="flex flex-wrap items-center gap-x-4 gap-y-1">
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="Ï∞©Í≥µÏ†Ñ">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(156, 163, 175);"></span>
                                        <span class="text-sm">Ï∞©Í≥µÏ†Ñ <span id="legendNotStarted" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="Í≥µÏÇ¨Ï§ë">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(59, 130, 246);"></span>
                                        <span class="text-sm">Í≥µÏÇ¨Ï§ë <span id="legendInProgress" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ÏßÄÏó∞">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(239, 68, 68);"></span>
                                        <span class="text-sm">ÏßÄÏó∞ <span id="legendDelayed" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ÏôÑÎ£å">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(34, 197, 94);"></span>
                                        <span class="text-sm">ÏôÑÎ£å <span id="legendCompleted" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="w-4 h-4 rounded" style="background: linear-gradient(90deg, rgb(156, 163, 175), rgb(59, 130, 246), rgb(34, 197, 94));"></span>
                                        <span class="text-sm">Í∑∏Î£π ÏßÑÌñâÎ•† <span id="legendGroupProgress" class="font-mono text-gray-500"></span></span>
                                    </div>
                                </div>
                            </div>

                            <div id="ganttChartWrapper" class="flex-grow min-h-0">
                                <div id="ganttChart" class="space-y-6 bg-white h-full"></div>
                            </div>
                        </div>
                    </div>
                 </div>
            </div>
        </main>
    </div>

    <!-- Í∞úÏÑ† ÏÇ¨Ìï≠: ÏÑ§Ï†ï(Ïª®Ìä∏Î°§) Ïä¨ÎùºÏù¥Îìú Ìå®ÎÑê -->
    <div id="controlsPanelOverlay" class="fixed inset-0 bg-black bg-opacity-40 z-50 hidden transition-opacity duration-300"></div>
    <div id="controlsPanel" class="fixed top-0 right-0 h-full bg-white shadow-2xl z-50 transform translate-x-full transition-transform duration-300 ease-in-out w-full max-w-sm">
        <div class="flex justify-between items-center p-4 border-b">
            <h2 class="text-xl font-bold">ÌïÑÌÑ∞ Î∞è ÌÉÄÏûÑÎùºÏù∏ ÏÑ§Ï†ï</h2>
            <button id="closeControlsPanelBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
        </div>
        <div class="p-4 overflow-y-auto h-[calc(100%-65px)]">
            <!-- Í∏∞Ï°¥ Controls SectionÏù¥ Ïù¥Í≥≥ÏúºÎ°ú Ïù¥Îèô -->
            <section id="controlsSection">
                <!-- Filtering & Sorting Toggle -->
                <div class="control-section-header open">
                    <h3 class="text-lg font-semibold">ÌïÑÌÑ∞ÎßÅ Î∞è Ï†ïÎ†¨</h3>
                    <svg class="control-section-icon w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="control-section-content">
                    <div class="flex flex-col gap-4">
                        <div class="pinnable-control-wrapper">
                            <select id="progressFilter" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                <option value="all">ÏßÑÏ≤ôÎ•†</option>
                                <option value="not_started">ÎØ∏Ï∞©Ïàò (0%)</option>
                                <option value="in_progress">ÏßÑÌñâÏ§ë (1-99%)</option>
                                <option value="completed">ÏôÑÎ£å (100%)</option>
                            </select>
                        </div>
                        <div class="pinnable-control-wrapper">
                            <select id="taskTypeFilter" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                <option value="all">Ïú†Ìòï</option>
                            </select>
                        </div>
                        <div id="customFilterContainer" class="flex flex-col gap-4"></div>
                        <div class="pinnable-control-wrapper">
                            <select id="sortBy" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                <option value="default">Ï†ïÎ†¨</option>
                                <option value="startDate">ÏãúÏûëÏùº Ïàú</option>
                                <option value="endDate">Ï¢ÖÎ£åÏùº Ïàú</option>
                                <option value="duration">Í∏∞Í∞Ñ Ïàú</option>
                                <option value="progress">ÏßÑÌñâ Ïàú</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Timeline Toggle -->
                <div class="control-section-header open mt-4">
                    <h3 class="text-lg font-semibold">ÌÉÄÏûÑÎùºÏù∏</h3>
                    <svg class="control-section-icon w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="control-section-content">
                    <div class="flex flex-col gap-4">
                         <div class="relative pinnable-control-wrapper">
                            <div class="relative">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 pointer-events-none" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                                </svg>
                                <input type="text" id="searchInput" placeholder="Í≤ÄÏÉâ..." class="w-full p-2 pl-10 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500 transition">
                            </div>
                        </div>
                        <div class="relative pinnable-control-wrapper">
                            <button id="zoomBtn" class="w-full text-left p-2 bg-gray-200 rounded hover:bg-gray-300 js-zoom-btn">ÎÇ†Ïßú ÏÑ§Ï†ï</button>
                            <div id="zoomPopover" class="hidden absolute top-full left-0 mt-2 bg-white border rounded-lg shadow-xl p-4 z-20 w-80 space-y-3">
                                <h4 class="font-bold text-sm">Í∏∞Í∞Ñ ÏÑ§Ï†ï</h4>
                                <div class="flex items-center gap-2">
                                    <input type="date" id="zoomStartDate" class="w-full p-1 border rounded text-sm">
                                    <span>~</span>
                                    <input type="date" id="zoomEndDate" class="w-full p-1 border rounded text-sm">
                                </div>
                                <h4 class="font-bold text-sm pt-2">Ï£º Îã®ÏúÑ ÏÑ†ÌÉù</h4>
                                <div class="grid grid-cols-3 gap-2">
                                    <button id="zoomPrevWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">Ïù¥Ï†Ñ Ï£º</button>
                                    <button id="zoomThisWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">Ïù¥Î≤à Ï£º</button>
                                    <button id="zoomNextWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">Îã§Ïùå Ï£º</button>
                                </div>
                                <h4 class="font-bold text-sm pt-2">3Ï£º Îã®ÏúÑ ÏÑ†ÌÉù</h4>
                                <div class="grid grid-cols-2 gap-2">
                                    <button id="zoomThreeWeeksToday" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">3Ï£ºÍ∞Ñ(Ïò§Îäò)</button>
                                    <button id="zoomThreeWeeksSelected" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">3Ï£ºÍ∞Ñ(ÏßÄÏ†ï)</button>
                                </div>
                                <div class="flex justify-end gap-2 pt-3 border-t">
                                    <button id="zoomResetBtn" class="px-3 py-1 bg-gray-500 text-white text-xs rounded hover:bg-gray-600">Ï¥àÍ∏∞Ìôî</button>
                                    <button id="zoomApplyBtn" class="px-3 py-1 bg-indigo-500 text-white text-xs rounded hover:bg-indigo-600">Ï†ÅÏö©</button>
                                </div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="pinnable-control-wrapper"><button id="expandAllBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300">ÌéºÏπòÍ∏∞</button></div>
                            <div class="pinnable-control-wrapper"><button id="collapseAllBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300">Ï†ëÍ∏∞</button></div>
                        </div>
                         <div class="pinnable-control-wrapper">
                            <button id="goToTodayBtn" class="w-full p-2 bg-blue-500 text-white rounded-md">Ïò§Îäò</button>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>


    <!-- Data Detail Modal -->
    <div id="dataDetailModal" class="modal-overlay hidden">
        <div class="modal-content">
             <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 id="dataDetailTitle" class="text-xl font-bold text-gray-800">ÏÉÅÏÑ∏ Îç∞Ïù¥ÌÑ∞</h2>
                <button id="closeDataDetailModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="resizable-modal-body">
                <div id="dataDetailTableContainer" class="h-full overflow-y-auto">
                    <!-- Table will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Gantt Modal -->
    <div id="fullscreenModal" class="fullscreen-modal-overlay hidden">
        <div class="resizable-modal-content">
            <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">ÏùºÏ†ï (Ï†ÑÏ≤¥ ÌôîÎ©¥)</h2>
                <button id="closeFullscreenModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
             <!-- Fullscreen body now uses flex-col for layout -->
            <div id="fullscreenModalBody" class="resizable-modal-body flex flex-col">
                 <!-- Legend and Gantt Chart will be moved here -->
            </div>
        </div>
    </div>

    <!-- Milestone Modal -->
    <div id="milestoneModal" class="modal-overlay hidden">
        <div class="modal-content w-[500px] h-auto min-h-[400px] resize overflow-visible">
            <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">ÎßàÏùºÏä§ÌÜ§ Í¥ÄÎ¶¨</h2>
                <button id="closeMilestoneModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="p-6 flex-grow flex flex-col">
                <div id="milestoneList" class="flex-grow mb-4 overflow-y-auto pr-2">
                    <!-- Milestone items will be injected here -->
                </div>
                <form id="addMilestoneForm" class="flex items-center gap-2 border-t pt-4">
                    <input type="date" id="milestoneDate" class="p-2 border rounded" required>
                    <input type="text" id="milestoneName" placeholder="ÎßàÏùºÏä§ÌÜ§ Ïù¥Î¶Ñ" class="p-2 border rounded flex-grow" required>
                    <button type="submit" class="p-2 bg-rose-500 text-white rounded hover:bg-rose-600">Ï∂îÍ∞Ä</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Data Mapping Modal -->
    <div id="mappingModal" class="modal-overlay hidden">
        <div class="modal-content !max-w-6xl !w-auto !h-auto">
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">Îç∞Ïù¥ÌÑ∞ Îß§Ìïë Î∞è ÎØ∏Î¶¨Î≥¥Í∏∞</h2>
                <button id="closeMappingModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="p-6 space-y-4">
                <div class="flex items-center gap-4 bg-gray-50 p-3 rounded-md">
                    <label for="mappingHeaderRowCount" class="text-sm font-medium text-gray-700 flex-shrink-0">Ìó§Îçî ÏãúÏûë Ìñâ:</label>
                    <input type="number" id="mappingHeaderRowCount" value="1" min="1" class="w-20 p-1 border border-gray-300 rounded-md text-center focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                    <p class="text-sm text-gray-500">ÌååÏùºÏóêÏÑú Ìó§Îçî(Ï†úÎ™©)Í∞Ä ÏãúÏûëÎêòÎäî Ìñâ Î≤àÌò∏Î•º ÏßÄÏ†ïÌïòÏÑ∏Ïöî.</p>
                </div>
                <!-- IMPROVEMENT: Added guidance text for data mapping -->
                <div class="bg-indigo-50 border-l-4 border-indigo-500 text-indigo-800 p-4 rounded-md mb-4 text-sm" role="alert">
                    <p class="font-bold">Îç∞Ïù¥ÌÑ∞ Îß§Ìïë ÏïàÎÇ¥</p>
                    <p>ÏóÖÎ°úÎìúÌïú ÌååÏùºÏùò Í∞Å Ïó¥(Column)Ïù¥ Ïñ¥Îñ§ Îç∞Ïù¥ÌÑ∞Ïóê Ìï¥ÎãπÌïòÎäîÏßÄ ÏïÑÎûò ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ÏóêÏÑú ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.</p>
                    <ul class="list-disc list-inside mt-2">
                        <li><strong class="font-semibold">'Î™ÖÏπ≠', 'ÏãúÏûëÏùº', 'Ï¢ÖÎ£åÏùº'</strong>ÏùÄ ÌïÑÏàò Ìï≠Î™©ÏûÖÎãàÎã§.</li>
                        <li>ÏãúÏä§ÌÖúÏóêÏÑú ÏûêÎèôÏúºÎ°ú ÏµúÏ†ÅÏùò Îß§ÌïëÏùÑ Ï†úÏïàÌïòÏßÄÎßå, ÌïÑÏöîÏãú ÏßÅÏ†ë ÏàòÏ†ïÌï† Ïàò ÏûàÏäµÎãàÎã§.</li>
                        <li>Î∂àÌïÑÏöîÌïú Ïó¥ÏùÄ 'Î¨¥Ïãú'Î°ú ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.</li>
                    </ul>
                </div>
                <div id="mappingPreviewContainer" class="overflow-auto border rounded-md" style="max-height: 50vh;">
                    <!-- Mapping preview table will be injected here -->
                </div>
            </div>
            <div class="flex justify-end items-center p-4 border-t bg-gray-50 rounded-b-md">
                <button id="cancelMappingBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 mr-2">Ï∑®ÏÜå</button>
                <button id="applyMappingBtn" class="px-4 py-2 bg-violet-600 text-white rounded-md hover:bg-violet-700">Îç∞Ïù¥ÌÑ∞ Ï†ÅÏö©</button>
            </div>
        </div>
    </div>

    <!-- Error Correction Modal -->
    <div id="errorCorrectionModal" class="modal-overlay hidden">
        <div class="modal-content !max-w-7xl !h-[90vh]">
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">Îç∞Ïù¥ÌÑ∞ ÏóÖÎ°úÎìú Ïò§Î•ò ÏàòÏ†ï</h2>
                <button id="closeErrorCorrectionModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <!-- IMPROVEMENT: Enhanced guidance text for error correction -->
            <div id="errorCorrectionInfo" class="p-4 bg-yellow-50 text-yellow-800 border-b text-sm">
                <!-- Info text will be injected here -->
            </div>
            <div class="flex-grow overflow-auto">
                <div id="errorCorrectionContainer" class="p-4">
                    <!-- Error correction table will be injected here -->
                </div>
            </div>
            <div class="flex justify-end items-center p-4 border-t bg-gray-50 rounded-b-md">
                <button id="discardErrorsBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 mr-2">Ïò§Î•ò Îç∞Ïù¥ÌÑ∞ Î¨¥ÏãúÌïòÍ≥† Îã´Í∏∞</button>
                <button id="retryImportBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">ÏàòÏ†ïÎêú Ìï≠Î™© Í∞ÄÏ†∏Ïò§Í∏∞</button>
            </div>
        </div>
    </div>

    <!-- Floating Action Button -->
    <button id="fabMenuBtn" class="fixed bottom-8 right-8 bg-indigo-600 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center text-3xl hover:bg-indigo-700 transition-transform duration-200 ease-in-out hover:rotate-90 z-40">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
        </svg>
    </button>

    <!-- Data Management Panel -->
    <div id="dataPanel" class="fixed top-0 left-0 w-full h-full bg-black bg-opacity-40 flex justify-center items-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md" id="dataPanelContent">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold">Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨</h2>
                <button id="closeDataPanelBtn" class="text-gray-400 hover:text-gray-700">&times;</button>
            </div>

            <div class="space-y-3">
                <p class="text-sm text-center text-gray-500 pb-2">ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Í±∞ÎÇò ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞Î•º Ï†ÄÏû•ÌïòÏÑ∏Ïöî.</p>

                <div class="flex items-center justify-center gap-2 pt-1 pb-2">
                    <label for="headerRowCount" class="text-sm font-medium text-gray-700 flex-shrink-0">Ìó§Îçî ÏãúÏûë Ìñâ:</label>
                    <input type="number" id="headerRowCount" value="1" min="1" class="w-20 p-1 border border-gray-300 rounded-md text-center focus:ring-2 focus:ring-violet-500 focus:border-violet-500" title="Ìó§ÎçîÍ∞Ä ÏãúÏûëÎêòÎäî Ïã§Ï†ú Ìñâ Î≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïòà: 1)">
                </div>

                <!-- Upload -->
                <button id="uploadBtn" class="w-full flex items-center justify-center gap-3 p-3 bg-violet-50 text-violet-700 rounded-lg hover:bg-violet-100 font-semibold transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>
                    <span>Îç∞Ïù¥ÌÑ∞ ÏóÖÎ°úÎìú (.csv, .xlsx)</span>
                </button>
                <input type="file" id="fileInput" accept=".csv, .xls, .xlsx" class="hidden"/>

                <!-- Download Template -->
                <div class="flex gap-2 justify-center pt-2">
                     <button data-format="csv" class="download-template-btn flex-1 p-2 bg-gray-100 text-gray-700 text-sm rounded hover:bg-gray-200 transition">ÏñëÏãù (.csv)</button>
                     <button data-format="xlsx" class="download-template-btn flex-1 p-2 bg-gray-100 text-gray-700 text-sm rounded hover:bg-gray-200 transition">ÏñëÏãù (.xlsx)</button>
                </div>

                <!-- Export Data Section -->
                <div class="space-y-3 pb-2">
                    <p class="text-sm text-center text-gray-500">ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞Î•º ÏóëÏÖÄ ÎòêÎäî CSVÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞</p>
                    <div class="flex gap-2">
                        <button id="exportToExcelBtn" class="flex-1 flex items-center justify-center gap-2 p-3 bg-indigo-50 text-indigo-700 rounded-lg hover:bg-indigo-100 font-semibold transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                            <span>Excel Îã§Ïö¥Î°úÎìú</span>
                        </button>
                        <button id="exportToCsvBtn" class="flex-1 flex items-center justify-center gap-2 p-3 bg-blue-50 text-blue-700 rounded-lg hover:bg-blue-100 font-semibold transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                            <span>CSV Îã§Ïö¥Î°úÎìú</span>
                        </button>
                    </div>
                </div>
                
                <!-- Separator -->
                <hr class="my-4 border-t border-gray-200"/>

                <!-- Save current state -->
                <button id="saveHtmlBtn" class="w-full flex items-center justify-center gap-3 p-3 bg-green-50 text-green-700 rounded-lg hover:bg-green-100 font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed group relative" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6a1 1 0 10-2 0v5.586L7.707 10.293zM3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 11-2 0V5H5v1a1 1 0 11-2 0V4z" />
                    </svg>
                    <span>ÌòÑÏû¨ ÏûëÏóÖ ÎÇ¥Ïö© Ï†ÄÏû•</span>
                    <div class="opacity-0 group-hover:opacity-100 transition-opacity absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-1 bg-gray-800 text-white text-xs rounded whitespace-nowrap">
                        Î™®Îì† Îç∞Ïù¥ÌÑ∞ÏôÄ ÏÑ§Ï†ïÏù¥ Ï†ÄÏû•ÎêòÎ©∞, ÎÇòÏ§ëÏóê Ïù¥Ïñ¥ÏÑú ÏûëÏóÖÌï† Ïàò ÏûàÏäµÎãàÎã§
                    </div>
                </button>
                <p id="saveMessage" class="text-sm text-center text-gray-600 pt-2 pb-1 hidden flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>
                    <span>Ï†ÄÏû•Îêú ÌååÏùºÏùÄ Ïù∏ÌÑ∞ÎÑ∑ ÏóÜÏù¥ÎèÑ Îã®ÎèÖÏúºÎ°ú Ïã§ÌñâÎêòÎ©∞ Î™®Îì† ÏûëÏóÖ ÎÇ¥Ïö©Ïù¥ Î≥¥Ï°¥Îê©ÎãàÎã§</span>
                </p>
                <!-- Auto-upload URL ÏÑ§Ï†ï (ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥ÄÍ≤Ω Í∞ÄÎä•) -->
                <div class="mt-4 border-t pt-3 space-y-2">
                    <label for="autoUploadUrlInput" class="text-sm font-medium text-gray-700">ÏûêÎèô ÏóÖÎ°úÎî© URL (GitHub Îì±)</label>
                    <input id="autoUploadUrlInput" type="text" class="w-full p-2 border border-gray-300 rounded-md text-sm" placeholder="ÏûêÎèô Î∂àÎü¨Ïò¨ ÌååÏùºÏùò URLÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî" />
                    <div class="flex items-center gap-2">
                        <input id="autoUploadEnabled" type="checkbox" class="w-4 h-4" />
                        <label for="autoUploadEnabled" class="text-sm text-gray-600">ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú ÏûêÎèôÏúºÎ°ú Î∂àÎü¨Ïò§Í∏∞</label>
                        <button id="autoUploadNowBtn" class="ml-auto px-3 py-1 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700">ÏßÄÍ∏à Î∂àÎü¨Ïò§Í∏∞</button>
                    </div>
                    <p class="text-xs text-gray-500">Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞Ïù¥ ÏóÜÍ±∞ÎÇò ÌååÏùºÏù¥ ÏóÜÏùÑ Í≤ΩÏö∞ Í∏∞Ï°¥ Î°úÏª¨ ÏóÖÎ°úÎìú Î∞©ÏãùÏù¥ ÎèôÏûëÌï©ÎãàÎã§.</p>
                </div>
            </div>
        </div>
    </div>

    <div id="progressPopup" class="hidden absolute bg-white border rounded-lg shadow-xl p-2 grid grid-cols-4 gap-2 w-56">
    </div>

    <div id="toast-container"></div>

    <!-- [DELETED] The template is no longer needed as we move the actual element. -->

    <!-- EMBEDDED_DATA_PLACEHOLDER -->
    <!-- EMBEDDED_MILESTONES_PLACEHOLDER -->
    <!-- EMBEDDED_SETTINGS_PLACEHOLDER -->

    <script>
        // Data Management Panel Elements
        const fabMenuBtn = document.getElementById('fabMenuBtn');
        const dataPanel = document.getElementById('dataPanel');
        const dataPanelContent = document.getElementById('dataPanelContent');
        const closeDataPanelBtn = document.getElementById('closeDataPanelBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const saveHtmlBtn = document.getElementById('saveHtmlBtn');
        const saveMessage = document.getElementById('saveMessage');
        const downloadTemplateBtns = document.querySelectorAll('.download-template-btn');
        const headerRowCountInput = document.getElementById('headerRowCount');

        const fileInput = document.getElementById('fileInput');
        const dashboardContent = document.getElementById('dashboardContent');
        const ganttChartWrapper = document.getElementById('ganttChartWrapper');
        const ganttChartContainer = document.getElementById('ganttChart');
        const exportToExcelBtn = document.getElementById('exportToExcelBtn');
        const exportToCsvBtn = document.getElementById('exportToCsvBtn');
        // Selectors updated after DOM changes for controls
        let taskTypeFilter, customFilterContainer, progressFilter, sortBy, searchInput;

        // Timeline controls (Selector might need update if ID changes)
        let goToTodayBtn;

        // Data Detail Modal
        const dataDetailModal = document.getElementById('dataDetailModal');
        const closeDataDetailModalBtn = document.getElementById('closeDataDetailModalBtn');
        const dataDetailTitle = document.getElementById('dataDetailTitle');
        const dataDetailTableContainer = document.getElementById('dataDetailTableContainer');

        // View Controls (Selectors might need update)
        let expandAllBtn, collapseAllBtn;

        // Fullscreen Modal
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const fullscreenModal = document.getElementById('fullscreenModal');
        const fullscreenModalContent = fullscreenModal.querySelector('.resizable-modal-content');
        const fullscreenModalBody = document.getElementById('fullscreenModalBody');
        const closeFullscreenModalBtn = document.getElementById('closeFullscreenModalBtn');

        // Milestone Modal
        const milestoneBtn = document.getElementById('milestoneBtn');
        const milestoneModal = document.getElementById('milestoneModal');
        const closeMilestoneModalBtn = document.getElementById('closeMilestoneModalBtn');
        const addMilestoneForm = document.getElementById('addMilestoneForm');
        const milestoneList = document.getElementById('milestoneList');

        // Mapping Modal
        const mappingModal = document.getElementById('mappingModal');
        const closeMappingModalBtn = document.getElementById('closeMappingModalBtn');
        const cancelMappingBtn = document.getElementById('cancelMappingBtn');
        const applyMappingBtn = document.getElementById('applyMappingBtn');
        const mappingHeaderRowCount = document.getElementById('mappingHeaderRowCount');
        const mappingPreviewContainer = document.getElementById('mappingPreviewContainer');

        // Error Correction Modal
        const errorCorrectionModal = document.getElementById('errorCorrectionModal');
        const closeErrorCorrectionModalBtn = document.getElementById('closeErrorCorrectionModalBtn');
        const errorCorrectionInfo = document.getElementById('errorCorrectionInfo');
        const errorCorrectionContainer = document.getElementById('errorCorrectionContainer');
        const discardErrorsBtn = document.getElementById('discardErrorsBtn');
        const retryImportBtn = document.getElementById('retryImportBtn');

        // Í∞úÏÑ† ÏÇ¨Ìï≠: Ïª®Ìä∏Î°§ Ìå®ÎÑê ÏöîÏÜå
        const openControlsPanelBtn = document.getElementById('openControlsPanelBtn');
        const controlsPanel = document.getElementById('controlsPanel');
        const controlsPanelOverlay = document.getElementById('controlsPanelOverlay');
        const closeControlsPanelBtn = document.getElementById('closeControlsPanelBtn');
        
        // Í∞úÏÑ† ÏÇ¨Ìï≠ 1: Î∞îÎ°úÍ∞ÄÍ∏∞ Î©îÎâ¥ ÏöîÏÜå
        const shortcutContainer = document.getElementById('shortcutContainer');


        const progressPopup = document.getElementById('progressPopup');

    // Auto-upload controls
    const autoUploadUrlInput = document.getElementById('autoUploadUrlInput');
    const autoUploadEnabled = document.getElementById('autoUploadEnabled');
    const autoUploadNowBtn = document.getElementById('autoUploadNowBtn');

    // Zoom controls (Selector might need update)
    let zoomBtn, zoomPopover, zoomStartDate, zoomEndDate, zoomApplyBtn, zoomResetBtn;
    // Keep original parent reference for the popover so we can reliably return it
    let zoomOriginalParent = null;
        let zoomPrevWeek, zoomThisWeek, zoomNextWeek, zoomThreeWeeksToday, zoomThreeWeeksSelected;

        let projectData = [];
        let milestones = [];
        let openTaskGroups = new Set();
        let minDate, maxDate;
        let viewMinDate, viewMaxDate;
        let savedSettings = null;
        let rawImportData = null;
        let importMapping = null;
        let failedImportRows = [];
        let legendStatusFilter = null;
        let pinnedShortcuts = new Set(); // Í∞úÏÑ† ÏÇ¨Ìï≠ 1: Î∞îÎ°úÍ∞ÄÍ∏∞ ÏÉÅÌÉú Ï†ÄÏû•

        let DAY_WIDTH = 40;

    // Í∏∞Î≥∏ ÏûêÎèô ÏóÖÎ°úÎìú URL
    const DEFAULT_AUTO_UPLOAD_URL = 'https://jonggunelee.github.io/wyggkr04/RawData/25ÎÖÑ ÏûîÏó¨ Í≥µÏÇ¨ Í≥µÏ†ïÍ¥ÄÎ¶¨_(ÏûÖÎ†•).xlsx';

        // ÏïàÏ†ÑÌïú ÌÇ§ ÏÉùÏÑ±: ÌïúÍ∏Ä(ÎòêÎäî Îã§Î•∏ Ïú†ÎãàÏΩîÎìú Î¨∏Ïûê)Í≥º Ïà´ÏûêÎäî Î≥¥Ï°¥ÌïòÍ≥†
        // Í∑∏ Ïô∏ ÌäπÏàòÎ¨∏ÏûêÎäî '_'Î°ú ÎåÄÏ≤¥Ìï©ÎãàÎã§. Ï†ÑÏó≠ÏóêÏÑú Ïû¨ÏÇ¨Ïö©Ìï©ÎãàÎã§.
        let customFieldDisplayNames = {}; // sanitizedKey -> original display name
        function sanitizeKey(key) {
            if (key === undefined || key === null) return '';
            try {
                // Keep Unicode letters and numbers, replace other chars with underscore
                return String(key).trim().replace(/[^\p{L}\p{N}]+/gu, '_').replace(/^_+|_+$/g, '').replace(/_+/g, '_');
            } catch (e) {
                // Fallback for environments without Unicode property escapes
                return String(key).trim().replace(/[^a-zA-Z0-9Í∞Ä-Ìû£]+/g, '_').replace(/^_+|_+$/g, '').replace(/_+/g, '_');
            }
        }

        const statusColors = {
            'Í≥µÏÇ¨Ï§ë': 'bg-blue-500',
            'Ï∞©Í≥µÏ†Ñ': 'bg-gray-400',
            'ÏôÑÎ£å': 'bg-green-500',
            'ÏßÄÏó∞': 'bg-red-500',
            'default': 'bg-sky-500'
        };

        let columnVisibility = {
            'project-name': true, 'project-po': false, 'project-progress': true, 'project-dates': true,
        };

        // Ensure any floating popovers are hidden before opening the data panel
        function hideFloatingPopovers() {
            try {
                if (zoomPopover) {
                    zoomPopover.classList.add('hidden');
                    // move back to original parent if available
                    if (zoomOriginalParent && zoomOriginalParent !== zoomPopover.parentElement) {
                        zoomOriginalParent.appendChild(zoomPopover);
                    }
                    // reset inline zIndex to avoid covering modals
                    zoomPopover.style.zIndex = '';
                }
            } catch (e) {
                console.warn('hideFloatingPopovers error', e);
            }
        }

        fabMenuBtn.addEventListener('click', () => {
            hideFloatingPopovers();
            dataPanel.classList.remove('hidden');
        });
        closeDataPanelBtn.addEventListener('click', () => dataPanel.classList.add('hidden'));
        dataPanel.addEventListener('click', (e) => {
            if (e.target === dataPanel) dataPanel.classList.add('hidden');
        });
        uploadBtn.addEventListener('click', () => fileInput.click());
        saveHtmlBtn.addEventListener('click', saveAsStandaloneHTML);
        downloadTemplateBtns.forEach(btn => {
            btn.addEventListener('click', () => downloadTemplate(btn.dataset.format));
        });

        // Main Accordion Click Logic
        dashboardContent.addEventListener('click', e => {
            const accordionHeader = e.target.closest('.accordion-header');
            
            // Í∞úÏÑ† ÏÇ¨Ìï≠ 1: Î∞îÎ°úÍ∞ÄÍ∏∞ Î©îÎâ¥ ÌÅ¥Î¶≠ Ïãú ÏïÑÏΩîÎîîÏñ∏ ÌÜ†Í∏Ä Î∞©ÏßÄ
            if (e.target.closest('#shortcutContainer')) {
                return;
            }

            if (accordionHeader && accordionHeader.parentElement.classList.contains('accordion-item')) { // Check it's a main accordion
                e.stopPropagation();
                const allAccordionItems = Array.from(dashboardContent.querySelectorAll('.accordion-item'));
                const clickedItem = accordionHeader.parentElement;
                const clickedContent = clickedItem.querySelector('.accordion-content');

                const isFocused = allAccordionItems.some(item => item !== clickedItem && item.style.display === 'none');

                if (isFocused) {
                    // Un-focusing: show all items, remove special classes
                    clickedItem.classList.remove('open', 'is-focused');
                    allAccordionItems.forEach(item => {
                        item.style.display = '';
                        item.classList.remove('is-focused');
                    });
                } else {
                    // Focusing: hide other items, add special classes to clicked item
                    const isOpening = !clickedItem.classList.contains('open');
                    if (isOpening) {
                        allAccordionItems.forEach(item => {
                            if (item === clickedItem) {
                                item.classList.add('open', 'is-focused');
                                item.style.display = '';
                            } else {
                                item.style.display = 'none';
                                item.classList.remove('open', 'is-focused');
                            }
                        });
                    } else {
                        // This case handles closing an item when it's not focused
                        clickedItem.classList.remove('open', 'is-focused');
                    }
                }
                // Ensure sub-accordions inside the just-opened/focused section are rendered correctly (if applicable)
                if (clickedItem.id === 'settlement-accordion' && clickedItem.classList.contains('open')) {
                    setupSettlementAccordions(); // Re-setup listeners if needed
                }
                 // Add listeners for control section toggles if schedule accordion is opened
                if (clickedItem.id === 'projectView' && clickedItem.classList.contains('open')) {
                    setupControlSectionToggles(clickedItem.querySelector('#controlsSection'));
                }
                setTimeout(render, 350); // Delay render slightly
                return;
            }

             // Sub-accordion click logic within Settlement
            const subAccordionHeader = e.target.closest('.sub-accordion-header');
            if (subAccordionHeader) {
                e.stopPropagation();
                const subAccordionItem = subAccordionHeader.parentElement;
                subAccordionItem.classList.toggle('open');
            }


            const card = e.target.closest('[data-filter-type]');
            if (card) {
                handleCardClick(e);
            }

             // Control Section Toggle Logic
            const controlHeader = e.target.closest('.control-section-header');
            if (controlHeader) {
                e.stopPropagation();
                controlHeader.classList.toggle('open');
            }
        });

        // Function to set up control section toggles
        function setupControlSectionToggles(controlsSectionElement) {
            if (!controlsSectionElement) return;
            controlsSectionElement.querySelectorAll('.control-section-header').forEach(header => {
                // Remove existing listener first to avoid duplicates
                header.removeEventListener('click', toggleControlSection);
                header.addEventListener('click', toggleControlSection);
            });
        }

        // Event handler for control section toggles
        function toggleControlSection(e) {
             // Only toggle if the click is directly on the header or the icon, not inputs inside
             if (e.target.closest('select, input, button') && !e.target.closest('.control-section-icon')) {
                 return;
             }
            e.currentTarget.classList.toggle('open');
        }
        
        // Í∞úÏÑ† ÏÇ¨Ìï≠: Ïª®Ìä∏Î°§ Ìå®ÎÑê Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        function closeControlsPanel() {
            controlsPanel.classList.add('translate-x-full');
            controlsPanelOverlay.classList.add('hidden');
        }
        openControlsPanelBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // ÏïÑÏΩîÎîîÏñ∏ ÌÜ†Í∏Ä Î∞©ÏßÄ
            controlsPanel.classList.remove('translate-x-full');
            controlsPanelOverlay.classList.remove('hidden');
            // Ìå®ÎÑê Ïò§Ìîà Ïãú Ïª®Ìä∏Î°§ Ï∞∏Ï°∞ÏôÄ ÌÜ†Í∏Ä, Î∞îÎ°úÍ∞ÄÍ∏∞ Ï¥àÍ∏∞Ìôî Î≥¥Ïû•
            updateControlReferences();
            setupControlSectionToggles(document.getElementById('controlsSection'));
            if (typeof setupPinnableControls === 'function') setupPinnableControls();
            
            // Ï∂îÍ∞Ä: Ï§å Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏßÅÏ†ë ÌôïÏù∏ Î∞è Ïû¨ÏÑ§Ï†ï
            setTimeout(() => {
                const zoomBtn = document.getElementById('zoomBtn');
                if (zoomBtn && !zoomBtn.hasAttribute('data-listener-attached')) {
                    zoomBtn.addEventListener('click', handleZoomButtonClick);
                    zoomBtn.setAttribute('data-listener-attached', 'true');
                }
            }, 100);
        });
        closeControlsPanelBtn.addEventListener('click', closeControlsPanel);
        controlsPanelOverlay.addEventListener('click', closeControlsPanel);

        // Í∞úÏÑ† ÏÇ¨Ìï≠ 1: Î∞îÎ°úÍ∞ÄÍ∏∞ Î©îÎâ¥ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updateShortcuts() {
    const shortcutContainer = document.getElementById('shortcutContainer');
    if (!shortcutContainer) return;
    
    shortcutContainer.innerHTML = '';
    const controlContainer = document.getElementById('controlsPanel');
    if (!controlContainer) return;

    pinnedShortcuts.forEach(id => {
        const originalElement = controlContainer.querySelector(`#${id}`);
        if (!originalElement) return;

        const shortcutWrapper = document.createElement('div');
        shortcutWrapper.className = 'shortcut-item';
        shortcutWrapper.addEventListener('click', e => e.stopPropagation());

        const clonedElement = originalElement.cloneNode(true);
        clonedElement.id = `shortcut-${id}`;

        // ÌòÑÏû¨ Í∞í Î≥µÏÇ¨
        if (clonedElement.tagName === 'SELECT' || clonedElement.tagName === 'INPUT') {
            clonedElement.value = originalElement.value;
        }

        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Í∞ïÌôî
        if (clonedElement.classList.contains('js-zoom-btn')) {
            clonedElement.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                toggleZoomPopover(clonedElement);
            });
        } else if (clonedElement.tagName === 'SELECT') {
            clonedElement.addEventListener('change', (e) => {
                e.stopPropagation();
                originalElement.value = clonedElement.value;
                originalElement.dispatchEvent(new Event('change')); // Ïù¥Î≤§Ìä∏ Ï†ÑÌåå
                render();
            });
        } else if (clonedElement.tagName === 'INPUT') {
            clonedElement.addEventListener('input', (e) => {
                e.stopPropagation();
                originalElement.value = clonedElement.value;
                originalElement.dispatchEvent(new Event('input')); // Ïù¥Î≤§Ìä∏ Ï†ÑÌåå
                render();
            });
        } else if (clonedElement.tagName === 'BUTTON') {
            clonedElement.addEventListener('click', (e) => {
                e.stopPropagation();
                originalElement.click();
            });
        }
        
        shortcutWrapper.appendChild(clonedElement);
        shortcutContainer.appendChild(shortcutWrapper);
    });

    // ÌïÄ Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    controlContainer.querySelectorAll('.pin-shortcut-btn').forEach(btn => {
        const controlId = btn.dataset.controlId;
        if (pinnedShortcuts.has(controlId)) {
            btn.classList.add('pinned');
            btn.innerHTML = '&#128205;'; // ÌïÄ Ïù¥Î™®ÏßÄ
        } else {
            btn.classList.remove('pinned');
            btn.innerHTML = '&#128278;'; // ÎßÅÌÅ¨ Ïù¥Î™®ÏßÄ
        }
        
        // Ìà¥ÌåÅ Ï∂îÍ∞Ä
        btn.title = pinnedShortcuts.has(controlId) ? 
            'Î∞îÎ°úÍ∞ÄÍ∏∞ÏóêÏÑú Ï†úÍ±∞' : 
            'Î∞îÎ°úÍ∞ÄÍ∏∞Î°ú Ï∂îÍ∞Ä';
    });
}
        
        // Í∞úÏÑ†ÏÇ¨Ìï≠ 2: ÏõêÎ≥∏ Ïª®Ìä∏Î°§ÏóêÏÑú Î∞îÎ°úÍ∞ÄÍ∏∞Î°ú ÎèôÍ∏∞ÌôîÌïòÎäî Ìï®Ïàò
        function syncShortcutsFromOriginal() {
            const controlContainer = document.getElementById('controlsPanel');
            
            pinnedShortcuts.forEach(id => {
                const originalElement = controlContainer.querySelector(`#${id}`);
                const shortcutElement = document.querySelector(`#shortcut-${id}`);
                
                if (!originalElement || !shortcutElement) return;
                
                // SELECTÎÇò INPUTÏùò Í≤ΩÏö∞ Í∞í ÎèôÍ∏∞Ìôî
                if ((originalElement.tagName === 'SELECT' || originalElement.tagName === 'INPUT') && 
                    (shortcutElement.tagName === 'SELECT' || shortcutElement.tagName === 'INPUT')) {
                    if (shortcutElement.value !== originalElement.value) {
                        shortcutElement.value = originalElement.value;
                    }
                }
            });
        }
        
        // Í∞úÏÑ† ÏÇ¨Ìï≠ 1: Î∞îÎ°úÍ∞ÄÍ∏∞ ÌïÄ ÏÑ§Ï†ï Ìï®Ïàò
        function setupPinnableControls() {
            const controlContainer = document.getElementById('controlsPanel');
            controlContainer.querySelectorAll('.pinnable-control-wrapper').forEach(wrapper => {
                const control = wrapper.querySelector('select, input, button');
                if (!control) return;

                // If a pin button already exists, ensure it has a dataset.controlId set
                let existingPin = wrapper.querySelector('.pin-shortcut-btn');
                // Ensure control has a stable id for referencing
                if (!control.id) {
                    // Generate a stable-ish id using the control type and a short random suffix
                    control.id = `ctrl-${(control.tagName || 'el').toLowerCase()}-${Math.random().toString(36).slice(2,8)}`;
                }

                if (existingPin) {
                    existingPin.dataset.controlId = control.id;
                } else {
                    const pinBtn = document.createElement('button');
                    pinBtn.className = 'pin-shortcut-btn';
                    pinBtn.title = 'Ìó§ÎçîÏóê Î∞îÎ°úÍ∞ÄÍ∏∞Î°ú Í≥†Ï†ï';
                    pinBtn.dataset.controlId = control.id;
                    pinBtn.setAttribute('type', 'button');
                    pinBtn.innerHTML = '&#128278;';
                    wrapper.appendChild(pinBtn);
                }
            });
            updateShortcuts(); // Initial render of shortcuts
        }

        // **Í∞úÏÑ† ÏÇ¨Ìï≠ 1 ÏàòÏ†ï: Ï§å Î≤ÑÌäº ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨**
        function handleZoomButtonClick(e) {
            e.stopPropagation();
            e.preventDefault();
            toggleZoomPopover(e.currentTarget);
        }

        // **Í∞úÏÑ† ÏÇ¨Ìï≠ 1 ÏàòÏ†ï: Ï§å ÌåùÏò§Î≤Ñ ÌÜ†Í∏Ä Ìï®Ïàò**
        function toggleZoomPopover(buttonEl) {
            if (!zoomPopover) return;
            
            const isHidden = zoomPopover.classList.contains('hidden');

            if (isHidden) {
                // ÌåùÏò§Î≤ÑÎ•º bodyÏóê ÏßÅÏ†ë Ï∂îÍ∞ÄÌïòÏó¨ z-index Î∞è ÏúÑÏπò Î¨∏Ï†úÎ•º Ìï¥Í≤∞
                document.body.appendChild(zoomPopover);
                const rect = buttonEl.getBoundingClientRect();
                zoomPopover.style.position = 'absolute'; // Ensure positioning context
                zoomPopover.style.top = `${rect.bottom + window.scrollY + 5}px`;
                zoomPopover.style.left = `${rect.left + window.scrollX}px`;
                // Keep zIndex moderate to avoid permanently overlaying modals; if a modal opens we'll hide popovers
                zoomPopover.style.zIndex = '60';
                zoomPopover.classList.remove('hidden');
                
                // ÌåùÏò§Î≤Ñ ÎÇ¥Î∂Ä Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ïû¨ÏÑ§Ï†ï
                setupZoomPopoverListeners();
            } else {
                zoomPopover.classList.add('hidden');
                // Return popover to its original parent when hiding
                if (zoomOriginalParent && zoomOriginalParent !== zoomPopover.parentElement) {
                    zoomOriginalParent.appendChild(zoomPopover);
                }
            }
        }

        // Ï§å ÌåùÏò§Î≤Ñ ÎÇ¥Î∂Ä Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
        function setupZoomPopoverListeners() {
            if (!zoomPopover) return;
            
            // Í∏∞Ï°¥ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
            const applyBtn = zoomPopover.querySelector('#zoomApplyBtn');
            const resetBtn = zoomPopover.querySelector('#zoomResetBtn');
            const prevWeekBtn = zoomPopover.querySelector('#zoomPrevWeek');
            const thisWeekBtn = zoomPopover.querySelector('#zoomThisWeek');
            const nextWeekBtn = zoomPopover.querySelector('#zoomNextWeek');
            const threeWeeksTodayBtn = zoomPopover.querySelector('#zoomThreeWeeksToday');
            const threeWeeksSelectedBtn = zoomPopover.querySelector('#zoomThreeWeeksSelected');
            
            // ÏÉà Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
            if (applyBtn) {
                applyBtn.removeEventListener('click', handleZoomApply);
                applyBtn.addEventListener('click', handleZoomApply);
            }
            if (resetBtn) {
                resetBtn.removeEventListener('click', handleZoomReset);
                resetBtn.addEventListener('click', handleZoomReset);
            }
            if (prevWeekBtn) {
                prevWeekBtn.removeEventListener('click', () => applyWeekZoom(-1));
                prevWeekBtn.addEventListener('click', () => applyWeekZoom(-1));
            }
            if (thisWeekBtn) {
                thisWeekBtn.removeEventListener('click', () => applyWeekZoom(0));
                thisWeekBtn.addEventListener('click', () => applyWeekZoom(0));
            }
            if (nextWeekBtn) {
                nextWeekBtn.removeEventListener('click', () => applyWeekZoom(1));
                nextWeekBtn.addEventListener('click', () => applyWeekZoom(1));
            }
            if (threeWeeksTodayBtn) {
                threeWeeksTodayBtn.removeEventListener('click', handleZoomThreeWeeksToday);
                threeWeeksTodayBtn.addEventListener('click', handleZoomThreeWeeksToday);
            }
            if (threeWeeksSelectedBtn) {
                threeWeeksSelectedBtn.removeEventListener('click', handleZoomThreeWeeksSelected);
                threeWeeksSelectedBtn.addEventListener('click', handleZoomThreeWeeksSelected);
            }
        }


        // Function to update control element references
        function updateControlReferences(container = document) {
            // Ïª®Ìä∏Î°§ ÏöîÏÜåÎì§ÏùÄ Ïù¥Ï†ú Î©îÏù∏ document ÎòêÎäî Ïª®Ìä∏Î°§ Ìå®ÎÑê ÎÇ¥Ïóê ÏûàÏùå
            const controlContainer = document.getElementById('controlsPanel');

            taskTypeFilter = controlContainer.querySelector('#taskTypeFilter');
            customFilterContainer = controlContainer.querySelector('#customFilterContainer');
            progressFilter = controlContainer.querySelector('#progressFilter');
            sortBy = controlContainer.querySelector('#sortBy');
            searchInput = controlContainer.querySelector('#searchInput');
            goToTodayBtn = controlContainer.querySelector('#goToTodayBtn');
            expandAllBtn = controlContainer.querySelector('#expandAllBtn');
            collapseAllBtn = controlContainer.querySelector('#collapseAllBtn');
            zoomBtn = controlContainer.querySelector('#zoomBtn');
            zoomPopover = document.getElementById('zoomPopover'); // **ÏàòÏ†ï: Ìï≠ÏÉÅ documentÏóêÏÑú Ï∞æÎèÑÎ°ù**
            zoomStartDate = controlContainer.querySelector('#zoomStartDate');
            zoomEndDate = controlContainer.querySelector('#zoomEndDate');
            zoomApplyBtn = controlContainer.querySelector('#zoomApplyBtn');
            zoomResetBtn = controlContainer.querySelector('#zoomResetBtn');
            zoomPrevWeek = controlContainer.querySelector('#zoomPrevWeek');
            zoomThisWeek = controlContainer.querySelector('#zoomThisWeek');
            zoomNextWeek = controlContainer.querySelector('#zoomNextWeek');
            zoomThreeWeeksToday = controlContainer.querySelector('#zoomThreeWeeksToday');
            zoomThreeWeeksSelected = controlContainer.querySelector('#zoomThreeWeeksSelected');

            // Remember original parent of the popover so it can be restored after being temporarily moved to body
            try {
                zoomOriginalParent = controlContainer.querySelector('#zoomBtn') ? controlContainer.querySelector('#zoomBtn').parentElement : zoomOriginalParent;
            } catch (e) {
                zoomOriginalParent = zoomOriginalParent || null;
            }

            // Re-attach listeners if elements exist
            if (taskTypeFilter) taskTypeFilter.addEventListener('change', render);
            if (progressFilter) progressFilter.addEventListener('change', render);
            if (sortBy) sortBy.addEventListener('change', render);
            if (searchInput) searchInput.addEventListener('input', render);
            if (goToTodayBtn) goToTodayBtn.addEventListener('click', scrollToToday);
            if (expandAllBtn) expandAllBtn.addEventListener('click', () => toggleAllGroups(true));
            if (collapseAllBtn) collapseAllBtn.addEventListener('click', () => toggleAllGroups(false));
            
            // **Í∞úÏÑ† ÏÇ¨Ìï≠ 1 ÏàòÏ†ï: ÏõêÎ≥∏ Ï§å Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà**
            if(zoomBtn) {
                // Remove any existing listeners to prevent duplicates
                zoomBtn.removeEventListener('click', handleZoomButtonClick);
                zoomBtn.addEventListener('click', handleZoomButtonClick);
            }

            // Ï§å ÌåùÏò§Î≤Ñ ÎÇ¥Î∂Ä Î≤ÑÌäºÎì§ÏùÄ ÌåùÏò§Î≤ÑÍ∞Ä Ïó¥Î¶¥ Îïå setupZoomPopoverListenersÏóêÏÑú Ï≤òÎ¶¨

             // Add listeners for custom filters
             if(customFilterContainer) {
                 customFilterContainer.querySelectorAll('select').forEach(select => {
                     select.removeEventListener('change', render); // Prevent duplicates
                     select.addEventListener('change', render);
                 });
             }
             setupControlSectionToggles(controlContainer.querySelector('#controlsSection'));

        }

        // --- Functions for Zoom Popover Handlers ---
        function handleZoomApply() {
            const start = zoomStartDate.value;
            const end = zoomEndDate.value;
            if (start && end) {
                const newMinDate = parseLocalDateString(start);
                const newMaxDate = parseLocalDateString(end);
                if (newMinDate > newMaxDate) {
                    showToast('ÏãúÏûëÏùºÏùÄ Ï¢ÖÎ£åÏùºÎ≥¥Îã§ Îä¶ÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.', 'error');
                    return;
                }
                viewMinDate = newMinDate;
                viewMaxDate = newMaxDate;
                render();
                if(zoomPopover) zoomPopover.classList.add('hidden');
            } else {
                showToast('ÏãúÏûëÏùºÍ≥º Ï¢ÖÎ£åÏùºÏùÑ Î™®Îëê ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.', 'warning');
            }
        }

        function handleZoomReset() {
             if (minDate && maxDate) {
                viewMinDate = new Date(minDate);
                viewMaxDate = new Date(maxDate);
                render();
                if(zoomPopover) zoomPopover.classList.add('hidden');
                if(zoomStartDate) zoomStartDate.value = '';
                if(zoomEndDate) zoomEndDate.value = '';
                
                // Í∞úÏÑ†ÏÇ¨Ìï≠ 3: Í≤ΩÍ≥† ÏÉÅÌÉú Ï†úÍ±∞
                const zoomBtn = document.getElementById('zoomBtn');
                if (zoomBtn) {
                    zoomBtn.classList.remove('bg-yellow-200');
                }
                showToast('ÎÇ†Ïßú ÏÑ§Ï†ïÏù¥ Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.', 'success');
            }
        }

        function handleZoomThreeWeeksToday() {
             const today = new Date();
            today.setHours(0, 0, 0, 0);
            const getStartOfWeek = (date) => {
                const d = new Date(date); const day = d.getDay(); const diff = d.getDate() - day;
                return new Date(d.setDate(diff));
            };
            const startOfCurrentWeek = getStartOfWeek(today);
            const startOfView = new Date(startOfCurrentWeek);
            startOfView.setDate(startOfCurrentWeek.getDate() - 7);
            const endOfView = new Date(startOfView);
            endOfView.setDate(startOfView.getDate() + 20);
            viewMinDate = startOfView; viewMaxDate = endOfView;
            render();
            if(zoomPopover) zoomPopover.classList.add('hidden');
        }

        function handleZoomThreeWeeksSelected() {
             const start = zoomStartDate.value;
            if (!start) {
                showToast('Í∏∞Í∞Ñ ÏÑ§Ï†ïÏóêÏÑú ÏãúÏûëÏùºÏùÑ Î®ºÏ†Ä ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.', 'warning');
                return;
            }
            const startDate = parseLocalDateString(start);
            // ensure local midnight
            if (startDate) startDate.setHours(0,0,0,0);
            const threeWeeksLater = startDate ? new Date(startDate) : null;
            threeWeeksLater.setDate(startDate.getDate() + 21);
            viewMinDate = startDate; viewMaxDate = threeWeeksLater;
            render();
            if(zoomPopover) zoomPopover.classList.add('hidden');
        }

        function applyWeekZoom(weekOffset) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const getStartOfWeek = (date) => {
                const d = new Date(date);
                const day = d.getDay();
                const diff = d.getDate() - day;
                return new Date(d.setDate(diff));
            };
            
            const startOfCurrentWeek = getStartOfWeek(today);
            const targetWeekStart = new Date(startOfCurrentWeek);
            targetWeekStart.setDate(startOfCurrentWeek.getDate() + (weekOffset * 7));
            
            const targetWeekEnd = new Date(targetWeekStart);
            targetWeekEnd.setDate(targetWeekStart.getDate() + 6);
            
            viewMinDate = targetWeekStart;
            viewMaxDate = targetWeekEnd;
            render();
            if(zoomPopover) zoomPopover.classList.add('hidden');
        }
        // --- End Zoom Popover Handlers ---


        fileInput.addEventListener('change', handleFileSelect, false);
        // Event listeners for controls are now attached in updateControlReferences


        function globalClickListener(e) {
            const toggleBtn = e.target.closest('.toggle-col-btn');
            const dateEditor = e.target.closest('.date-editor');
            const progressEditor = e.target.closest('.progress-editor');

            if (!progressPopup.classList.contains('hidden') && !progressPopup.contains(e.target) && !e.target.closest('.progress-editor')) {
                progressPopup.classList.add('hidden');
            }

            // **Í∞úÏÑ† ÏÇ¨Ìï≠ 1 ÏàòÏ†ï: Ï§å ÌåùÏò§Î≤Ñ Ïà®Í∏∞Í∏∞ Î°úÏßÅ**
            const currentZoomPopover = document.getElementById('zoomPopover');
            if (currentZoomPopover && !currentZoomPopover.classList.contains('hidden') && !currentZoomPopover.contains(e.target) && !e.target.closest('.js-zoom-btn')) {
                currentZoomPopover.classList.add('hidden');
            }


            if (toggleBtn) {
                e.stopPropagation();
                handleColumnToggle(toggleBtn);
            }
            else if (dateEditor && !dateEditor.closest('.group-header')) {
                e.stopPropagation();
                handleDateEditClick(dateEditor);
            }
            else if (progressEditor) {
                e.stopPropagation();
                handleProgressEditClick(progressEditor);
            }
        }

        function globalMousedownListener(e) {
            if (e.target.classList.contains('resizer')) handleResizeMousedown(e);
            if (e.target.classList.contains('col-resizer')) handleColResizeMousedown(e);
        }

        // Attach listeners once to the body, they will work even when elements move
        document.body.addEventListener('click', globalClickListener);
        document.body.addEventListener('mousedown', globalMousedownListener);

        // Î™®Îã¨ Îã´Í∏∞ Ìï®Ïàò Ï†ïÏùò
        function closeDetailModal() {
            dataDetailModal.classList.add('hidden');
            // Î™®Îã¨ Ïä§ÌÉÄÏùº Ï¥àÍ∏∞Ìôî
            dataDetailModal.style.display = '';
            dataDetailModal.style.justifyContent = '';
            dataDetailModal.style.alignItems = '';
            
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.position = '';
                modalContent.style.width = '';
                modalContent.style.maxWidth = '';
                modalContent.style.height = '';
                modalContent.style.maxHeight = '';
                modalContent.style.margin = '';
                modalContent.style.transform = '';
                modalContent.style.top = '';
                modalContent.style.left = '';
                modalContent.style.overflow = '';
            }
            
            // Ïä§ÌÅ¨Î°§Î∞î ÏúÑÏπò Ï¥àÍ∏∞Ìôî
            if (dataDetailTableContainer) {
                dataDetailTableContainer.scrollTop = 0;
                dataDetailTableContainer.style.maxHeight = '';
            }
        }

        // Î™®Îã¨ Îã´Í∏∞ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
        closeDataDetailModalBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeDetailModal();
        });

        // ESC ÌÇ§Î°ú Î™®Îã¨ Îã´Í∏∞
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !dataDetailModal.classList.contains('hidden')) {
                closeDetailModal();
            }
        });

        fullscreenBtn.addEventListener('click', openFullscreenModal);
        closeFullscreenModalBtn.addEventListener('click', closeFullscreenModal);

        milestoneBtn.addEventListener('click', () => {
            renderMilestoneModal();
            milestoneModal.classList.remove('hidden');
        });
        closeMilestoneModalBtn.addEventListener('click', () => milestoneModal.classList.add('hidden'));
        // Î∞∞Í≤Ω ÌÅ¥Î¶≠ÏúºÎ°ú Ïù∏Ìïú Îã´Í∏∞ Í∏∞Îä• Ï†úÍ±∞ (milestoneModal click Ïù¥Î≤§Ìä∏ Ï†úÍ±∞)
        addMilestoneForm.addEventListener('submit', handleAddMilestone);
        milestoneList.addEventListener('click', handleMilestoneListClick);

        closeMappingModalBtn.addEventListener('click', () => mappingModal.classList.add('hidden'));
        cancelMappingBtn.addEventListener('click', () => mappingModal.classList.add('hidden'));
        applyMappingBtn.addEventListener('click', applyMapping);
        mappingHeaderRowCount.addEventListener('change', () => openMappingModal(rawImportData));

        closeErrorCorrectionModalBtn.addEventListener('click', () => errorCorrectionModal.classList.add('hidden'));
        discardErrorsBtn.addEventListener('click', () => errorCorrectionModal.classList.add('hidden'));
        retryImportBtn.addEventListener('click', handleRetryImport);

        const holidays = new Set([]);

        function isHoliday(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return holidays.has(`${yyyy}-${mm}-${dd}`);
        }

        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toast-container');
            if (!container) {
                const newContainer = document.createElement('div');
                newContainer.id = 'toast-container';
                document.body.appendChild(newContainer);
            }
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type} flex items-center gap-2`;
            
            // Add appropriate icon based on type
            let icon = '';
            switch(type) {
                case 'success':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>';
                    break;
                case 'error':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/></svg>';
                    break;
                case 'warning':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/></svg>';
                    break;
                default:
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>';
            }
            
            toast.innerHTML = `${icon}<span>${message}</span>`;
            document.getElementById('toast-container').appendChild(toast);

            requestAnimationFrame(() => toast.classList.add('show'));

            const timer = setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);

            // Ìò∏Î≤Ñ Ïãú ÌÉÄÏù¥Î®∏ ÏùºÏãú Ï§ëÏßÄ
            toast.addEventListener('mouseenter', () => clearTimeout(timer));
            toast.addEventListener('mouseleave', () => {
                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => toast.remove());
                }, duration / 2);
            });
        }

        function formatDate(date) {
            if (!(date instanceof Date) || isNaN(date)) return '';
            const year = date.getFullYear().toString().slice(-2);
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Full YYYY-MM-DD local format (avoids timezone-to-UTC issues from toISOString)
        function formatDateYMD(date) {
            if (!(date instanceof Date) || isNaN(date)) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            // ÎÇ†ÏßúÎ•º YYYY-MM-DD ÌòïÏãùÏúºÎ°úÎßå Î∞òÌôò
            return `${year}-${month}-${day}`;
        }

        // Parse a local YYYY-MM-DD (or similar) string into a Date at local midnight.
        // If input is already a Date, returns a copy normalized to local midnight.
        function parseLocalDateString(s) {
            if (!s) return null;
            
            // ÎÇ†ÏßúÍ∞Ä Ïù¥ÎØ∏ Date Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞, Î°úÏª¨ ÏãúÍ∞ÑÏúºÎ°ú Î≥ÄÌôò
            if (s instanceof Date && !isNaN(s)) {
                // ÏãúÍ∞ÑÎåÄ ÏòÅÌñ•ÏùÑ Ï†úÍ±∞ÌïòÍ∏∞ ÏúÑÌï¥ UTC ÎÇ†Ïßú/ÏãúÍ∞Ñ Ïª¥Ìè¨ÎÑåÌä∏Î•º ÏÇ¨Ïö©
                const year = s.getUTCFullYear();
                const month = s.getUTCMonth();
                const date = s.getUTCDate();
                return new Date(Date.UTC(year, month, date));
            }

            // Excel ÏãúÎ¶¨Ïñº ÎÇ†Ïßú Î≤àÌò∏ Ï≤òÎ¶¨ (1900ÎÖÑ Í∏∞Ï§Ä)
            if (typeof s === 'number' && s > 0) {
                try {
                    const msPerDay = 24 * 60 * 60 * 1000;
                    const jan1_1900 = new Date(Date.UTC(1900, 0, 1));
                    const daysSince1900 = s - 1; // ExcelÏùò 1ÏùÄ 1900ÎÖÑ 1Ïõî 1Ïùº
                    const utcDate = new Date(jan1_1900.getTime() + (daysSince1900 * msPerDay));
                    
                    // UTC ÎÇ†Ïßú/ÏãúÍ∞Ñ Ïª¥Ìè¨ÎÑåÌä∏Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÏÉàÎ°úÏö¥ ÎÇ†Ïßú ÏÉùÏÑ±
                    const d = new Date(Date.UTC(
                        utcDate.getUTCFullYear(),
                        utcDate.getUTCMonth(),
                        utcDate.getUTCDate()
                    ));
                    // ÏóÖÎ°úÎìú Î≥¥Ï†ï: Î™®Îì† ÏóÖÎ°úÎìúÎêú ÎÇ†ÏßúÏóê +1Ïùº Ï†ÅÏö©
                    try { d.setUTCDate(d.getUTCDate() + 1); } catch (e) {}
                    return d;
                } catch (e) {
                    console.error('Excel date parsing error:', e);
                    return null;
                }
            }

            // Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨
            try {
                const str = String(s).trim();
                
                // YYYY-MM-DD ÎòêÎäî YYYY/MM/DD ÌòïÏãù Ï≤òÎ¶¨
                const m = str.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
                if (m) {
                    const [_, year, month, day] = m;
                    const y = parseInt(year, 10);
                    const mo = parseInt(month, 10) - 1;
                    const d = parseInt(day, 10);
                    if (!isNaN(y) && !isNaN(mo) && !isNaN(d)) {
                        // UTCÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÎÇ†Ïßú ÏÉùÏÑ±
                        return new Date(Date.UTC(y, mo, d));
                    }
                }

                // Îã§Î•∏ ÌòïÏãùÏùò ÎÇ†Ïßú Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨
                const tempDate = new Date(str);
                if (!isNaN(tempDate)) {
                    // UTC Ïª¥Ìè¨ÎÑåÌä∏Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÏÉàÎ°úÏö¥ ÎÇ†Ïßú ÏÉùÏÑ±
                    return new Date(Date.UTC(
                        tempDate.getUTCFullYear(),
                        tempDate.getUTCMonth(),
                        tempDate.getUTCDate()
                    ));
                }
            } catch (e) {
                console.error('Date string parsing error:', e);
            }
            
            return null;
        }

        function formatCurrency(amount) {
            if (amount === null || amount === undefined || isNaN(amount)) {
                return '0Ïõê';
            }
            return `${parseInt(amount, 10).toLocaleString('ko-KR')}Ïõê`;
        }

        function formatAmountWithUnit(amount) {
            if (!amount || isNaN(amount)) return '';
            if (amount >= 100000000) { // Ïñµ
                return `(${(amount / 100000000).toFixed(1)}Ïñµ)`;
            } else if (amount >= 1000000) { // Î∞±ÎßåÏõê
                return `(${(amount / 1000000).toFixed(1)}Î∞±ÎßåÏõê)`;
            } else if (amount >= 100000) { // Ïã≠ÎßåÏõê
                return `(${(amount / 100000).toFixed(1)}Ïã≠ÎßåÏõê)`;
            }
            return '';
        }

        function getGroupProgressColor(progress) {
            const p = Math.max(0, Math.min(100, progress));
            const gray = { r: 156, g: 163, b: 175 }; // gray-400
            const blue = { r: 59, g: 130, b: 246 };  // blue-500
            const green = { r: 34, g: 197, b: 94 }; // green-500

            let r, g, b;
            if (p < 50) {
                const t = p / 50;
                r = Math.round(gray.r + t * (blue.r - gray.r));
                g = Math.round(gray.g + t * (blue.g - gray.g));
                b = Math.round(gray.b + t * (blue.b - gray.b));
            } else {
                const t = (p - 50) / 50;
                r = Math.round(blue.r + t * (green.r - blue.r));
                g = Math.round(blue.g + t * (green.g - blue.g));
                b = Math.round(blue.b + t * (green.b - blue.b));
            }
            return `rgb(${r}, ${g}, ${b})`;
        }

        function updateAndApplyDateRange() {
            if (projectData.length === 0 && milestones.length === 0) {
                minDate = null; maxDate = null;
                viewMinDate = null; viewMaxDate = null;
                return;
            }

            const allDates = [
                ...projectData.map(p => p.startDate),
                ...projectData.map(p => p.endDate),
                ...milestones.map(m => parseLocalDateString(m.date))
            ].filter(d => d && !isNaN(d));

            if (allDates.length > 0) {
                const oldMinDateStr = minDate ? formatDateYMD(minDate) : null;
                const oldMaxDateStr = maxDate ? formatDateYMD(maxDate) : null;
                const viewMinDateStr = viewMinDate ? formatDateYMD(viewMinDate) : null;
                const viewMaxDateStr = viewMaxDate ? formatDateYMD(viewMaxDate) : null;

                const wasShowingFullRange = (viewMinDateStr === oldMinDateStr) && (viewMaxDateStr === oldMaxDateStr);

                minDate = new Date(Math.min(...allDates));
                maxDate = new Date(Math.max(...allDates));
                minDate.setDate(minDate.getDate() - 7);
                maxDate.setDate(maxDate.getDate() + 14);

                if (wasShowingFullRange || !viewMinDate) {
                     viewMinDate = new Date(minDate);
                     viewMaxDate = new Date(maxDate);
                }
            }
        }

        function toggleAllGroups(expand) {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody.querySelector('#ganttChartWrapper'); // Target chart wrapper
            if (!container) return;
            const groupHeaders = container.querySelectorAll('.group-header');

            groupHeaders.forEach(header => {
                const groupContainer = header.nextElementSibling;
                if (groupContainer && groupContainer.classList.contains('group-item-container')) {
                    const isCollapsed = groupContainer.classList.contains('hidden');

                    if (expand && isCollapsed) header.click();
                    else if (!expand && !isCollapsed) header.click();
                }
            });
        }


        function openFullscreenModal() {
            const ganttViewContent = document.getElementById('ganttViewContent');
            // Í∞úÏÑ† ÏÇ¨Ìï≠: Ïª®Ìä∏Î°§ Ìå®ÎÑê ÎåÄÏã† Î≤îÎ°Ä(Legend)ÏôÄ Í∞ÑÌä∏ Ï∞®Ìä∏Î•º Ïù¥Îèô
            const legendSection = ganttViewContent.querySelector('#legendSection');
            const ganttWrapper = ganttViewContent.querySelector('#ganttChartWrapper');

            // Move Legend and Gantt Chart to the modal
            if (legendSection) fullscreenModalBody.appendChild(legendSection);
            if (ganttWrapper) fullscreenModalBody.appendChild(ganttWrapper);

            // Reset modal position and size
            const overlay = fullscreenModal;
            overlay.style.justifyContent = '';
            overlay.style.alignItems = '';
            const content = overlay.querySelector('.resizable-modal-content');
            content.style.top = '';
            content.style.left = '';
            content.style.margin = '';
            content.style.width = '95vw'; // Reset width
            content.style.height = '90vh'; // Reset height

            fullscreenModal.classList.remove('hidden');
            // Ïª®Ìä∏Î°§ Ï∞∏Ï°∞Îäî Ìï≠ÏÉÅ Î©îÏù∏ Î¨∏ÏÑúÏùò Ìå®ÎÑêÏùÑ Í∞ÄÎ¶¨ÌÇ§ÎØÄÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Ìï† ÌïÑÏöî ÏóÜÏùå
            render(); // Re-render Gantt in its new location
        }

        function closeFullscreenModal() {
             const ganttViewContent = document.getElementById('ganttViewContent');
             
             // Í∞úÏÑ† ÏÇ¨Ìï≠: Î≤îÎ°ÄÏôÄ Í∞ÑÌä∏ Ï∞®Ìä∏Î•º ÏõêÎûò ÏúÑÏπòÎ°ú Î≥µÏõê
             const legendSection = fullscreenModalBody.querySelector('#legendSection');
             const ganttWrapper = fullscreenModalBody.querySelector('#ganttChartWrapper');
             
             if(legendSection) {
                 // ganttViewContentÏùò Ï≤´ Î≤àÏß∏ ÏûêÏãùÏúºÎ°ú Î≤îÎ°ÄÎ•º ÏÇΩÏûÖ
                 ganttViewContent.insertBefore(legendSection, ganttViewContent.firstChild);
             }
             if (ganttWrapper) {
                 // ganttViewContentÏùò ÎßàÏßÄÎßâ ÏûêÏãùÏúºÎ°ú Í∞ÑÌä∏ ÎûòÌçºÎ•º Ï∂îÍ∞Ä
                 ganttViewContent.appendChild(ganttWrapper);
             }

            // [NEW] Ensure the 'ÏùºÏ†ï' accordion is open after closing fullscreen.
            const projectViewAccordion = document.getElementById('projectView');
            if (projectViewAccordion) {
                // Hide all other main accordions to maintain the "focused" view
                document.querySelectorAll('#dashboardContent > .accordion-item').forEach(item => {
                    if (item.id !== 'projectView') {
                        item.style.display = 'none';
                        item.classList.remove('open', 'is-focused');
                    }
                });
                // Ensure the project view accordion is visible and marked as open/focused
                projectViewAccordion.style.display = '';
                projectViewAccordion.classList.add('open', 'is-focused');
            }

             fullscreenModal.classList.add('hidden');
             // Ïª®Ìä∏Î°§ Ï∞∏Ï°∞Îäî Ìï≠ÏÉÅ Î©îÏù∏ Î¨∏ÏÑúÏùò Ìå®ÎÑêÏùÑ Í∞ÄÎ¶¨ÌÇ§ÎØÄÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Ìï† ÌïÑÏöî ÏóÜÏùå
             render(); // Re-render Gantt in its original location
        }


        function autoDetectHeaderRow(sheetData) {
            let bestGuess = 0;
            let maxScore = -1;

            for (let i = 0; i < Math.min(sheetData.length, 10); i++) {
                let stringCells = 0;
                let nonEmptyCells = 0;
                let dateCells = 0;
                const row = sheetData[i];
                if (!row || row.length === 0) continue;

                row.forEach(cell => {
                    if (cell !== null && cell !== undefined && cell !== "") {
                        nonEmptyCells++;
                        if (cell instanceof Date) {
                            dateCells++;
                        }
                        if (typeof cell === 'string' && isNaN(cell)) {
                            stringCells++;
                        }
                    }
                });

                if (nonEmptyCells === 0) continue;

                const stringRatio = stringCells / nonEmptyCells;
                const dateRatio = dateCells / nonEmptyCells;

                const score = stringRatio - (dateRatio * 2);

                if (score > maxScore) {
                    maxScore = score;
                    bestGuess = i;
                }
            }
            return bestGuess + 1;
        }

        function initDefaultPinnedShortcuts() {
            // Í∏∞Î≥∏ Î∞îÎ°úÍ∞ÄÍ∏∞ ÏàúÏÑú ÏÑ§Ï†ï
            const defaultPinnedControls = [
                'goToTodayBtn',          // Ïò§Îäò
                'customer-filter',        // Í≥†Í∞ùÏÇ¨
                'contractor-filter',      // ÏãúÍ≥µÏÇ¨
                'expandAllBtn',          // ÌéºÏπòÍ∏∞
                'collapseAllBtn',        // Ï†ëÍ∏∞
                'sortBy',                // Ï†ïÎ†¨
                'progressFilter',         // ÏßÑÏ≤ôÎ•†
                'taskTypeFilter',        // Ïú†Ìòï
                'zoomBtn'                // ÎÇ†Ïßú ÏÑ§Ï†ï
            ];
            
            // Í∏∞Ï°¥ ÌïÄ Ï¥àÍ∏∞Ìôî
            pinnedShortcuts.clear();
            
            // ÏÉàÎ°úÏö¥ ÌïÄ ÏÑ§Ï†ï
            defaultPinnedControls.forEach(id => {
                pinnedShortcuts.add(id);
            });
            
            // Î∞îÎ°úÍ∞ÄÍ∏∞ Î©îÎâ¥ ÏóÖÎç∞Ïù¥Ìä∏
            if (typeof updateShortcuts === 'function') {
                updateShortcuts();
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                    const sheetNames = workbook.SheetNames || [];

                    // Reset any pending milestone sheet
                    pendingMilestoneSheetData = null;

                    // Try to find a sheet that looks like a milestone sheet
                    const milestoneSheetIndex = sheetNames.findIndex(n => /milestone|ÎßàÏùºÏä§ÌÜ§/i.test(n));

                    // Parse the primary (first) sheet as project data as before
                    const primarySheetName = sheetNames[0];
                    const primaryWorksheet = workbook.Sheets[primarySheetName];
                    const sheetData = XLSX.utils.sheet_to_json(primaryWorksheet, { header: 1, defval: "" });

                    // If a milestone sheet exists and is not the first sheet, parse and store it for later
                    if (milestoneSheetIndex > -1 && milestoneSheetIndex !== 0) {
                        try {
                            const msWorksheet = workbook.Sheets[sheetNames[milestoneSheetIndex]];
                            const msData = XLSX.utils.sheet_to_json(msWorksheet, { header: 1, defval: "" });
                            if (msData && msData.length > 0) {
                                pendingMilestoneSheetData = msData;
                                showToast('ÎßàÏùºÏä§ÌÜ§ ÏãúÌä∏Í∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§. ÌîÑÎ°úÏ†ùÌä∏ Îß§Ìïë ÏôÑÎ£å ÌõÑ ÎßàÏùºÏä§ÌÜ§ Îß§ÌïëÏùÑ ÏãúÏûëÌï©ÎãàÎã§.', 'info');
                            }
                        } catch (errMs) {
                            console.warn('milestone sheet parse failed', errMs);
                        }
                    }

                    if (sheetData.length > 0) {
                        const detectedHeaderRow = autoDetectHeaderRow(sheetData);
                        headerRowCountInput.value = detectedHeaderRow;
                        // Ensure mapping modal will use project fields by default
                        mappingTarget = 'projects';
                        CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
                        openMappingModal(sheetData);
                    } else {
                        showToast("Îπà ÌååÏùºÏù¥Í±∞ÎÇò ÏùΩÏùÑ Ïàò ÏóÜÎäî ÌòïÏãùÏûÖÎãàÎã§.", 'error');
                    }
                } catch (error) {
                    console.error("Error processing file:", error);
                    showToast("ÌååÏùº Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.", 'error');
                }
            };
            reader.onerror = () => {
                 showToast("ÌååÏùºÏùÑ ÏùΩÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.", 'error');
            };
            reader.readAsArrayBuffer(file);
            event.target.value = '';
        }

        const MAPPING_FIELDS = [
            { key: 'id', name: 'ID', aliases: ['id', 'ÏïÑÏù¥Îîî', 'Í≥†Ïú†Î≤àÌò∏', 'Ïú†ÏßÄÍ¥ÄÎ¶¨Î≤àÌò∏'], required: false },
            { key: 'name', name: 'Î™ÖÏπ≠', aliases: ['name', 'Î™ÖÏπ≠', 'ÌîÑÎ°úÏ†ùÌä∏Î™Ö', 'ÏûëÏóÖÎ™Ö', 'Í≥µÏÇ¨Î™Ö', 'Ïú†ÏßÄÍ¥ÄÎ¶¨Î™Ö'], required: true },
            { key: 'taskType', name: 'ÏûëÏóÖ Ïú†Ìòï', aliases: ['tasktype', 'task type', 'ÏûëÏóÖÏú†Ìòï', 'ÏûëÏóÖ Ïú†Ìòï', 'Í≥µÏ¢Ö'], required: false },
            { key: 'status', name: 'ÏÉÅÌÉú', aliases: ['status', 'ÏÉÅÌÉú', 'Í≥µÏÇ¨ÏßÑÌñâÏÉÅÌÉú'], required: false },
            { key: 'startDate', name: 'ÏãúÏûëÏùº', aliases: ['startdate', 'start date', 'ÏãúÏûëÏùº', 'Ï∞©ÏàòÏùº', 'ÏãúÏûë'], required: true },
            { key: 'endDate', name: 'Ï¢ÖÎ£åÏùº', aliases: ['enddate', 'end date', 'Ï¢ÖÎ£åÏùº', 'ÏôÑÎ£åÏùº', 'Ï¢ÖÎ£å'], required: true },
            { key: 'poAmount', name: 'Ï†ïÏÇ∞', aliases: ['poamount', 'po amount', 'Ï†ïÏÇ∞', 'Í∏àÏï°', 'Í≥ÑÏïΩÍ∏à', 'poÍ∏àÏï°'], required: false }
        , { key: 'progress', name: 'ÏßÑÌñâÎ•†', aliases: ['progress', 'ÏßÑÌñâÎ•†', 'ÏßÑÏ≤ôÎ•†'], required: false }
];

        // Current mapping fields in use by the mapping modal. Default to project mapping fields.
        let CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
        // Mapping target: 'projects' or 'milestones'
        let mappingTarget = 'projects';
        // Hold pending milestone sheet data if workbook contains a separate milestone sheet
        let pendingMilestoneSheetData = null;

        const MILESTONE_MAPPING_FIELDS = [
            { key: 'id', name: 'ID', aliases: ['id', 'ÏïÑÏù¥Îîî', 'Í≥†Ïú†Î≤àÌò∏'], required: false },
            { key: 'ÎßàÏùºÏä§ÌÜ§', name: 'ÎßàÏùºÏä§ÌÜ§', aliases: ['milestone', 'ÎßàÏùºÏä§ÌÜ§', 'name', 'Î™ÖÏπ≠'], required: true },
            { key: 'ÎÇ†Ïßú', name: 'ÎÇ†Ïßú', aliases: ['date', 'ÎÇ†Ïßú', 'ÏùºÏûê'], required: true }
        ];

        function openMappingModal(sheetData) {
            rawImportData = sheetData;
            mappingHeaderRowCount.value = headerRowCountInput.value;
            const headerRowIndex = parseInt(mappingHeaderRowCount.value, 10) - 1;

            if (headerRowIndex < 0 || headerRowIndex >= sheetData.length) {
                showToast("Îç∞Ïù¥ÌÑ∞ ÏãúÏûë ÌñâÏù¥ ÌååÏùºÏùò Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ©ÎãàÎã§.", 'error');
                return;
            }

            const primaryHeaders = sheetData[headerRowIndex] || [];
            const secondaryHeaders = sheetData[headerRowIndex + 1] || [];

            const combinedHeaders = primaryHeaders.map((h, i) => {
                const primary = h ? String(h).trim() : '';
                const secondary = (secondaryHeaders[i]) ? String(secondaryHeaders[i]).trim() : '';
                if (primary && !secondary) return primary;
                if (!primary && secondary) return secondary;
                return (primary + ' ' + secondary).trim();
            });

            const previewData = sheetData.slice(headerRowIndex + 2, headerRowIndex + 12);

            let tableHTML = '<table class="w-full text-left border-collapse"><thead class="bg-gray-100"><tr>';

            combinedHeaders.forEach(headerText => {
                tableHTML += `<th class="border"><div class="flex flex-col gap-1 p-2">`;
                tableHTML += `<select class="p-1 border rounded-md bg-white mapping-select">`;
                tableHTML += `<option value="ignore">Î¨¥Ïãú</option>`;

                CURRENT_MAPPING_FIELDS.forEach(field => {
                    tableHTML += `<option value="${field.key}">${field.name}${field.required ? ' (ÌïÑÏàò)' : ''}</option>`;
                });

                // ÌîÑÎ°úÏ†ùÌä∏ Îß§ÌïëÏùº ÎïåÎßå ÏÉà ÏÜçÏÑ± Ï∂îÍ∞Ä ÏòµÏÖò ÌëúÏãú
                if (mappingTarget === 'projects') {
                    tableHTML += `<optgroup label="---">`;
                    tableHTML += `<option value="--add-new--">ÏÉà ÏÜçÏÑ±ÏúºÎ°ú Ï∂îÍ∞Ä...</option>`;
                    tableHTML += `</optgroup>`;
                }
                tableHTML += `</select>`;

                tableHTML += `<input type="text" class="new-property-input hidden mt-1 p-1 border rounded-md w-full" placeholder="ÏÉà ÏÜçÏÑ± Ïù¥Î¶Ñ">`;

                tableHTML += `<span class="font-normal text-gray-600 truncate pt-1" title="${headerText}">${headerText}</span>`;
                tableHTML += `</div></th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            previewData.forEach(row => {
                tableHTML += '<tr class="border-b">';
                combinedHeaders.forEach((_, colIndex) => {
                    let cellData = row[colIndex] || '';
                    if (cellData instanceof Date) {
                        cellData = formatDateYMD(cellData);
                    }
                    tableHTML += `<td class="p-2 border truncate" title="${cellData}">${cellData}</td>`;
                });
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table>';

            mappingPreviewContainer.innerHTML = tableHTML;

            // Now, set initial values and add listeners
            const allSelects = mappingPreviewContainer.querySelectorAll('.mapping-select');
            const allInputs = mappingPreviewContainer.querySelectorAll('.new-property-input');

            combinedHeaders.forEach((headerText, index) => {
                const select = allSelects[index];
                const input = allInputs[index];

                // Best match logic
                let bestMatch = 'ignore';
                let highestScore = 0.1; // Set a small threshold to avoid weak matches
                CURRENT_MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    field.aliases.forEach(alias => {
                        const lowerHeaderText = headerText.toLowerCase().trim();
                        const lowerAlias = alias.toLowerCase().trim();
                        if (headerText && lowerHeaderText.includes(lowerAlias)) {
                            let score = lowerAlias.length / lowerHeaderText.length;
                            if (lowerHeaderText === lowerAlias) {
                               score = 1.1;
                            }
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) {
                        highestScore = currentScore;
                        bestMatch = field.key;
                    }
                });

                // If no good standard match, suggest as new property
                if (bestMatch === 'ignore' && headerText) {
                     bestMatch = `custom:${headerText}`;
                }

                // Apply best match to UI
                if (bestMatch.startsWith('custom:')) {
                    select.value = '--add-new--';
                    input.classList.remove('hidden');
                    input.value = bestMatch.substring(7);
                } else {
                    select.value = bestMatch;
                }

                // Add event listener
                select.addEventListener('change', (e) => {
                    if (e.target.value === '--add-new--') {
                        input.classList.remove('hidden');
                        if (!input.value) {
                            input.value = headerText; // Pre-fill if empty
                        }
                    } else {
                        input.classList.add('hidden');
                    }
                });
            });


            dataPanel.classList.add('hidden');
            mappingModal.classList.remove('hidden');
        }

        function applyMapping() {
            const headerRowIndex = parseInt(mappingHeaderRowCount.value, 10) - 1;
            const mappingSelectors = mappingPreviewContainer.querySelectorAll('.mapping-select');
            const mappingInputs = mappingPreviewContainer.querySelectorAll('.new-property-input');

            // Branch based on mapping target (projects or milestones)
            if (mappingTarget === 'projects') {
                const mapping = {
                    core: {},
                    custom: []
                };
                MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

                let hasError = false;
                const usedFields = new Set();

                mappingSelectors.forEach((sel, index) => {
                    const value = sel.value;
                    if (value === 'ignore') return;

                    if (value === '--add-new--') {
                        const input = mappingInputs[index];
                        const fieldName = input.value.trim();
                        if (!fieldName) {
                            showToast(`ÏÉà ÏÜçÏÑ±Ïùò Ïù¥Î¶ÑÏù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§ (Ïó¥ ${index + 1}).`, 'error');
                            hasError = true; return;
                        }
                        if (usedFields.has(fieldName)) { showToast(`ÏÜçÏÑ± Ïù¥Î¶Ñ '${fieldName}'Ïù¥(Í∞Ä) Ï§ëÎ≥µÎê©ÎãàÎã§.`, 'error'); hasError = true; return; }
                        mapping.custom.push({ colIndex: index, fieldName: fieldName });
                        usedFields.add(fieldName);
                    } else {
                        if (usedFields.has(value)) { showToast(`ÌïÑÎìú '${MAPPING_FIELDS.find(f=>f.key === value).name}'Ïù¥(Í∞Ä) Ï§ëÎ≥µÎê©ÎãàÎã§.`, 'error'); hasError = true; return; }
                        mapping.core[value] = index;
                        usedFields.add(value);
                    }
                });

                if (hasError) return;

                const missingFields = MAPPING_FIELDS.filter(f => f.required && mapping.core[f.key] === -1);
                if (missingFields.length > 0) {
                    const missingFieldNames = missingFields.map(f => f.name).join(', ');
                    showToast(`ÌïÑÏàò ÌïÑÎìúÏù∏ '${missingFieldNames}'ÏùÑ(Î•º) Îß§ÌïëÌï¥Ïïº Ìï©ÎãàÎã§.`, 'error');
                    return;
                }

                importMapping = mapping;
                processMappedData(rawImportData, mapping, headerRowIndex + 2);

                // If a milestone sheet was detected earlier, open mapping for it next
                if (pendingMilestoneSheetData) {
                    // Prepare for milestone mapping
                    mappingTarget = 'milestones';
                    CURRENT_MAPPING_FIELDS = MILESTONE_MAPPING_FIELDS;
                    // Use the same detected header row value
                    mappingHeaderRowCount.value = headerRowCountInput.value;
                    // Open milestone mapping after a small delay to let UI settle
                    const msData = pendingMilestoneSheetData;
                    pendingMilestoneSheetData = null; // clear pending
                    setTimeout(() => openMappingModal(msData), 600);
                }
                return;
            }

                // Milestone mapping path
            if (mappingTarget === 'milestones') {
                const mapping = {};
                MILESTONE_MAPPING_FIELDS.forEach(f => mapping[f.key] = -1);

                let hasError = false;
                const usedFields = new Set();

                mappingSelectors.forEach((sel, index) => {
                    const value = sel.value;
                    if (value === 'ignore') return;
                    if (value === '--add-new--') {
                        showToast('ÎßàÏùºÏä§ÌÜ§ Îç∞Ïù¥ÌÑ∞Îäî Í∏∞Î≥∏ ÌïÑÎìúÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.', 'info');
                        hasError = true; 
                        return;
                    }
                    if (usedFields.has(value)) { 
                        showToast('Ï§ëÎ≥µÎêú Îß§ÌïëÏù¥ ÏûàÏäµÎãàÎã§.', 'error'); 
                        hasError = true; 
                        return; 
                    }
                    mapping[value] = index;
                    usedFields.add(value);
                });

                if (hasError) {
                    mappingTarget = 'projects';  // ÏóêÎü¨ Î∞úÏÉùÏãú Îß§Ìïë ÌÉÄÍ≤ü Ï¥àÍ∏∞Ìôî
                    return;
                }

                const missing = MILESTONE_MAPPING_FIELDS.filter(f => f.required && mapping[f.key] === -1);
                if (missing.length > 0) {
                    const missingNames = missing.map(f => f.name).join(', ');
                    showToast(`ÌïÑÏàò ÌïÑÎìúÎ•º Î™®Îëê Îß§ÌïëÌïòÏÑ∏Ïöî: ${missingNames}`, 'error');
                    mappingTarget = 'projects';  // ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ Ïãú Îß§Ìïë ÌÉÄÍ≤ü Ï¥àÍ∏∞Ìôî
                    return;
                }                try {
                    const processedMilestones = [];
                    for (let i = headerRowIndex + 2; i < rawImportData.length; i++) {
                        const row = rawImportData[i];
                        if (!row || row.every(cell => !cell)) continue;

                        const name = row[mapping['ÎßàÏùºÏä§ÌÜ§']];
                        let dateValue = row[mapping['ÎÇ†Ïßú']];

                        if (!name || !dateValue) continue;

                        // ÎÇ†Ïßú Ï≤òÎ¶¨
                        let finalDate = null;
                        
                    // Îß§Ìïë ÏÑ±Í≥µ ÌõÑ Î™®Îã¨ Îã´Í∏∞
                    mappingModal.classList.add('hidden');
                        if (typeof dateValue === 'number' && dateValue > 0) {
                            // Excel ÏãúÎ¶¨Ïñº ÎÇ†Ïßú Ï≤òÎ¶¨ (1900ÎÖÑ Í∏∞Ï§Ä)
                            const excelEpoch = new Date(Date.UTC(1899, 11, 30));
                            const utcDate = new Date(excelEpoch.getTime() + (Math.floor(dateValue) * 24 * 60 * 60 * 1000));
                            // UTC ÎÇ†ÏßúÎ•º Î°úÏª¨ ÏãúÍ∞ÑÏúºÎ°ú Î≥ÄÌôò
                            finalDate = new Date(Date.UTC(
                                utcDate.getUTCFullYear(),
                                utcDate.getUTCMonth(),
                                utcDate.getUTCDate()
                            ));
                        } else if (dateValue instanceof Date && !isNaN(dateValue)) {
                            // Date Í∞ùÏ≤¥Î•º UTC Í∏∞Ï§ÄÏúºÎ°ú ÏÉàÎ°ú ÏÉùÏÑ±ÌïòÏó¨ ÌÉÄÏûÑÏ°¥ Ïù¥Ïäà Ìï¥Í≤∞
                            finalDate = new Date(Date.UTC(
                                dateValue.getFullYear(),
                                dateValue.getMonth(),
                                dateValue.getDate()
                            ));
                        } else if (typeof dateValue === 'string') {
                            const match = dateValue.trim().match(/^(\d{4})[-\/]?(\d{2})[-\/]?(\d{2})$/);
                            if (match) {
                                const [_, year, month, day] = match;
                                // Î¨∏ÏûêÏó¥ ÎÇ†ÏßúÎ•º UTC Í∏∞Ï§ÄÏúºÎ°ú ÏÉùÏÑ±
                                finalDate = new Date(Date.UTC(
                                    parseInt(year),
                                    parseInt(month) - 1,
                                    parseInt(day)
                                ));
                            }
                        }

                        if (finalDate && !isNaN(finalDate)) {
                            // ÏóÖÎ°úÎìúÎêú ÎÇ†ÏßúÎäî +1Ïùº Î≥¥Ï†ï Ï†ÅÏö©
                            try { finalDate.setUTCDate(finalDate.getUTCDate() + 1); } catch (e) {}
                            // UTC ÎÇ†ÏßúÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Ìè¨Îß∑ÌåÖ
                            const formattedDate = finalDate.getUTCFullYear() + '-' +
                                String(finalDate.getUTCMonth() + 1).padStart(2, '0') + '-' +
                                String(finalDate.getUTCDate()).padStart(2, '0');

                            processedMilestones.push({
                                name: name,
                                date: formattedDate
                            });
                        }
                    }

                    if (processedMilestones.length > 0) {
                        milestones = processedMilestones;
                        renderMilestoneModal();
                        render();
                        updateAndApplyDateRange();
                        showToast(`${processedMilestones.length}Í∞úÏùò ÎßàÏùºÏä§ÌÜ§Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î°úÎìúÎêòÏóàÏäµÎãàÎã§.`, 'success');
                        
                        // ÎßàÏùºÏä§ÌÜ§ Îß§Ìïë ÏÑ±Í≥µ Ïãú Î™®Îã¨ Îã´Í∏∞
                        mappingModal.classList.add('hidden');
                    } else {
                        showToast('Ï≤òÎ¶¨Ìï† Ïàò ÏûàÎäî ÎßàÏùºÏä§ÌÜ§ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.', 'warning');
                    }
                    
                    // reset mapping target and fields
                    mappingTarget = 'projects';
                    CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
                } catch (e) {
                    console.error('Error processing milestone data:', e);
                    showToast('ÎßàÏùºÏä§ÌÜ§ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', 'error');
                }
                return;
            }
        }

        function validateAndParseRow(row, mapping) {
            const errors = [];
            const parsed = {};

            // 1. ÌïÑÏàò Í∞í ÌôïÏù∏ Î∞è Îç∞Ïù¥ÌÑ∞ ÌååÏã±
            MAPPING_FIELDS.forEach(field => {
                if (field.required) {
                    const val = row[mapping.core[field.key]];
                    if (val === null || val === undefined || String(val).trim() === '') {
                        errors.push(`${field.name}ÏùÄ(Îäî) ÌïÑÏàòÍ∞íÏûÖÎãàÎã§.`);
                    }
                }
            });

            // [Í∞úÏÑ† ÏÇ¨Ìï≠ 1] ÎÇ†Ïßú ÌååÏã± Ïãú ÌëúÏ§Ä ÏãúÍ∞ÑÎåÄ(Timezone) Î¨∏Ï†ú Ìï¥Í≤∞
            // ÏóëÏÖÄÏóêÏÑú ÏùΩÏñ¥Ïò® Date Í∞ùÏ≤¥Îäî UTC ÏûêÏ†ïÏúºÎ°ú Ìï¥ÏÑùÎê† Ïàò ÏûàÏñ¥, ÌòÑÏßÄ ÏãúÍ∞ÑÏúºÎ°ú Î≥ÄÌôò Ïãú ÌïòÎ£® Ï†Ñ ÎÇ†ÏßúÍ∞Ä ÎêòÎäî Î¨∏Ï†úÎ•º Î∞©ÏßÄÌï©ÎãàÎã§.
            // UTC ÏãúÍ∞ÑÏúºÎ°ú Í∞ÑÏ£ºÌïòÍ≥† ÎÇ†ÏßúÏùò ÎÖÑ, Ïõî, ÏùºÏùÑ Ï∂îÏ∂úÌïòÏó¨ ÏÉàÎ°úÏö¥ ÌòÑÏßÄ ÏãúÍ∞Ñ Í∏∞Ï§Ä Date Í∞ùÏ≤¥Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
            const fixTimezone = (date) => {
                return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            };
            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 2. Îç∞Ïù¥ÌÑ∞ ÌååÏã± Î∞è ÌÉÄÏûÖ Í≤ÄÏ¶ù
            // ÎÇ†Ïßú
            const startDateVal = row[mapping.core.startDate];
            const endDateVal = row[mapping.core.endDate];
            const parseDate = (val) => {
                // ÎÇ†Ïßú ÌååÏã±ÏùÑ Í∞úÏÑ†ÌïòÏó¨ Ìï≠ÏÉÅ Î°úÏª¨ ÏãúÍ∞Ñ Í∏∞Ï§ÄÏúºÎ°ú Ï≤òÎ¶¨ÌïòÍ≥† ÏãúÍ∞ÑÎåÄ Î¨∏Ï†ú Ìï¥Í≤∞
                try {
                    let d = null;
                    if (val instanceof Date && !isNaN(val)) {
                        // Date Í∞ùÏ≤¥Ïùò Í≤ΩÏö∞ Î°úÏª¨ ÏãúÍ∞Ñ Ïª¥Ìè¨ÎÑåÌä∏Î°ú ÏÉàÎ°úÏö¥ ÎÇ†Ïßú ÏÉùÏÑ±
                        const localYear = val.getFullYear();
                        const localMonth = val.getMonth();
                        const localDate = val.getDate();
                        d = new Date(localYear, localMonth, localDate);
                        // KST ÌôòÍ≤ΩÏóêÏÑúÏùò ÎÇ†Ïßú Ïò§ÌîÑÏÖã Î≥¥Ï†ï
                        d.setDate(d.getDate() + 1);
                    } else if (typeof val === 'number' && val > 25569) {
                        // Excel ÏùºÎ†® Î≤àÌò∏Î•º UTCÎ°ú Î≥ÄÌôò ÌõÑ Î°úÏª¨ ÎÇ†ÏßúÎ°ú Î≥ÄÌôò
                        const utcDate = new Date(Math.round((val - 25569) * 86400 * 1000));
                        const localYear = utcDate.getUTCFullYear();
                        const localMonth = utcDate.getUTCMonth();
                        const localDate = utcDate.getUTCDate();
                        d = new Date(localYear, localMonth, localDate);
                        // KST ÌôòÍ≤ΩÏóêÏÑúÏùò ÎÇ†Ïßú Ïò§ÌîÑÏÖã Î≥¥Ï†ï
                        d.setDate(d.getDate() + 1);
                    } else {
                        const s = String(val || '').trim();
                        if (s === '') return null;
                        // YYYY-MM-DD ÎòêÎäî YYYY/MM/DD ÌòïÏãù Ïö∞ÏÑ† ÌôïÏù∏
                        const m = s.match(/^(\d{4})[-\/]?(\d{1,2})[-\/]?(\d{1,2})/);
                        if (m) {
                            const y = parseInt(m[1], 10);
                            const mo = parseInt(m[2], 10) - 1;
                            const day = parseInt(m[3], 10);
                            d = new Date(y, mo, day);
                            // KST ÌôòÍ≤ΩÏóêÏÑúÏùò ÎÇ†Ïßú Ïò§ÌîÑÏÖã Î≥¥Ï†ï
                            d.setDate(d.getDate() + 1);
                        } else {
                            // Îã§Î•∏ ÌòïÏãùÏùò Í≤ΩÏö∞ Î°úÏª¨ ÏãúÍ∞ÑÏúºÎ°ú ÌååÏã±
                            const tempDate = new Date(s);
                            if (!isNaN(tempDate)) {
                                d = new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());
                                // KST ÌôòÍ≤ΩÏóêÏÑúÏùò ÎÇ†Ïßú Ïò§ÌîÑÏÖã Î≥¥Ï†ï
                                d.setDate(d.getDate() + 1);
                            }
                        }
                    }

                    if (!d || isNaN(d)) return null;
                    // Return local midnight constructed from the detected year/month/day
                    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
                } catch (e) {
                    return null;
                }
            };
            parsed.startDate = parseDate(startDateVal);
            parsed.endDate = parseDate(endDateVal);
            if (!parsed.startDate) errors.push('ÏãúÏûëÏùºÏùò ÎÇ†Ïßú ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');
            if (!parsed.endDate) errors.push('Ï¢ÖÎ£åÏùºÏùò ÎÇ†Ïßú ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');

            // ÎÇ†Ïßú Î≥¥Ï†ï Î∂àÌïÑÏöî - Î™®Îì† ÎÇ†ÏßúÎäî Î°úÏª¨ ÏãúÍ∞ÑÎåÄÏóêÏÑú Ï≤òÎ¶¨Îê®

            // Í∏àÏï°
            if (mapping.core.poAmount > -1) {
                const poStr = String(row[mapping.core.poAmount] || '0').replace(/,/g, '');
                parsed.poAmount = parseInt(poStr, 10);
                if (isNaN(parsed.poAmount)) errors.push('Ï†ïÏÇ∞ Í∏àÏï°Ïù¥ Ïú†Ìö®Ìïú Ïà´ÏûêÍ∞Ä ÏïÑÎãôÎãàÎã§.');
            } else {
                parsed.poAmount = 0;
            }

            // ÏßÑÌñâÎ•†
            parsed.progress = 0; // Default to 0
            if (mapping.core.progress > -1) {
                const progressStr = String(row[mapping.core.progress] || '0').replace(/%/g, '').trim();
                parsed.progress = parseInt(progressStr, 10);
                if (isNaN(parsed.progress) || parsed.progress < 0 || parsed.progress > 100) {
                    errors.push('ÏßÑÌñâÎ•†ÏùÄ 0Í≥º 100 ÏÇ¨Ïù¥Ïùò Ïà´ÏûêÏó¨Ïïº Ìï©ÎãàÎã§.');
                }
            }

            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 3. ÎÖºÎ¶¨Ï†Å Ïò§Î•ò Í≤ÄÏ¶ù
            if (parsed.startDate > parsed.endDate) {
                errors.push('Ï¢ÖÎ£åÏùºÏùÄ ÏãúÏûëÏùºÎ≥¥Îã§ Îπ†Î•º Ïàò ÏóÜÏäµÎãàÎã§.');
            }

            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 4. ÏµúÏ¢Ö Îç∞Ïù¥ÌÑ∞ Í∞ùÏ≤¥ ÏÉùÏÑ±
            const customFields = {};
            // Store custom fields using sanitized keys to avoid problems with special characters.
            mapping.custom.forEach(cf => {
                const originalName = cf.fieldName || '';
                const safeKey = sanitizeKey(originalName);
                // Preserve display name mapping for UI
                if (safeKey) customFieldDisplayNames[safeKey] = originalName;
                customFields[safeKey] = row[cf.colIndex] || '';
            });

            const toYMD = (d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            return {
                success: true,
                data: {
                    id: mapping.core.id > -1 && row[mapping.core.id] ? String(row[mapping.core.id]) : `gen-${Math.random().toString(36).substr(2, 9)}`,
                    name: String(row[mapping.core.name]),
                    taskType: mapping.core.taskType > -1 ? String(row[mapping.core.taskType] || 'ÎØ∏Î∂ÑÎ•ò') : 'ÎØ∏Î∂ÑÎ•ò',
                    status: mapping.core.status > -1 ? String(row[mapping.core.status]) : 'Ï∞©Í≥µÏ†Ñ',
                    startDateStr: parsed.startDate ? toYMD(parsed.startDate) : '',
                    endDateStr: parsed.endDate ? toYMD(parsed.endDate) : '',
                    startDate: parsed.startDate,
                    endDate: parsed.endDate,
                    poAmount: parsed.poAmount,
                    progress: parsed.progress,
                    customFields: customFields
                }
            };
        }

        function processMappedData(rawData, mapping, dataStartIndex) {
            const dataRows = rawData.slice(dataStartIndex);
            const successfulData = [];
            const failedData = [];

            dataRows.forEach(row => {
                // Îπà ÌñâÏùÄ Í±¥ÎÑàÎõ∞Í∏∞
                if (row.every(cell => cell === null || cell === undefined || String(cell).trim() === '')) {
                    return;
                }
                const result = validateAndParseRow(row, mapping);
                if (result.success) {
                    successfulData.push(result.data);
                } else {
                    failedData.push(result);
                }
            });

            projectData.push(...successfulData);
            
            // [FIX] Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÌõÑ ÌïÑÌÑ∞Í∞Ä Î™®Îëê ÏÉùÏÑ±Îêú Îã§Ïùå Í∏∞Î≥∏ Î∞îÎ°úÍ∞ÄÍ∏∞Î•º ÏÑ§Ï†ïÌï©ÎãàÎã§.
            initDefaultPinnedShortcuts();
            failedImportRows = failedData;

            updateAndApplyDateRange();
            populateFilters();
            render();

            mappingModal.classList.add('hidden');

            // Í≤∞Í≥º ÌîºÎìúÎ∞±
            let summaryMessage = `${successfulData.length}Í∞ú Ìï≠Î™©ÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§.`;
            if (failedData.length > 0) {
                summaryMessage += ` ${failedData.length}Í∞ú Ìï≠Î™©ÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.`;
                showToast(summaryMessage, 'warning', 5000);
                openErrorCorrectionModal(failedData, mapping);
            } else {
                showToast(summaryMessage, 'success');
            }

            if (projectData.length > 0 || milestones.length > 0) {
                saveHtmlBtn.disabled = false;
                saveMessage.classList.remove('hidden');
            }
        }

        function openErrorCorrectionModal(failedRows, mapping) {
            errorCorrectionInfo.innerHTML = `Ï¥ù <strong>${failedRows.length}Í∞ú</strong>Ïùò Ìï≠Î™©ÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§. Ïò§Î•ò ÎÇ¥Ïö©ÏùÄ Îπ®Í∞ÑÏÉâÏúºÎ°ú ÌëúÏãúÎê©ÎãàÎã§. ÏïÑÎûò ÌëúÏóêÏÑú ÏßÅÏ†ë Í∞íÏùÑ ÏàòÏ†ïÌïú ÌõÑ 'ÏàòÏ†ïÎêú Ìï≠Î™© Í∞ÄÏ†∏Ïò§Í∏∞' Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî. ÎÇ†ÏßúÎäî Îã¨Î†•ÏóêÏÑú ÏÑ†ÌÉùÌï† Ïàò ÏûàÏäµÎãàÎã§.`;

            const headerFields = [];
            MAPPING_FIELDS.forEach(f => {
                if (mapping.core[f.key] > -1) {
                    headerFields.push({ ...f, isCustom: false, colIndex: mapping.core[f.key] });
                }
            });
            mapping.custom.forEach(cf => {
                headerFields.push({ name: cf.fieldName, key: cf.fieldName, isCustom: true, colIndex: cf.colIndex });
            });
            headerFields.sort((a,b) => a.colIndex - b.colIndex);


            let tableHTML = `<table class="w-full text-left border-collapse"><thead><tr>`;
            tableHTML += `<th class="border text-center p-2">Ïò§Î•ò ÎÇ¥Ïö©</th>`;
            headerFields.forEach(field => {
                tableHTML += `<th class="border p-2">${field.name}</th>`;
            });
            tableHTML += `</tr></thead><tbody>`;

            failedRows.forEach((item, index) => {
                tableHTML += `<tr data-row-index="${index}">`;
                tableHTML += `<td class="border align-top text-red-600 !max-w-xs !whitespace-normal text-xs p-2">${item.errors.join('<br>')}</td>`;
                headerFields.forEach(field => {
                    const colIndex = field.colIndex;
                    let originalValue = item.originalData[colIndex] ?? '';
                    let inputType = 'text';

                    // IMPROVEMENT: Use calendar for date fields and handle various date formats
                    if (field.key === 'startDate' || field.key === 'endDate') {
                        inputType = 'date';
                        // Use local parser to avoid timezone shifts when originalValue is a date-string
                        let d = null;
                        if (typeof originalValue === 'number' && originalValue > 25569) {
                            d = new Date(Math.round((originalValue - 25569) * 86400 * 1000));
                            try { d.setDate(d.getDate() + 1); } catch (e) {}
                            originalValue = formatDateYMD(new Date(d.getFullYear(), d.getMonth(), d.getDate()));
                        } else {
                            d = parseLocalDateString(originalValue);
                            if (d && !isNaN(d.getTime())) {
                                try { d.setDate(d.getDate() + 1); } catch (e) {}
                                originalValue = formatDateYMD(d);
                            } else {
                                originalValue = '';
                            }
                        }
                    }
                    if (field.key === 'poAmount') {
                        originalValue = String(originalValue).replace(/,/g, '');
                    }

                    tableHTML += `<td class="border"><input type="${inputType}" data-field-key="${field.key}" data-is-custom="${field.isCustom}" class="w-full p-1 border rounded" value="${originalValue}"></td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table>`;

            errorCorrectionContainer.innerHTML = tableHTML;
            errorCorrectionModal.classList.remove('hidden');
        }

        function handleRetryImport() {
            const rows = errorCorrectionContainer.querySelectorAll('tbody tr');
            const correctedRawData = [];
            rows.forEach(tr => {
                const originalIndex = parseInt(tr.dataset.rowIndex, 10);
                const originalFailedItem = failedImportRows[originalIndex];

                const newRow = [...originalFailedItem.originalData];
                tr.querySelectorAll('input').forEach(input => {
                    const fieldKey = input.dataset.fieldKey;
                    const isCustom = input.dataset.isCustom === 'true';

                    if (isCustom) {
                        const customMapping = importMapping.custom.find(cf => cf.fieldName === fieldKey);
                        if(customMapping) newRow[customMapping.colIndex] = input.value;
                    } else {
                        const colIndex = importMapping.core[fieldKey];
                        if(colIndex > -1) newRow[colIndex] = input.value;
                    }
                });
                correctedRawData.push(newRow);
            });

            const successfulData = [];
            const stillFailingData = [];
            correctedRawData.forEach(row => {
                 const result = validateAndParseRow(row, importMapping);
                 if (result.success) {
                    successfulData.push(result.data);
                } else {
                    stillFailingData.push(result);
                }
            });

            projectData.push(...successfulData);
            failedImportRows = stillFailingData;

            updateAndApplyDateRange();
            populateFilters();
            render();

            if (stillFailingData.length > 0) {
                showToast(`${successfulData.length}Í∞ú Ìï≠Î™© Ï∂îÍ∞Ä ÏÑ±Í≥µ, ${stillFailingData.length}Í∞ú Ìï≠Î™© Ïó¨Ï†ÑÌûà Ïò§Î•ò Î∞úÏÉù.`, 'warning', 5000);
                openErrorCorrectionModal(stillFailingData, importMapping);
            } else {
                 showToast(`${successfulData.length}Í∞ú Ìï≠Î™©ÏùÑ Ï∂îÍ∞ÄÎ°ú Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§.`, 'success');
                 errorCorrectionModal.classList.add('hidden');
            }

            if (projectData.length > 0 || milestones.length > 0) {
                saveHtmlBtn.disabled = false;
                saveMessage.classList.remove('hidden');
            }
        }

        function populateFilters() {
            // Ïª®Ìä∏Î°§ ÏöîÏÜåÎì§ÏùÄ Ìï≠ÏÉÅ Ïª®Ìä∏Î°§ Ìå®ÎÑê ÎÇ¥Ïóê ÏûàÏúºÎØÄÎ°ú Í∑∏Í≥≥ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ï∞æÏùå
            const controlContainer = document.getElementById('controlsPanel');
            if (!controlContainer) return;
            
            updateControlReferences(controlContainer);

            if (!taskTypeFilter || !customFilterContainer) return; // Exit if elements not found

            const taskTypes = [...new Set(projectData.map(p => p.taskType))];
            // Store current value before clearing
            const currentTaskType = taskTypeFilter.value;
            taskTypeFilter.innerHTML = '<option value="all">Ïú†Ìòï</option>';
            taskTypes.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type;
                taskTypeFilter.appendChild(option);
            });
             // Restore previous selection if possible
             if (taskTypes.includes(currentTaskType)) {
                 taskTypeFilter.value = currentTaskType;
             }

            // Store custom filter values
            const currentCustomFilters = {};
            customFilterContainer.querySelectorAll('select').forEach(sel => {
                currentCustomFilters[sel.dataset.filterKey] = sel.value;
            });

            customFilterContainer.innerHTML = ''; // Clear existing filters
            const customFieldKeys = new Set();
            projectData.forEach(p => {
                if (p.customFields) {
                    Object.keys(p.customFields).forEach(key => customFieldKeys.add(key));
                }
            });

            Array.from(customFieldKeys).sort().forEach(key => {
                 const wrapper = document.createElement('div');
                 wrapper.className = 'pinnable-control-wrapper';

                const select = document.createElement('select');
                select.className = "w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500";
                const safeKey = sanitizeKey(key);
                select.dataset.filterKey = safeKey;

                // [FIX] 'Í≥†Í∞ùÏÇ¨' ÎòêÎäî 'ÏãúÍ≥µÏÇ¨'ÏôÄ Í∞ôÏùÄ ÌäπÏ†ï ÌïÑÎìúÏóê Í≥†Ï†ï IDÎ•º Ìï†ÎãπÌï©ÎãàÎã§.
                const lowerKey = (customFieldDisplayNames[safeKey] || key).toLowerCase();
                if (lowerKey.includes('Í≥†Í∞ùÏÇ¨') || lowerKey.includes('client')) {
                    select.id = 'customer-filter';
                } else if (lowerKey.includes('ÏãúÍ≥µÏÇ¨') || lowerKey.includes('constructor')) {
                    select.id = 'contractor-filter';
                } else {
                    select.id = `custom-filter-${safeKey}`;
                }

                const values = [...new Set(projectData.map(p => p.customFields?.[safeKey]).filter(v => v))]

                const displayName = customFieldDisplayNames[safeKey] || key;
                select.innerHTML = `<option value=\"all\">${displayName}</option>`;
                values.sort().forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    select.appendChild(option);
                });
                 // Restore selection
                 if (currentCustomFilters[safeKey] && values.includes(currentCustomFilters[safeKey])) {
                     select.value = currentCustomFilters[safeKey];
                 } else if (key === 'Í≥†Í∞ùÏÇ¨' && values.includes('ÏÜîÎ£®ÏÖò') && !currentCustomFilters[key]) {
                     // Default selection logic if no previous selection stored
                    select.value = 'ÏÜîÎ£®ÏÖò';
                 }

                select.addEventListener('change', render);
                wrapper.appendChild(select);
                customFilterContainer.appendChild(wrapper);

            });
            setupPinnableControls();
        }

        // --- Auto-upload helper functions ---
        async function fetchAndImportFromUrl(url) {
            // Quick online check: navigator.onLine is a hint; still attempt fetch and handle failures
            if (typeof fetch !== 'function') {
                throw new Error('fetch unsupported');
            }

            showToast('ÏûêÎèô ÏóÖÎ°úÎî©ÏùÑ ÏãúÎèÑÌï©ÎãàÎã§...', 'info');
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout
            let resp;
            try {
                resp = await fetch(url, { method: 'GET', signal: controller.signal });
                clearTimeout(timeoutId);
            } catch (err) {
                clearTimeout(timeoutId);
                throw err;
            }

            if (!resp || !resp.ok) {
                throw new Error('Fetch failed: ' + (resp ? resp.status : 'no response'));
            }

            const arrayBuffer = await resp.arrayBuffer();
            const data = new Uint8Array(arrayBuffer);
            const workbook = XLSX.read(data, { type: 'array', cellDates: true });
            const sheetNames = workbook.SheetNames || [];

            if (!sheetNames || sheetNames.length === 0) {
                throw new Error('Empty workbook');
            }

            // Primary sheet import (projects)
            const primarySheetName = sheetNames[0];
            const primaryWorksheet = workbook.Sheets[primarySheetName];
            const sheetData = XLSX.utils.sheet_to_json(primaryWorksheet, { header: 1, defval: '' });
            if (!sheetData || sheetData.length === 0) {
                throw new Error('Empty or unreadable primary sheet');
            }

            await autoMapAndImport(sheetData);

            // If workbook contains a milestone sheet (name contains 'milestone' or 'ÎßàÏùºÏä§ÌÜ§'), try to import it as milestones
            const milestoneIndex = sheetNames.findIndex(n => /milestone|ÎßàÏùºÏä§ÌÜ§/i.test(n));
            if (milestoneIndex > -1 && milestoneIndex !== 0) {
                try {
                    const msWorksheet = workbook.Sheets[sheetNames[milestoneIndex]];
                    const msData = XLSX.utils.sheet_to_json(msWorksheet, { header: 1, defval: '' });
                    if (msData && msData.length > 0) {
                        // Auto-map/import milestones without modal
                        await autoMapAndImportMilestones(msData);
                    }
                } catch (errMs) {
                    console.warn('auto-import milestone failed', errMs);
                }
            }

            showToast('ÏûêÎèô ÏóÖÎ°úÎî©Ïù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.', 'success');
        }

        async function autoMapAndImport(sheetData) {
            // Reuse autoDetectHeaderRow if available
            let headerRow = 1;
            try {
                if (typeof autoDetectHeaderRow === 'function') {
                    headerRow = autoDetectHeaderRow(sheetData);
                }
            } catch (e) {
                console.warn('autoDetectHeaderRow failed', e);
            }
            const headerRowIndex = Math.max(0, headerRow - 1);
            const primaryHeaders = sheetData[headerRowIndex] || [];
            const secondaryHeaders = sheetData[headerRowIndex + 1] || [];
            const combinedHeaders = primaryHeaders.map((h, i) => {
                const primary = h ? String(h).trim() : '';
                const secondary = (secondaryHeaders[i]) ? String(secondaryHeaders[i]).trim() : '';
                if (primary && !secondary) return primary;
                if (!primary && secondary) return secondary;
                return (primary + ' ' + secondary).trim();
            });

            // Build mapping similar to openMappingModal's best-guess logic
            const mapping = { core: {}, custom: [] };
            MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

            combinedHeaders.forEach((headerText, colIndex) => {
                let bestMatch = 'ignore';
                let highestScore = 0.1;
                MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    field.aliases.forEach(alias => {
                        const lowerHeader = headerText.toLowerCase().trim();
                        const lowerAlias = alias.toLowerCase().trim();
                        if (headerText && lowerHeader.includes(lowerAlias)) {
                            let score = lowerAlias.length / Math.max(1, lowerHeader.length);
                            if (lowerHeader === lowerAlias) score = 1.1;
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) {
                        highestScore = currentScore;
                        bestMatch = field.key;
                    }
                });

                if (bestMatch === 'ignore') {
                    // Add as custom property
                    mapping.custom.push({ colIndex: colIndex, fieldName: headerText || `col_${colIndex}` });
                } else {
                    // assign to core if not already assigned
                    if (mapping.core[bestMatch] === -1) {
                        mapping.core[bestMatch] = colIndex;
                    } else {
                        // collision: treat as custom
                        mapping.custom.push({ colIndex: colIndex, fieldName: headerText || `col_${colIndex}` });
                    }
                }
            });

            // Set rawImportData so processMappedData can use it
            rawImportData = sheetData;

            // Use same dataStartIndex logic as applyMapping (headerRowIndex + 2)
            processMappedData(rawImportData, mapping, headerRowIndex + 2);
        }

        // Auto-map & import for milestone sheets (name + date)
        async function autoMapAndImportMilestones(sheetData) {
            let headerRow = 1;
            try {
                if (typeof autoDetectHeaderRow === 'function') headerRow = autoDetectHeaderRow(sheetData);
            } catch (e) { console.warn('autoDetectHeaderRow failed for milestones', e); }
            const headerRowIndex = Math.max(0, headerRow - 1);

            const primaryHeaders = sheetData[headerRowIndex] || [];
            const secondaryHeaders = sheetData[headerRowIndex + 1] || [];
            const combinedHeaders = primaryHeaders.map((h, i) => {
                const primary = h ? String(h).trim() : '';
                const secondary = (secondaryHeaders[i]) ? String(secondaryHeaders[i]).trim() : '';
                if (primary && !secondary) return primary;
                if (!primary && secondary) return secondary;
                return (primary + ' ' + secondary).trim();
            });

            // Build best-guess mapping for milestone fields
            const mapping = { core: {} };
            MILESTONE_MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

            combinedHeaders.forEach((headerText, colIndex) => {
                let bestMatch = 'ignore';
                let highestScore = 0.1;
                MILESTONE_MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    (field.aliases || []).forEach(alias => {
                        const lh = headerText.toLowerCase().trim();
                        const la = alias.toLowerCase().trim();
                        if (headerText && lh.includes(la)) {
                            let score = la.length / Math.max(1, lh.length);
                            if (lh === la) score = 1.1;
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) { highestScore = currentScore; bestMatch = field.key; }
                });

                if (bestMatch === 'ignore') {
                    // skip unknown columns
                } else {
                    if (mapping.core[bestMatch] === -1) mapping.core[bestMatch] = colIndex;
                    else {
                        // collision -> ignore
                    }
                }
            });

            // rawImportData for milestone processing
            rawImportData = sheetData;
            // Attempt to process milestone rows. If the helper is missing (older builds),
            // fallback to inline processing to ensure auto-upload works correctly.
            if (typeof processMappedMilestoneData === 'function') {
                processMappedMilestoneData(rawImportData, mapping, headerRowIndex + 2);
            } else {
                // Inline fallback: parse milestone rows similarly to manual mapping path
                try {
                    const processedMilestones = [];
                    for (let i = headerRowIndex + 2; i < rawImportData.length; i++) {
                        const row = rawImportData[i];
                        if (!row || row.every(cell => !cell)) continue;

                        const name = row[mapping.core['ÎßàÏùºÏä§ÌÜ§']];
                        let dateValue = row[mapping.core['ÎÇ†Ïßú']];
                        if (!name || !dateValue) continue;

                        let finalDate = null;
                        if (typeof dateValue === 'number' && dateValue > 0) {
                            const excelEpoch = new Date(Date.UTC(1899, 11, 30));
                            const utcDate = new Date(excelEpoch.getTime() + (Math.floor(dateValue) * 24 * 60 * 60 * 1000));
                            finalDate = new Date(Date.UTC(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate()));
                        } else if (dateValue instanceof Date && !isNaN(dateValue)) {
                            finalDate = new Date(Date.UTC(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate()));
                        } else if (typeof dateValue === 'string') {
                            const match = dateValue.trim().match(/^(\d{4})[-\/]?(\d{2})[-\/]?(\d{2})$/);
                            if (match) {
                                const [_, year, month, day] = match;
                                finalDate = new Date(Date.UTC(parseInt(year,10), parseInt(month,10) - 1, parseInt(day,10)));
                            }
                        }

                        if (finalDate && !isNaN(finalDate)) {
                            try { finalDate.setUTCDate(finalDate.getUTCDate() + 1); } catch (e) {}
                            const formattedDate = finalDate.getUTCFullYear() + '-' +
                                String(finalDate.getUTCMonth() + 1).padStart(2, '0') + '-' +
                                String(finalDate.getUTCDate()).padStart(2, '0');
                            processedMilestones.push({ name: name, date: formattedDate });
                        }
                    }

                    if (processedMilestones.length > 0) {
                        milestones = processedMilestones;
                        renderMilestoneModal();
                        render();
                        updateAndApplyDateRange();
                        showToast(`${processedMilestones.length}Í∞úÏùò ÎßàÏùºÏä§ÌÜ§Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î°úÎìúÎêòÏóàÏäµÎãàÎã§.`, 'success');
                        if (projectData.length > 0 || milestones.length > 0) {
                            saveHtmlBtn.disabled = false;
                            saveMessage.classList.remove('hidden');
                        }
                    }
                } catch (e) {
                    console.warn('fallback milestone processing failed', e);
                }
            }
        }
        // --- End auto-upload helpers ---


        function updateProjectStatuses() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            projectData.forEach(p => {
                if (p.progress === 100) {
                    p.status = 'ÏôÑÎ£å';
                } else if (p.endDate < today) {
                    p.status = 'ÏßÄÏó∞';
                } else if (p.progress > 0) {
                    p.status = 'Í≥µÏÇ¨Ï§ë';
                } else {
                    p.status = 'Ï∞©Í≥µÏ†Ñ';
                }
            });
        }

        function getFilteredAndSortedData() {
            let data = [...projectData];
            // Ïª®Ìä∏Î°§ Í∞íÎì§ÏùÄ IDÎ°ú ÏßÅÏ†ë Ï†ëÍ∑ºÌïòÎØÄÎ°ú Ìï≠ÏÉÅ ÏµúÏã† ÏÉÅÌÉúÎ•º Î∞òÏòÅ
            const searchTerm = (searchInput?.value || '').toLowerCase();

            if (searchTerm && legendStatusFilter) {
                legendStatusFilter = null;
                 // Need to target legend within the correct container (normal or fullscreen)
                 const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                 if (legendContainer) {
                    legendContainer.querySelectorAll('.legend-section [data-status-filter].legend-filter-active').forEach(el => el.classList.remove('legend-filter-active'));
                 }
            }

            if (taskTypeFilter && taskTypeFilter.value !== 'all') {
                data = data.filter(p => p.taskType === taskTypeFilter.value);
            }

             if(customFilterContainer) {
                 customFilterContainer.querySelectorAll('select').forEach(select => {
                    if (select.value !== 'all') {
                        const key = select.dataset.filterKey;
                        data = data.filter(p => p.customFields?.[key] === select.value);
                    }
                });
             }


            if (progressFilter) {
                 switch(progressFilter.value) {
                    case 'not_started': data = data.filter(p => p.progress === 0); break;
                    case 'in_progress': data = data.filter(p => p.progress > 0 && p.progress < 100); break;
                    case 'completed': data = data.filter(p => p.progress === 100); break;
                }
            }


            if (legendStatusFilter) {
                data = data.filter(p => p.status === legendStatusFilter);
            } else if (searchTerm) {
                data = data.filter(p => p.name.toLowerCase().includes(searchTerm));
            }

             if(sortBy) {
                switch(sortBy.value) {
                    case 'startDate': data.sort((a, b) => a.startDate - b.startDate); break;
                    case 'endDate': data.sort((a, b) => a.endDate - b.endDate); break;
                    case 'duration': data.sort((a, b) => (a.endDate - a.startDate) - (b.endDate - b.startDate)); break;
                    case 'progress': data.sort((a, b) => b.progress - a.progress); break;
                }
             }

            return data;
        }

        function render() {
             updateControlReferences(); // Ensure references are always correct
            updateProjectStatuses();
            const filteredData = getFilteredAndSortedData();
            updateSummary(filteredData); // Summary updates are always based on main page elements
            renderGanttChart(filteredData);
            
            // Í∞úÏÑ†ÏÇ¨Ìï≠ 2: Î∞îÎ°úÍ∞ÄÍ∏∞ ÎèôÍ∏∞Ìôî
            syncShortcutsFromOriginal();
            setTimeout(scrollToToday, 100);
        }

        function updateSummary(data) {
             // Summary elements are always on the main page, not in fullscreen
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const notStartedCount = data.filter(p => (p.progress || 0) === 0 && p.status !== 'ÏßÄÏó∞').length;
            const inProgressCount = data.filter(p => p.progress > 0 && p.progress < 100 && p.status !== 'ÏßÄÏó∞').length;
            const completedCount = data.filter(p => p.progress === 100).length;
            const delayedCount = data.filter(p => p.status === 'ÏßÄÏó∞').length;

            document.getElementById('totalProjects').textContent = data.length + 'Í±¥';
            document.getElementById('inProgressProjects').textContent = inProgressCount + 'Í±¥';
            document.getElementById('beforeStartProjects').textContent = notStartedCount + 'Í±¥';
            document.getElementById('completedProjects').textContent = completedCount + 'Í±¥';
            document.getElementById('delayedProjects').textContent = delayedCount + 'Í±¥';

            let totalPo = 0;
            let weightedProgressSum = 0;

            data.forEach(p => {
                weightedProgressSum += (p.progress || 0) * (p.poAmount || 0);
                totalPo += (p.poAmount || 0);
            });

            const overallProgressRate = totalPo > 0 ? Math.round(weightedProgressSum / totalPo) : 0;
            document.getElementById('overallProgress').textContent = `${overallProgressRate}%`;
            document.getElementById('overallProgressBar').style.width = `${overallProgressRate}%`;

             // Update legend counts (find legend elements in the correct container)
             const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if (legendContainer) {
                 const legendNs = legendContainer.querySelector('#legendNotStarted');
                 const legendIp = legendContainer.querySelector('#legendInProgress');
                 const legendC = legendContainer.querySelector('#legendCompleted');
                 const legendD = legendContainer.querySelector('#legendDelayed');
                 const legendGp = legendContainer.querySelector('#legendGroupProgress');
                 if(legendNs) legendNs.textContent = `(${notStartedCount}Í±¥)`;
                 if(legendIp) legendIp.textContent = `(${inProgressCount}Í±¥)`;
                 if(legendC) legendC.textContent = `(${completedCount}Í±¥)`;
                 if(legendD) legendD.textContent = `(${delayedCount}Í±¥)`;
                 if(legendGp) legendGp.textContent = `(${overallProgressRate}%)`;
             }


            // Render standard PO summary by task type for the currently filtered data
            renderPoSummary(data);

            // Render dynamic group summaries based on all data
            renderGroupSummaries(projectData);

            // Update the subtle filter label to show which 'Í≥†Í∞ùÏÇ¨' (if any) is currently applied
            try {
                const summaryFilterLabel = document.getElementById('summaryFilterLabel');
                if (summaryFilterLabel && customFilterContainer) {
                    let filterText = 'Ï†ÑÏ≤¥';
                    let customerValue = 'Ï†ÑÏ≤¥';
                    let constructorValue = 'Ï†ÑÏ≤¥';
                    
                    // Î®ºÏ†Ä Í≥†Í∞ùÏÇ¨ÏôÄ ÏãúÍ≥µÏÇ¨ ÌïÑÌÑ∞Ïùò ÌòÑÏû¨ Í∞íÏùÑ Ï∞æÏùå
                    customFilterContainer.querySelectorAll('select').forEach(sel => {
                        const key = sel.dataset.filterKey;
                        const displayName = (customFieldDisplayNames[key] || '').toString();
                        if (displayName.includes('Í≥†Í∞ùÏÇ¨')) {
                            if (sel.value && sel.value !== 'all') {
                                customerValue = sel.value;
                            }
                        } else if (displayName.includes('ÏãúÍ≥µÏÇ¨') || displayName.includes('constructor')) {
                            if (sel.value && sel.value !== 'all') {
                                constructorValue = sel.value;
                            }
                        }
                    });

                    // ÌïÑÌÑ∞ ÌÖçÏä§Ìä∏ Íµ¨ÏÑ±: Í≥†Í∞ùÏÇ¨Îßå ÏÑ†ÌÉù, ÏãúÍ≥µÏÇ¨Îßå ÏÑ†ÌÉù, Îëò Îã§ ÏÑ†ÌÉù Í≤ΩÏö∞ Ï≤òÎ¶¨
                    if (customerValue !== 'Ï†ÑÏ≤¥') {
                        filterText = constructorValue !== 'Ï†ÑÏ≤¥' ? 
                            `${customerValue}>${constructorValue}` : 
                            `${customerValue}>Ï†ÑÏ≤¥`;
                    } else if (constructorValue !== 'Ï†ÑÏ≤¥') {
                        filterText = `Ï†ÑÏ≤¥>${constructorValue}`;
                    }
                    
                    summaryFilterLabel.textContent = `ÌïÑÌÑ∞: ${filterText}`;
                }
            } catch (e) {
                // Fail silently to avoid breaking UI if something unexpected occurs
                console.warn('summary filter label update error', e);
            }
        }

        function renderPoSummary(data) {
            const poSummaryContainer = document.getElementById('poSummary'); // Always on main page
            if (!poSummaryContainer) return;
            poSummaryContainer.innerHTML = '';

            let totalPoAmount = 0;
            const summaryData = data.reduce((acc, p) => {
                if (!acc[p.taskType]) acc[p.taskType] = { amount: 0, count: 0 };
                if (p.poAmount && !isNaN(p.poAmount)) {
                    const amount = p.poAmount;
                    acc[p.taskType].amount += amount;
                    totalPoAmount += amount;
                }
                acc[p.taskType].count++;
                return acc;
            }, {});

            if (Object.keys(summaryData).length === 0 || Object.values(summaryData).every(v => v.amount === 0 && v.count === 0)) {
                poSummaryContainer.innerHTML = '<p class="text-gray-500 col-span-full">ÌëúÏãúÌï† Ï†ïÏÇ∞ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.</p>';
            } else {
                 Object.keys(summaryData).sort().forEach(taskType => {
                    const groupData = summaryData[taskType];
                    if (groupData.count > 0) {
                        const card = document.createElement('div');
                        card.className = "summary-card bg-slate-100 border-l-4 border-slate-500 p-2 rounded-lg shadow-sm";
                        card.dataset.filterType = 'taskType';
                        card.dataset.filterValue = taskType;
                        card.innerHTML = `
                            <div class="font-medium text-slate-700 text-sm pointer-events-none">${taskType} (${groupData.count}Í±¥)</div>
                            <div class="text-xl font-bold text-gray-800 pointer-events-none">${formatCurrency(groupData.amount)}</div>
                        `;
                        poSummaryContainer.appendChild(card);
                    }
                });
            }
        }

        // Modified renderGroupSummaries function
        function renderGroupSummaries(fullData) {
             // These are always on the main page
            const overviewContainer = document.getElementById('overview-group-summaries');
            const settlementHeaderContainer = document.getElementById('settlement-header-summaries');
            const settlementGroupContainer = document.getElementById('settlement-group-summaries');
             if (!overviewContainer || !settlementHeaderContainer || !settlementGroupContainer) return;


            overviewContainer.innerHTML = '';
            settlementHeaderContainer.innerHTML = '';
            settlementGroupContainer.innerHTML = ''; // Clear previous content

            const customFieldKeys = new Set();
            fullData.forEach(p => {
                if (p.customFields) {
                    Object.keys(p.customFields).forEach(key => customFieldKeys.add(key));
                }
            });

            const GROUPING_KEYWORDS = ['Í≥†Í∞ùÏÇ¨', 'ÏãúÍ≥µÏÇ¨', 'ÏóÖÏ≤¥', 'Îã¥ÎãπÏûê', 'client', 'constructor', 'company'];
            const groupingFields = Array.from(customFieldKeys).filter(key =>
                GROUPING_KEYWORDS.some(keyword => key.toLowerCase().includes(keyword))
            ).sort();

            let finalSettlementHeaderHTML = '';

            groupingFields.forEach(field => {
                // --- 1. Data Aggregation (Same as before) ---
                const groupedData = fullData.reduce((acc, p) => {
                    const groupValue = p.customFields?.[field] || 'ÎØ∏ÏßÄÏ†ï';
                    if (!acc[groupValue]) {
                        acc[groupValue] = { poAmount: 0, count: 0, weightedProgress: 0, projects: [] };
                    }
                    const po = p.poAmount || 0;
                    const progress = p.progress || 0;

                    acc[groupValue].poAmount += po;
                    acc[groupValue].count++;
                    acc[groupValue].weightedProgress += po * progress;
                    acc[groupValue].projects.push(p);

                    return acc;
                }, {});
                const sortedGroupValues = Object.keys(groupedData).sort();

                // --- 2. Render Overview Section (Same as before) ---
                const displayFieldName = customFieldDisplayNames[field] || field;
                let overviewHTML = `<div class="border-t pt-4 mt-4"><h3 class="text-lg font-semibold mb-2">${displayFieldName}Î≥Ñ Ï¥ùÍ¥Ñ</h3><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">`;
                sortedGroupValues.forEach(groupValue => {
                    const group = groupedData[groupValue];
                    const groupProgress = group.poAmount > 0 ? Math.round(group.weightedProgress / group.poAmount) : 0;
                    overviewHTML += `
                        <div class="summary-card bg-white border-l-4 border-gray-300 p-3 rounded-lg shadow-sm" data-filter-type="custom-group" data-filter-field="${field}" data-filter-value="${groupValue}">
                            <div class="font-bold text-gray-700">${groupValue} (${group.count}Í±¥)</div>
                            <div class="text-xl font-bold text-gray-800">${formatCurrency(group.poAmount)}</div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                                <div class="bg-gray-500 h-2 rounded-full" style="width: ${groupProgress}%" title="Í≥µÏ†ïÎ•†: ${groupProgress}%"></div>
                            </div>
                        </div>`;
                });
                overviewHTML += `</div></div>`;
                overviewContainer.innerHTML += overviewHTML;

                // --- 3. Render Settlement Section (Modified for Sub-Accordions) ---
                if ((customFieldDisplayNames[field] || field).includes('Í≥†Í∞ùÏÇ¨')) {
                     finalSettlementHeaderHTML = sortedGroupValues.map(groupValue => {
                         const group = groupedData[groupValue];
                         const formattedUnit = formatAmountWithUnit(group.poAmount);
                         return `<span class="font-semibold">${groupValue}:</span> Ï¥ù ${formatCurrency(group.poAmount)} ${formattedUnit} / ${group.count}Í±¥`;
                    }).join(' <span class="text-black font-light mx-3">üîõ</span> ');
                }

                // Create the main container for this field's sub-accordions
                const fieldAccordionContainer = document.createElement('div');
                fieldAccordionContainer.className = 'border-t pt-4 mt-4'; // Add styling as needed

                // Create main settlement section accordion
                const mainSettlementAccordion = document.createElement('div');
                mainSettlementAccordion.className = 'main-settlement-accordion-item mb-4 border border-gray-200 rounded-lg';
                
                // Main settlement section header
                const mainSettlementHeader = document.createElement('div');
                mainSettlementHeader.className = 'main-settlement-header p-3 cursor-pointer flex items-center justify-between bg-gray-50 hover:bg-gray-100';
                mainSettlementHeader.innerHTML = `
                    <h3 class="text-lg font-semibold">‚ñ† ${displayFieldName}Î≥Ñ Ï†ïÏÇ∞</h3>
                    <svg class="main-settlement-icon w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                `;
                
                // Main settlement section content
                const mainSettlementContent = document.createElement('div');
                mainSettlementContent.className = 'main-settlement-content p-4';
                
                // Í∞úÏÑ†ÏÇ¨Ìï≠ 1: Í∏∞Î≥∏ ÎèôÏûëÏùÄ Ï†ëÌûòÏù¥ÏßÄÎßå, Ï†ÄÏû•Îêú ÏÑ§Ï†ïÏù¥ ÏûàÏúºÎ©¥ Í∑∏ ÏÉÅÌÉúÎ•º Î≥µÏõêÌï©ÎãàÎã§.
                let isSettlementOpen = false;
                try {
                    if (savedSettings && Array.isArray(savedSettings.settlementOpenFields)) {
                        isSettlementOpen = savedSettings.settlementOpenFields.includes(displayFieldName);
                    }
                } catch (e) {
                    isSettlementOpen = false;
                }

                if (isSettlementOpen) {
                    mainSettlementAccordion.classList.add('expanded');
                    mainSettlementContent.style.display = 'block';
                } else {
                    mainSettlementAccordion.classList.add('collapsed');
                    mainSettlementContent.style.display = 'none';
                }
                
                mainSettlementAccordion.appendChild(mainSettlementHeader);
                mainSettlementAccordion.appendChild(mainSettlementContent);
                
                // Add click handler for main settlement accordion
                mainSettlementHeader.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isCollapsed = mainSettlementAccordion.classList.contains('collapsed');
                    if (isCollapsed) {
                        mainSettlementAccordion.classList.remove('collapsed');
                        mainSettlementAccordion.classList.add('expanded');
                        mainSettlementContent.style.display = 'block';
                    } else {
                        mainSettlementAccordion.classList.remove('expanded');
                        mainSettlementAccordion.classList.add('collapsed');
                        mainSettlementContent.style.display = 'none';
                    }
                    
                    // Update scroll behavior after accordion toggle
                    setTimeout(() => {
                        updateSettlementScrollBehavior();
                        // Recompute today marker height after layout change (allow DOM to settle)
                        try {
                            const containerRef = fullscreenModal.classList.contains('hidden') 
                                ? document.getElementById('ganttViewContent') 
                                : fullscreenModalBody;
                            recomputeTodayMarkerHeight(containerRef);
                        } catch (e) {
                            // fail silently if environment not ready
                        }
                    }, 120);
                });
                
                fieldAccordionContainer.appendChild(mainSettlementAccordion);

                // Create individual sub-accordions for each group value inside main settlement content
                sortedGroupValues.forEach(groupValue => {
                    const group = groupedData[groupValue];

                    // Sub-Accordion Item Wrapper
                    const subAccordionItem = document.createElement('div');
                    subAccordionItem.className = 'sub-accordion-item mb-2 border-b last:border-b-0'; // Initially closed

                    // Sub-Accordion Header
                    const subAccordionHeader = document.createElement('div');
                    subAccordionHeader.className = 'sub-accordion-header py-2'; // Added padding
                    subAccordionHeader.innerHTML = `
                        <h4 class="font-semibold text-md hover:text-indigo-600" data-filter-type="custom-group" data-filter-field="${field}" data-filter-value="${groupValue}">
                            ${groupValue}
                             <span class="text-sm font-normal text-gray-500 ml-2">(${group.count}Í±¥ / ${formatCurrency(group.poAmount)})</span>
                        </h4>
                         <svg class="sub-accordion-icon w-5 h-5 flex-shrink-0 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    `;
                    subAccordionItem.appendChild(subAccordionHeader);

                    // Sub-Accordion Content
                    const subAccordionContent = document.createElement('div');
                    subAccordionContent.className = 'sub-accordion-content'; // Content starts hidden

                    const contentGrid = document.createElement('div');
                     // Added pl-4 for indentation
                    contentGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 pb-2 pl-4';

                    const taskTypeSummary = group.projects.reduce((acc, p) => {
                         if (!acc[p.taskType]) {
                            acc[p.taskType] = { amount: 0, count: 0 };
                        }
                        acc[p.taskType].amount += p.poAmount || 0;
                        acc[p.taskType].count++;
                        return acc;
                    }, {});

                    // Sort task types and add numbering
                    Object.keys(taskTypeSummary).sort().forEach((taskType, index) => {
                        const taskData = taskTypeSummary[taskType];
                        contentGrid.innerHTML += `
                        <div class="summary-card bg-slate-50 border-l-4 border-slate-400 p-2 rounded-lg shadow-sm"
                             data-filter-type="custom-group-task"
                             data-filter-field="${field}"
                             data-filter-value="${groupValue}"
                             data-filter-task-type="${taskType}">
                             <div class="flex items-baseline">
                                <span class="text-xs font-mono mr-1.5">${index + 1}.</span> <!-- Numbering -->
                                <div class="flex-1">
                                    <div class="font-medium text-slate-700 text-sm pointer-events-none">${taskType} (${taskData.count}Í±¥)</div>
                                    <div class="text-lg font-bold text-gray-800 pointer-events-none">${formatCurrency(taskData.amount)}</div>
                                </div>
                             </div>
                        </div>`;
                    });


                    subAccordionContent.appendChild(contentGrid);
                    subAccordionItem.appendChild(subAccordionContent);

                    // Add the complete sub-accordion item to the main settlement content
                    mainSettlementContent.appendChild(subAccordionItem);
                });

                // Append the container for this field to the main settlement group container
                settlementGroupContainer.appendChild(fieldAccordionContainer);
            });

            settlementHeaderContainer.innerHTML = finalSettlementHeaderHTML;

            // Add event listeners after rendering
            setupSettlementAccordions();
            
            // Setup settlement section wheel scrolling
            setupSettlementWheelScrolling();
            
            // Setup resize observer for dynamic content changes
            setupSettlementResizeObserver();
            
            // Update scroll behavior after content changes
            updateSettlementScrollBehavior();
        }


        // Function to setup sub-accordion listeners
        function setupSettlementAccordions() {
            const settlementGroupContainer = document.getElementById('settlement-group-summaries');
             if (!settlementGroupContainer) return;
            settlementGroupContainer.querySelectorAll('.sub-accordion-header').forEach(header => {
                 // Remove existing listener to prevent duplicates if called multiple times
                header.removeEventListener('click', toggleSubAccordion);
                header.addEventListener('click', toggleSubAccordion);
            });
        }

        function setupSettlementWheelScrolling() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            // Remove existing listeners to prevent duplicates
            settlementContent.removeEventListener('wheel', handleSettlementWheel);
            settlementContent.addEventListener('wheel', handleSettlementWheel, { passive: false });
        }
        
        function handleSettlementWheel(e) {
            const settlementContent = e.currentTarget;
            
            // Check if content is scrollable
            const isScrollable = settlementContent.scrollHeight > settlementContent.clientHeight;
            
            if (isScrollable && e.deltaY !== 0) {
                // Prevent default browser scrolling
                e.preventDefault();
                e.stopPropagation();
                
                // Smooth scrolling with custom delta
                const scrollAmount = e.deltaY * 0.5; // Reduce scroll speed for better control
                settlementContent.scrollTop += scrollAmount;
            }
        }
        
        function updateSettlementScrollBehavior() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            // Force re-evaluation of scroll behavior
            setTimeout(() => {
                const needsScroll = settlementContent.scrollHeight > settlementContent.clientHeight;
                
                if (needsScroll) {
                    settlementContent.style.overflowY = 'auto';
                    settlementContent.style.maxHeight = '70vh';
                } else {
                    settlementContent.style.overflowY = 'visible';
                    settlementContent.style.maxHeight = 'none';
                }
            }, 100);
        }
        
        // Setup resize observer for settlement content
        function setupSettlementResizeObserver() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(() => {
                    updateSettlementScrollBehavior();
                });
                resizeObserver.observe(settlementContent);
            }
        }

        function toggleSubAccordion(e) {
             // Prevent card click event when clicking the header itself
            if (!e.target.closest('[data-filter-type="custom-group"]')) {
                 const subAccordionItem = e.currentTarget.parentElement;
                 subAccordionItem.classList.toggle('open');
                 
                 // Update scroll behavior after sub-accordion toggle and recompute today marker
                 setTimeout(() => {
                     updateSettlementScrollBehavior();
                     try {
                         const containerRef = fullscreenModal.classList.contains('hidden') 
                             ? document.getElementById('ganttViewContent') 
                             : fullscreenModalBody;
                         recomputeTodayMarkerHeight(containerRef);
                     } catch (e) {
                         // ignore errors silently
                     }
                 }, 120);
            }
        }


        function handleCardClick(e) {
            const card = e.target.closest('[data-filter-type]');
             // Prevent modal opening if clicking within a sub-accordion header (let the toggle handle it)
            if (!card || e.target.closest('.sub-accordion-header')) return;

            const filterType = card.dataset.filterType;
            const filterValue = card.dataset.filterValue;
            let title = '';
            let dataForModal = [];

            let baseData;
            // [Í∞úÏÑ† ÏÇ¨Ìï≠ 1] Í∑∏Î£πÌôîÎêú Ïπ¥Îìú(Í≥†Í∞ùÏÇ¨Î≥Ñ, ÏãúÍ≥µÏÇ¨Î≥Ñ Îì±)Î•º ÌÅ¥Î¶≠Ìï† ÎïåÎäî Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Ï§ÄÏúºÎ°ú ÌïÑÌÑ∞ÎßÅÌï¥Ïïº Ìï©ÎãàÎã§.
            // Í∑∏Î†áÏßÄ ÏïäÏúºÎ©¥ ÌòÑÏû¨ Ï†ÅÏö©Îêú ÌïÑÌÑ∞(Ïòà: Í≥†Í∞ùÏÇ¨ 'ÏÜîÎ£®ÏÖò') ÎïåÎ¨∏Ïóê Îã§Î•∏ Í∑∏Î£π(Ïòà: Í≥†Í∞ùÏÇ¨ 'ÌôîÌïô')Ïùò Îç∞Ïù¥ÌÑ∞Í∞Ä Î≥¥Ïù¥ÏßÄ ÏïäÏäµÎãàÎã§.
            if (filterType === 'custom-group' || filterType === 'custom-group-task') {
                baseData = projectData; // Ï†ÑÏ≤¥ ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©
            } else {
                // Í∑∏ Ïô∏Ïùò Ïπ¥Îìú(Ïòà: ÏÉÅÌÉúÎ≥Ñ Ïπ¥Îìú)Îäî ÌòÑÏû¨ ÌïÑÌÑ∞ÎßÅÎêú Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Ï§ÄÏúºÎ°ú Ìï©ÎãàÎã§.
                baseData = getFilteredAndSortedData();
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (filterType === 'status') {
                const statusText = filterValue === 'all' ? 'Ï†ÑÏ≤¥ ÏûëÏóÖ' : filterValue;
                title = `${statusText} Î™©Î°ù`;
                switch (filterValue) {
                    case 'all':
                        dataForModal = baseData;
                        break;
                    case 'Í≥µÏÇ¨Ï§ë':
                        dataForModal = baseData.filter(p => p.progress > 0 && p.progress < 100 && p.endDate >= today);
                        break;
                    case 'Ï∞©Í≥µÏ†Ñ':
                        dataForModal = baseData.filter(p => (p.progress || 0) === 0 && p.endDate >= today);
                        break;
                    case 'ÏôÑÎ£å':
                        dataForModal = baseData.filter(p => p.progress === 100);
                        break;
                    case 'ÏßÄÏó∞':
                        dataForModal = baseData.filter(p => p.progress < 100 && p.endDate < today);
                        break;
                    default:
                        dataForModal = [];
                }
                if (dataForModal.length > 0) {
                    showDataDetailModal(title, dataForModal);
                }
            } else if (filterType === 'taskType') {
                title = `'${filterValue}' ÏÉÅÏÑ∏ Í≥µÏ†ï ÌòÑÌô©`;
                dataForModal = baseData.filter(p => p.taskType === filterValue);
                 if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${filterValue}' Í≥µÏ†ïÏú®`);
                }
            } else if (filterType === 'progress') {
                title = 'Ï¥ùÍ¥Ñ ÏÉÅÏÑ∏ ÌòÑÌô©';
                dataForModal = baseData;
                if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, 'Ï¥ùÍ¥Ñ Í≥µÏ†ïÏú®');
                }
            } else if (filterType === 'custom-group') {
                const field = card.dataset.filterField;
                const value = card.dataset.filterValue;
                title = `'${value}' (${field}) ÏÉÅÏÑ∏ Í≥µÏ†ï ÌòÑÌô©`;
                dataForModal = baseData.filter(p => p.customFields?.[field] === value);
                 if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${value}' Í≥µÏ†ïÏú®`);
                }
            // Improvement: Handle click on sub-cards in settlement group section
            } else if (filterType === 'custom-group-task') {
                const field = card.dataset.filterField;
                const value = card.dataset.filterValue;
                const taskType = card.dataset.filterTaskType;
                title = `'${value}' (${field}) - '${taskType}' ÏÉÅÏÑ∏`;
                dataForModal = baseData.filter(p => p.customFields?.[field] === value && p.taskType === taskType);
                if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${taskType}' Í≥µÏ†ïÏú®`);
                }
            }


             if (dataForModal.length > 0 && !e.target.closest('.sub-accordion-header')) {
                if (['status'].includes(filterType)) { // Only show simple list for status clicks
                     showDataDetailModal(title, dataForModal);
                 } else {
                     showProgressDetailModal(title, dataForModal, title.replace(' ÏÉÅÏÑ∏ Í≥µÏ†ï ÌòÑÌô©', ' Í≥µÏ†ïÏú®')); // Generate label
                 }
            } else if (dataForModal.length === 0 && !e.target.closest('.sub-accordion-header')) {
                 showToast('ÌëúÏãúÌï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.', 'info');
            }
        }

        function showProgressDetailModal(title, data, summaryLabel = 'Ï¥ùÍ¥Ñ Í≥µÏ†ïÏú®') {
            // Î™®Îã¨ Ï¥àÍ∏∞Ìôî
            const overlay = dataDetailModal;
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            
            const content = overlay.querySelector('.modal-content');
            // Î™®Îã¨ Í∏∞Î≥∏ ÌÅ¨Í∏∞ Î∞è ÏúÑÏπò ÏÑ§Ï†ï
            content.style.width = '80%';
            content.style.maxWidth = '1200px';
            content.style.height = '80vh';
            content.style.maxHeight = '800px';
            content.style.position = 'relative';
            content.style.top = '0';
            content.style.left = '0';
            content.style.transform = 'none';
            content.style.margin = 'auto';
            
            dataDetailTitle.textContent = title;
            // Toolbar with export button and count
            const toolbarHTML = `<div class="flex justify-between items-center mb-3">
                    <div class="text-sm text-gray-600">Ï¥ù <strong>${data.length}</strong>Í±¥</div>
                    <div><button class="table-export-btn px-3 py-1 bg-indigo-600 text-white rounded text-sm">ÏóëÏÖÄ Îã§Ïö¥Î°úÎìú</button></div>
                </div>`;

            let tableHTML = `${toolbarHTML}<table class="w-full text-sm text-left text-gray-500">
                <thead class="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0">
                    <tr>
                        <th scope="col" class="px-4 py-3">No.</th>
                        <th scope="col" class="px-4 py-3">ÌîÑÎ°úÏ†ùÌä∏ Î™Ö</th>
                        <th scope="col" class="px-4 py-3 text-right">Ï†ïÏÇ∞ (A)</th>
                        <th scope="col" class="px-4 py-3 text-right">ÏßÑÌñâ (B)</th>
                        <th scope="col" class="px-4 py-3 text-right">Í∞ÄÏ§ëÏπò Ï†ÅÏö©Í∞í (A*B)</th>
                    </tr>
                </thead>
                <tbody>`;

            let totalPo = 0;
            let weightedProgressSum = 0;

            data.forEach((item, index) => {
                const po = item.poAmount || 0;
                const progress = item.progress || 0;
                const weightedValue = po * progress;
                totalPo += po;
                weightedProgressSum += weightedValue;
                // IMPROVEMENT: Apply accounting format
                tableHTML += `
                    <tr class="border-b hover:bg-gray-50">
                        <td class="px-4 py-2 font-medium text-gray-900">${index + 1}</td>
                        <td class="px-4 py-2">${item.name}</td>
                        <td class="px-4 py-2 text-right">${formatCurrency(po)}</td>
                        <td class="px-4 py-2 text-right">${progress}%</td>
                        <td class="px-4 py-2 text-right">${(weightedValue/100).toLocaleString('ko-KR')}</td>
                    </tr>`;
            });

            const overallProgressRate = totalPo > 0 ? (weightedProgressSum / totalPo).toFixed(2) : 0;

            tableHTML += `</tbody>
                <tfoot class="text-sm font-semibold text-gray-800 bg-gray-100">
                    <tr>
                        <td colspan="2" class="px-4 py-3 text-center">Ìï©Í≥Ñ</td>
                        <td class="px-4 py-3 text-right">${formatCurrency(totalPo)}</td>
                        <td class="px-4 py-3 text-right">-</td>
                        <td class="px-4 py-3 text-right">${(weightedProgressSum/100).toLocaleString('ko-KR')}</td>
                    </tr>
                    <tr>
                        <td colspan="4" class="px-4 py-3 text-center text-base">${summaryLabel} (Í∞ÄÏ§ëÏπò Ìï©Í≥Ñ / Ï†ïÏÇ∞ Ìï©Í≥Ñ)</td>
                        <td class="px-4 py-3 text-right text-base font-bold text-blue-600">${overallProgressRate}%</td>
                    </tr>
                </tfoot>
            </table>`;

            dataDetailTableContainer.innerHTML = tableHTML;

            // Make table sortable and attach export
            const tbl = dataDetailTableContainer.querySelector('table');
            if (tbl) makeTableSortable(tbl);
            const btn = dataDetailTableContainer.querySelector('.table-export-btn');
            if (btn) btn.addEventListener('click', () => exportTableToXLSX(tbl, `${title.replace(/[^0-9a-zA-ZÍ∞Ä-Ìû£\s_-]/g,'') || 'export'}.xlsx`));

            // Î™®Îã¨ ÌëúÏãú Î∞è Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
            dataDetailModal.classList.remove('hidden');
            dataDetailModal.style.display = 'flex';
            dataDetailModal.style.justifyContent = 'center';
            dataDetailModal.style.alignItems = 'center';
            
            // Î™®Îã¨ Ïª®ÌÖêÏ∏† ÌÅ¨Í∏∞ÏôÄ ÏúÑÏπò Ïû¨Ï°∞Ï†ï
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                requestAnimationFrame(() => {
                    modalContent.style.position = 'relative';
                    modalContent.style.width = '80%';
                    modalContent.style.maxWidth = '1200px';
                    modalContent.style.height = '80vh';
                    modalContent.style.maxHeight = '800px';
                    modalContent.style.margin = 'auto';
                    modalContent.style.transform = 'none';
                    modalContent.style.top = '0';
                    modalContent.style.left = '0';
                    
                    // Ïä§ÌÅ¨Î°§Î∞î ÏúÑÏπò Ï¥àÍ∏∞Ìôî
                    if (dataDetailTableContainer) {
                        dataDetailTableContainer.scrollTop = 0;
                    }
                });
            }
        }

        function showDataDetailModal(title, data) {
            dataDetailTitle.textContent = title;
            const toolbarHTML = `<div class="flex justify-between items-center mb-3">
                    <div class="text-sm text-gray-600">Ï¥ù <strong>${data.length}</strong>Í±¥</div>
                    <div><button class="table-export-btn px-3 py-1 bg-indigo-600 text-white rounded text-sm">ÏóëÏÖÄ Îã§Ïö¥Î°úÎìú</button></div>
                </div>`;

            let tableHTML = `${toolbarHTML}<table class="w-full text-sm text-left text-gray-500">
                <thead class="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0">
                    <tr>
                        <th scope="col" class="px-4 py-3">No.</th>
                        <th scope="col" class="px-4 py-3">ÌîÑÎ°úÏ†ùÌä∏ Î™Ö</th>
                        <th scope="col" class="px-4 py-3">ÏÉÅÌÉú</th>
                        <th scope="col" class="px-4 py-3">ÏãúÏûëÏùº</th>
                        <th scope="col" class="px-4 py-3">Ï¢ÖÎ£åÏùº</th>
                        <th scope="col" class="px-4 py-3 text-right">Ï†ïÏÇ∞</th>
                    </tr>
                </thead>
                <tbody>`;

            data.forEach((item, index) => {
                // IMPROVEMENT: Apply accounting format
                tableHTML += `
                    <tr class="border-b hover:bg-gray-50">
                        <td class="px-4 py-2 font-medium text-gray-900">${index + 1}</td>
                        <td class="px-4 py-2">${item.name}</td>
                        <td class="px-4 py-2">${item.status}</td>
                        <td class="px-4 py-2">${formatDate(item.startDate)}</td>
                        <td class="px-4 py-2">${formatDate(item.endDate)}</td>
                        <td class="px-4 py-2 text-right">${formatCurrency(item.poAmount)}</td>
                    </tr>`;
            });

            tableHTML += `</tbody></table>`;
            dataDetailTableContainer.innerHTML = tableHTML;

            // Make table sortable and attach export
            const tbl = dataDetailTableContainer.querySelector('table');
            if (tbl) makeTableSortable(tbl);
            const btn = dataDetailTableContainer.querySelector('.table-export-btn');
            if (btn) btn.addEventListener('click', () => exportTableToXLSX(tbl, `${title.replace(/[^0-9a-zA-ZÍ∞Ä-Ìû£\s_-]/g,'') || 'export'}.xlsx`));

            // Î™®Îã¨ ÌëúÏãú Î∞è Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
            dataDetailModal.classList.remove('hidden');
            dataDetailModal.style.display = 'flex';
            dataDetailModal.style.justifyContent = 'center';
            dataDetailModal.style.alignItems = 'center';
            
            // Î™®Îã¨ Ïª®ÌÖêÏ∏† ÌÅ¨Í∏∞ÏôÄ ÏúÑÏπò Ïû¨Ï°∞Ï†ï
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                requestAnimationFrame(() => {
                    modalContent.style.position = 'relative';
                    modalContent.style.width = '80%';
                    modalContent.style.maxWidth = '1200px';
                    modalContent.style.height = '80vh';
                    modalContent.style.maxHeight = '800px';
                    modalContent.style.margin = 'auto';
                    modalContent.style.transform = 'none';
                    modalContent.style.top = '0';
                    modalContent.style.left = '0';
                    
                    // Ïä§ÌÅ¨Î°§Î∞î ÏúÑÏπò Ï¥àÍ∏∞Ìôî
                    if (dataDetailTableContainer) {
                        dataDetailTableContainer.scrollTop = 0;
                    }
                });
            }
        }

        function dateDiffInDays(a, b) {
            const _MS_PER_DAY = 1000 * 60 * 60 * 24;
            const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
            const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());
            return Math.floor((utc2 - utc1) / _MS_PER_DAY);
        }

        function scrollToToday() {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if (!container) return; // Add check
            const todayMarker = container.querySelector('.gantt-today-marker-container');
            if (todayMarker) {
                const todayPosition = todayMarker.offsetLeft;
                const timelineContainer = container.querySelector('.gantt-timeline-body-wrapper');
                if(timelineContainer) {
                    const scrollTarget = todayPosition - (timelineContainer.clientWidth / 2);
                    timelineContainer.scrollTo({ left: scrollTarget, behavior: 'smooth' });
                }
            }
        }

        function handleResizeMousedown(e) {
            if (!e.target.classList.contains('resizer')) return;
            const titlesPane = e.target.closest('.gantt-titles');
            if (!titlesPane) return;

            e.preventDefault();

            const startX = e.clientX;
            const startWidth = titlesPane.offsetWidth;

            const doDrag = (moveEvent) => {
                const newWidth = startWidth + (moveEvent.clientX - startX);
                if (newWidth > 250 && newWidth < 900) {
                    titlesPane.style.width = `${newWidth}px`;
                }
            };

            const stopDrag = () => {
                document.documentElement.removeEventListener('mousemove', doDrag);
                document.documentElement.removeEventListener('mouseup', stopDrag);
            };

            document.documentElement.addEventListener('mousemove', doDrag);
            document.documentElement.addEventListener('mouseup', stopDrag);
        }

        function handleColResizeMousedown(e) {
            const resizer = e.target;
            const titlesPane = resizer.closest('.gantt-titles');
            if (!titlesPane) return;

            e.preventDefault();

            const leftColName = resizer.dataset.colLeft;
            const rightColName = resizer.dataset.colRight;

            const leftColVar = `--${leftColName}-col-width`;
            const rightColVar = `--${rightColName}-col-width`;

            const startX = e.clientX;
            const startLeftWidth = parseFloat(getComputedStyle(titlesPane).getPropertyValue(leftColVar));
            const startRightWidth = parseFloat(getComputedStyle(titlesPane).getPropertyValue(rightColVar));
            const minWidth = 60;

            const doDrag = (moveEvent) => {
                const diffX = moveEvent.clientX - startX;
                let newLeftWidth = startLeftWidth + diffX;
                let newRightWidth = startRightWidth - diffX;

                if (newLeftWidth < minWidth) {
                    newLeftWidth = minWidth;
                    newRightWidth = startLeftWidth + startRightWidth - minWidth;
                }
                if (newRightWidth < minWidth) {
                    newRightWidth = minWidth;
                    newLeftWidth = startLeftWidth + startRightWidth - minWidth;
                }

                titlesPane.style.setProperty(leftColVar, `${newLeftWidth}px`);
                titlesPane.style.setProperty(rightColVar, `${newRightWidth}px`);
            };

            const stopDrag = () => {
                document.documentElement.removeEventListener('mousemove', doDrag);
                document.documentElement.removeEventListener('mouseup', stopDrag);
            };

            document.documentElement.addEventListener('mousemove', doDrag);
            document.documentElement.addEventListener('mouseup', stopDrag);
        }

        function handleColumnToggle(toggleBtn) {
            const colName = toggleBtn.dataset.col;
            if (colName && typeof columnVisibility[colName] !== 'undefined') {
                columnVisibility[colName] = !columnVisibility[colName];
                toggleBtn.textContent = columnVisibility[colName] ? '[-]' : '[+]';
                const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                 if (!container) return; // Add check
                const elementsToToggle = container.querySelectorAll(`.${colName}`);
                elementsToToggle.forEach(el => {
                    el.style.display = columnVisibility[colName] ? '' : 'none';
                    if (colName === 'project-dates' && columnVisibility[colName]) {
                         el.style.display = 'flex';
                    }
                });
            }
        }

        function handleDateEditClick(dateEditor) {
            if (dateEditor.querySelector('input')) return;

            const projectId = dateEditor.dataset.projectId;
            const dateType = dateEditor.dataset.dateType;
            const project = projectData.find(p => p.id === projectId);
            if (!project) return;

            const originalDate = project[dateType];
            const originalDateText = dateEditor.textContent;

            const input = document.createElement('input');
            input.type = 'date';
            input.className = 'date-input';

          if (originalDate && !isNaN(originalDate)) {
              input.value = formatDateYMD(originalDate);
          }

            dateEditor.textContent = '';
            dateEditor.appendChild(input);
            input.focus();

            try {
                input.showPicker();
            } catch (error) {
                console.log("showPicker() is not supported by this browser.");
            }

            const saveChange = () => {
                const newDateValue = input.value;
                if (newDateValue) {
                    // Parse as local date (avoid Date(string) which can be interpreted as UTC)
                    const newDate = parseLocalDateString(newDateValue);

                    if (newDate && !isNaN(newDate.getTime())) {
                        const tempProject = { ...project, [dateType]: newDate };

                        if (dateType === 'startDate' && tempProject.endDate && newDate > tempProject.endDate) {
                            showToast('ÏãúÏûëÏùºÏùÄ ÏôÑÎ£åÏùºÎ≥¥Îã§ Îä¶ÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.', 'error');
                            dateEditor.innerHTML = originalDateText;
                            return;
                        }
                        if (dateType === 'endDate' && tempProject.startDate && newDate < tempProject.startDate) {
                            showToast('ÏôÑÎ£åÏùºÏùÄ ÏãúÏûëÏùºÎ≥¥Îã§ Îπ†Î•º Ïàò ÏóÜÏäµÎãàÎã§.', 'error');
                            dateEditor.innerHTML = originalDateText;
                            return;
                        }

                        project[dateType] = newDate;
                        project[`${dateType}Str`] = formatDateYMD(newDate);

                        updateAndApplyDateRange();
                        render();
                        showToast('ÎÇ†ÏßúÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.', 'success');
                        return;
                    }
                }
                showToast('ÏûòÎ™ªÎêú ÎÇ†Ïßú ÌòïÏãùÏûÖÎãàÎã§. ÏûÖÎ†•ÏùÑ Ï∑®ÏÜåÌï©ÎãàÎã§.', 'error');
                dateEditor.innerHTML = originalDateText;
            };

            input.addEventListener('blur', saveChange);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    input.removeEventListener('blur', saveChange);
                    dateEditor.innerHTML = originalDateText;
                }
            });
        }

        function handleProgressEditClick(progressEditor) {
            if (progressPopup.dataset.projectId === progressEditor.dataset.projectId && !progressPopup.classList.contains('hidden')) {
                progressPopup.classList.add('hidden');
                return;
            }

            const projectId = progressEditor.dataset.projectId;
            const project = projectData.find(p => p.id === projectId);
            if (!project) return;

            const currentProgress = project.progress || 0;

            progressPopup.innerHTML = '';
            progressPopup.dataset.projectId = projectId;

            for (let i = 0; i <= 10; i++) {
                const value = i * 10;
                const btn = document.createElement('button');
                btn.textContent = `${value}%`;
                btn.dataset.value = value;
                btn.className = 'progress-val-btn';
                if (value === currentProgress) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    project.progress = value;
                    render();
                    showToast('ÏßÑÌñâÎ•†Ïù¥ ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.', 'success');
                    progressPopup.classList.add('hidden');
                });
                progressPopup.appendChild(btn);
            }

            const inputContainer = document.createElement('div');
            inputContainer.className = 'progress-input-area';

            const input = document.createElement('input');
            input.type = 'number';
            input.min = 0;
            input.max = 100;
            input.value = currentProgress;

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Ï†ÄÏû•';

            const saveProgress = () => {
                let newProgress = parseInt(input.value, 10);
                if (!isNaN(newProgress) && newProgress >= 0 && newProgress <= 100) {
                    project.progress = newProgress;
                    render();
                    showToast('ÏßÑÌñâÎ•†Ïù¥ ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.', 'success');
                    progressPopup.classList.add('hidden');
                } else {
                    showToast('0ÏóêÏÑú 100 ÏÇ¨Ïù¥Ïùò Ïà´ÏûêÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.', 'error');
                }
            };

            saveBtn.addEventListener('click', saveProgress);
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') saveProgress();
                if (e.key === 'Escape') progressPopup.classList.add('hidden');
            });

            inputContainer.appendChild(input);
            inputContainer.appendChild(saveBtn);
            progressPopup.appendChild(inputContainer);

            const rect = progressEditor.getBoundingClientRect();
            progressPopup.style.top = `${rect.bottom + window.scrollY + 5}px`;

            const popupWidth = 224;
            let leftPos = rect.left + window.scrollX;
            if (leftPos + popupWidth > window.innerWidth) {
                leftPos = window.innerWidth - popupWidth - 10;
            }
            progressPopup.style.left = `${leftPos}px`;

            progressPopup.classList.remove('hidden');
            input.select();
        }

        function handleLegendClick(legendItem) {
            const status = legendItem.dataset.statusFilter;
            const isActive = legendItem.classList.contains('legend-filter-active');

             // Target legend within the correct container
             const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if(legendContainer) {
                 legendContainer.querySelectorAll('.legend-section [data-status-filter].legend-filter-active').forEach(el => el.classList.remove('legend-filter-active'));
             }


            if (isActive) {
                legendStatusFilter = null;
            } else {
                legendStatusFilter = status;
                legendItem.classList.add('legend-filter-active');
            }

            if (searchInput) searchInput.value = '';

            render();
        }

        function renderGanttChart(data) {
             const isInFullscreen = !fullscreenModal.classList.contains('hidden');
             const container = isInFullscreen ? fullscreenModalBody : document.getElementById('ganttViewContent');
             if (!container) return; // Exit if container not found
             const currentGanttContainer = container.querySelector('#ganttChart'); // Find chart within the current container
             if (!currentGanttContainer) return; // Exit if chart area not found


            currentGanttContainer.innerHTML = '';

            if (!viewMinDate || !viewMaxDate) {
                currentGanttContainer.innerHTML = `<p class="text-center text-gray-500 p-8">Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. Ïö∞Ï∏° ÌïòÎã® Î©îÎâ¥Î•º ÌÜµÌï¥ Îç∞Ïù¥ÌÑ∞Î•º ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî.</p>`;
                return;
            }

            const ganttEl = document.createElement('div');
            ganttEl.className = 'gantt-chart-container';

            const titlesPane = document.createElement('div');
            titlesPane.className = 'gantt-titles';

            if (savedSettings) {
                if (savedSettings.titlesPaneWidth) {
                    titlesPane.style.width = savedSettings.titlesPaneWidth;
                }
                if (savedSettings.columnWidths) {
                    titlesPane.style.setProperty('--po-col-width', savedSettings.columnWidths.po);
                    titlesPane.style.setProperty('--dates-col-width', savedSettings.columnWidths.dates);
                    titlesPane.style.setProperty('--progress-col-width', savedSettings.columnWidths.progress);
                }
            }

            const headerEl = document.createElement('div');
            headerEl.className = 'header flex items-center';
            headerEl.innerHTML = `
                <div class="flex items-center flex-grow pr-2">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-name">${columnVisibility['project-name'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">Î™ÖÏπ≠</span>
                </div>

                <div class="header-col justify-start items-center" style="width: var(--po-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-po">${columnVisibility['project-po'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">Ï†ïÏÇ∞</span>
                </div>
                <div class="col-resizer" data-col-left="po" data-col-right="dates"></div>
                <div class="header-col justify-start items-center" style="width: var(--dates-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-dates">${columnVisibility['project-dates'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">Í∏∞Í∞Ñ</span>
                </div>
                <div class="col-resizer" data-col-left="dates" data-col-right="progress"></div>
                <div class="header-col justify-start items-center" style="width: var(--progress-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-progress">${columnVisibility['project-progress'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">ÏßÑÌñâ</span>
                </div>
            `;
            titlesPane.appendChild(headerEl);

            const resizer = document.createElement('div');
            resizer.className = 'resizer';
            titlesPane.appendChild(resizer);

            const titlesBodyWrapper = document.createElement('div');
            titlesBodyWrapper.className = 'gantt-titles-body-wrapper';


            const timelineWrapper = document.createElement('div');
            timelineWrapper.className = 'gantt-timeline-wrapper';

            const timelineHeaderWrapper = document.createElement('div');
            timelineHeaderWrapper.className = 'gantt-timeline-header-wrapper';

            const timelineBodyWrapper = document.createElement('div');
            timelineBodyWrapper.className = 'gantt-timeline-body-wrapper';

            const timelineHeader = document.createElement('div');
            timelineHeader.className = 'gantt-timeline-header';
            const yearMonthHeader = document.createElement('div');
            yearMonthHeader.className = 'gantt-year-month-header';
            const dayHeader = document.createElement('div');
            dayHeader.className = 'gantt-day-header';
            const weekdayHeader = document.createElement('div');
            weekdayHeader.className = 'gantt-weekday-header';

            const totalDays = dateDiffInDays(viewMinDate, viewMaxDate);
            const timelineWidth = (totalDays + 1) * DAY_WIDTH;

            let currentMonth = -1, monthDayCount = 0, monthEl;
            const weekdays = ['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'];

            for (let i = 0; i <= totalDays; i++) {
                const date = new Date(viewMinDate);
                date.setDate(date.getDate() + i);
                const dayOfWeek = date.getDay();
                const isWeekendOrHoliday = dayOfWeek === 0 || dayOfWeek === 6 || isHoliday(date);

                if (date.getMonth() !== currentMonth) {
                    if (monthEl) monthEl.style.width = `${monthDayCount * DAY_WIDTH}px`;
                    currentMonth = date.getMonth();
                    monthDayCount = 0;
                    monthEl = document.createElement('div');
                    monthEl.className = 'gantt-month';
                    monthEl.textContent = `${date.getFullYear()}ÎÖÑ ${currentMonth + 1}Ïõî`;
                    yearMonthHeader.appendChild(monthEl);
                }
                monthDayCount++;

                const dayEl = document.createElement('div');
                dayEl.className = 'gantt-day';
                dayEl.style.width = `${DAY_WIDTH}px`;
                dayEl.textContent = date.getDate();
                if(isWeekendOrHoliday) {
                    dayEl.classList.add('bg-red-50', 'text-red-500', 'font-bold');
                } else if (dayOfWeek === 6) {
                    dayEl.classList.add('bg-gray-100');
                }
                dayHeader.appendChild(dayEl);

                const weekdayEl = document.createElement('div');
                weekdayEl.className = 'gantt-weekday';
                weekdayEl.style.width = `${DAY_WIDTH}px`;
                weekdayEl.textContent = weekdays[dayOfWeek];
                if (isWeekendOrHoliday) {
                    weekdayEl.classList.add('text-red-500', 'font-bold');
                }
                weekdayHeader.appendChild(weekdayEl);
            }
            if (monthEl) monthEl.style.width = `${monthDayCount * DAY_WIDTH}px`;

            timelineHeader.appendChild(yearMonthHeader);
            timelineHeader.appendChild(dayHeader);
            timelineHeader.appendChild(weekdayHeader);
            timelineHeader.style.width = `${timelineWidth}px`;

            const ganttBody = document.createElement('div');
            ganttBody.className = 'gantt-body';
            ganttBody.style.width = `${timelineWidth}px`;

            const gridAndMarkerContainer = document.createElement('div');
            gridAndMarkerContainer.style.position = 'absolute';
            gridAndMarkerContainer.style.top = '0';
            gridAndMarkerContainer.style.left = '0';
            gridAndMarkerContainer.style.width = '100%';
            gridAndMarkerContainer.style.height = '100%';
            gridAndMarkerContainer.style.zIndex = '1';

            for (let i = 0; i <= totalDays; i++) {
                const line = document.createElement('div');
                line.className = 'gantt-grid-line';
                line.style.left = `${i * DAY_WIDTH}px`;
                gridAndMarkerContainer.appendChild(line);
            }
            ganttBody.appendChild(gridAndMarkerContainer);

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (today >= viewMinDate && today <= viewMaxDate) {
                const todayOffsetDays = dateDiffInDays(viewMinDate, today);
                const todayLeftPosition = `${todayOffsetDays * DAY_WIDTH + (DAY_WIDTH/2)}px`;

                // Ìó§ÎçîÏùò "Ïò§Îäò" ÎßàÏª§ ÏÉùÏÑ±
                const headerMarkerContainer = document.createElement('div');
                headerMarkerContainer.className = 'gantt-today-marker-container';
                headerMarkerContainer.style.left = todayLeftPosition;
                headerMarkerContainer.style.height = '32px';
                headerMarkerContainer.style.bottom = 'auto';
                headerMarkerContainer.style.pointerEvents = 'none'; // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Î∞©ÏßÄ

                const headerMarkerLine = document.createElement('div');
                headerMarkerLine.className = 'gantt-today-marker';

                const markerLabel = document.createElement('div');
                markerLabel.className = 'gantt-today-label';
                markerLabel.textContent = 'Ïò§Îäò';

                headerMarkerContainer.appendChild(headerMarkerLine);
                headerMarkerContainer.appendChild(markerLabel);
                timelineHeaderWrapper.appendChild(headerMarkerContainer);

                // Î≥∏Î¨∏Ïùò "Ïò§Îäò" ÎßàÏª§ ÏÉùÏÑ±
                const bodyMarkerContainer = document.createElement('div');
                bodyMarkerContainer.className = 'gantt-today-marker-container';
                bodyMarkerContainer.style.left = todayLeftPosition;
                bodyMarkerContainer.style.zIndex = '3';
                bodyMarkerContainer.style.pointerEvents = 'none'; // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Î∞©ÏßÄ
                bodyMarkerContainer.style.position = 'absolute';
                bodyMarkerContainer.style.top = '0';
                bodyMarkerContainer.style.bottom = '0'; // Ï†ÑÏ≤¥ ÎÜíÏù¥ ÏÑ§Ï†ï

                const bodyMarkerLine = document.createElement('div');
                bodyMarkerLine.className = 'gantt-today-marker';
                bodyMarkerLine.style.height = '100%'; // Ïª®ÌÖåÏù¥ÎÑà Ï†ÑÏ≤¥ ÎÜíÏù¥ ÏÇ¨Ïö©
                
                bodyMarkerContainer.appendChild(bodyMarkerLine);
                ganttBody.appendChild(bodyMarkerContainer);
            }

            const titlesBody = document.createElement('div');
            const ganttRowsBody = document.createElement('div');

            const milestoneTrack = document.createElement('div');
            milestoneTrack.className = 'milestone-track';
            ganttBody.appendChild(milestoneTrack);
            titlesBody.innerHTML += `<div style="height: 40px; border-bottom: 1px solid #e2e8f0;"></div>`;

            milestones.forEach(m => {
                const mDate = parseLocalDateString(m.date);
                if (mDate && viewMinDate && viewMaxDate && mDate >= viewMinDate && mDate <= viewMaxDate) {
                    const offset = dateDiffInDays(viewMinDate, mDate);
                    const marker = document.createElement('div');
                    marker.className = 'milestone-marker';
                    marker.style.left = `${offset * DAY_WIDTH + (DAY_WIDTH / 2)}px`;
                    // ÎßàÏùºÏä§ÌÜ§ ÌëúÏãúÎ•º YYYY-MM-DD ÌòïÏãùÏúºÎ°úÎßå ÌëúÏãú

                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.innerHTML = `<strong>${m.name}</strong><br>${formatDateYMD(mDate)}`;
                    marker.setAttribute('title', `${m.name} (${formatDateYMD(mDate)})`);
                    marker.appendChild(tooltip);

                    milestoneTrack.appendChild(marker);
                }
            });

            ganttBody.appendChild(ganttRowsBody);

            const groupedData = data.reduce((acc, project) => {
                (acc[project.taskType] = acc[project.taskType] || []).push(project);
                return acc;
            }, {});

            // Ï†ÑÏ≤¥ Í≥ÑÏ∏µ(Í∑∏Î£π Î∞è ÌïòÏúÑ ÌîÑÎ°úÏ†ùÌä∏)Ïóê Ï†ÅÏö©ÎêòÎäî Ï†ïÎ†¨ Î°úÏßÅ
            // - groups: Í∑∏Î£π ÎåÄÌëúÍ∞í(ÏµúÏÜå ÏãúÏûëÏùº, ÏµúÎåÄ Ï¢ÖÎ£åÏùº, Ï¥ù Í∏∞Í∞Ñ, Í∞ÄÏ§ë ÏßÑÏ≤ô Îì±)ÏùÑ ÏÇ¨Ïö©Ìï¥ Ï†ïÎ†¨
            // - projects: Í∞Å Í∑∏Î£π ÎÇ¥ÏóêÏÑúÎèÑ ÎèôÏùºÌïú Ï†ïÎ†¨ Í∏∞Ï§ÄÏùÑ Ï†ÅÏö©
            const sortMode = sortBy ? sortBy.value : 'default';

            // Compute stats per group to allow group-level sorting
            const groupStats = {};
            Object.keys(groupedData).forEach(taskType => {
                const projects = groupedData[taskType];
                let minStart = null, maxEnd = null, totalDuration = 0, totalPo = 0, weightedProgressSum = 0;
                projects.forEach(p => {
                    if (p.startDate && !isNaN(p.startDate)) {
                        if (minStart === null || p.startDate < minStart) minStart = p.startDate;
                    }
                    if (p.endDate && !isNaN(p.endDate)) {
                        if (maxEnd === null || p.endDate > maxEnd) maxEnd = p.endDate;
                    }
                    const dur = (p.startDate && p.endDate && !isNaN(p.startDate) && !isNaN(p.endDate)) ? (dateDiffInDays(p.startDate, p.endDate) + 1) : 0;
                    totalDuration += dur;
                    const po = p.poAmount || 0;
                    totalPo += po;
                    weightedProgressSum += (p.progress || 0) * po;
                });
                const groupProgress = totalPo > 0 ? Math.round(weightedProgressSum / totalPo) : 0;
                groupStats[taskType] = { minStart, maxEnd, totalDuration, totalPo, groupProgress };
            });

            // Decide comparator for groups based on sortMode
            let groupComparator;
            switch (sortMode) {
                case 'startDate':
                    groupComparator = (a, b) => {
                        const aDate = groupStats[a].minStart ? +groupStats[a].minStart : Number.POSITIVE_INFINITY;
                        const bDate = groupStats[b].minStart ? +groupStats[b].minStart : Number.POSITIVE_INFINITY;
                        return aDate - bDate;
                    };
                    break;
                case 'endDate':
                    groupComparator = (a, b) => {
                        const aDate = groupStats[a].maxEnd ? +groupStats[a].maxEnd : Number.POSITIVE_INFINITY;
                        const bDate = groupStats[b].maxEnd ? +groupStats[b].maxEnd : Number.POSITIVE_INFINITY;
                        return aDate - bDate;
                    };
                    break;
                case 'duration':
                    groupComparator = (a, b) => groupStats[b].totalDuration - groupStats[a].totalDuration; // longer first
                    break;
                case 'progress':
                    groupComparator = (a, b) => groupStats[b].groupProgress - groupStats[a].groupProgress; // higher progress first
                    break;
                default:
                    groupComparator = (a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' });
            }

            // Sort groups (task types) according to comparator
            const sortedTaskTypes = Object.keys(groupedData).sort((a, b) => groupComparator(a, b));

            // Also sort projects within each group using same sortMode
            Object.keys(groupedData).forEach(taskType => {
                const projects = groupedData[taskType];
                projects.sort((p1, p2) => {
                    switch (sortMode) {
                        case 'startDate':
                            return (p1.startDate ? +p1.startDate : Number.POSITIVE_INFINITY) - (p2.startDate ? +p2.startDate : Number.POSITIVE_INFINITY);
                        case 'endDate':
                            return (p1.endDate ? +p1.endDate : Number.POSITIVE_INFINITY) - (p2.endDate ? +p2.endDate : Number.POSITIVE_INFINITY);
                        case 'duration':
                            const d1 = (p1.startDate && p1.endDate) ? (dateDiffInDays(p1.startDate, p1.endDate) + 1) : 0;
                            const d2 = (p2.startDate && p2.endDate) ? (dateDiffInDays(p2.startDate, p2.endDate) + 1) : 0;
                            return d2 - d1; // longer first
                        case 'progress':
                            return (p2.progress || 0) - (p1.progress || 0); // higher first
                        default:
                            return 0; // keep original order
                    }
                });
            });
            const searchTerm = (searchInput?.value || '');

            const typesToExpand = new Set();
            if (searchTerm || legendStatusFilter) {
                data.forEach(p => {
                    typesToExpand.add(p.taskType);
                });
            }

            sortedTaskTypes.forEach(taskType => {
                const projects = groupedData[taskType];
                if (projects.length === 0) return;

                let groupTotalPo = 0;
                let groupWeightedProgressSum = 0;
                projects.forEach(p => {
                    groupWeightedProgressSum += (p.progress || 0) * (p.poAmount || 0);
                    groupTotalPo += (p.poAmount || 0);
                });
                const groupProgress = groupTotalPo > 0 ? Math.round(groupWeightedProgressSum / groupTotalPo) : 0;

                const groupPoSum = projects.reduce((sum, p) => sum + (p.poAmount || 0), 0);
                const formattedGroupPoSum = formatCurrency(groupPoSum);
                const groupMinDate = new Date(Math.min(...projects.map(p => p.startDate.getTime())));
                const groupMaxDate = new Date(Math.max(...projects.map(p => p.endDate.getTime())));

                const isInitiallyOpen = (searchTerm || legendStatusFilter) ? typesToExpand.has(taskType) : openTaskGroups.has(taskType);

                const allProjectsInGroupCompleted = projects.every(p => p.progress === 100);
                const groupCompletedClass = allProjectsInGroupCompleted ? 'text-gray-400 line-through' : '';

                const groupHeader = document.createElement('div');
                groupHeader.className = 'group-header';
                groupHeader.style.display = 'flex';
                groupHeader.style.justifyContent = 'space-between';
                groupHeader.style.alignItems = 'center';
                groupHeader.innerHTML = `
                    <div class="flex-grow whitespace-nowrap overflow-hidden text-ellipsis pr-2 ${groupCompletedClass}">
                        <span class="group-toggle">${isInitiallyOpen ? '[-]' : '[+]'}</span> üìÇ ${taskType} (${projects.length}Í±¥ / ${formattedGroupPoSum})
                    </div>
                     <div class="flex items-center flex-shrink-0">
                        <div class="project-po justify-end" style="width: var(--po-col-width); display: ${columnVisibility['project-po'] ? '' : 'none'}"></div>
                        <div class="project-dates group-dates-summary justify-center ${groupCompletedClass}" style="width: var(--dates-col-width); margin: 0; display: ${columnVisibility['project-dates'] ? 'flex' : 'none'};">
                            <span class="font-semibold">${formatDate(groupMinDate)}</span>
                            <span class="mx-1">~</span>
                            <span class="font-semibold">${formatDate(groupMaxDate)}</span>
                        </div>
                        <div class="project-progress font-bold text-right pr-2.5 ${groupCompletedClass}" style="width: var(--progress-col-width); display: ${columnVisibility['project-progress'] ? '' : 'none'}">${groupProgress}%</div>
                    </div>
                `;
                titlesBody.appendChild(groupHeader);

                const groupBarRow = document.createElement('div');
                groupBarRow.className = 'gantt-bar-row';
                ganttRowsBody.appendChild(groupBarRow);

                const groupDuration = dateDiffInDays(groupMinDate, groupMaxDate) + 1;
                const groupOffset = dateDiffInDays(viewMinDate, groupMinDate);
                const groupBar = document.createElement('div');
                const groupColor = getGroupProgressColor(groupProgress);
                groupBar.className = 'gantt-bar';
                if(isInitiallyOpen) groupBar.classList.add('hidden');
                groupBar.style.backgroundColor = groupColor;
                groupBar.style.height = '10px';
                groupBar.style.top = '11px';
                groupBar.style.left = `${groupOffset * DAY_WIDTH}px`;
                groupBar.style.width = `${Math.max(1, groupDuration) * DAY_WIDTH - 2}px`;
                groupBar.style.borderRadius = '2px';
                groupBar.style.opacity = '1';

                const groupTooltip = document.createElement('div');
                groupTooltip.className = 'tooltip';
                groupTooltip.innerHTML = `<strong>${taskType} (ÏöîÏïΩ)</strong><br><strong>Í∏∞Í∞Ñ:</strong> ${groupMinDate.toLocaleDateString()} ~ ${groupMaxDate.toLocaleDateString()} (${groupDuration}Ïùº)<br><strong>Ï¥ù ${projects.length}Í∞ú ÌîÑÎ°úÏ†ùÌä∏</strong>`;
                groupBar.appendChild(groupTooltip);
                groupBarRow.appendChild(groupBar);

                if (groupProgress > 0) {
                    const groupProgressFill = document.createElement('div');
                    groupProgressFill.className = 'gantt-bar-progress';
                    if (isInitiallyOpen) groupProgressFill.classList.add('hidden');
                    groupProgressFill.style.left = `${groupOffset * DAY_WIDTH}px`;
                    const groupBarWidth = Math.max(1, groupDuration) * DAY_WIDTH - 2;
                    groupProgressFill.style.width = `${groupBarWidth * (groupProgress / 100)}px`;
                    groupProgressFill.style.top = '11px';
                    groupProgressFill.style.height = '10px';
                    groupBarRow.appendChild(groupProgressFill);
                }

                const groupContainer = document.createElement('div');
                groupContainer.className = 'group-item-container';
                if(!isInitiallyOpen) groupContainer.classList.add('hidden');
                titlesBody.appendChild(groupContainer);

                const childBarRowsContainer = document.createElement('div');
                 if(!isInitiallyOpen) childBarRowsContainer.classList.add('hidden');
                ganttRowsBody.appendChild(childBarRowsContainer);

                projects.forEach(p => {
                    let displayName = p.name;
                    if (searchTerm) {
                        const regex = new RegExp(searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
                        displayName = displayName.replace(regex, match => `<span class="search-highlight">${match}</span>`);
                    }

                    const completedClass = p.progress === 100 ? 'text-gray-400 line-through' : '';

                    const titleItem = document.createElement('div');
                    titleItem.className = 'title-item';
                    titleItem.dataset.projectId = p.id;
                    titleItem.innerHTML = `
                        <span class="project-name ${completedClass}" style="display: ${columnVisibility['project-name'] ? '' : 'none'}" title="${p.name}">${displayName}</span>
                        <div class="flex items-center flex-shrink-0">
                            <span class="project-po ${completedClass}" style="width: var(--po-col-width); display: ${columnVisibility['project-po'] ? '' : 'none'}">${formatCurrency(p.poAmount)}</span>
                            <div class="project-dates ${completedClass}" style="width: var(--dates-col-width); margin: 0; display: ${columnVisibility['project-dates'] ? 'flex' : 'none'}">
                                <span class="date-editor start-date" data-project-id="${p.id}" data-date-type="startDate">${formatDate(p.startDate)}</span>
                                <span>~</span>
                                <span class="date-editor end-date" data-project-id="${p.id}" data-date-type="endDate">${formatDate(p.endDate)}</span>
                            </div>
                            <span class="project-progress" style="width: var(--progress-col-width); display: ${columnVisibility['project-progress'] ? '' : 'none'}">
                               <span class="progress-editor" data-project-id="${p.id}">${p.progress || 0}%</span>
                            </span>
                        </div>
                    `;
                    groupContainer.appendChild(titleItem);

                    const barRow = document.createElement('div');
                    barRow.className = 'gantt-bar-row';
                    barRow.dataset.projectId = p.id;
                    childBarRowsContainer.appendChild(barRow);

                    const duration = dateDiffInDays(p.startDate, p.endDate) + 1;
                    const offset = dateDiffInDays(viewMinDate, p.startDate);

                    const barWidth = Math.max(1, duration) * DAY_WIDTH - 4;
                    const barLeft = offset * DAY_WIDTH;

                    const bar = document.createElement('div');
                    const barColorClass = statusColors[p.status] || statusColors['default'];
                    bar.className = `gantt-bar ${barColorClass}`;
                    bar.style.left = `${barLeft}px`;
                    bar.style.width = `${barWidth}px`;

                    if (p.endDate < today && p.status !== 'ÏôÑÎ£å') {
                        bar.style.opacity = '0.7';
                    }

                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';

                    let customFieldsHTML = '';
                    if (p.customFields) {
                        for(const key in p.customFields){
                            if(p.customFields[key]) {
                                customFieldsHTML += `<strong>${key}:</strong> ${p.customFields[key]}<br>`;
                            }
                        }
                    }

                    tooltip.innerHTML = `<strong>${p.name}</strong><br>
                                       <strong>ÏßÑÌñâ:</strong> ${p.progress || 0}%<br>
                                       <strong>Í∏∞Í∞Ñ:</strong> ${p.startDate.toLocaleDateString()} ~ ${p.endDate.toLocaleDateString()} (${duration}Ïùº)<br>
                                       <strong>ÏÉÅÌÉú:</strong> ${p.status}<br>
                                       ${customFieldsHTML}`;
                    bar.appendChild(tooltip);
                    barRow.appendChild(bar);

                    if ((p.progress || 0) > 0) {
                        const progressFill = document.createElement('div');
                        progressFill.className = 'gantt-bar-progress';
                        progressFill.style.left = `${barLeft}px`;
                        progressFill.style.width = `${barWidth * (p.progress / 100)}px`;
                        barRow.appendChild(progressFill);
                    }
                });

                groupHeader.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isNowCollapsed = groupContainer.classList.toggle('hidden');
                    childBarRowsContainer.classList.toggle('hidden', isNowCollapsed);
                    groupBar.classList.toggle('hidden', !isNowCollapsed);

                    const progressFill = groupBarRow.querySelector('.gantt-bar-progress');
                    if(progressFill) {
                        progressFill.classList.toggle('hidden', !isNowCollapsed);
                    }

                    if (isNowCollapsed) {
                        groupHeader.querySelector('.group-toggle').textContent = '[+]';
                        openTaskGroups.delete(taskType);
                    } else {
                        groupHeader.querySelector('.group-toggle').textContent = '[-]';
                        openTaskGroups.add(taskType);
                    }
                    setTimeout(() => {
                        updateLayoutSync();
                        // Recompute today marker height after group expand/collapse
                        try {
                            const containerRef = fullscreenModal.classList.contains('hidden') 
                                ? document.getElementById('ganttViewContent') 
                                : fullscreenModalBody;
                            recomputeTodayMarkerHeight(containerRef);
                        } catch (e) {
                            // ignore
                        }
                    }, 300);
                });
            });

            titlesBodyWrapper.appendChild(titlesBody);
            titlesPane.appendChild(titlesBodyWrapper);

            timelineWrapper.appendChild(timelineHeaderWrapper);
            timelineWrapper.appendChild(timelineBodyWrapper);

            timelineHeaderWrapper.appendChild(timelineHeader);
            timelineBodyWrapper.appendChild(ganttBody);

            ganttEl.appendChild(titlesPane);
            ganttEl.appendChild(timelineWrapper);

            currentGanttContainer.appendChild(ganttEl);

            setTimeout(updateLayoutSync, 0);

            const finalTitlesBodyWrapper = ganttEl.querySelector('.gantt-titles-body-wrapper');
            const finalTimelineHeaderWrapper = ganttEl.querySelector('.gantt-timeline-header-wrapper');
            const finalTimelineBodyWrapper = ganttEl.querySelector('.gantt-timeline-body-wrapper');

             if (finalTimelineBodyWrapper && finalTitlesBodyWrapper && finalTimelineHeaderWrapper) {
                // Í∞úÏÑ†ÏÇ¨Ìï≠ 2: Ïä§ÌÅ¨Î°§ ÎèôÍ∏∞Ìôî Î∞è Ïó¥ Íµ¨Î∂ÑÏÑ† Ï†ïÎ†¨ Í≤ÄÏ¶ù
                let scrollTimeout;
                finalTimelineBodyWrapper.addEventListener('scroll', () => {
                    // ÏàòÏßÅ/ÏàòÌèâ Ïä§ÌÅ¨Î°§ ÎèôÍ∏∞Ìôî
                    finalTitlesBodyWrapper.scrollTop = finalTimelineBodyWrapper.scrollTop;
                    finalTimelineHeaderWrapper.scrollLeft = finalTimelineBodyWrapper.scrollLeft;
                    
                    // Ïä§ÌÅ¨Î°§ Ï§ëÏóêÎäî ÎßàÏª§ Ìà¨Î™ÖÎèÑÎ•º ÎÇÆÏ∂§
                    const markers = document.querySelectorAll('.gantt-today-marker-container');
                     markers.forEach(marker => {
                         const line = marker.querySelector('.gantt-today-marker');
                         if (line) line.style.opacity = '0.5';
                         // ÎùºÎ≤®Ïùò Ìà¨Î™ÖÎèÑÎäî Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏäµÎãàÎã§.
                     });
                    
                    // Ïä§ÌÅ¨Î°§ ÏôÑÎ£å ÌõÑ ÎßàÏª§ Ïû¨Í≥ÑÏÇ∞ Î∞è Ìà¨Î™ÖÎèÑ Î≥µÏõê
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const containerRef = fullscreenModal.classList.contains('hidden') 
                            ? document.getElementById('ganttViewContent') 
                            : fullscreenModalBody;
                        recomputeTodayMarkerHeight(containerRef);
                        
                        // Ïó¥ Íµ¨Î∂ÑÏÑ† Ï†ïÎ†¨ ÏÉÅÌÉú Í≤ÄÏ¶ù (ÎîîÎ∞îÏö¥Ïä§ Ï†ÅÏö©)
                        if (!finalTimelineBodyWrapper.alignmentTimeout) {
                            finalTimelineBodyWrapper.alignmentTimeout = setTimeout(() => {
                                verifyTimelineAlignment();
                                finalTimelineBodyWrapper.alignmentTimeout = null;
                            }, 100);
                        }
                    }, 150); // Ïä§ÌÅ¨Î°§ ÏôÑÎ£å ÌõÑ ÏßÄÏó∞ ÏãúÍ∞Ñ
                });                 // Modify the wheel event listener for the timeline body
                finalTimelineBodyWrapper.addEventListener('wheel', (e) => {
                    // Prevent default only if scrolling horizontally or if the default scroll wouldn't do anything
                    if (e.deltaX !== 0 || (e.deltaY !== 0 && (timelineBodyWrapper.scrollHeight <= timelineBodyWrapper.clientHeight))) {
                       e.preventDefault();
                    }
                    // Always allow vertical scroll propagation if possible
                    finalTimelineBodyWrapper.scrollTop += e.deltaY;
                    finalTimelineBodyWrapper.scrollLeft += e.deltaX; // Allow horizontal scroll with wheel if applicable
                }, { passive: false });


                const scrollbarWidth = finalTimelineBodyWrapper.offsetWidth - finalTimelineBodyWrapper.clientWidth;
                finalTimelineHeaderWrapper.style.paddingRight = `${scrollbarWidth}px`;
            }

            ganttEl.querySelectorAll('.title-item').forEach(titleItem => {
                const projectId = titleItem.dataset.projectId;
                if (!projectId) return;

                const barRow = ganttEl.querySelector(`.gantt-bar-row[data-project-id="${projectId}"]`);
                if (!barRow) return;
                const highlight = () => { titleItem.classList.add('row-hover'); barRow.classList.add('row-hover'); };
                const unhighlight = () => { titleItem.classList.remove('row-hover'); barRow.classList.remove('row-hover'); };
                titleItem.addEventListener('mouseenter', highlight);
                titleItem.addEventListener('mouseleave', unhighlight);
                barRow.addEventListener('mouseenter', highlight);
                barRow.addEventListener('mouseleave', unhighlight);
            });

             // Add legend click listeners specifically for the current view
             const currentLegendContainer = container.querySelector('#legendSection');
             if (currentLegendContainer) {
                 currentLegendContainer.querySelectorAll('[data-status-filter]').forEach(item => {
                     item.removeEventListener('click', handleLegendClickEvent); // Remove previous listener
                     item.addEventListener('click', handleLegendClickEvent); // Add new one
                 });
             }
        }

         // Separate event handler function for legend clicks
         function handleLegendClickEvent(e) {
             handleLegendClick(e.currentTarget);
         }


        function updateLayoutSync() {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (!container) return;

            const titlesBodyWrapper = container.querySelector('.gantt-titles-body-wrapper');
            const titlesBody = titlesBodyWrapper ? titlesBodyWrapper.querySelector('div') : null; // The actual scrolling div
            const timelineBodyWrapper = container.querySelector('.gantt-timeline-body-wrapper');
            const bodyTodayMarker = container.querySelector('.gantt-body > .gantt-today-marker-container');
            const ganttBody = container.querySelector('.gantt-body');

            if (!titlesBody || !timelineBodyWrapper || !ganttBody) return;

            // **Í∞úÏÑ† ÏÇ¨Ìï≠ 1: 'Ïò§Îäò' Ï†êÏÑ† ÎÜíÏù¥ ÎèôÏ†Å Ï†úÌïú**
            if (bodyTodayMarker) {
                recomputeTodayMarkerHeight(container);
            }

            // Sync scrollbar spacer
            const oldSpacer = titlesBody.querySelector('.scrollbar-spacer');
            if (oldSpacer) oldSpacer.remove();

            const scrollbarHeight = timelineBodyWrapper.offsetHeight - timelineBodyWrapper.clientHeight;
            if (scrollbarHeight > 0) {
                const spacer = document.createElement('div');
                spacer.className = 'scrollbar-spacer';
                spacer.style.height = `${scrollbarHeight}px`;
                titlesBody.appendChild(spacer);
            }
        }

        // ÌòÑÏû¨ Î≥¥Ïù¥Îäî ÎßàÏßÄÎßâ ÌñâÏùò Ï†ïÏ§ëÏïôÍπåÏßÄÎßå 'Ïò§Îäò' Ï†êÏÑ† ÌëúÏãú
        // Í∞úÏÑ†ÏÇ¨Ìï≠ 2&3: ÌÉÄÏûÑÎùºÏù∏ Ï†ïÎ†¨ Í≤ÄÏ¶ù Î∞è Ï≤òÎ¶¨ Ìï®Ïàò
        function verifyTimelineAlignment() {
            const timelineHeader = document.querySelector('.gantt-timeline-header');
            const ganttBody = document.querySelector('.gantt-body');
            if (!timelineHeader || !ganttBody) return;

            const headerGridLines = Array.from(timelineHeader.querySelectorAll('.gantt-day')).map(day => {
                const rect = day.getBoundingClientRect();
                return Math.round(rect.left);
            });
            
            const bodyGridLines = Array.from(ganttBody.querySelectorAll('.gantt-grid-line')).map(line => {
                const rect = line.getBoundingClientRect();
                return Math.round(rect.left);
            });

            const threshold = 1; // 1ÌîΩÏÖÄ Ïù¥ÎÇ¥Ïùò Ïò§Ï∞®Îäî ÌóàÏö©
            const isAligned = headerGridLines.every((headerPos, index) => {
                const bodyPos = bodyGridLines[index];
                return Math.abs(headerPos - bodyPos) <= threshold;
            });

            if (!isAligned) {
                showTimelineAlignmentWarning();
            }
        }

        function showTimelineAlignmentWarning() {
            const zoomBtn = document.getElementById('zoomBtn');
            if (!zoomBtn) return;

            const warningClass = 'bg-yellow-200';
            if (!zoomBtn.classList.contains(warningClass)) {
                zoomBtn.classList.add(warningClass);
                showToast('ÎÇ†Ïßú ÏÑ§Ï†ïÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏó¨ Ïó¥ Íµ¨Î∂ÑÏÑ†ÏùÑ Ï†ïÎ†¨Ìï¥Ï£ºÏÑ∏Ïöî.', 'warning');
                
                // ÏûêÎèôÏúºÎ°ú Ï§å ÌåùÏò§Î≤Ñ ÌëúÏãú
                if (zoomPopover && zoomPopover.classList.contains('hidden')) {
                    toggleZoomPopover(zoomBtn);
                }
            }
        }

        function recomputeTodayMarkerHeight(container) {
            const wrapper = container.querySelector('.gantt-timeline-body-wrapper');
            const ganttBody = container.querySelector('.gantt-body');
            const marker = container.querySelector('.gantt-body > .gantt-today-marker-container');
            if (!wrapper || !ganttBody || !marker) return;
        
            const markerLine = marker.querySelector('.gantt-today-marker');
        
            // Î™®Îì† ÏûëÏóÖ Ìï≠Î™©(ÌéºÏ≥êÏßÑ Í≤ÉÍ≥º Ï†ëÌûå Í≤É Î™®Îëê)ÏùÑ Í∞ÄÏ†∏Ïò¥
            const allItems = Array.from(ganttBody.querySelectorAll('.gantt-bar-row'));
            const visibleItems = allItems.filter(item => {
                // ÌñâÏù¥ Î≥¥Ïù¥Î†§Î©¥, Ìï¥Îãπ ÏöîÏÜåÏôÄ Í∑∏ Î™®Îì† Î∂ÄÎ™® ÏöîÏÜåÎì§Ïù¥ 'hidden' ÌÅ¥ÎûòÏä§Î•º Í∞ÄÏßÄÍ≥† ÏûàÏßÄ ÏïäÏïÑÏïº Ìï©ÎãàÎã§.
                let el = item;
                while(el && el !== ganttBody) {
                    if (el.classList.contains('hidden')) return false;
                    el = el.parentElement;
                }
                return true;
            });
            
            // Í≥ÑÏ∏µ Íµ¨Ï°∞Î•º Í≥†Î†§ÌïòÏó¨ ÎßàÏßÄÎßâ ÌëúÏãú Ìï≠Î™©ÏùÑ Ï∞æÏùå
            const lastVisibleItem = visibleItems[visibleItems.length - 1];
        
            if (lastVisibleItem) {
                const ganttBodyRect = ganttBody.getBoundingClientRect();
                const lastItemRect = lastVisibleItem.getBoundingClientRect();
                
                // ÎßàÏßÄÎßâÏúºÎ°ú Î≥¥Ïù¥Îäî Ìï≠Î™©Ïùò Ï§ëÍ∞Ñ ÏßÄÏ†êÍπåÏßÄÏùò ÎÜíÏù¥Î•º Í≥ÑÏÇ∞Ìï©ÎãàÎã§.
                const heightToMiddle = (lastItemRect.top - ganttBodyRect.top) + (lastItemRect.height / 2);
                marker.style.height = `${heightToMiddle}px`;
            }

            // Ïä§ÌÅ¨Î°§ Ïãú ÎßàÏª§Ïùò Í∞ÄÏãúÏÑ± ÌôïÏù∏
            const todayOffset = parseInt(marker.style.left);
            const scrollLeft = wrapper.scrollLeft;
            const clientWidth = wrapper.clientWidth;
        
            // Í∞ÄÏãú ÏòÅÏó≠Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥† Ìà¨Î™ÖÎèÑ Ï°∞Ï†ï
            if (todayOffset >= scrollLeft && todayOffset <= scrollLeft + clientWidth) {
                marker.style.opacity = '1';
                if (markerLine) markerLine.style.opacity = '1';
            } else {
                // ÌôîÎ©¥ Î∞ñÏóê ÏûàÏùÑ ÎïåÎäî ÏïΩÍ∞Ñ Ìà¨Î™ÖÌïòÍ≤å Ï≤òÎ¶¨
                if (markerLine) markerLine.style.opacity = '0.5';
            }
        }

        // Make a table sortable by clicking on headers. Adds small ‚ñ≤/‚ñº indicators.
        function makeTableSortable(table) {
            if (!table) return;
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            if (!thead || !tbody) return;

            const ths = Array.from(thead.querySelectorAll('th'));
            ths.forEach((th, colIndex) => {
                // add sort indicator
                let indicator = th.querySelector('.sort-indicator');
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'sort-indicator ml-2 text-xs';
                    indicator.style.cursor = 'pointer';
                    th.appendChild(indicator);
                }

                th.style.userSelect = 'none';
                th.addEventListener('click', () => {
                    const currentDir = th.dataset.sortDir || 'none';
                    const newDir = currentDir === 'asc' ? 'desc' : 'asc';
                    // reset all
                    ths.forEach(t => { t.dataset.sortDir = ''; const si = t.querySelector('.sort-indicator'); if (si) si.textContent = ''; });
                    th.dataset.sortDir = newDir;
                    indicator.textContent = newDir === 'asc' ? '‚ñ≤' : '‚ñº';

                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const cellValues = rows.map(r => {
                        const cell = r.children[colIndex];
                        return cell ? cell.textContent.trim() : '';
                    });

                    // detect numeric or date
                    const isNumeric = cellValues.every(v => v === '' || /^[-+]?\d{1,3}(?:[,\d]{0,}|\d*)(?:\.\d+)?(?:%|Ïõê)?$/.test(v.replace(/\s/g,'')));
                    const isDate = cellValues.every(v => parseLocalDateString(v) instanceof Date && !isNaN(parseLocalDateString(v)?.getTime()));

                    rows.sort((a, b) => {
                        const va = a.children[colIndex] ? a.children[colIndex].textContent.trim() : '';
                        const vb = b.children[colIndex] ? b.children[colIndex].textContent.trim() : '';
                        let resa = va, resb = vb;
                        if (isNumeric) {
                            const numA = parseFloat(va.replace(/[,%Ïõê\s]/g, '')) || 0;
                            const numB = parseFloat(vb.replace(/[,%Ïõê\s]/g, '')) || 0;
                            resa = numA; resb = numB;
                        } else if (isDate) {
                            const da = parseLocalDateString(va); const db = parseLocalDateString(vb);
                            resa = da ? +da : 0; resb = db ? +db : 0;
                        } else {
                            resa = va.toLowerCase(); resb = vb.toLowerCase();
                        }

                        if (resa < resb) return newDir === 'asc' ? -1 : 1;
                        if (resa > resb) return newDir === 'asc' ? 1 : -1;
                        return 0;
                    });

                    // Re-attach rows in sorted order
                    rows.forEach(r => tbody.appendChild(r));
                });
            });
        }

        function exportTableToXLSX(tableElement, filename = 'export.xlsx') {
            if (!tableElement) return;
            try {
                // Use direct table->sheet conversion
                const ws = XLSX.utils.table_to_sheet(tableElement);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
                XLSX.writeFile(wb, filename);
            } catch (e) {
                console.error('exportTableToXLSX error', e);
                showToast('ÌÖåÏù¥Î∏îÏùÑ ÏóëÏÖÄÎ°ú ÎÇ¥Î≥¥ÎÇ¥Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', 'error');
            }
        }


        function makeResizable(modalContentElement) {
            const resizers = modalContentElement.querySelectorAll('.resizer-handle');
            let original_width = 0, original_height = 0, original_x = 0, original_y = 0, original_mouse_x = 0, original_mouse_y = 0;

            resizers.forEach(resizer => {
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const rect = modalContentElement.getBoundingClientRect();
                    original_width = rect.width;
                    original_height = rect.height;
                    original_x = rect.left;
                    original_y = rect.top;
                    original_mouse_x = e.pageX;
                    original_mouse_y = e.pageY;
                    const direction = resizer.dataset.direction;

                    const overlay = modalContentElement.parentElement;
                    if (overlay.style.justifyContent !== 'flex-start') {
                        overlay.style.justifyContent = 'flex-start';
                        overlay.style.alignItems = 'flex-start';
                        modalContentElement.style.left = `${rect.left}px`;
                        modalContentElement.style.top = `${rect.top}px`;
                        modalContentElement.style.margin = '0';
                    }

                    function resize(e) {
                        if (direction.includes('e')) {
                            const width = original_width + (e.pageX - original_mouse_x);
                            if (width > 400) modalContentElement.style.width = width + 'px';
                        }
                        if (direction.includes('s')) {
                             const height = original_height + (e.pageY - original_mouse_y);
                             if (height > 300) modalContentElement.style.height = height + 'px';
                        }
                         if (direction.includes('w')) {
                            const width = original_width - (e.pageX - original_mouse_x);
                            if (width > 400) {
                                modalContentElement.style.width = width + 'px';
                                modalContentElement.style.left = original_x + (e.pageX - original_mouse_x) + 'px';
                            }
                        }
                        if (direction.includes('n')) {
                            const height = original_height - (e.pageY - original_mouse_y);
                            if (height > 300) {
                                modalContentElement.style.height = height + 'px';
                                modalContentElement.style.top = original_y + (e.pageY - original_mouse_y) + 'px';
                            }
                        }
                    }

                    function stopResize() {
                        window.removeEventListener('mousemove', resize);
                        window.removeEventListener('mouseup', stopResize);
                    }
                    window.addEventListener('mousemove', resize);
                    window.addEventListener('mouseup', stopResize);
                });
            });
        }

        function makeDraggable(modalContent, handle) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

            handle.style.cursor = 'move';
            handle.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;

                const overlay = modalContent.parentElement;
                if (overlay.style.justifyContent !== 'flex-start') {
                    const rect = modalContent.getBoundingClientRect();
                    overlay.style.justifyContent = 'flex-start';
                    overlay.style.alignItems = 'flex-start';
                    modalContent.style.left = `${rect.left}px`;
                    modalContent.style.top = `${rect.top}px`;
                    modalContent.style.margin = '0';
                }

                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                modalContent.style.top = (modalContent.offsetTop - pos2) + "px";
                modalContent.style.left = (modalContent.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        makeResizable(fullscreenModalContent);
        makeResizable(dataDetailModal.querySelector('.modal-content'));

        const dataDetailModalContent = dataDetailModal.querySelector('.modal-content');
        makeDraggable(dataDetailModalContent, dataDetailModalContent.querySelector('.resizable-modal-header'));
        makeDraggable(fullscreenModalContent, fullscreenModalContent.querySelector('.resizable-modal-header'));

        // Make milestone modal resizable & draggable
        const milestoneModalContent = milestoneModal.querySelector('.modal-content');
        if (milestoneModalContent) {
            makeResizable(milestoneModalContent);
            const milestoneHeader = milestoneModalContent.querySelector('.resizable-modal-header');
            if (milestoneHeader) makeDraggable(milestoneModalContent, milestoneHeader);
        }

        function downloadTemplate(format) {
            const templateData = [
                {
                    'No': '1', 'ID': 'A-001', 'ÏûëÏóÖ Ïú†Ìòï': 'Í≥µÌÜµ', 'Í≥†Í∞ùÏÇ¨': 'Í≥†Í∞ùÏÇ¨ A', 'Î™ÖÏπ≠': 'ÌîÑÎ°úÏ†ùÌä∏ ÏòàÏãú 1', 'Î∞úÏ£º Ïú†Ìòï': 'ÏùºÎ∞ò', 'ÏÉÅÌÉú': 'Ï∞©Í≥µÏ†Ñ', 'ÏãúÏûëÏùº': '2025-01-01', 'Ï¢ÖÎ£åÏùº': '2025-01-31', 'Ï†ïÏÇ∞': '50000000', 'ÏßÑÌñâÎ•†': '0'
                },
                {
                    'No': '2', 'ID': 'B-002', 'ÏûëÏóÖ Ïú†Ìòï': 'Í±¥Ï∂ï', 'Í≥†Í∞ùÏÇ¨': 'Í≥†Í∞ùÏÇ¨ B', 'Î™ÖÏπ≠': 'ÌîÑÎ°úÏ†ùÌä∏ ÏòàÏãú 2', 'Î∞úÏ£º Ïú†Ìòï': 'Í∏¥Í∏â', 'ÏÉÅÌÉú': 'Í≥µÏÇ¨Ï§ë', 'ÏãúÏûëÏùº': '2025-02-15', 'Ï¢ÖÎ£åÏùº': '2025-03-20', 'Ï†ïÏÇ∞': '120000000', 'ÏßÑÌñâÎ•†': '50%'
                }
            ];
            const wsData = [
                ["[Îç∞Ïù¥ÌÑ∞ ÏñëÏãù ÏÑ§Î™Ö]"],
                ["No", "ID", "ÏûëÏóÖ Ïú†Ìòï", "Í≥†Í∞ùÏÇ¨", "Î™ÖÏπ≠", "Î∞úÏ£º Ïú†Ìòï", "ÏÉÅÌÉú", "ÏãúÏûëÏùº", "Ï¢ÖÎ£åÏùº", "Ï†ïÏÇ∞"],
                ["(Ïà´Ïûê)", "(Î¨∏Ïûê, Í≥†Ïú†Í∞í)", "(Î¨∏Ïûê)", "(Î¨∏Ïûê, ÌïÑÏàò)", "(Î¨∏Ïûê)", "(Ï∞©Í≥µÏ†Ñ/Í≥µÏÇ¨Ï§ë/ÏôÑÎ£å)", "(YYYY-MM-DD, ÌïÑÏàò)", "(YYYY-MM-DD, ÌïÑÏàò)", "(Ïà´Ïûê, ÏΩ§Îßà Ï†úÏô∏)"],
            ];
            wsData[1].push('ÏßÑÌñâÎ•†');
            wsData[2].push('(Ïà´Ïûê ÎòêÎäî %)');
            const sheet = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.sheet_add_json(sheet, templateData, { origin: "A4", skipHeader: true });

            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, sheet, "Project Data");

            // Add milestone sample sheet for XLSX
            const milestoneSample = [
                ['No', 'ÎßàÏùºÏä§ÌÜ§', 'ÎÇ†Ïßú'],
                [1, 'ÌîÑÎ°úÏ†ùÌä∏ ÌÇ•Ïò§ÌîÑ', '2025-01-15']
            ];
            const msSheet = XLSX.utils.aoa_to_sheet(milestoneSample);

            if (format === 'xlsx') {
                XLSX.utils.book_append_sheet(workbook, msSheet, 'ÎßàÏùºÏä§ÌÜ§');
                const fileName = `gantt_template.${format}`;
                XLSX.writeFile(workbook, fileName);
                showToast(`"${fileName}" ÏñëÏãù ÌååÏùº Îã§Ïö¥Î°úÎìúÎ•º ÏãúÏûëÌï©ÎãàÎã§.`, 'info');
            } else if (format === 'csv') {
                // For CSV, generate two separate CSV files: projects template and milestone template
                const projectsCsv = XLSX.utils.sheet_to_csv(sheet);
                const milestoneCsv = XLSX.utils.sheet_to_csv(msSheet);

                // helper to download plain text as file
                const downloadText = (content, name) => {
                    // Prepend UTF-8 BOM to help Excel on Windows recognize UTF-8 encoding
                    const bomPrefixed = '\uFEFF' + content;
                    const blob = new Blob([bomPrefixed], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };

                const dateSuffix = new Date().toISOString().slice(0,10);
                downloadText(projectsCsv, `gantt_template_projects_${dateSuffix}.csv`);
                // small delay to ensure browser processing of consecutive downloads
                setTimeout(() => {
                    downloadText(milestoneCsv, `gantt_template_milestones_${dateSuffix}.csv`);
                }, 150);
                showToast('CSV ÏñëÏãù ÌååÏùº(ÌîÑÎ°úÏ†ùÌä∏, ÎßàÏùºÏä§ÌÜ§) Îã§Ïö¥Î°úÎìúÎ•º ÏãúÏûëÌï©ÎãàÎã§.', 'info');
            } else {
                const fileName = `gantt_template.${format}`;
                XLSX.writeFile(workbook, fileName);
                showToast(`"${fileName}" ÏñëÏãù ÌååÏùº Îã§Ïö¥Î°úÎìúÎ•º ÏãúÏûëÌï©ÎãàÎã§.`, 'info');
            }
        }

        /**
         * [IMPROVED FUNCTION] ÌòÑÏû¨ ÎåÄÏãúÎ≥¥Îìú ÏÉÅÌÉúÎ•º ÏÉàÎ°úÏö¥ ÎèÖÎ¶Ω Ïã§ÌñâÌòï HTML ÌååÏùºÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.
         * Ïù¥ Ìï®ÏàòÎäî Î™®Îì† Ï†ÄÏû• Í¥ÄÎ†® Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÍ∏∞ ÏúÑÌïú ÌïµÏã¨ ÏàòÏ†ï ÏÇ¨Ìï≠ÏûÖÎãàÎã§.
         * @returns {void}
         */
        function saveAsStandaloneHTML() {
            if (projectData.length === 0 && milestones.length === 0) {
                showToast("Ï†ÄÏû•Ìï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.", 'warning');
                return;
            }

            // [FIX] DOM Ï°∞Ïûë Ï†ÑÏóê Îç∞Ïù¥ÌÑ∞Î•º ÏßÅÎ†¨ÌôîÌïòÏó¨ Íπ®ÎÅóÌïú ÏÉÅÌÉúÎ•º Î≥¥Ïû•Ìï©ÎãàÎã§.
            // ÎÇ†ÏßúÎäî ÏïàÏ†ïÏ†ÅÏù∏ ÏßÅÎ†¨ÌôîÎ•º ÏúÑÌï¥ ISO Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôòÎê©ÎãàÎã§.
            const toYMD = (d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            const dataToEmbed = projectData.map(p => {
                // [FIX] ÎÇ†ÏßúÍ∞Ä Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ ÌõÑ Î≥ÄÌôòÌï©ÎãàÎã§. Î∞òÎìúÏãú Î°úÏª¨ Í∏∞Ï§Ä YYYY-MM-DD ÌòïÏãùÏúºÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.
                const startDateStr = (p.startDate instanceof Date && !isNaN(p.startDate)) ? toYMD(p.startDate) : (p.startDateStr || '');
                const endDateStr = (p.endDate instanceof Date && !isNaN(p.endDate)) ? toYMD(p.endDate) : (p.endDateStr || '');
                return {
                    ...p,
                    startDate: startDateStr,
                    endDate: endDateStr,
                };
            });

            const customFiltersState = {};
            document.querySelectorAll('#controlsPanel #customFilterContainer select').forEach(sel => {
                customFiltersState[sel.dataset.filterKey] = sel.value;
            });
            
            // Î∞îÎ°úÍ∞ÄÍ∏∞ ÏÑ§Ï†ï Ï†ÄÏû•
            const pinnedShortcutsArray = Array.from(pinnedShortcuts);

            const currentTitlesPane = document.querySelector('.gantt-titles');
            const settlementOpenFields = Array.from(document.querySelectorAll('.main-settlement-accordion-item')).map(el => {
                const hdr = el.querySelector('.main-settlement-header h3');
                // Remove the visual bullet prefix '‚ñ† ' if present to get the field name
                const text = hdr ? hdr.textContent.replace(/^‚ñ†\s*/, '').trim() : null;
                return el.classList.contains('expanded') && text ? text : null;
            }).filter(Boolean);

            // [Í∞úÏÑ† ÏÇ¨Ìï≠ 2] Ï†ÄÏû• Ïãú Î™®Îì† UI ÏÉÅÌÉúÏôÄ ÏÑ§Ï†ïÏùÑ Ìè¨Ìï®ÌïòÎèÑÎ°ù Í∞úÏÑ†
            const settings = { 
                openTaskGroups: Array.from(openTaskGroups),
                columnVisibility: columnVisibility,
                filters: {
                    progress: progressFilter ? progressFilter.value : 'all',
                    taskType: taskTypeFilter ? taskTypeFilter.value : 'all',
                    sort: sortBy ? sortBy.value : 'default',
                    search: searchInput ? searchInput.value : '',
                    customFilters: customFiltersState,
                },
                titlesPaneWidth: currentTitlesPane ? currentTitlesPane.style.width : null,
                columnWidths: currentTitlesPane ? {
                    po: getComputedStyle(currentTitlesPane).getPropertyValue('--po-col-width'),
                    dates: getComputedStyle(currentTitlesPane).getPropertyValue('--dates-col-width'),
                    progress: getComputedStyle(currentTitlesPane).getPropertyValue('--progress-col-width'),
                } : null,
                viewMinDate: viewMinDate ? toYMD(viewMinDate) : null,
                viewMaxDate: viewMaxDate ? toYMD(viewMaxDate) : null,
                pinnedShortcuts: Array.from(pinnedShortcuts),
                controlsPanelOpen: !controlsPanel.classList.contains('translate-x-full'),
                controlSections: Array.from(document.querySelectorAll('#controlsPanel .control-section-header')).map(header => ({
                    id: header.id || header.querySelector('h3').textContent.trim(),
                    isOpen: header.classList.contains('open')
                })),
                timelineScrollLeft: document.querySelector('.gantt-timeline-body-wrapper')?.scrollLeft || 0,
                timelineScrollTop: document.querySelector('.gantt-timeline-body-wrapper')?.scrollTop || 0
                , // Ï†ïÏÇ∞ ÏïÑÏΩîÎîîÏñ∏ ÏÉÅÌÉú Ï†ÄÏû•
                settlementOpenFields: settlementOpenFields,
                autoUploadUrl: (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL,
                autoUploadEnabled: !!(autoUploadEnabled && autoUploadEnabled.checked)
            };

            // Milestone modal state (position/size and open state)
            try {
                const mmOverlay = document.getElementById('milestoneModal');
                const mmContent = mmOverlay ? mmOverlay.querySelector('.modal-content') : null;
                settings.milestoneModalOpen = mmOverlay ? !mmOverlay.classList.contains('hidden') : false;
                if (mmContent) {
                    // Capture inline style values if present (left/top/width/height)
                    settings.milestoneModalStyle = {
                        left: mmContent.style.left || null,
                        top: mmContent.style.top || null,
                        width: mmContent.style.width || null,
                        height: mmContent.style.height || null,
                        overlayJustify: mmOverlay ? mmOverlay.style.justifyContent || null : null,
                        overlayAlign: mmOverlay ? mmOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.milestoneModalStyle = null;
                }
            } catch (e) {
                console.warn('milestone modal state capture failed', e);
            }

            // Data Detail modal state
            try {
                const ddOverlay = document.getElementById('dataDetailModal');
                const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                settings.dataDetailModalOpen = ddOverlay ? !ddOverlay.classList.contains('hidden') : false;
                if (ddContent) {
                    settings.dataDetailModalStyle = {
                        left: ddContent.style.left || null,
                        top: ddContent.style.top || null,
                        width: ddContent.style.width || null,
                        height: ddContent.style.height || null,
                        overlayJustify: ddOverlay ? ddOverlay.style.justifyContent || null : null,
                        overlayAlign: ddOverlay ? ddOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.dataDetailModalStyle = null;
                }
            } catch (e) {
                console.warn('data detail modal state capture failed', e);
            }

            // Data Detail modal state
            try {
                const ddOverlay = document.getElementById('dataDetailModal');
                const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                settings.dataDetailModalOpen = ddOverlay ? !ddOverlay.classList.contains('hidden') : false;
                if (ddContent) {
                    settings.dataDetailModalStyle = {
                        left: ddContent.style.left || null,
                        top: ddContent.style.top || null,
                        width: ddContent.style.width || null,
                        height: ddContent.style.height || null,
                        overlayJustify: ddOverlay ? ddOverlay.style.justifyContent || null : null,
                        overlayAlign: ddOverlay ? ddOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.dataDetailModalStyle = null;
                }
            } catch (e) {
                console.warn('data detail modal state capture failed', e);
            }

            // Í∞ïÎ†•Ìïú Î©îÏÑúÎìúÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏµúÏ¢Ö HTML Î¨∏ÏûêÏó¥ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
            const htmlContent = generateStandaloneHTML(dataToEmbed, milestones, settings);

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gantt_dashboard_${new Date().toISOString().slice(0,10)}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast("HTML ÌååÏùºÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.", 'success');
        }

        /**
         * [NEW & IMPROVED] Ï†ÄÏû•ÏùÑ ÏúÑÌïú ÏµúÏ¢Ö HTML ÏΩòÌÖêÏ∏† Î¨∏ÏûêÏó¥ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
         * Ïù¥ Ìï®ÏàòÎäî Îã§Ï§ë Ï†ÄÏû• Î¨∏Ï†ú Ìï¥Í≤∞Ïùò ÌïµÏã¨ÏûÖÎãàÎã§. Î¨∏ÏÑúÏùò Î¨∏ÏûêÏó¥ ÌëúÌòÑÏóê ÎåÄÌï¥ ÏûëÎèôÌïòÏó¨
         * Îü∞ÌÉÄÏûÑ ÏïÑÌã∞Ìå©Ìä∏Í∞Ä Ï†ÄÏû•Îêú ÌååÏùºÏùÑ ÏÜêÏÉÅÏãúÌÇ§ÏßÄ ÏïäÎèÑÎ°ù Ìï©ÎãàÎã§.
         * @param {Array} data - Ìè¨Ìï®Ìï† ÌîÑÎ°úÏ†ùÌä∏ Îç∞Ïù¥ÌÑ∞.
         * @param {Array} milestonesToEmbed - Ìè¨Ìï®Ìï† ÎßàÏùºÏä§ÌÜ§ Îç∞Ïù¥ÌÑ∞.
         * @param {Object} settings - Ìè¨Ìï®Ìï† UI/ÏÉÅÌÉú ÏÑ§Ï†ï.
         * @returns {string} ÎèÖÎ¶Ω Ïã§ÌñâÌòï ÌååÏùºÏùÑ ÏúÑÌïú Ï†ÑÏ≤¥ HTML.
         */
        function generateStandaloneHTML(data, milestonesToEmbed, settings) {
            // 1. Ï†ÑÏ≤¥ Î¨∏ÏÑúÏùò HTMLÏùÑ Î¨∏ÏûêÏó¥Î°ú Í∞ÄÏ†∏ÏòµÎãàÎã§.
            let html = document.documentElement.outerHTML;

            // 2. [FIX] Ï§ëÏöî ÏàòÏ†ï: ÏÉà Îç∞Ïù¥ÌÑ∞Î•º Ï∂îÍ∞ÄÌïòÍ∏∞ Ï†ÑÏóê Ïù¥Ï†Ñ Ï†ÄÏû•ÏóêÏÑú Ï°¥Ïû¨Ìï† Ïàò ÏûàÎäî
            // Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ïä§ÌÅ¨Î¶ΩÌä∏Î•º Ï†úÍ±∞Ìï©ÎãàÎã§. Ïù¥Îäî Îç∞Ïù¥ÌÑ∞ Ï§ëÎ≥µ Î∞è ÏÜêÏÉÅÏùÑ Î∞©ÏßÄÌï©ÎãàÎã§.
            // Ï†ïÍ∑úÏãùÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ïù¥Ï†Ñ Ïä§ÌÅ¨Î¶ΩÌä∏ Î∏îÎ°ùÏùÑ Ï∞æÏïÑ Ï†úÍ±∞Ìï©ÎãàÎã§.
            html = html.replace(/<script>window\.embeddedData\s*=\s*[\s\S]*?;<\/script>/, '');
            html = html.replace(/<script>window\.embeddedMilestones\s*=\s*[\s\S]*?;<\/script>/, '');
            html = html.replace(/<script>window\.embeddedSettings\s*=\s*[\s\S]*?;<\/script>/, '');
            html = html.replace(/<script>window\.isStandalone\s*=\s*true;<\/script>/, '');

            // 3. Ï£ºÏûÖÌï† ÏÉà Îç∞Ïù¥ÌÑ∞Î•º Ï§ÄÎπÑÌï©ÎãàÎã§.
            const dataScript = `<script>window.embeddedData = ${JSON.stringify(data, null, 2)};<\/script>`;
            const milestonesScript = `<script>window.embeddedMilestones = ${JSON.stringify(milestonesToEmbed, null, 2)};<\/script>`;
            const settingsScript = `<script>window.embeddedSettings = ${JSON.stringify(settings, null, 2)};<\/script>`;
            const standaloneMarkerScript = `<script>window.isStandalone = true;<\/script>`;

            // 4. HTML Î¨∏ÏûêÏó¥Ïùò ÌîåÎ†àÏù¥Ïä§ÌôÄÎçîÎ•º ÏÉà Îç∞Ïù¥ÌÑ∞ Ïä§ÌÅ¨Î¶ΩÌä∏Î°ú ÍµêÏ≤¥Ìï©ÎãàÎã§.
            // Ïù¥Îäî Îß§Î≤à Íπ®ÎÅóÌïòÍ≥† ÏòàÏ∏° Í∞ÄÎä•Ìïú Ï£ºÏûÖÏùÑ Î≥¥Ïû•Ìï©ÎãàÎã§.
            html = html.replace('<!-- EMBEDDED_DATA_PLACEHOLDER -->', dataScript);
            html = html.replace('<!-- EMBEDDED_MILESTONES_PLACEHOLDER -->', milestonesScript);
            html = html.replace('<!-- EMBEDDED_SETTINGS_PLACEHOLDER -->', settingsScript + standaloneMarkerScript);

            return `<!DOCTYPE html>\n` + html; // [FIX] DoctypeÏùÑ Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÌï©ÎãàÎã§.
        }

        function renderMilestoneModal() {
            milestoneList.innerHTML = '';
            
            // Ï†ÄÏû•Îêú Î™®Îã¨ ÏÉÅÌÉú Î≥µÏõê
            if (savedSettings && savedSettings.milestoneModalStyle) {
                const modalContent = milestoneModal.querySelector('.modal-content');
                const s = savedSettings.milestoneModalStyle;
                if (modalContent) {
                    if (s.width) modalContent.style.width = s.width;
                    if (s.height) modalContent.style.height = s.height;
                    if (s.left) modalContent.style.left = s.left;
                    if (s.top) modalContent.style.top = s.top;
                }
                if (s.overlayJustify) milestoneModal.style.justifyContent = s.overlayJustify;
                if (s.overlayAlign) milestoneModal.style.alignItems = s.overlayAlign;
            }

            if (milestones.length === 0) {
                milestoneList.innerHTML = `<p class="text-center text-gray-500">Îì±Î°ùÎêú ÎßàÏùºÏä§ÌÜ§Ïù¥ ÏóÜÏäµÎãàÎã§.</p>`;
            } else {
                milestones.sort((a,b) => new Date(a.date) - new Date(b.date)).forEach((m, index) => {
                    const item = document.createElement('div');
                    item.className = 'flex items-center justify-between p-2 border-b';
                    item.innerHTML = `
                        <div>
                            <span class="font-semibold">${m.name}</span>
                            <span class="text-sm text-gray-500 ml-2">${m.date}</span>
                        </div>
                        <button data-index="${index}" class="delete-milestone-btn text-red-500 hover:text-red-700">ÏÇ≠Ï†ú</button>
                    `;
                    milestoneList.appendChild(item);
                });
            }
        }

        function handleAddMilestone(e) {
            e.preventDefault();
            const dateInput = document.getElementById('milestoneDate');
            const nameInput = document.getElementById('milestoneName');

            if (dateInput.value && nameInput.value) {
                // ÏûÖÎ†•Îêú ÎÇ†ÏßúÎ•º ÌååÏã±ÌïòÍ≥† 1ÏùºÏùÑ Ï∂îÍ∞Ä
                const inputDate = new Date(dateInput.value + 'T00:00:00');
                inputDate.setDate(inputDate.getDate() + 1);
                
                // YYYY-MM-DD ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
                const adjustedDate = 
                    inputDate.getFullYear() + '-' +
                    String(inputDate.getMonth() + 1).padStart(2, '0') + '-' +
                    String(inputDate.getDate()).padStart(2, '0');

                milestones.push({ date: adjustedDate, name: nameInput.value });
                updateAndApplyDateRange();
                renderMilestoneModal();
                render();
                showToast('ÎßàÏùºÏä§ÌÜ§Ïù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.', 'success');
                
                // Í∞úÏÑ†ÏÇ¨Ìï≠: Ìèº Î¶¨ÏÖã ÏãúÏóêÎèÑ ÏÉÅÌÉú Î≥¥Ï°¥ÏùÑ ÏúÑÌï¥ Í∞í Ï†ÄÏû•
                const savedDateValue = dateInput.value;
                const savedNameValue = nameInput.value;
                addMilestoneForm.reset();
                
                // Í∞úÏÑ†ÏÇ¨Ìï≠: Ï†ÄÏû•Îêú Í∞íÏúºÎ°ú Î≥µÏõê (ÏÇ¨Ïö©Ïûê Ìé∏ÏùòÏÑ±)
                if (savedDateValue) dateInput.value = savedDateValue;
                if (savedNameValue) nameInput.value = savedNameValue;
                
                if(projectData.length > 0 || milestones.length > 0){
                    saveHtmlBtn.disabled = false;
                    saveMessage.classList.remove('hidden');
                }
            }
        }

        function handleMilestoneListClick(e) {
            if (e.target.classList.contains('delete-milestone-btn')) {
                const index = parseInt(e.target.dataset.index, 10);
                milestones.splice(index, 1);
                updateAndApplyDateRange();
                renderMilestoneModal();
                render();
                showToast('ÎßàÏùºÏä§ÌÜ§Ïù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.', 'info');
                 if(projectData.length === 0 && milestones.length === 0){
                    saveHtmlBtn.disabled = true;
                    saveMessage.classList.add('hidden');
                }
            }
        }

        function initDefaultPinnedShortcuts() {
            // Í∏∞Î≥∏ Î∞îÎ°úÍ∞ÄÍ∏∞ ÏàúÏÑú ÏÑ§Ï†ï
            const defaultPinnedControls = [
                'goToTodayBtn',          // Ïò§Îäò
                'customer-filter',        // Í≥†Í∞ùÏÇ¨
                'contractor-filter',      // ÏãúÍ≥µÏÇ¨
                'expandAllBtn',          // ÌéºÏπòÍ∏∞
                'collapseAllBtn',        // Ï†ëÍ∏∞
                'sortBy',                // Ï†ïÎ†¨
                'progressFilter',         // ÏßÑÏ≤ôÎ•†
                'taskTypeFilter',        // Ïú†Ìòï
                'zoomBtn'                // ÎÇ†Ïßú ÏÑ§Ï†ï
            ];
            
            // Í∏∞Ï°¥ ÌïÄ Ï¥àÍ∏∞Ìôî
            pinnedShortcuts.clear();
            
            // ÏÉàÎ°úÏö¥ ÌïÄ ÏÑ§Ï†ï
            defaultPinnedControls.forEach(id => {
                pinnedShortcuts.add(id);
            });
            
            // Î∞îÎ°úÍ∞ÄÍ∏∞ Î©îÎâ¥ ÏóÖÎç∞Ïù¥Ìä∏
            updateShortcuts();
        }

        function initializeDashboard() {
            if (window.isStandalone) {
                dataPanel.classList.add('hidden');

                const shouldBeOpen = window.embeddedSettings && window.embeddedSettings.controlsPanelOpen === true;
                if (!shouldBeOpen) {
                    controlsPanel.classList.add('translate-x-full');
                    controlsPanelOverlay.classList.add('hidden');
                }
            }

            const controlsPanelEl = document.getElementById('controlsPanel');
            if (controlsPanelEl && !controlsPanelEl.hasAttribute('data-pin-listener-attached')) {
                controlsPanelEl.addEventListener('click', function(e) {
                    const pinBtn = e.target.closest('.pin-shortcut-btn');
                    if (!pinBtn) return;
                    
                    e.stopPropagation();
                    const controlId = pinBtn.dataset.controlId;
                    if (!controlId) return;

                    if (pinnedShortcuts.has(controlId)) {
                        pinnedShortcuts.delete(controlId);
                    } else {
                        pinnedShortcuts.add(controlId);
                    }
                    
                    updateShortcuts();
                    
                    showToast(pinnedShortcuts.has(controlId) ? 
                        'Î∞îÎ°úÍ∞ÄÍ∏∞Í∞Ä Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.' : 
                        'Î∞îÎ°úÍ∞ÄÍ∏∞Í∞Ä Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§.', 
                        'info'
                    );
                });
                
                controlsPanelEl.setAttribute('data-pin-listener-attached', 'true');
            }

            updateControlReferences();


             const initialLegendSection = document.getElementById('legendSection');
             if (initialLegendSection) {
                 initialLegendSection.querySelectorAll('[data-status-filter]').forEach(item => {
                     item.addEventListener('click', handleLegendClickEvent);
                 });
             }


            if (window.embeddedData) {
                const parsedData = window.embeddedData.map(p => ({
                    ...p,
                    startDate: p.startDate ? parseLocalDateString(p.startDate) : null,
                    endDate: p.endDate ? parseLocalDateString(p.endDate) : null,
                    startDateStr: p.startDate,
                    endDateStr: p.endDate
                }));
                projectData = parsedData.filter(p => p && p.startDate && p.endDate && p.taskType && !isNaN(p.startDate) && !isNaN(p.endDate) && p.id);

                // Normalize custom field keys in loaded embedded data: sanitize keys and populate display name map
                projectData.forEach(p => {
                    if (p.customFields) {
                        const newCustom = {};
                        Object.keys(p.customFields).forEach(origKey => {
                            const safe = sanitizeKey(origKey);
                            if (safe) {
                                newCustom[safe] = p.customFields[origKey];
                                customFieldDisplayNames[safe] = customFieldDisplayNames[safe] || origKey;
                            }
                        });
                        p.customFields = newCustom;
                    }
                });
            }

            if (window.embeddedMilestones) {
                milestones = window.embeddedMilestones;
            }

            updateAndApplyDateRange();

            if (window.embeddedSettings) {
                savedSettings = window.embeddedSettings;
                openTaskGroups = new Set(savedSettings.openTaskGroups || []);
                columnVisibility = savedSettings.columnVisibility || columnVisibility;
                pinnedShortcuts = new Set(savedSettings.pinnedShortcuts || []);
                // Ensure pinnable controls and header shortcuts are rendered and synchronized
                // even if the controls panel is closed when loading the standalone file.
                try {
                    // This will add pin buttons to control wrappers and render shortcut items
                    if (typeof setupPinnableControls === 'function') setupPinnableControls();
                    if (typeof updateShortcuts === 'function') updateShortcuts();
                    // Sync values from original controls into shortcut clones if needed
                    if (typeof syncShortcutsFromOriginal === 'function') syncShortcutsFromOriginal();
                } catch (e) {
                    console.warn('Shortcut initialization failed during restore:', e);
                }
                
                if(savedSettings.filters) {
                    if(progressFilter) progressFilter.value = savedSettings.filters.progress;
                    if(taskTypeFilter) taskTypeFilter.value = savedSettings.filters.taskType;
                    if(sortBy) sortBy.value = savedSettings.filters.sort;
                    if(searchInput && savedSettings.filters.search) {
                        searchInput.value = savedSettings.filters.search;
                    }
                    if (savedSettings.filters.customFilters) {
                        // populateFilters Ïù¥ÌõÑÏóê Ï†ÅÏö©Îê† Í≤ÉÏûÖÎãàÎã§.
                    }
                }

                if (savedSettings.viewMinDate && savedSettings.viewMaxDate) {
                    const parseLocalDateStringForSettings = (s) => {
                        try {
                            const parts = String(s).split('-');
                            if (parts.length >= 3) return new Date(parseInt(parts[0],10), parseInt(parts[1],10)-1, parseInt(parts[2],10));
                        } catch (e) {}
                        return new Date(s);
                    };
                    viewMinDate = parseLocalDateStringForSettings(savedSettings.viewMinDate);
                    viewMaxDate = parseLocalDateStringForSettings(savedSettings.viewMaxDate);
                }

                // Ïª®Ìä∏Î°§ Ìå®ÎÑê ÏÉÅÌÉú Î≥µÏõê
                const shouldBeOpen = savedSettings.controlsPanelOpen === true;
                if (shouldBeOpen) {
                    controlsPanel.classList.remove('translate-x-full');
                    controlsPanelOverlay.classList.remove('hidden');
                } else {
                    controlsPanel.classList.add('translate-x-full');
                    controlsPanelOverlay.classList.add('hidden');
                }
                
                // Ïª®Ìä∏Î°§ ÏÑπÏÖò ÏÉÅÌÉú Î≥µÏõê
                if (savedSettings.controlSections) {
                    savedSettings.controlSections.forEach(section => {
                        const header = document.querySelector(`#controlsPanel .control-section-header[id="${section.id}"]`) || 
                                     Array.from(document.querySelectorAll('#controlsPanel .control-section-header'))
                                          .find(h => h.querySelector('h3').textContent.trim() === section.id);
                        if (header) {
                            if (section.isOpen) {
                                header.classList.add('open');
                                const content = header.nextElementSibling;
                                if (content && content.classList.contains('control-section-content')) {
                                    content.style.maxHeight = '1000px';
                                    content.style.paddingTop = '0.5rem';
                                    content.style.paddingBottom = '0.5rem';
                                }
                            } else {
                                header.classList.remove('open');
                                const content = header.nextElementSibling;
                                if (content && content.classList.contains('control-section-content')) {
                                    content.style.maxHeight = '0';
                                    content.style.paddingTop = '0';
                                    content.style.paddingBottom = '0';
                                }
                            }
                        }
                    });
                }

                setTimeout(() => {
                    const timelineWrapper = document.querySelector('.gantt-timeline-body-wrapper');
                    if (timelineWrapper) {
                        timelineWrapper.scrollLeft = savedSettings.timelineScrollLeft || 0;
                        timelineWrapper.scrollTop = savedSettings.timelineScrollTop || 0;
                    }

                }, 100);

                // Restore milestone modal position/size and open state if present
                try {
                    const mmOverlay = document.getElementById('milestoneModal');
                    const mmContent = mmOverlay ? mmOverlay.querySelector('.modal-content') : null;
                    if (savedSettings.milestoneModalStyle && mmContent) {
                        const s = savedSettings.milestoneModalStyle;
                        if (s.width) mmContent.style.width = s.width;
                        if (s.height) mmContent.style.height = s.height;
                        if (s.left) mmContent.style.left = s.left;
                        if (s.top) mmContent.style.top = s.top;
                        if (s.overlayJustify && mmOverlay) mmOverlay.style.justifyContent = s.overlayJustify;
                        if (s.overlayAlign && mmOverlay) mmOverlay.style.alignItems = s.overlayAlign;
                    }
                    if (typeof savedSettings.milestoneModalOpen !== 'undefined' && mmOverlay) {
                        if (savedSettings.milestoneModalOpen) mmOverlay.classList.remove('hidden');
                        else mmOverlay.classList.add('hidden');
                    }
                } catch (e) {
                    console.warn('milestone modal restore failed', e);
                }

                // Restore data detail modal position/size and open state if present
                try {
                    const ddOverlay = document.getElementById('dataDetailModal');
                    const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                    if (savedSettings.dataDetailModalStyle && ddContent) {
                        const s = savedSettings.dataDetailModalStyle;
                        if (s.width) ddContent.style.width = s.width;
                        if (s.height) ddContent.style.height = s.height;
                        if (s.left) ddContent.style.left = s.left;
                        if (s.top) ddContent.style.top = s.top;
                        if (s.overlayJustify && ddOverlay) ddOverlay.style.justifyContent = s.overlayJustify;
                        if (s.overlayAlign && ddOverlay) ddOverlay.style.alignItems = s.overlayAlign;
                    }
                    if (typeof savedSettings.dataDetailModalOpen !== 'undefined' && ddOverlay) {
                        if (savedSettings.dataDetailModalOpen) ddOverlay.classList.remove('hidden');
                        else ddOverlay.classList.add('hidden');
                    }
                } catch (e) {
                    console.warn('data detail modal restore failed', e);
                }
            }

            // Î≥µÏõê: ÏûêÎèô ÏóÖÎ°úÎìú URL Î∞è ÌôúÏÑ±Ìôî ÏÉÅÌÉú
            try {
                if (savedSettings && savedSettings.autoUploadUrl) {
                    if (autoUploadUrlInput) autoUploadUrlInput.value = savedSettings.autoUploadUrl;
                } else {
                    if (autoUploadUrlInput) autoUploadUrlInput.value = DEFAULT_AUTO_UPLOAD_URL;
                }

                // Í∏∞Î≥∏Í∞í: ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú ÏûêÎèô Î∂àÎü¨Ïò§Í∏∞ ON
                if (savedSettings && typeof savedSettings.autoUploadEnabled !== 'undefined') {
                    if (autoUploadEnabled) autoUploadEnabled.checked = !!savedSettings.autoUploadEnabled;
                } else {
                    if (autoUploadEnabled) autoUploadEnabled.checked = true; // Ï¥àÍ∏∞ Í∏∞Î≥∏Í∞íÏùÑ Ïº¨
                }
            } catch (e) {
                console.warn('auto upload restore error', e);
            }

            // ÌéòÏù¥ÏßÄ Ï¥àÍ∏∞ Î°úÎìú Ïãú ÏûêÎèô ÏóÖÎ°úÎìú ÏãúÎèÑ (Ïò®ÎùºÏù∏Ïù¥Î©¥)
            setTimeout(() => {
                try {
                    // [FIX] ÎèÖÎ¶Ω Ïã§ÌñâÌòï ÌååÏùºÏù¥ ÏïÑÎãê ÎïåÎßå ÏûêÎèô ÏóÖÎ°úÎìúÎ•º ÏãúÎèÑÌï©ÎãàÎã§.
                    if (window.isStandalone) return;
                    if (autoUploadEnabled && autoUploadEnabled.checked) {
                        const url = (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL;
                        if (url) {
                            fetchAndImportFromUrl(url).catch(err => {
                                console.warn('auto upload failed', err);
                                showToast('ÏûêÎèô ÏóÖÎ°úÎî©Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. (Ïò§ÌîÑÎùºÏù∏ ÎòêÎäî ÌååÏùº ÏóÜÏùå)', 'warning');
                            });
                        }
                    }
                } catch (e) {
                    console.warn('auto upload init error', e);
                }
            }, 600);

            // Î≤ÑÌäº Î¶¨Ïä§ÎÑà: ÏßÄÍ∏à Î∂àÎü¨Ïò§Í∏∞
            if (autoUploadNowBtn) {
                autoUploadNowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const url = (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL;
                    if (!url) {
                        showToast('ÏûêÎèô ÏóÖÎ°úÎî© URLÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.', 'warning');
                        return;
                    }
                    fetchAndImportFromUrl(url).catch(err => {
                        console.warn('manual auto upload failed', err);
                        showToast('ÌååÏùºÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.', 'error');
                    });
                });
            }
            if (projectData.length > 0 || milestones.length > 0) {
                 saveHtmlBtn.disabled = false;
                 exportToExcelBtn.disabled = false;
                 exportToCsvBtn.disabled = false;
                 saveMessage.classList.remove('hidden');
            }

            function exportData(format = 'xlsx') {
                if (projectData.length === 0) {
                    showToast('ÎÇ¥Î≥¥ÎÇº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.', 'warning');
                    return;
                }
                const workbook = XLSX.utils.book_new();

                // Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏãúÌä∏ Ï§ÄÎπÑ
                const mainData = projectData.map((item, index) => ({
                    'No': index + 1,
                    'ID': item.id || '',
                    'ÏûëÏóÖ Ïú†Ìòï': item.taskType || '',
                    'Î™ÖÏπ≠': item.name || '',
                    'ÏÉÅÌÉú': item.status || '',
                    'ÏãúÏûëÏùº': item.startDateStr || '',
                    'Ï¢ÖÎ£åÏùº': item.endDateStr || '',
                    'ÏßÑÌñâÎ•†': item.progress || 0,
                    'Ï†ïÏÇ∞': item.poAmount || 0,
                    ...Object.entries(item.customFields || {}).reduce((acc, [key, value]) => {
                        acc[customFieldDisplayNames[key] || key] = value;
                        return acc;
                    }, {})
                }));

                // Î©îÏù∏ Îç∞Ïù¥ÌÑ∞ ÏãúÌä∏ Ï∂îÍ∞Ä
                const mainSheet = XLSX.utils.json_to_sheet(mainData);
                XLSX.utils.book_append_sheet(workbook, mainSheet, 'ÏûëÏóÖ Î™©Î°ù');

                // ÎßàÏùºÏä§ÌÜ§ Îç∞Ïù¥ÌÑ∞ ÏãúÌä∏ Ï∂îÍ∞Ä (ÎßàÏùºÏä§ÌÜ§Ïù¥ ÏûàÎäî Í≤ΩÏö∞)
                let milestoneSheet = null;
                if (milestones.length > 0) {
                    const milestoneData = milestones.map((item, index) => ({
                        'No': index + 1,
                        'ÎßàÏùºÏä§ÌÜ§': item.name,
                        'ÎÇ†Ïßú': item.date
                    }));
                    milestoneSheet = XLSX.utils.json_to_sheet(milestoneData);
                    XLSX.utils.book_append_sheet(workbook, milestoneSheet, 'ÎßàÏùºÏä§ÌÜ§');
                }

                // ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏãúÌä∏ Ï∂îÍ∞Ä
                const statsData = [];
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                // Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
                const notStartedCount = projectData.filter(p => (p.progress || 0) === 0 && p.status !== 'ÏßÄÏó∞').length;
                const inProgressCount = projectData.filter(p => p.progress > 0 && p.progress < 100 && p.status !== 'ÏßÄÏó∞').length;
                const completedCount = projectData.filter(p => p.progress === 100).length;
                const delayedCount = projectData.filter(p => p.status === 'ÏßÄÏó∞').length;

                let totalPo = 0;
                let weightedProgressSum = 0;
                projectData.forEach(p => {
                    weightedProgressSum += (p.progress || 0) * (p.poAmount || 0);
                    totalPo += (p.poAmount || 0);
                });

                const overallProgressRate = totalPo > 0 ? Math.round(weightedProgressSum / totalPo * 100) / 100 : 0;

                statsData.push(
                    ['Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ', ''],
                    ['Ï¥ù Í±¥Ïàò', projectData.length],
                    ['Ï∞©Í≥µÏ†Ñ', notStartedCount],
                    ['ÏßÑÌñâÏ§ë', inProgressCount],
                    ['ÏôÑÎ£å', completedCount],
                    ['ÏßÄÏó∞', delayedCount],
                    ['Ï¥ù Ï†ïÏÇ∞Ïï°', totalPo],
                    ['Ï†ÑÏ≤¥ ÏßÑÌñâÎ•†', overallProgressRate + '%'],
                    ['', ''],
                    ['ÏûëÏóÖ Ïú†ÌòïÎ≥Ñ ÌÜµÍ≥Ñ', '']
                );

                // ÏûëÏóÖ Ïú†ÌòïÎ≥Ñ ÌÜµÍ≥Ñ
                const taskTypeStats = projectData.reduce((acc, p) => {
                    const type = p.taskType || 'ÎØ∏Î∂ÑÎ•ò';
                    if (!acc[type]) {
                        acc[type] = { count: 0, amount: 0, progress: 0, weightedProgress: 0 };
                    }
                    acc[type].count++;
                    acc[type].amount += p.poAmount || 0;
                    acc[type].weightedProgress += (p.progress || 0) * (p.poAmount || 0);
                    return acc;
                }, {});

                Object.entries(taskTypeStats).sort((a, b) => a[0].localeCompare(b[0])).forEach(([type, stats]) => {
                    const progressRate = stats.amount > 0 ? Math.round(stats.weightedProgress / stats.amount * 100) / 100 : 0;
                    statsData.push(
                        [type, ''],
                        ['Í±¥Ïàò', stats.count],
                        ['Ï†ïÏÇ∞Ïï°', stats.amount],
                        ['ÏßÑÌñâÎ•†', progressRate + '%'],
                        ['', '']
                    );
                });

                const statsSheet = XLSX.utils.aoa_to_sheet(statsData);
                XLSX.utils.book_append_sheet(workbook, statsSheet, 'ÌÜµÍ≥Ñ');

                // ÌååÏùº Ï†ÄÏû•: XLSXÎäî Í∏∞Ï°¥ Î∞©Ïãù Ïú†ÏßÄ, CSVÎäî ÌîÑÎ°úÏ†ùÌä∏/ÎßàÏùºÏä§ÌÜ§ÏùÑ Í∞ÅÍ∞Å CSVÎ°ú Îã§Ïö¥Î°úÎìú
                if (format === 'xlsx') {
                    const fileName = `gantt_data_${new Date().toISOString().slice(0,10)}.${format}`;
                    XLSX.writeFile(workbook, fileName);
                    showToast(`Îç∞Ïù¥ÌÑ∞Î•º ${format.toUpperCase()} ÌååÏùºÎ°ú Ï†ÄÏû•ÌñàÏäµÎãàÎã§.`, 'success');
                } else if (format === 'csv') {
                    // Create CSV content for main sheet and milestone sheet (if present)
                    const projectsCsv = XLSX.utils.sheet_to_csv(mainSheet);
                    const downloadText = (content, name) => {
                        // Prepend UTF-8 BOM so Excel (Windows) opens CSV with correct encoding
                        const bomPrefixed = '\uFEFF' + content;
                        const blob = new Blob([bomPrefixed], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = name;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    };

                    const dateSuffix = new Date().toISOString().slice(0,10);
                    downloadText(projectsCsv, `gantt_data_projects_${dateSuffix}.csv`);

                    if (milestoneSheet) {
                        setTimeout(() => {
                            const milestoneCsv = XLSX.utils.sheet_to_csv(milestoneSheet);
                            downloadText(milestoneCsv, `gantt_data_milestones_${dateSuffix}.csv`);
                        }, 150);
                    }

                    showToast('ÌîÑÎ°úÏ†ùÌä∏ Î∞è ÎßàÏùºÏä§ÌÜ§ CSV ÌååÏùºÏùÑ Îã§Ïö¥Î°úÎìúÌñàÏäµÎãàÎã§.', 'success');
                } else {
                    const fileName = `gantt_data_${new Date().toISOString().slice(0,10)}.${format}`;
                    XLSX.writeFile(workbook, fileName);
                    showToast(`Îç∞Ïù¥ÌÑ∞Î•º ${format.toUpperCase()} ÌååÏùºÎ°ú Ï†ÄÏû•ÌñàÏäµÎãàÎã§.`, 'success');
                }
            }

            // ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
            exportToExcelBtn.addEventListener('click', () => exportData('xlsx'));
            exportToCsvBtn.addEventListener('click', () => exportData('csv'));

            populateFilters();
             if(savedSettings && savedSettings.filters.customFilters && customFilterContainer) {
                 customFilterContainer.querySelectorAll('select').forEach(sel => {
                    // [FIX] 'Í≥†Í∞ùÏÇ¨'/'ÏãúÍ≥µÏÇ¨' ÌïÑÌÑ∞Îäî Í≥†Ï†ï IDÎ•º Í∞ÄÏßÄÎØÄÎ°ú IDÎ°ú ÏßÅÏ†ë Í∞íÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§.
                    if (sel.id === 'customer-filter' || sel.id === 'contractor-filter') {
                        sel.value = savedSettings.filters.customFilters[sel.dataset.filterKey] || 'all';
                        return;
                    }
                     const key = sel.dataset.filterKey;
                     if(savedSettings.filters.customFilters[key] !== undefined) {
                         sel.value = savedSettings.filters.customFilters[key] || 'all';
                     }
                 });
             }

            render();
            if(window.embeddedData) {
                showToast('Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨ÏôîÏäµÎãàÎã§.', 'info');
                renderMilestoneModal();
            }

            // [FIX] Ï†ÄÏû•Îêú ÌååÏùº Î°úÎìú Ïãú Î∞îÎ°úÍ∞ÄÍ∏∞ Î©îÎâ¥Î•º Ïò¨Î∞îÎ•¥Í≤å Î≥µÏõêÌï©ÎãàÎã§.
            if (savedSettings) {
                setTimeout(() => {
                    updateControlReferences();
                    updateShortcuts();
                }, 100);
            }
            
            setupSettlementAccordions();
            setupControlSectionToggles(document.getElementById('controlsSection'));
        }

        document.addEventListener('DOMContentLoaded', initializeDashboard);
    </script>
</body>
</html>

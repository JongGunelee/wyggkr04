<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>잔여 공사 공정관리</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
        }

        
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .gantt-titles .header,
        .gantt-titles .group-header,
        .gantt-titles .title-item {
            letter-spacing: -0.04em;
        }
        .gantt-titles .toggle-col-btn,
        .gantt-titles .group-toggle {
            letter-spacing: normal;
        }
        .gantt-chart-container {
            display: flex;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: visible !important; /* [Modified] Allow toggle button to sit outside on top */
            height: 100%;
            position: relative;
            margin-top: 14px; /* [Modified] Space for top toggle button */
        }
        .gantt-titles {
            flex-shrink: 0;
            border-right: 1px solid #e2e8f0;
            background-color: #f8fafc;
            position: relative;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            --po-col-width: 120px;
            --dates-col-width: 170px;
            --progress-col-width: 70px;
            --progress-summary-col-width: 120px; /* 새로 추가된 진행률 요약 열 너비 */
            --name-padding: 55px;
            isolation: isolate;
        }
        .gantt-titles-body-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }
        .resizer {
            position: absolute;
            top: 0;
            right: -2.5px;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            z-index: 12;
        }
        .resizer:hover {
            background: rgba(100, 116, 139, 0.25);
        }
        .gantt-titles .header {
            font-weight: 700;
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            height: 88px;
            display: flex;
            align-items: center;
            background-color: #fff;
            position: sticky;
            top: 0;
            z-index: 12;
            flex-shrink: 0;
            box-sizing: border-box;
            width: 100%;
            transition: height 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
        }
        /* Header Collapsed State */
        .gantt-chart-container.header-collapsed .gantt-titles .header,
        .gantt-chart-container.header-collapsed .gantt-timeline-header {
            height: 0 !important;
            padding: 0 !important;
            opacity: 0;
            overflow: hidden;
            border-bottom: none;
        }
        .gantt-chart-container.header-collapsed .milestone-title-row,
        .gantt-chart-container.header-collapsed .milestone-track {
            display: none !important;
        }

        /* Header Toggle Button */
        .header-toggle-btn-container {
            position: absolute;
            top: -12px; /* [Modified] Move above the container */
            left: 0;
            right: 0;
            height: 12px;
            z-index: 50; /* Above headers */
            display: flex;
            justify-content: center;
            pointer-events: none; /* Allow clicks to pass through for resizing etc */
        }
        .header-toggle-btn {
            pointer-events: auto;
            width: 24px;
            height: 12px;
            background-color: #e2e8f0;
            /* [Modified] Change to top-tab shape */
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 -1px 2px rgba(0,0,0,0.1); /* Shadow upwards */
            transition: background-color 0.2s;
        }
        .header-toggle-btn:hover {
            background-color: #cbd5e1;
        }
        .header-toggle-btn.active {
            background-color: #3b82f6; /* Blue active state */
        }
        .header-toggle-btn::after {
            content: '';
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #64748b;
            transition: transform 0.3s;
        }
        .header-toggle-btn.active::after {
            border-top-color: white;
            transform: rotate(180deg);
        }
        .gantt-titles .group-header {
            font-weight: 600;
            padding: 0 12px;
            height: 32px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            background-color: #f1f5f9;
            font-size: 14px;
        }
        .gantt-titles .group-header:hover {
            background-color: #e2e8f0;
        }
        .gantt-titles .group-toggle {
            display: inline-block;
            width: 20px;
            text-align: center;
        }
        .gantt-titles .title-item {
            padding: 0 12px;
            height: 32px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            border-bottom: 1px solid #f1f5f9;
            white-space: nowrap;
            font-size: 14px;
            box-sizing: border-box;
            width: 100%;
            position: relative;
        }
        .title-item .project-name {
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1 0 auto;
            padding-right: 10px;
            padding-left: 43px;
            box-sizing: border-box;
            width: calc(100% - var(--po-col-width) - var(--dates-col-width) - var(--progress-col-width));
            min-width: 0;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        /* [핵심 수정] 작업 목록 영역 의존성 표시 기호 스타일 */
        .dependency-symbol {
            display: inline-flex;
            align-items: center;
            margin-left: 4px;
            white-space: nowrap;
            font-size: 12px;
            line-height: 1;
            vertical-align: middle;
        }
        
        .dependency-start-circle,
        .dependency-end-circle {
            display: inline-block;
            font-size: 14px;
            line-height: 1;
            font-weight: normal;
        }
        
        .dependency-line {
            display: inline-block;
            font-size: 12px;
            line-height: 1;
            letter-spacing: -1px;
            font-weight: normal;
        }
        
        .dependency-label {
            font-size: 11px;
            margin-left: 2px;
            color: #6b7280;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* [핵심 수정] 작업 목록 영역 의존성 SVG 스타일 */
        .task-list-dependency-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            overflow: visible;
        }
        
        .task-list-dependency-svg path {
            cursor: pointer;
            pointer-events: stroke;
        }
        
        .task-list-dependency-svg path:hover {
            stroke-width: 2.5;
            opacity: 0.8;
        }
        
        /* [핵심 수정] 의존성 표시 기호 클릭 가능 스타일 */
        .dependency-symbol-clickable {
            cursor: pointer;
            transition: transform 0.2s ease, opacity 0.2s ease;
            user-select: none;
            position: relative;
            z-index: 10;
            pointer-events: auto;
        }
        
        .dependency-symbol-clickable:hover {
            transform: scale(1.15);
            opacity: 0.9;
        }
        
        .dependency-symbol-clickable:active {
            transform: scale(1.1);
            opacity: 0.8;
        }
        
        .title-item .project-po, .title-item .project-progress {
            text-align: right;
            padding-right: 10px;
            font-weight: 500;
            color: #64748b;
            flex-shrink: 0;
        }
        .title-item .project-dates {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px; /* 날짜 사이의 '~' 구분자를 위한 gap 유지 */
            flex-shrink: 0;
            font-size: 13px;
            color: #475569;
        }
        /* 날짜/진척률 요소 내부의 '변경' 라벨이 바로 뒤에 붙도록 추가 스타일 */
        .date-editor.date-changed, .progress-editor.date-changed {
            margin-right: 0px; /* 오른쪽 마진 제거하여 '변경' 라벨이 바로 붙도록 */
        }
        .date-editor, .progress-editor {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: background-color 0.2s, color 0.2s;
        }
        .date-editor, .progress-editor {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 0px; /* gap을 0px로 설정하여 '변경' 라벨이 바로 뒤에 위치하도록 */
            font-weight: 500;
            white-space: nowrap;
            z-index: 20;
            pointer-events: auto;
        }
        .date-editor:hover, .progress-editor:hover {
            background-color: #e0e7ff;
        }
        .date-editor.date-changed, .progress-editor.date-changed {
            color: #b91c1c !important;
            font-weight: 700 !important;
            background-color: rgba(248, 113, 113, 0.12) !important;
            padding-right: 0px !important; /* 오른쪽 패딩 제거하여 '변경' 라벨이 바로 붙도록 */
        }
        .date-editor.date-changed::after, .progress-editor.date-changed::after {
            content: '변경';
            font-size: 10px;
            line-height: 1;
            color: #b91c1c;
            background-color: rgba(254, 226, 226, 0.95);
            border-radius: 9999px;
            padding: 2px 6px;
            margin-left: 1px; /* 날짜/진척률 바로 뒤에 위치하도록 최소 간격만 유지 */
            margin-right: 0px; /* 오른쪽 마진 제거 */
            display: inline !important; /* inline으로 설정하여 텍스트와 자연스럽게 붙도록 */
            white-space: nowrap;
            vertical-align: middle; /* 수직 정렬 개선 */
        }
        /* 업데이트 완료 하이라이트 애니메이션 */
        .date-editor.cell-updated-highlight, .progress-editor.cell-updated-highlight {
            animation: cellHighlightPulse 2s ease-in-out;
            background-color: rgba(34, 197, 94, 0.2) !important;
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.3);
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        @keyframes cellHighlightPulse {
            0% {
                background-color: rgba(34, 197, 94, 0.4);
                box-shadow: 0 0 0 6px rgba(34, 197, 94, 0.5);
                transform: scale(1.05);
            }
            50% {
                background-color: rgba(34, 197, 94, 0.3);
                box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.4);
                transform: scale(1.02);
            }
            100% {
                background-color: transparent;
                box-shadow: none;
                transform: scale(1);
            }
        }
        .change-label {
            margin-left: 4px;
            font-size: 10px;
            color: #b91c1c;
            background-color: rgba(254, 226, 226, 0.95);
            border-radius: 9999px;
            padding: 2px 6px;
            display: inline-flex;
            align-items: center;
            white-space: nowrap;
            font-weight: 600;
        }
        .date-editor.date-completed {
            color: #9ca3af;
            font-weight: 400;
            background-color: transparent;
        }
        .date-editor.date-completed::after {
            display: none;
        }
        .date-editor.date-completed.date-changed {
            color: #b91c1c;
            font-weight: 700;
            background-color: rgba(248, 113, 113, 0.12);
        }
        .date-editor.date-completed.date-changed::after {
            display: inline-flex;
        }
        .date-editor.editing {
            background-color: #eef2ff;
            color: #312e81;
        }
        .date-edit-form {
            position: fixed !important;
            z-index: 99999 !important;
            background: #ffffff !important;
            background-color: #ffffff !important;
            background-image: none !important;
            opacity: 1 !important;
            border: 1px solid #c7d2fe !important;
            box-shadow: 0 8px 18px rgba(79, 70, 229, 0.25) !important;
            border-radius: 8px !important;
            padding: 10px !important;
            min-width: 190px !important;
            display: flex !important;
            flex-direction: column !important;
            gap: 6px !important;
            margin: 0 !important;
            box-sizing: border-box !important;
            pointer-events: auto !important;
            isolation: isolate !important; /* 새로운 stacking context 생성 */
            backdrop-filter: none !important; /* backdrop filter 제거 */
            -webkit-backdrop-filter: none !important; /* webkit backdrop filter 제거 */
            mix-blend-mode: normal !important; /* blend mode 제거 */
            will-change: auto !important; /* will-change 제거 */
            transform: none !important; /* transform 제거 */
        }
        .date-edit-form * {
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        .progress-edit-form {
            position: fixed !important;
            z-index: 99999 !important;
            background: #ffffff !important;
            background-color: #ffffff !important;
            background-image: none !important;
            opacity: 1 !important;
            border: 1px solid #c7d2fe !important;
            box-shadow: 0 8px 18px rgba(79, 70, 229, 0.25) !important;
            border-radius: 8px !important;
            padding: 10px !important;
            min-width: 190px !important;
            display: flex !important;
            flex-direction: column !important;
            gap: 6px !important;
            margin: 0 !important;
            box-sizing: border-box !important;
            pointer-events: auto !important;
            isolation: isolate !important; /* 새로운 stacking context 생성 */
            backdrop-filter: none !important; /* backdrop filter 제거 */
            -webkit-backdrop-filter: none !important; /* webkit backdrop filter 제거 */
            mix-blend-mode: normal !important; /* blend mode 제거 */
            will-change: auto !important; /* will-change 제거 */
            transform: none !important; /* transform 제거 */
        }
        .progress-edit-form * {
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        .date-edit-form label {
            font-size: 11px;
            font-weight: 600;
            color: #4338ca;
        }
        .date-edit-form input[type="date"],
        .date-edit-form input[type="text"],
        .date-edit-form input[type="number"],
        .progress-edit-form input[type="date"],
        .progress-edit-form input[type="text"],
        .progress-edit-form input[type="number"] {
            width: 100%;
            font-size: 12px;
            padding: 6px 8px;
            border: 1px solid #cbd5f5;
            border-radius: 4px;
            background-color: #f8fafc !important;
            opacity: 1 !important;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .date-edit-form input[type="date"]:focus,
        .date-edit-form input[type="text"]:focus,
        .date-edit-form input[type="number"]:focus,
        .progress-edit-form input[type="date"]:focus,
        .progress-edit-form input[type="text"]:focus,
        .progress-edit-form input[type="number"]:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.35);
            outline: none;
            background-color: #ffffff !important;
            opacity: 1 !important;
        }
        .date-edit-helper {
            font-size: 11px;
            color: #64748b;
        }
        .date-edit-original {
            font-size: 11px;
            color: #94a3b8;
        }
        .date-edit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 6px;
        }
        .date-edit-actions button {
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            opacity: 1 !important;
            background-color: transparent !important;
        }
        .date-edit-actions .date-edit-save {
            background-color: #4f46e5 !important;
            color: #ffffff !important;
            opacity: 1 !important;
        }
        .date-edit-actions .date-edit-save:hover {
            background-color: #4338ca !important;
            opacity: 1 !important;
        }
        .date-edit-actions .date-edit-cancel {
            background-color: #e2e8f0 !important;
            color: #1e293b !important;
            opacity: 1 !important;
        }
        .date-edit-actions .date-edit-cancel:hover {
            background-color: #cbd5e1;
        }
        .date-input {
            width: 130px;
            font-size: 13px;
            padding: 2px;
            border: 1px solid #6366f1;
            border-radius: 4px;
            text-align: center;
        }
        .progress-input { width: 60px; }
        .gantt-timeline-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            contain: layout style paint;
        }
        .gantt-timeline-header-wrapper {
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
            position: relative; /* Today Marker positioning context */
            contain: layout style paint;
            will-change: transform;
        }
        .gantt-timeline-body-wrapper {
            overflow: auto;
            flex-grow: 1;
            contain: layout style paint;
            will-change: transform;
        }
        .gantt-timeline-header {
            z-index: 11;
            background-color: #fff;
            position: sticky;
            top: 0;
            height: 88px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            width: 100%;
            contain: layout style;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
            -webkit-font-smoothing: antialiased;
            transition: height 0.3s ease, opacity 0.3s ease;
        }
        .gantt-year-month-header, .gantt-day-header, .gantt-weekday-header {
            display: flex;
            font-size: 12px;
            font-weight: 500;
            border-bottom: 1px solid #e2e8f0;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        .gantt-weekday-header {
            font-size: 11px;
             color: #64748b;
        }

        .gantt-month, .gantt-day, .gantt-weekday {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-right: 1px solid #e2e8f0;
            box-sizing: border-box;
            position: relative;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
            contain: layout style paint;
        }
        .gantt-month { height: 32px; }
        .gantt-day { height: 32px; }
        .gantt-weekday { height: 24px; }

        .gantt-body {
            position: relative;
        }
        .gantt-bar-row {
            height: 32px;
            border-bottom: 1px solid #f1f5f9;
            position: relative;
            z-index: 2;
            box-sizing: border-box;
            width: 100%;
        }
        .gantt-bar-row.hierarchy-summary-hidden {
            display: none !important;
        }
        .gantt-grid-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 0;
            border-left: 1px solid #e2e8f0;
            z-index: 1;
            pointer-events: none;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
        }
        .gantt-today-marker-container {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 15;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        .gantt-today-marker {
            width: 0;
            height: 100%;
            border-left: 3px dashed #1d4ed8;
            will-change: transform;
            transform: translateZ(0);
        }
        .gantt-today-label {
            position: absolute;
            top: 5px;
            background-color: #1d4ed8;
            color: white;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 4px;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transform: translateZ(0);
        }
        .gantt-bar {
            position: absolute;
            top: 4px;
            height: 24px;
            border-radius: 4px;
            opacity: 0.8;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            overflow: visible; /* [FIX] 라벨이 막대 밖으로 표시되도록 overflow 수정 */
            white-space: nowrap;
            z-index: 9;
        }
         .gantt-bar-progress {
            position: absolute;
            top: 11px;
            height: 10px;
            border-radius: 2px;
            background-color: rgba(0, 0, 0, 0.35);
            box-shadow: inset 0 1px 1px rgba(0,0,0,0.2);
            z-index: 10;
            pointer-events: none;
            transition: width 0.3s ease-in-out;
        }
        .gantt-bar-progress::after {
            content: attr(data-weighted-value);
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #94a3b8;
            white-space: nowrap;
        }
        .gantt-bar.hidden, .title-item.hidden {
            display: none;
        }
        .gantt-bar:hover {
            opacity: 1;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .tooltip {
            visibility: hidden;
            background-color: #1f2937;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 200;
            bottom: 125%;
            transform: translateX(-50%); /* JS에서 left를 동적으로 설정하므로, 가운데 정렬을 위해 transform만 유지 */
            opacity: 0;
            transition: opacity 0.3s;
            width: 220px;
            font-size: 12px;
            pointer-events: none;
        }
        /* [FIX] 툴팁은 클릭 시에만 보이도록 변경 */
        .gantt-bar.show-tooltip .tooltip {
            visibility: visible;
            opacity: 1;
        }
        #ganttFloatingTooltip {
            position: fixed;
            background-color: #1f2937;
            color: #fff;
            padding: 10px 12px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.35);
            pointer-events: none;
            z-index: 4000;
            max-width: 280px;
            font-size: 12px;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }
        #ganttFloatingTooltip.visible {
            opacity: 1;
            transform: translateY(0px);
        }
        #ganttHoverTooltip {
            position: fixed;
            background-color: rgba(15, 23, 42, 0.92);
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.3;
            pointer-events: none;
            z-index: 3500;
            opacity: 0;
            transform: translateY(-6px);
            transition: opacity 0.12s ease, transform 0.12s ease;
            max-width: 240px;
            white-space: nowrap;
        }
        #ganttHoverTooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.5); /* 툴팁 중복 문제 해결 */
            display: flex; justify-content: center; align-items: center;
            z-index: 50;
        }
        .modal-content {
            background-color: white;
            padding: 0;
            border-radius: 0.5rem;
            width: 400px;
            height: auto;
            min-height: 400px;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            resize: both;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
            border-radius: 50%; border-left-color: #4f46e5;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .summary-card {
             cursor: pointer;
             transition: transform 0.2s;
        }
        .summary-card:hover {
            transform: translateY(-4px);
        }
        .row-hover {
            background-color: #fef08a;
        }
        .fullscreen-modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
        }
        .resizable-modal-content {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            position: relative;
            width: 95vw;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .resizable-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e5e7eb;
            flex-shrink: 0;
        }
        .resizable-modal-body {
            flex-grow: 1;
            padding: 1rem;
            overflow: auto;
            max-height: 60vh;
            display: flex; /* Added for fullscreen layout */
            flex-direction: column; /* Added for fullscreen layout */
        }
        #ganttViewContent {
             height: 100%;
             display: flex;
             flex-direction: column;
        }
        #ganttChartWrapper {
            flex-grow: 1;
             min-height: 0; /* Added for flex grow in column */
        }
        #ganttChartWrapper .gantt-chart-container {
            height: 100%;
        }
        .resizer-handle {
            position: absolute;
            background: transparent;
            z-index: 101;
        }
        .resizer-handle.n { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-handle.s { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-handle.e { top: 0; bottom: 0; right: -5px; width: 10px; cursor: ew-resize; }
        .resizer-handle.w { top: 0; bottom: 0; left: -5px; width: 10px; cursor: ew-resize; }
        .resizer-handle.ne { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-handle.sw { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-handle.nw { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; }
        .resizer-handle.se { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; }

        .header-col {
            display: flex;
            align-items: center;
        }
        .col-resizer {
            flex-shrink: 0;
            width: 6px;
            height: 40px;
            cursor: col-resize;
            background-color: transparent;
            z-index: 13;
            border-left: 1px solid transparent;
            border-right: 1px solid transparent;
            transition: background-color 0.2s;
        }
        .col-resizer:hover {
            background-color: rgba(100, 116, 139, 0.25);
            border-left: 1px solid #cbd5e1;
            border-right: 1px solid #cbd5e1;
        }
        #dataPanel.hidden {
            display: none;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        /* Ensure accordions start collapsed */
        .accordion-item:not(.open) .accordion-content {
            max-height: 0 !important;
            overflow: hidden !important;
        }
        .accordion-item:not(.open) .accordion-content,
        .sub-accordion-item:not(.open) .sub-accordion-content { /* Added sub-accordion */
             max-height: 0;
             overflow: hidden;
             padding-top: 0;
             padding-bottom: 0;
        }
        .accordion-item.open > .accordion-content,
        .sub-accordion-item.open > .sub-accordion-content { /* Added sub-accordion */
            max-height: 5000px; /* Allow expansion */
            transition: max-height 0.5s ease-in;
             /* Padding moved to content grid for sub-accordion */
        }



        /* [MODIFIED] Padding moved from sub-accordion-content.open to the grid inside it */
        .sub-accordion-item.open > .sub-accordion-content > .grid {
             padding-top: 1rem;
             padding-bottom: 1rem;
        }


        .accordion-item.open > .accordion-content.flex-grow {
            max-height: none;
        }
        .accordion-icon, .sub-accordion-icon, .control-section-icon { /* Added sub-accordion and control */
            transition: transform 0.3s ease;
        }
        .accordion-item.open > .accordion-header .accordion-icon,
        .sub-accordion-item.open > .sub-accordion-header .sub-accordion-icon, /* Added sub-accordion */
        .control-section-header.open .control-section-icon { /* Added control */
            transform: rotate(180deg);
        }

        /* Overview accordion sections (group summaries inside 총괄) */
        .overview-accordion-item {
            border-top: 1px solid #e5e7eb;
            padding-top: 1rem;
            margin-top: 1rem;
        }
        .overview-accordion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            cursor: pointer;
            padding: 0.25rem 0;
        }
        .overview-accordion-header:focus-visible {
            outline: 2px solid rgba(99, 102, 241, 0.6);
            outline-offset: 2px;
        }
        .overview-accordion-content {
            margin-top: 0.75rem;
        }
        .overview-accordion-item.collapsed .overview-accordion-content {
            display: none;
        }
        .overview-accordion-icon {
            transition: transform 0.3s ease;
        }
        .overview-accordion-item.expanded .overview-accordion-icon {
            transform: rotate(180deg);
        }
        /* Schedule header-only collapse/expand triangle (like legend), active when accordion is open */
        #projectView > .accordion-header {
            position: relative;
        }
        #projectView .schedule-header-toggle {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 8px solid #374151; /* expanded: gray-700 */
            background: transparent;
            cursor: pointer;
            z-index: 2;
            outline: none;
        }
        #projectView .schedule-header-toggle:hover,
        #projectView .schedule-header-toggle:focus {
            border-bottom-color: #111827; /* gray-900 */
        }
        /* Collapses only the header area into a single line with centered triangle */
        #projectView.schedule-header-collapsed > .accordion-header {
            padding: 0 !important;
            min-height: 0 !important;
        }
        #projectView.schedule-header-collapsed > .accordion-header > *:not(.schedule-header-toggle) {
            display: none !important;
        }
        #projectView.schedule-header-collapsed > .accordion-header .schedule-header-toggle {
            border-bottom: none;
            border-top: 8px solid #2563eb; /* collapsed: blue-600 */
            top: 0; /* [Modified] triangle tip touches top line */
            transform: translate(-50%, 0); /* [Modified] no vertical offset, sits at top */
        }
        #projectView.schedule-header-collapsed > .accordion-header .schedule-header-toggle:hover,
        #projectView.schedule-header-collapsed > .accordion-header .schedule-header-toggle:focus {
            border-top-color: #1d4ed8; /* blue-700 */
        }

        /* Styles for sub-accordion in Settlement section */
        .sub-accordion-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0; /* Adjust padding as needed */
        }
        .sub-accordion-content {
             max-height: 0;
             overflow: hidden;
             transition: max-height 0.3s ease-out;
             /* Removed padding-top/bottom here, handled by .open */
        }
        /* End of sub-accordion styles */
        
        /* Main settlement accordion styles */
        .main-settlement-accordion-item {
            transition: all 0.3s ease;
        }
        
        .main-settlement-header {
            transition: background-color 0.2s ease;
        }
        
        .main-settlement-icon {
            transition: transform 0.3s ease;
        }
        
        .main-settlement-accordion-item.expanded .main-settlement-icon {
            transform: rotate(180deg);
        }
        
        .main-settlement-accordion-item.collapsed .main-settlement-icon {
            transform: rotate(0deg);
        }
        
        /* Settlement section scroll behavior
           Use available viewport space (subtract header/controls chrome) so the inner
           container can always show a scrollbar when content overflows even when
           the overall page scrolling is prevented (body { overflow: hidden }). */
        .settlement-scrollable {
            max-height: calc(100vh - 220px);
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }
        
        /* Enhanced scroll behavior for settlement section */
        .settlement-scrollable:hover {
            overflow-y: auto;
        }
        
        /* Ensure scrollbar is always visible when content overflows */
        .settlement-scrollable:not(:hover) {
            overflow-y: auto;
        }
        
        .settlement-scrollable::-webkit-scrollbar {
            width: 8px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Styles for control section toggles */
        .control-section-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 0.5rem;
        }
         .control-section-header h3 {
             margin-bottom: 0; /* Remove default margin */
         }
        .control-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding-top: 0;
            padding-bottom: 0;
        }
        .control-section-header.open + .control-section-content {
            max-height: 1000px; /* Adjust as needed */
            transition: max-height 0.5s ease-in, padding 0.5s ease-in;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        /* End control section styles */


        .milestone-track {
            height: 40px;
            position: sticky;
            top: 0;
            border-bottom: 1px solid #e2e8f0;
            background: #fff;
            z-index: 6;
            display: flex;
            align-items: center;
        }
        .milestone-title-row {
            height: 40px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            font-weight: 600;
            gap: 8px;
            padding: 0 8px;
            position: sticky;
            top: 0;
            background: #fff;
            z-index: 7;
        }
        .milestone-title-row span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            color: #1f2937;
        }
        .change-label {
            display: inline-flex;
            align-items: center;
            font-size: 0.75rem;
            font-weight: 700;
            color: #dc2626;
            margin-left: 6px;
            border: 1px solid #dc2626;
            border-radius: 999px;
            padding: 0 6px;
            line-height: 1.2;
        }
        .filter-toggle-btn {
            transition: all 0.2s ease;
        }
        .filter-toggle-btn.filter-toggle-active {
            background-color: #dbeafe !important;
            border: 2px solid #2563eb;
            color: #1e40af;
            font-weight: 600;
        }
        .milestone-marker {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 20px;
            height: 20px;
            background-color: #e11d48;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            cursor: pointer;
            z-index: 15;
        }
         .milestone-marker .tooltip {
            transform: translate(-50%, 0) rotate(-45deg);
            bottom: 25px;
        }
        #progressPopup {
            /* [FIX] Increased z-index to appear above fullscreen modal */
            z-index: 150 !important;
        }
        /* 개선 사항 2: 간트 바 위에 표시될 이름 라벨 */
        .gantt-bar-label {
            position: absolute;
            bottom: 100%;
            left: 0;
            margin-bottom: 4px;
            background-color: rgba(31, 41, 55, 0.85); /* bg-gray-800/85 */
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
        }
        .gantt-bar-label { z-index: 30; } /* 라벨이 다른 요소 위에 항상 표시되도록 z-index 추가 */
        .gantt-bar:hover .gantt-bar-label {
        
        /* 작업 의존성 시각화 스타일 */
        /* 의존성 선과 마커 스타일: 얇은 대시라인 + 유형별 색상 그룹화 */
        .gantt-dependency-arrow {
            position: absolute;
            z-index: 5; /* Lower than bars (z-index: 9) to render behind them */
            pointer-events: none;
            fill: none;
            opacity: 0.95; /* 선을 명확히 보이게 */
            transition: opacity 0.2s, stroke-width 0.2s;
            stroke-width: 0.8; /* 얇은 선 */
            stroke-linecap: round;
            stroke-dasharray: 6 4; /* '------' 시각화 */
        }
        .gantt-dependency-arrow:hover {
            opacity: 1;
            stroke-width: 1;
            z-index: 6; /* Slightly higher on hover but still behind bars */
        }
        /* 유형별 색상 그룹화 (SS, FS, FF, SF) */
        .gantt-dependency-arrow.dependency-start-to-start { stroke: #2563eb; } /* 파란계열 */
        .gantt-dependency-arrow.dependency-end-to-start   { stroke: #10b981; } /* 녹색계열 */
        .gantt-dependency-arrow.dependency-end-to-end     { stroke: #f59e0b; } /* 주황계열 */
        .gantt-dependency-arrow.dependency-start-to-end   { stroke: #ef4444; } /* 빨강계열 */

        .dependency-flow-circle { opacity: 0.9; }

        /* 의존성 설정 버튼: 다른 아이콘과 일관된 크기로 통일 (더 읽기 쉬운 크기) */
        .dependency-setting-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.12em !important; /* 표준 내부 여백 */
            margin-left: 4px;
            background: #ffffff;
            border: 1px solid #d1d5db !important;
            border-radius: 4px;
            cursor: pointer;
            color: #9ca3af;
            transition: all 0.12s ease;
            font-size: 0.95em !important; /* 다른 아이콘과 유사한 표준 크기 */
            line-height: 1 !important;
            font-weight: 400 !important; /* 보통 굵기 */
            box-shadow: none !important;
            width: 1.6em !important; /* 박스 크기 통일 */
            height: 1.6em !important;
            box-sizing: border-box !important;
            vertical-align: middle !important;
            position: relative;
            z-index: 1; /* [수정] 고정 헤더(z-index: 12)보다 낮게 설정하여 헤더 아래로 가려지도록 함 */
        }
        .dependency-setting-btn:hover { background: #f3f4f6; border-color: #9ca3af !important; }
        .dependency-setting-btn.has-dependency { background: #eff6ff; color: #3b82f6; border-color: #60a5fa !important; }
        .dependency-setting-btn.has-dependency:hover { background: #dbeafe; border-color: #3b82f6 !important; }
        /* 의존성 설정 버튼 기호 색상 - 이모지 색상 강제 적용 */
        .dependency-setting-btn.has-dependency span {
            color: transparent !important;
            text-shadow: 0 0 0 #3b82f6 !important;
        }
        .dependency-setting-btn:not(.has-dependency) span {
            color: transparent !important;
            text-shadow: 0 0 0 #d1d5db !important;
        }
        .dependency-modal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            background: rgba(0, 0, 0, 0.5) !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            z-index: 9999 !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        .dependency-modal.hidden {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        .dependency-modal-content {
            background: white !important;
            border-radius: 12px !important;
            padding: 24px !important;
            max-width: 600px !important;
            width: 90% !important;
            max-height: 85vh !important;
            overflow-y: auto !important;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15) !important;
            position: relative !important;
            z-index: 10000 !important;
            margin: auto !important;
            display: flex !important;
            flex-direction: column !important;
        }
        .dependency-modal-header {
            display: flex !important;
            justify-content: space-between !important;
            align-items: center !important;
            margin-bottom: 16px !important;
            padding-bottom: 12px !important;
            border-bottom: 1px solid #e2e8f0 !important;
        }
        .dependency-modal-title {
            font-size: 18px !important;
            font-weight: 600 !important;
            color: #1e293b !important;
            margin: 0 !important;
        }
        .dependency-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #64748b;
            padding: 0;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        .dependency-modal-close:hover {
            background: #f1f5f9;
            color: #1e293b;
        }
        #dependencyModalBody {
            display: block !important;
            width: 100% !important;
            box-sizing: border-box !important;
            flex: 1 !important;
            overflow-y: auto !important;
            padding-right: 4px !important;
        }
        #dependencyCurrentProject {
            display: block !important;
            padding: 12px 16px !important;
            background: #f1f5f9 !important;
            border-radius: 8px !important;
            font-weight: 600 !important;
            font-size: 15px !important;
            color: #1e293b !important;
            word-wrap: break-word !important;
            white-space: normal !important;
            border: 1px solid #e2e8f0 !important;
        }
        .dependency-form-group {
            margin-bottom: 20px !important;
            display: block !important;
        }
        .dependency-form-label {
            display: block !important;
            font-size: 15px !important;
            font-weight: 600 !important;
            color: #1e293b !important;
            margin-bottom: 10px !important;
        }
        .dependency-form-select {
            width: 100% !important;
            padding: 10px 14px !important;
            border: 2px solid #d1d5db !important;
            border-radius: 8px !important;
            font-size: 14px !important;
            background: white !important;
            min-height: 140px !important;
            box-sizing: border-box !important;
            transition: border-color 0.2s !important;
        }
        .dependency-form-select option {
            padding: 8px 12px !important;
            white-space: normal !important;
            word-wrap: break-word !important;
        }
        .dependency-form-select:focus {
            outline: none !important;
            border-color: #6366f1 !important;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1) !important;
        }
        .dependency-type-group {
            display: flex !important;
            gap: 8px !important;
            flex-wrap: wrap !important;
        }
        .dependency-type-option {
            flex: 1 !important;
            min-width: 130px !important;
            padding: 12px !important;
            border: 2px solid #e2e8f0 !important;
            border-radius: 8px !important;
            cursor: pointer !important;
            text-align: center !important;
            transition: all 0.2s ease !important;
            background: white !important;
            box-sizing: border-box !important;
            position: relative !important; /* for ::before color indicator */
        }
        .dependency-type-option:hover {
            border-color: #c7d2fe;
            background: #f8fafc;
        }
        .dependency-type-option.selected {
            border-color: #6366f1;
            background: #eef2ff;
            color: #4338ca;
            font-weight: 600;
        }
        .dependency-type-option-title {
            font-size: 12px !important;
            font-weight: 600 !important;
            margin-bottom: 4px !important;
            display: block !important;
        }
        .dependency-type-option-desc {
            font-size: 11px !important;
            color: #64748b !important;
            display: block !important;
        }
        /* 상단 색상 바: 각 의존성 타입을 막대 그래프 색상과 일치시켜 가독성 강화 */
        .dependency-type-option::before {
            content: '';
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            height: 6px !important;
            border-top-left-radius: 6px !important;
            border-top-right-radius: 6px !important;
        }
        .dependency-type-option[data-type="start-to-start"]::before { background: #2563eb !important; }
        .dependency-type-option[data-type="end-to-start"]::before { background: #10b981 !important; }
        .dependency-type-option[data-type="end-to-end"]::before { background: #f59e0b !important; }
        .dependency-type-option[data-type="start-to-end"]::before { background: #ef4444 !important; }

        /* Ensure title/desc have spacing from top color bar */
        .dependency-type-option-title { margin-top: 8px !important; }
        .dependency-search-toggle {
            background: none !important;
            border: none !important;
            cursor: pointer !important;
            font-size: 16px !important;
            padding: 4px !important;
            color: #64748b !important;
            transition: color 0.2s !important;
        }
        .dependency-search-toggle:hover {
            color: #6366f1 !important;
        }
        .dependency-search-input {
            width: 100% !important;
            padding: 8px 12px !important;
            border: 1px solid #d1d5db !important;
            border-radius: 6px !important;
            font-size: 14px !important;
            box-sizing: border-box !important;
        }
        .dependency-search-input:focus {
            outline: none !important;
            border-color: #6366f1 !important;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1) !important;
        }
        .dependency-type-help-toggle {
            background: none !important;
            border: none !important;
            cursor: pointer !important;
            font-size: 16px !important;
            padding: 4px !important;
            color: #6366f1 !important;
            font-weight: bold !important;
            transition: color 0.2s !important;
            width: 24px !important;
            height: 24px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            border-radius: 50% !important;
            background-color: #eef2ff !important;
        }
        .dependency-type-help-toggle:hover {
            color: #4f46e5 !important;
            background-color: #e0e7ff !important;
        }
        .dependency-type-help-container {
            display: none !important;
            margin-bottom: 12px !important;
            padding: 12px !important;
            background: #f8fafc !important;
            border-radius: 6px !important;
            border: 1px solid #e2e8f0 !important;
        }
        .dependency-type-help-content {
            font-size: 13px !important;
            line-height: 1.6 !important;
            color: #374151 !important;
        }
        .dependency-type-radio {
            width: 18px !important;
            height: 18px !important;
            cursor: pointer !important;
            flex-shrink: 0 !important;
        }
        .dependency-type-option.selected .dependency-type-radio {
            accent-color: #6366f1 !important;
        }
        .dependency-modal-actions {
            display: flex !important;
            justify-content: flex-end !important;
            align-items: center !important;
            gap: 8px !important;
            margin-top: 28px !important;
            padding: 20px 24px !important;
            border-top: 2px solid #e2e8f0 !important;
            background: #f8fafc !important;
            border-radius: 0 0 12px 12px !important;
            margin-left: -24px !important;
            margin-right: -24px !important;
            margin-bottom: -24px !important;
            flex-shrink: 0 !important;
        }
        .dependency-modal-btn {
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            padding: 10px 20px !important;
            border-radius: 6px !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            border: none !important;
            min-width: 100px !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
            white-space: nowrap !important;
        }
        .dependency-modal-btn-primary {
            background: #2563eb !important; /* 파란색 - 저장 버튼 */
            color: #ffffff !important;
            padding: 10px 20px !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            border-radius: 6px !important;
            min-width: 100px !important;
        }
        .dependency-modal-btn-primary:hover {
            background: #1d4ed8 !important;
            box-shadow: 0 4px 8px rgba(37,99,235,0.25) !important;
            transform: translateY(-1px) !important;
        }
        .dependency-modal-btn-primary:active {
            transform: translateY(0) !important;
            box-shadow: 0 2px 4px rgba(37,99,235,0.2) !important;
            background: #1e40af !important;
        }
        .dependency-modal-btn-secondary {
            background: #6b7280 !important; /* 회색 - 취소 버튼 */
            color: #ffffff !important;
            padding: 10px 20px !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            border-radius: 6px !important;
            min-width: 100px !important;
            border: none !important;
        }
        .dependency-modal-btn-secondary:hover {
            background: #4b5563 !important;
            box-shadow: 0 4px 8px rgba(107,114,128,0.25) !important;
            transform: translateY(-1px) !important;
        }
        .dependency-modal-btn-secondary:active {
            transform: translateY(0) !important;
            box-shadow: 0 2px 4px rgba(107,114,128,0.2) !important;
            background: #374151 !important;
        }
        .dependency-modal-btn-danger {
            background: #dc2626 !important; /* 빨간색 - 의존성 해제 버튼 */
            color: #ffffff !important;
            padding: 10px 20px !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            border-radius: 6px !important;
            min-width: 100px !important;
            border: none !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            white-space: nowrap !important;
        }
        .dependency-modal-btn-danger:hover {
            background: #b91c1c !important;
            box-shadow: 0 4px 8px rgba(220,38,38,0.25) !important;
            transform: translateY(-1px) !important;
        }
        .dependency-modal-btn-danger:active {
            transform: translateY(0) !important;
            box-shadow: 0 2px 4px rgba(220,38,38,0.2) !important;
            background: #991b1b !important;
        }
            visibility: visible;
            opacity: 1;
        }
        #progressPopup {
            /* [FIX] Increased z-index to appear above fullscreen modal */
            z-index: 150 !important;
        }
        #progressPopup button.progress-val-btn {
            width: 100%;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 0.375rem;
            transition: all 0.2s;
            background-color: #f3f4f6;
            color: #374151;
        }
        #progressPopup button.progress-val-btn:hover {
            background-color: #6366f1;
            color: white;
        }
        #progressPopup button.progress-val-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        #progressPopup .progress-input-area {
            grid-column: span 4 / span 4;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-top: 0.5rem;
            border-top-width: 1px;
            margin-top: 0.25rem;
        }
        #progressPopup .progress-input-area input {
            width: 100%;
            padding: 0.25rem;
            border-width: 1px;
            border-radius: 0.25rem;
        }
        #progressPopup .progress-input-area button {
            padding: 0.25rem 0.75rem;
            background-color: #6366f1;
            color: white;
            border-radius: 0.25rem;
            font-size: 0.75rem;
        }
        #progressPopup .progress-input-area button:hover {
            background-color: #4f46e5;
        }
        .search-highlight {
            background-color: #fde047;
            border-radius: 2px;
        }
        #mappingPreviewContainer table, #errorCorrectionContainer table {
            font-size: 0.8rem;
        }
        #mappingPreviewContainer th, #mappingPreviewContainer td,
        #errorCorrectionContainer th, #errorCorrectionContainer td {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            padding: 0.5rem;
        }
        #mappingPreviewContainer th, #errorCorrectionContainer th {
            position: sticky;
            top: 0;
            background: #f3f4f6;
        }
        #mappingPreviewContainer select {
            width: 100%;
            font-size: 0.75rem;
        }
        .mapping-analysis-meta {
            margin-top: 0.35rem;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }
        .mapping-analysis-toggle {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            color: #4b5563;
        }
        .mapping-analysis-toggle input[type="checkbox"] {
            width: 12px;
            height: 12px;
            accent-color: #6366f1;
        }
        .analysis-usage-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            min-height: 1rem;
        }
        .analysis-usage-badge {
            font-size: 0.65rem;
            padding: 0 0.35rem;
            border-radius: 9999px;
            background-color: #e0f2fe;
            color: #0369a1;
        }
        .analysis-usage-badge--settlement {
            background-color: #fef3c7;
            color: #92400e;
        }
        .analysis-usage-badge--active {
            background-color: #ede9fe;
            color: #5b21b6;
        }
        .analysis-usage-empty {
            font-size: 0.65rem;
            color: #9ca3af;
        }
        .error-input {
            border-color: #ef4444 !important; /* red-500 */
            box-shadow: 0 0 0 1px #ef4444;
        }
        /* Improved Toast Container */
        #toast-container {
            position: fixed;
            bottom: 1.25rem;
            right: 1.25rem;
            display: flex;
            flex-direction: column-reverse;
            gap: 0.75rem;
            z-index: 1000;
            max-height: 100vh;
            overflow-y: auto;
            padding: 1rem;
            pointer-events: none;
        }
        
        .toast {
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            color: white;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
            min-width: 300px;
            max-width: 500px;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .toast:hover {
            transform: translateX(-5px);
            box-shadow: 0 15px 20px -3px rgba(0, 0, 0, 0.15), 0 6px 8px -2px rgba(0, 0, 0, 0.1);
        }
        
        .toast-success { 
            background-color: #22c55e;
            border-left: 4px solid #16a34a;
        }
        
        .toast-error { 
            background-color: #ef4444;
            border-left: 4px solid #dc2626;
        }
        
        .toast-info { 
            background-color: #3b82f6;
            border-left: 4px solid #2563eb;
        }
        
        .toast-warning { 
            background-color: #f97316;
            border-left: 4px solid #ea580c;
        }

        /* Online/Offline Status Indicator */
        #network-status {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 999;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            pointer-events: auto;
        }
        /* controlsPanel이 열릴 때 network-status의 z-index를 낮춤 */
        #network-status.panel-open {
            z-index: 100 !important;
        }
        /* closeControlsPanelBtn의 z-index를 높여 network-status 위에 표시 */
        #closeControlsPanelBtn {
            position: relative;
            z-index: 1000 !important;
            pointer-events: auto !important;
        }
        #network-status.online {
            background-color: #22c55e;
            color: white;
        }
        #network-status.offline {
            background-color: #ef4444;
            color: white;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        #network-status-icon {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background-color: currentColor;
        }
        #network-status.online #network-status-icon {
            background-color: white;
        }
        #network-status.offline #network-status-icon {
            background-color: white;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .scrollable-accordion.open > .accordion-content {
            /* Keep explicit display to satisfy linters; actual scroll behavior handled elsewhere */
            display: block;
        }

        /* Improvement: Styles for focused accordion item */
        .accordion-item.is-focused {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .accordion-title-btn {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            user-select: none;
            transition: color 0.2s ease, transform 0.2s ease;
            border-radius: 0.375rem;
            padding: 0.15rem 0.35rem;
        }
        .accordion-title-btn:hover,
        .accordion-title-btn:focus-visible {
            color: #4338ca;
            background: rgba(99, 102, 241, 0.08);
        }
        .accordion-title-btn:focus-visible {
            outline: 2px solid rgba(99, 102, 241, 0.6);
            outline-offset: 2px;
        }
        .accordion-item.open .accordion-title-btn {
            color: #1d4ed8;
        }
        .accordion-hint-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            padding: 0.2rem 0.6rem;
            border-radius: 9999px;
            border: 1px dashed rgba(99, 102, 241, 0.6);
            background: rgba(129, 140, 248, 0.1);
            color: #4338ca;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            animation: accordionHintPulse 1.6s infinite;
            white-space: nowrap;
        }
        .accordion-hint-chip.hint-hidden {
            display: none;
        }
        .accordion-hint-chip.hint-visible {
            opacity: 1;
            transform: translateY(0);
        }
        @keyframes accordionHintPulse {
            0% { box-shadow: 0 0 0 0 rgba(129,140,248,0.4); }
            70% { box-shadow: 0 0 0 8px rgba(129,140,248,0); }
            100% { box-shadow: 0 0 0 0 rgba(129,140,248,0); }
        }
        .accordion-state-pill {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            padding: 0.15rem 0.55rem;
            border-radius: 9999px;
            border: 1px solid rgba(59,130,246,0.4);
            background: rgba(191,219,254,0.4);
            color: #1d4ed8;
            margin-left: 0.5rem;
            transition: transform 0.25s ease, background 0.25s ease, color 0.25s ease, border-color 0.25s ease;
        }
        .accordion-state-pill[data-state="open"] {
            background: rgba(34,197,94,0.18);
            color: #047857;
            border-color: rgba(16,185,129,0.5);
        }
        .accordion-state-pill[data-state="closed"] {
            background: rgba(191,219,254,0.5);
            color: #1d4ed8;
            border-color: rgba(59,130,246,0.45);
        }

        /* [REPLACED] - Start of accordion scroll fix */
        /* Focused content that should FILL the space (e.g., Gantt) */
        .accordion-item.is-focused > .accordion-content.flex-grow {
            flex-grow: 1;
            overflow-y: auto; /* Changed from hidden to auto */
            max-height: none !important;
        }

        /* Focused content that should SCROLL (e.g., Overview, Settlement) */
        .accordion-item.is-focused > .accordion-content.scrollable-content {
            flex-grow: 1; /* Grow to fill the 'is-focused' item's space */
            overflow-y: auto; /* Enable vertical scrolling */
            max-height: none; /* [FIX] Allow content to overflow and scroll by removing height constraint in focused mode */
        }

        /* Fallback for any other focused content (though all should be one of the above) */
        .accordion-item.is-focused > .accordion-content:not(.flex-grow):not(.scrollable-content) {
            flex-grow: 1;
            overflow-y: auto;
        }
        /* [REPLACED] - End of accordion scroll fix */

        /* Fullscreen Legend Style */
        #fullscreenModalBody > .controls-section {
             background-color: white;
             padding: 1rem;
             border-radius: 0.5rem;
             box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
             margin-bottom: 1rem;
             flex-shrink: 0;
        }
		/* Legend selection highlight */
		.legend-section [data-status-filter].legend-filter-active {
			background-color: rgba(59, 130, 246, 0.12);
			border-radius: 0.375rem;
            border: 2px solid transparent;
		}
        .legend-section [data-status-filter] {
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
        }
        .legend-section [data-status-filter].legend-filter-active {
            border-color: #ef4444;
            animation: legendBlink 1s linear infinite;
        }
        @keyframes legendBlink {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.6); }
            50% { box-shadow: 0 0 0 6px rgba(239,68,68,0); }
        }
        #shortcutContainer .shortcut-item.active-shortcut {
            border: 2px solid #ef4444;
            border-radius: 0.5rem;
            animation: legendBlink 1s linear infinite;
        }
        #header-customer-filter-shortcut.header-shortcut-active,
        #header-contractor-filter-shortcut.header-shortcut-active,
        #header-cost-account-filter-shortcut.header-shortcut-active {
            border: 2px solid #ef4444;
            border-radius: 0.5rem;
            animation: legendBlink 1s linear infinite;
        }
		
		/* 개선 사항: 날짜 범례 항목 스타일 (크기 80%, 그룹화 색상) */
		.legend-section [data-status-filter="오늘시작"],
		.legend-section [data-status-filter="오늘종료"],
		.legend-section [data-status-filter="내일시작"],
		.legend-section [data-status-filter="내일종료"] {
			transform: scale(0.8);
			transform-origin: center;
		}
		
		/* 오늘 그룹 색상 그룹화 (파란색 계열) */
		.legend-section [data-status-filter="오늘시작"] {
			background-color: rgba(96, 165, 250, 0.15);
			border-left: 3px solid rgb(96, 165, 250);
			padding-left: 0.5rem;
			border-radius: 0.25rem;
		}
		.legend-section [data-status-filter="오늘종료"] {
			background-color: rgba(59, 130, 246, 0.15);
			border-left: 3px solid rgb(59, 130, 246);
			padding-left: 0.5rem;
			border-radius: 0.25rem;
		}
		
		/* 내일 그룹 색상 그룹화 (보라색 계열) */
		.legend-section [data-status-filter="내일시작"] {
			background-color: rgba(196, 181, 253, 0.2);
			border-left: 3px solid rgb(196, 181, 253);
			padding-left: 0.5rem;
			border-radius: 0.25rem;
		}
		.legend-section [data-status-filter="내일종료"] {
			background-color: rgba(147, 51, 234, 0.15);
			border-left: 3px solid rgb(147, 51, 234);
			padding-left: 0.5rem;
			border-radius: 0.25rem;
		}

        /* Legend collapse/expand toggle and states */
        .legend-section {
            position: relative;
        }
        .legend-toggle {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 8px solid #374151; /* gray-700 for stronger contrast when expanded */
            background: transparent;
            cursor: pointer;
            z-index: 1;
            outline: none;
        }
        .legend-toggle:hover,
        .legend-toggle:focus {
            border-bottom-color: #111827; /* gray-900 */
        }
        .legend-section.legend-collapsed .legend-toggle:hover,
        .legend-section.legend-collapsed .legend-toggle:focus {
            border-top-color: #1d4ed8; /* blue-700 on hover/focus when collapsed */
        }
        .legend-section.legend-collapsed {
            padding: 0 !important;
        }
        .legend-section.legend-collapsed > *:not(.legend-toggle) {
            display: none !important;
        }
        .legend-section.legend-collapsed .legend-toggle {
            border-bottom: none;
            border-top: 8px solid #2563eb; /* blue-600 for strong contrast when collapsed */
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* 개선 사항 1: 바로가기 메뉴 스타일 */
        .pinnable-control-wrapper {
            position: relative;
        }
        .pin-shortcut-btn {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background-color: #e5e7eb;
            color: #6b7280;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.5;
            z-index: 10;
        }
        .pinnable-control-wrapper:hover .pin-shortcut-btn {
            opacity: 1;
        }
        .pin-shortcut-btn.pinned {
            background-color: #4f46e5;
            color: white;
            opacity: 1;
        }
        .legend-header-actions {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .legend-header-actions .legend-button-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .legend-header-actions .legend-button-group > * {
            flex-shrink: 0;
        }
        #shortcutContainer {
            display: flex;
            align-items: center;
            gap: 0.4rem 0.5rem;
            margin-left: 0;
            flex-wrap: wrap;
            align-content: flex-start;
        }
        #shortcutContainer > * {
            flex-shrink: 0;
        }
        #shortcutContainer .shortcut-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.15rem;
            transition: transform 0.15s ease;
        }
        #shortcutContainer .shortcut-item[data-shortcut-id="toggleHierarchyOrderBtn"] {
            margin-left: 0.35rem;
            margin-right: 0.5rem;
        }
        .shortcut-item:hover {
            transform: translateY(-1px);
        }
        #shortcutContainer .shortcut-item select,
        #shortcutContainer .shortcut-item input,
        #shortcutContainer .shortcut-item button {
             font-size: 0.875rem;
             padding: 0.25rem 0.75rem;
             min-height: 28px;
             border-radius: 4px;
             border: 1px solid #e5e7eb;
             transition: all 0.2s ease;
        }
        #shortcutContainer .shortcut-search-wrapper {
            display: flex;
            align-items: center;
        }
        #shortcutContainer .shortcut-search-input {
            width: 75px;
            min-width: 75px;
            max-width: 260px;
            transition: width 0.2s ease;
        }
        #shortcutContainer .shortcut-item select:hover,
        #shortcutContainer .shortcut-item input:hover,
        #shortcutContainer .shortcut-item button:hover {
            border-color: #6366f1;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #shortcutContainer .shortcut-item select:focus,
        #shortcutContainer .shortcut-item input:focus,
        #shortcutContainer .shortcut-item button:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(99,102,241,0.2);
        }
        #shortcutContainer .shortcut-item input[type="text"] {
             width: 150px;
        }
        #shortcutContainer .shortcut-item button.js-zoom-btn {
            background-color: #f3f4f6;
            color: #4b5563;
            font-weight: 500;
        }
        #shortcutContainer .shortcut-item button.js-zoom-btn:hover {
            background-color: #e5e7eb;
            color: #1f2937;
        }

        /* Compact "유형" 및 "시공사" shortcut: 라벨 제목이 표시되는 최소 너비 */
        #shortcutContainer .shortcut-type-small-wrapper,
        #shortcutContainer .shortcut-contractor-small-wrapper,
        #shortcutContainer .shortcut-cost-account-small-wrapper {
            display: inline-block;
            max-width: 70px; /* '시공사', '유형' 글자가 표시되는 너비 */
            overflow: hidden;
            vertical-align: middle;
        }
        #shortcutContainer .shortcut-type-small,
        #shortcutContainer .shortcut-contractor-small,
        #shortcutContainer .shortcut-cost-account-small {
            width: 70px;
            max-width: 70px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            -webkit-appearance: none; /* better visual consistency */
            appearance: none;
        }
        /* Compact "진척률" 및 "정렬" shortcut: 라벨 제목이 표시되는 최소 너비 */
        #shortcutContainer .shortcut-progress-small-wrapper,
        #shortcutContainer .shortcut-sort-small-wrapper {
            display: inline-block;
            max-width: 70px; /* '진척률', '정렬' 글자가 표시되는 너비 */
            overflow: hidden;
            vertical-align: middle;
        }
        #shortcutContainer .shortcut-progress-small,
        #shortcutContainer .shortcut-sort-small {
            width: 70px;
            max-width: 70px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            -webkit-appearance: none; /* better visual consistency */
            appearance: none;
        }
        @media (max-width: 768px) {
            #shortcutContainer .shortcut-type-small-wrapper,
            #shortcutContainer .shortcut-type-small,
            #shortcutContainer .shortcut-contractor-small-wrapper,
            #shortcutContainer .shortcut-contractor-small,
            #shortcutContainer .shortcut-cost-account-small-wrapper,
            #shortcutContainer .shortcut-cost-account-small,
            #shortcutContainer .shortcut-progress-small-wrapper,
            #shortcutContainer .shortcut-progress-small,
            #shortcutContainer .shortcut-sort-small-wrapper,
            #shortcutContainer .shortcut-sort-small {
                width: 80px;
                max-width: 80px;
            }
        }

        .sort-control-wrapper {
            position: relative;
        }
        .sort-control-inner {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }
        .sort-direction-toggle {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 2px 6px;
            font-size: 0.75rem;
            line-height: 1;
            background-color: #f9fafb;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 32px;
            min-height: 40px;
        }
        .sort-direction-toggle .sort-arrow {
            opacity: 0.4;
            font-size: 0.75rem;
            line-height: 1.1;
        }
        .sort-direction-toggle .sort-arrow.active {
            opacity: 1;
            color: #4c1d95;
            font-weight: 600;
        }
        .sort-direction-toggle:hover {
            border-color: #7c3aed;
            color: #4338ca;
            background-color: #f3e8ff;
        }
        .sort-direction-toggle--disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #e5e7eb;
            background-color: #f3f4f6;
        }
        .sort-direction-toggle--disabled .sort-arrow {
            opacity: 0.25;
        }
        #shortcutContainer .shortcut-sort-small-wrapper.sort-control-wrapper {
            max-width: 110px;
        }
        #shortcutContainer .shortcut-sort-small-wrapper .sort-control-inner {
            gap: 4px;
        }
        #shortcutContainer .shortcut-sort-small-wrapper .shortcut-sort-small {
            flex: 1 1 auto;
            width: auto;
            max-width: none;
        }
        #shortcutContainer .shortcut-sort-small-wrapper .sort-direction-toggle {
            min-width: 28px;
            min-height: 34px;
            font-size: 0.65rem;
        }

    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="w-full h-full p-4 md:p-8 flex flex-col">
        <!-- Main content area -->
        <main id="dashboardContent" class="flex flex-col flex-grow min-h-0 space-y-4">

            <!-- Accordion 1: 총괄 -->
            <div class="accordion-item bg-white rounded-lg shadow-sm flex-shrink-0">
                <div class="accordion-header p-4 flex justify-between items-center border-b">
                    <h2 class="accordion-title-btn text-2xl font-bold flex items-baseline"
                        role="button"
                        tabindex="0"
                        aria-expanded="false"
                        aria-controls="accordion-panel-overview"
                        data-accordion-id="overview">
                        <span>📊 총괄</span>
                        <span class="text-lg font-medium text-gray-400 ml-2">(PO비용 기준)</span>
                        <span class="accordion-hint-chip hint-hidden" data-accordion-hint="overview">
                            <span aria-hidden="true">👆</span>
                            <span>클릭하면 펼쳐져요</span>
                        </span>
                        <span class="accordion-state-pill" data-accordion-state="overview" data-state="closed" aria-live="polite">접힘</span>
                    </h2>
                    <svg class="accordion-icon w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                 <!-- Improvement: Added scrollable-content class -->
                <div id="accordion-panel-overview" class="accordion-content p-4 scrollable-content">
                    <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-4">
                        <div class="summary-card bg-slate-100 border-l-4 border-slate-500 text-slate-700 p-4 rounded-lg shadow" data-filter-type="progress" data-filter-value="overall">
                            <div class="font-bold text-lg">총괄 공정율</div>
                            <div id="overallProgress" class="text-3xl font-extrabold">0%</div>
                            <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                                <div id="overallProgressBar" class="bg-slate-600 h-2.5 rounded-full" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="summary-card bg-sky-100 border-l-4 border-sky-500 text-sky-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="all">
                            <div class="font-bold text-lg">전체</div><div id="totalProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="공사중">
                            <div class="font-bold text-lg">진행중</div><div id="inProgressProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-gray-100 border-l-4 border-gray-500 text-gray-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="착공전">
                            <div class="font-bold text-lg">착공전</div><div id="beforeStartProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="지연">
                            <div class="font-bold text-lg">지연</div><div id="delayedProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                         <div class="summary-card bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="완료">
                            <div class="font-bold text-lg">완료</div><div id="completedProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                    </div>
                    <!-- 현재 요약이 어떤 필터(예: 고객사) 기준인지 알려주는 라벨 (눈에 튀지 않도록 연한 색상) -->
                    <div id="summaryFilterLabel" class="mt-2 text-sm text-gray-500">필터: 전체</div>
                    <div id="overview-group-summaries" class="mt-4 space-y-4"></div>
                </div>
            </div>

            <!-- Accordion 2: 정산 -->
            <div class="accordion-item bg-white rounded-lg shadow-sm flex-shrink-0">
                <div class="accordion-header p-4 flex items-center border-b">
                    <h2 class="accordion-title-btn text-2xl font-bold flex items-baseline"
                        role="button"
                        tabindex="0"
                        aria-expanded="false"
                        aria-controls="accordion-panel-settlement"
                        data-accordion-id="settlement">
                        <span>💰 정산</span>
                        <span class="text-lg font-medium text-gray-400 ml-2">(PO비용 기준)</span>
                        <span class="accordion-hint-chip hint-hidden" data-accordion-hint="settlement">
                            <span aria-hidden="true">👆</span>
                            <span>정산 내용을 펼쳐보세요</span>
                        </span>
                        <span class="accordion-state-pill" data-accordion-state="settlement" data-state="closed" aria-live="polite">접힘</span>
                    </h2>
                    <div id="settlement-header-summaries" class="ml-auto text-right text-xl font-semibold text-gray-600"></div>
                    <svg class="accordion-icon w-6 h-6 flex-shrink-0 ml-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                 <!-- Improvement: Added scrollable-content class -->
                <div id="accordion-panel-settlement" class="accordion-content p-4 scrollable-content settlement-scrollable">
                    <div id="poSummary" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4"></div>
                    <!-- 개선 사항 1: 금액대별 프로젝트 현황 섹션 추가 -->
                    <div id="poRangeSummary" class="mt-6"></div>
                    <!-- 개선 사항 1: 정산 효율 분석 섹션 추가 -->
                    <div id="settlementEfficiencyAnalysis" class="mt-6"></div>
                    <div id="settlement-group-summaries" class="mt-4 space-y-4"></div> <!-- Added space-y-4 -->
                </div>
            </div>

            <!-- Accordion 3: 일정 -->
            <div id="projectView" class="accordion-item bg-white rounded-lg shadow-sm flex flex-col flex-grow min-h-0">
                 <div class="accordion-header p-4 flex justify-between items-center border-b">
                     <button id="scheduleHeaderToggle" class="schedule-header-toggle" aria-expanded="true" title="접기"></button>
                     <div class="flex items-center flex-grow">
                        <h2 class="accordion-title-btn text-2xl font-bold transition-colors"
                            role="button"
                            tabindex="0"
                            aria-expanded="false"
                            aria-controls="accordion-panel-schedule"
                            data-accordion-id="schedule"
                            style="user-select: none;">
                            <span>🗓️ 일정</span>
                            <span class="accordion-hint-chip hint-hidden" data-accordion-hint="schedule">
                                <span aria-hidden="true">👆</span>
                                <span>타임라인을 열어보세요</span>
                            </span>
                            <span class="accordion-state-pill" data-accordion-state="schedule" data-state="closed" aria-live="polite">접힘</span>
                        </h2>
                        <!-- 개선 사항: 발주처와 시공사 바로가기 추가 -->
                        <div class="flex items-center gap-2 ml-4 flex-wrap" style="pointer-events: auto;">
                            <select id="header-customer-filter-shortcut" class="px-3 py-1 text-sm border border-gray-300 rounded hover:border-violet-500 focus:ring-2 focus:ring-violet-500 focus:border-violet-500 bg-white" style="pointer-events: auto;">
                                <option value="all">발주처</option>
                            </select>
                            <select id="header-contractor-filter-shortcut" class="px-3 py-1 text-sm border border-gray-300 rounded hover:border-violet-500 focus:ring-2 focus:ring-violet-500 focus:border-violet-500 bg-white" style="pointer-events: auto;">
                                <option value="all">시공사</option>
                            </select>
                            <select id="header-cost-account-filter-shortcut" class="px-3 py-1 text-sm border border-gray-300 rounded hover:border-violet-500 focus:ring-2 focus:ring-violet-500 focus:border-violet-500 bg-white" style="pointer-events: auto;">
                                <option value="all">비용계정</option>
                            </select>
                        </div>
                     </div>
                     <svg class="accordion-icon w-6 h-6 flex-shrink-0 cursor-pointer" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                 </div>
                  <!-- Marked as flex-grow for layout -->
                 <div id="accordion-panel-schedule" class="accordion-content flex-grow flex flex-col min-h-0">
                    <div class="p-4 flex-grow flex flex-col min-h-0">
                        <div id="ganttViewContent" class="flex flex-col flex-grow min-h-0 h-full">
                            <!-- 개선 사항: 범례(Legend) 섹션을 컨트롤 패널 밖으로 이동 -->
                            <div id="legendSection" class="legend-section relative flex items-center gap-x-3 gap-y-2 border p-4 mb-4 rounded-lg shadow-md bg-white w-full flex-wrap">
                                <button id="legendToggle" class="legend-toggle" aria-expanded="true" title="접기"></button>
                                <h3 class="text-lg font-semibold flex-shrink-0 flex items-center gap-3">
                                    <span>범례</span>
                                    <div class="legend-header-actions">
                                        <div class="legend-button-group">
                                            <button id="fullscreenBtn" class="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 flex-shrink-0">전체 화면</button>
                                            <button id="legendGoToTodayBtn" class="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 flex-shrink-0">오늘</button>
                                            <button id="milestoneBtn" class="px-3 py-1 bg-rose-500 text-white text-sm rounded hover:bg-rose-600 flex-shrink-0">마일스톤</button>
                                        </div>
                                        <div id="shortcutContainer" class="flex items-center gap-2 flex-shrink-0"></div>
                                    </div>
                                </h3>
                                <div class="flex flex-nowrap items-center gap-x-2">
								<div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="전체">
									<span class="w-4 h-4 rounded" style="background: linear-gradient(90deg, rgb(156, 163, 175), rgb(59, 130, 246), rgb(239, 68, 68), rgb(34, 197, 94));"></span>
									<span class="text-sm">전체 <span id="legendAll" class="font-mono text-gray-500"></span></span>
								</div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="착공전">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(156, 163, 175);"></span>
                                        <span class="text-sm">착공전 <span id="legendNotStarted" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="공사중">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(59, 130, 246);"></span>
                                        <span class="text-sm">공사중 <span id="legendInProgress" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="오늘시작">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(96, 165, 250);"></span>
                                        <span class="text-sm">오늘 시작 <span id="legendTodayStart" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="오늘종료">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(59, 130, 246);"></span>
                                        <span class="text-sm">오늘 종료 <span id="legendTodayEnd" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="내일시작">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(196, 181, 253);"></span>
                                        <span class="text-sm">내일 시작 <span id="legendTomorrowStart" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="내일종료">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(147, 51, 234);"></span>
                                        <span class="text-sm">내일 종료 <span id="legendTomorrowEnd" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="지연">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(239, 68, 68);"></span>
                                        <span class="text-sm">지연 <span id="legendDelayed" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="완료">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(34, 197, 94);"></span>
                                        <span class="text-sm">완료 <span id="legendCompleted" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="w-4 h-4 rounded" style="background: linear-gradient(90deg, rgb(156, 163, 175), rgb(59, 130, 246), rgb(34, 197, 94));"></span>
                                        <span class="text-sm">그룹 진행률 <span id="legendGroupProgress" class="font-mono text-gray-500"></span></span>
                                    </div>
                                </div>
                            </div>

                            <div id="ganttChartWrapper" class="flex-grow min-h-0">
                                <div id="ganttChart" class="space-y-6 bg-white h-full"></div>
                            </div>
                        </div>
                    </div>
                 </div>
            </div>
        </main>
    </div>

    <!-- 개선 사항: 설정(컨트롤) 슬라이드 패널 -->
    <div id="controlsPanelOverlay" class="fixed inset-0 bg-black bg-opacity-40 z-[130] hidden transition-opacity duration-300"></div>
    <div id="controlsPanel" class="fixed top-0 right-0 h-full bg-white shadow-2xl z-[140] transform translate-x-full transition-transform duration-300 ease-in-out w-full max-w-sm">
        <div class="flex justify-between items-center p-4 border-b">
            <h2 class="text-xl font-bold">필터 및 타임라인 설정</h2>
            <button id="closeControlsPanelBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
        </div>
        <div class="p-4 overflow-y-auto h-[calc(100%-65px)]">
            <!-- 기존 Controls Section이 이곳으로 이동 -->
            <section id="controlsSection">
                <!-- Filtering & Sorting Toggle -->
                <div class="control-section-header open">
                    <h3 class="text-lg font-semibold">필터링 및 정렬</h3>
                    <svg class="control-section-icon w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="control-section-content">
                    <div class="flex flex-col gap-4">
                        <div class="pinnable-control-wrapper">
                            <select id="progressFilter" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                <option value="all">진척률</option>
                                <option value="not_started">미착수 (0%)</option>
                                <option value="in_progress">진행중 (1-99%)</option>
                                <option value="completed">완료 (100%)</option>
                            </select>
                        </div>
                        <div class="pinnable-control-wrapper">
                            <select id="taskTypeFilter" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                <option value="all">유형</option>
                            </select>
                        </div>
                        <div id="customFilterContainer" class="flex flex-col gap-4"></div>
                        <div class="pinnable-control-wrapper sort-control-wrapper">
                            <div class="sort-control-inner">
                                <select id="sortBy" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                    <option value="default">정렬</option>
                                    <option value="startDate">시작일 순</option>
                                    <option value="endDate">종료일 순</option>
                                    <option value="duration">기간 순</option>
                                    <option value="progress">진행 순</option>
                                </select>
                                <button type="button"
                                        class="sort-direction-toggle"
                                        data-sort-target="sortBy"
                                        aria-label="정렬 방향 전환"
                                        title="정렬 방향 전환">
                                    <span class="sort-arrow sort-arrow-up" aria-hidden="true">▲</span>
                                    <span class="sort-arrow sort-arrow-down" aria-hidden="true">▼</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Timeline Toggle -->
                <div class="control-section-header open mt-4">
                    <h3 class="text-lg font-semibold">타임라인</h3>
                    <svg class="control-section-icon w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="control-section-content">
                    <div class="flex flex-col gap-4">
                         <div class="relative pinnable-control-wrapper">
                            <div class="relative">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 pointer-events-none" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                                </svg>
                                <input type="text" id="searchInput" placeholder="검색..." class="w-full p-2 pl-10 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500 transition">
                            </div>
                        </div>
                        <div class="relative pinnable-control-wrapper">
                            <button id="zoomBtn" class="w-full text-left p-2 bg-gray-200 rounded hover:bg-gray-300 js-zoom-btn">날짜 설정</button>
                        </div>
                        <div class="pinnable-control-wrapper">
                            <button id="showChangesBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300 filter-toggle-btn">변경</button>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="pinnable-control-wrapper"><button id="expandAllBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300">펼치기</button></div>
                            <div class="pinnable-control-wrapper"><button id="collapseAllBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300">접기</button></div>
                        </div>
                        <div class="pinnable-control-wrapper">
                            <button id="toggleHierarchyOrderBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300">계층순서</button>
                        </div>
                         <div class="pinnable-control-wrapper">
                            <button id="goToTodayBtn" class="w-full p-2 bg-blue-500 text-white rounded-md">오늘</button>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>


    <!-- Data Detail Modal -->
    <!-- 작업 의존성 설정 모달 -->
    <div id="dependencyModal" class="dependency-modal hidden">
        <div class="dependency-modal-content">
            <div class="dependency-modal-header">
                <h3 class="dependency-modal-title">작업 의존성 설정</h3>
                <button class="dependency-modal-close" onclick="closeDependencyModal()">&times;</button>
            </div>
            <div id="dependencyModalBody">
                <div class="dependency-form-group">
                    <label class="dependency-form-label">현재 작업</label>
                    <div id="dependencyCurrentProject" style="padding: 8px; background: #f8fafc; border-radius: 6px; font-weight: 500;"></div>
                </div>
                <div class="dependency-form-group">
                    <label class="dependency-form-label" style="display: flex; align-items: center; gap: 8px;">
                        <span>의존 작업 선택</span>
                        <button type="button" id="dependencySearchToggle" class="dependency-search-toggle" title="검색" style="background: none; border: none; cursor: pointer; font-size: 16px; padding: 4px; color: #64748b;">🔍</button>
                    </label>
                    <div id="dependencySearchContainer" style="display: none; margin-bottom: 8px;">
                        <input type="text" id="dependencySearchInput" placeholder="작업명으로 검색..." class="dependency-search-input" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    </div>
                    <select id="dependencyProjectSelect" class="dependency-form-select" multiple style="min-height: 120px;">
                    </select>
                    <div style="font-size: 12px; color: #64748b; margin-top: 4px;">Ctrl/Cmd 키를 누른 채로 여러 작업을 선택할 수 있습니다.</div>
                </div>
                <div class="dependency-form-group">
                    <label class="dependency-form-label" style="display: flex; align-items: center; gap: 8px;">
                        <span>의존성 유형</span>
                        <button type="button" id="dependencyTypeHelpToggle" class="dependency-type-help-toggle" title="의존성 유형 도움말" style="background: none; border: none; cursor: pointer; font-size: 16px; padding: 4px; color: #6366f1; font-weight: bold;">!</button>
                    </label>
                    <div id="dependencyTypeHelpContainer" class="dependency-type-help-container" style="display: none; margin-bottom: 12px; padding: 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">
                        <div class="dependency-type-help-content" style="font-size: 13px; line-height: 1.6; color: #374151;">
                            <div style="margin-bottom: 12px;">
                                <strong style="color: #1e293b;">시작→시작 (SS)</strong>
                                <div style="margin-top: 4px; padding-left: 12px;">
                                    <div><strong>적용 방법:</strong> 선행 작업이 시작되면 현재 작업도 동시에 시작됩니다.</div>
                                    <div><strong>의도:</strong> 두 작업이 동시에 시작되어야 하는 경우에 사용합니다.</div>
                                    <div><strong>목적:</strong> 병렬 작업 시작을 보장하여 전체 프로젝트 일정을 단축합니다.</div>
                                </div>
                            </div>
                            <div style="margin-bottom: 12px;">
                                <strong style="color: #1e293b;">종료→시작 (FS)</strong>
                                <div style="margin-top: 4px; padding-left: 12px;">
                                    <div><strong>적용 방법:</strong> 선행 작업이 완료되면 현재 작업이 시작됩니다.</div>
                                    <div><strong>의도:</strong> 선행 작업의 결과물이 필요하거나 완료 후에만 시작 가능한 경우에 사용합니다.</div>
                                    <div><strong>목적:</strong> 작업 순서를 보장하여 작업 간 의존성을 명확히 관리합니다. 가장 일반적인 의존성 유형입니다.</div>
                                </div>
                            </div>
                            <div style="margin-bottom: 12px;">
                                <strong style="color: #1e293b;">종료→종료 (FF)</strong>
                                <div style="margin-top: 4px; padding-left: 12px;">
                                    <div><strong>적용 방법:</strong> 선행 작업이 완료되면 현재 작업도 동시에 완료됩니다.</div>
                                    <div><strong>의도:</strong> 두 작업이 동시에 완료되어야 하는 경우에 사용합니다.</div>
                                    <div><strong>목적:</strong> 관련 작업들의 동시 완료를 보장하여 다음 단계로의 전환을 원활하게 합니다.</div>
                                </div>
                            </div>
                            <div>
                                <strong style="color: #1e293b;">시작→종료 (SF)</strong>
                                <div style="margin-top: 4px; padding-left: 12px;">
                                    <div><strong>적용 방법:</strong> 선행 작업이 시작되면 현재 작업이 완료됩니다.</div>
                                    <div><strong>의도:</strong> 특수한 상황에서 선행 작업의 시작을 신호로 사용하는 경우에 사용합니다.</div>
                                    <div><strong>목적:</strong> 작업 간 특수한 연계 관계를 표현하여 복잡한 프로젝트 일정을 관리합니다.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="dependency-type-group">
                        <div class="dependency-type-option" data-type="start-to-start" onclick="selectDependencyType('start-to-start')">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="radio" name="dependencyType" value="start-to-start" id="dependencyType-ss" class="dependency-type-radio" style="cursor: pointer;">
                                <div style="flex: 1;">
                                    <div class="dependency-type-option-title">시작→시작 (SS)</div>
                                    <div class="dependency-type-option-desc">선행 작업 시작 시 시작</div>
                                </div>
                            </div>
                        </div>
                        <div class="dependency-type-option" data-type="end-to-start" onclick="selectDependencyType('end-to-start')">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="radio" name="dependencyType" value="end-to-start" id="dependencyType-fs" class="dependency-type-radio" style="cursor: pointer;">
                                <div style="flex: 1;">
                                    <div class="dependency-type-option-title">종료→시작 (FS)</div>
                                    <div class="dependency-type-option-desc">선행 작업 종료 시 시작</div>
                                </div>
                            </div>
                        </div>
                        <div class="dependency-type-option" data-type="end-to-end" onclick="selectDependencyType('end-to-end')">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="radio" name="dependencyType" value="end-to-end" id="dependencyType-ff" class="dependency-type-radio" style="cursor: pointer;">
                                <div style="flex: 1;">
                                    <div class="dependency-type-option-title">종료→종료 (FF)</div>
                                    <div class="dependency-type-option-desc">선행 작업 종료 시 종료</div>
                                </div>
                            </div>
                        </div>
                        <div class="dependency-type-option" data-type="start-to-end" onclick="selectDependencyType('start-to-end')">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="radio" name="dependencyType" value="start-to-end" id="dependencyType-sf" class="dependency-type-radio" style="cursor: pointer;">
                                <div style="flex: 1;">
                                    <div class="dependency-type-option-title">시작→종료 (SF)</div>
                                    <div class="dependency-type-option-desc">선행 작업 시작 시 종료</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dependency-modal-actions">
                <button class="dependency-modal-btn dependency-modal-btn-secondary" onclick="closeDependencyModal()">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" style="display: inline-block; vertical-align: middle; margin-right: 6px;">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                    </svg>
                    취소
                </button>
                <button class="dependency-modal-btn dependency-modal-btn-danger" onclick="clearDependency()" id="clearDependencyBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" style="display: inline-block; vertical-align: middle; margin-right: 6px;">
                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"/>
                    </svg>
                    의존성 해제
                </button>
                <button class="dependency-modal-btn dependency-modal-btn-primary" onclick="saveDependency()">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" style="display: inline-block; vertical-align: middle; margin-right: 6px;">
                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                    </svg>
                    저장
                </button>
            </div>
        </div>
    </div>

    <div id="dataDetailModal" class="modal-overlay hidden">
        <div class="modal-content">
             <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 id="dataDetailTitle" class="text-xl font-bold text-gray-800">상세 데이터</h2>
                <button id="closeDataDetailModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="resizable-modal-body">
                <div id="dataDetailTableContainer" class="h-full overflow-y-auto">
                    <!-- Table will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Gantt Modal -->
    <div id="fullscreenModal" class="fullscreen-modal-overlay hidden">
        <div class="resizable-modal-content">
            <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">일정 (전체 화면)</h2>
                <button id="closeFullscreenModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
             <!-- Fullscreen body now uses flex-col for layout -->
            <div id="fullscreenModalBody" class="resizable-modal-body flex flex-col">
                 <!-- Legend and Gantt Chart will be moved here -->
            </div>
        </div>
    </div>

    <!-- Milestone Modal -->
    <div id="milestoneModal" class="modal-overlay hidden">
        <div class="modal-content w-auto min-w-[500px] h-auto min-h-[400px] resize overflow-visible">
            <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">마일스톤 관리</h2>
                <button id="closeMilestoneModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="p-6 flex-grow flex flex-col">
                <div id="milestoneList" class="flex-grow mb-4 overflow-y-auto pr-2">
                    <!-- Milestone items will be injected here -->
                </div>
                <form id="addMilestoneForm" class="flex items-center gap-2 border-t pt-4">
                    <input type="date" id="milestoneDate" class="p-2 border rounded" required>
                    <input type="text" id="milestoneName" placeholder="마일스톤 이름" class="p-2 border rounded flex-grow" required>
                    <button type="submit" class="p-2 bg-rose-500 text-white rounded hover:bg-rose-600">추가</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Data Mapping Modal -->
    <div id="mappingModal" class="modal-overlay hidden">
        <div class="modal-content !max-w-6xl !w-auto !h-auto">
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">데이터 매핑 및 미리보기</h2>
                <button id="closeMappingModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="p-6 space-y-4" style="max-height: 60vh; overflow-y: auto;">
                <div class="flex items-center gap-4 bg-gray-50 p-3 rounded-md flex-wrap">
                    <div class="flex items-center gap-2">
                        <label for="mappingHeaderRowCount" class="text-sm font-medium text-gray-700 flex-shrink-0">헤더 시작 행:</label>
                        <input type="number" id="mappingHeaderRowCount" value="1" min="1" class="w-20 p-1 border border-gray-300 rounded-md text-center focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="mappingHeaderRowCountNumber" class="text-sm font-medium text-gray-700 flex-shrink-0">헤더 행 갯수:</label>
                        <input type="number" id="mappingHeaderRowCountNumber" value="2" min="1" max="5" class="w-20 p-1 border border-gray-300 rounded-md text-center focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                    </div>
                    <p class="text-sm text-gray-500">파일에서 헤더(제목)가 시작되는 행 번호와 헤더 행의 갯수를 지정하세요.</p>
                </div>
                <div class="flex items-center gap-2 bg-gray-50 p-2 rounded-md">
                    <input type="checkbox" id="saveMappingHeaderSettings" class="w-4 h-4 text-violet-600 border-gray-300 rounded focus:ring-violet-500">
                    <label for="saveMappingHeaderSettings" class="text-sm text-gray-700 cursor-pointer">이 선택을 저장하기</label>
                </div>
                <!-- IMPROVEMENT: Added guidance text for data mapping -->
                <div class="bg-indigo-50 border-l-4 border-indigo-500 text-indigo-800 p-4 rounded-md mb-4 text-sm" role="alert">
                    <p class="font-bold">데이터 매핑 안내</p>
                    <p>업로드한 파일의 각 열(Column)이 어떤 데이터에 해당하는지 아래 드롭다운 메뉴에서 선택해주세요.</p>
                    <ul class="list-disc list-inside mt-2">
                        <li><strong class="font-semibold">'명칭', '시작일', '종료일'</strong>은 필수 항목입니다.</li>
                        <li>시스템에서 자동으로 최적의 매핑을 제안하지만, 필요시 직접 수정할 수 있습니다.</li>
                        <li>불필요한 열은 '무시'로 설정하세요.</li>
                    </ul>
                </div>
                <div id="mappingPreviewContainer" class="overflow-auto border rounded-md" style="max-height: 50vh;">
                    <!-- Mapping preview table will be injected here -->
                </div>
            </div>
            <div class="flex justify-end items-center p-4 border-t bg-gray-50 rounded-b-md">
                <button id="cancelMappingBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 mr-2">취소</button>
                <button id="applyMappingBtn" class="px-4 py-2 bg-violet-600 text-white rounded-md hover:bg-violet-700">데이터 적용</button>
            </div>
        </div>
    </div>

    <!-- Date Settings Modal -->
    <div id="zoomModal" class="modal-overlay hidden">
        <div class="modal-content w-auto min-w-[380px] h-auto min-h-[350px]">
            <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 class="text-lg font-bold text-gray-800">날짜 설정</h2>
                <button id="closeZoomModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div id="zoomPopover" class="resizable-modal-body p-4 space-y-3">
                <h4 class="font-bold text-sm">기간 설정</h4>
                <div class="flex items-center gap-2">
                    <input type="date" id="zoomStartDate" class="w-full p-1 border rounded text-sm">
                    <span>~</span>
                    <input type="date" id="zoomEndDate" class="w-full p-1 border rounded text-sm">
                </div>
                <h4 class="font-bold text-sm pt-2">주 단위 선택</h4>
                <div class="grid grid-cols-3 gap-2">
                    <button id="zoomPrevWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">이전 주</button>
                    <button id="zoomThisWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">이번 주</button>
                    <button id="zoomNextWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">다음 주</button>
                </div>
                <h4 class="font-bold text-sm pt-2">3주 단위 선택</h4>
                <div class="grid grid-cols-2 gap-2">
                    <button id="zoomThreeWeeksToday" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">3주간(오늘)</button>
                    <button id="zoomThreeWeeksSelected" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">3주간(지정)</button>
                </div>
                <div class="flex justify-end gap-2 pt-3 border-t">
                    <button id="zoomResetBtn" class="px-3 py-1 bg-gray-500 text-white text-xs rounded hover:bg-gray-600">초기화</button>
                    <button id="zoomApplyBtn" class="px-3 py-1 bg-indigo-500 text-white text-xs rounded hover:bg-indigo-600">적용</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Correction Modal -->
    <div id="errorCorrectionModal" class="modal-overlay hidden">
        <div class="modal-content !max-w-7xl !h-[90vh]">
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">데이터 업로드 오류 수정</h2>
                <button id="closeErrorCorrectionModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <!-- IMPROVEMENT: Enhanced guidance text for error correction -->
            <div id="errorCorrectionInfo" class="p-4 bg-yellow-50 text-yellow-800 border-b text-sm">
                <!-- Info text will be injected here -->
            </div>
            <div class="flex-grow overflow-auto">
                <div id="errorCorrectionContainer" class="p-4">
                    <!-- Error correction table will be injected here -->
                </div>
            </div>
            <div class="flex justify-end items-center p-4 border-t bg-gray-50 rounded-b-md">
                <button id="discardErrorsBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 mr-2">오류 데이터 무시하고 닫기</button>
                <button id="retryImportBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">수정된 항목 가져오기</button>
            </div>
        </div>
    </div>

    <!-- Floating Action Buttons -->
    <button id="revisionHistoryFabBtn" aria-label="변경 이력" title="변경 이력" class="fixed bottom-48 bg-blue-600 text-white rounded-full shadow-lg flex items-center justify-center hover:bg-blue-700 transition-transform duration-200 ease-in-out hover:-translate-y-0.5 z-[140]" style="right: 8px; width: 45px; height: 45px;">
        <span class="relative flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="text-white" style="width: 28px; height: 28px;" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"/>
            </svg>
        </span>
    </button>
    <button id="filterTimelineFabBtn" aria-label="필터 및 타임라인 설정" title="필터 및 타임라인 설정" class="fixed bottom-28 bg-violet-600 text-white rounded-full shadow-lg flex items-center justify-center hover:bg-violet-700 transition-transform duration-200 ease-in-out hover:-translate-y-0.5 z-[140]" style="right: 8px; width: 45px; height: 45px;">
        <span class="relative flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="text-white" style="width: 28px; height: 28px;" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 011 1v1a1 1 0 01-.293.707L13 11.414V17a1 1 0 01-.553.894l-2 1A1 1 0 019 18v-6.586L3.293 5.707A1 1 0 013 5V4z" clip-rule="evenodd"/>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="text-violet-100 absolute -bottom-1 -right-1 drop-shadow-md" style="width: 14px; height: 14px;" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10 3a7 7 0 100 14 7 7 0 000-14zm0 2a5 5 0 110 10 5 5 0 010-10zm-.75 2.75c0-.414.336-.75.75-.75s.75.336.75.75V10.5h1.75a.75.75 0 010 1.5h-2.5A.75.75 0 019.25 11V7.75z" clip-rule="evenodd"/>
            </svg>
        </span>
    </button>
    <button id="fabMenuBtn" class="fixed bottom-8 bg-indigo-600 text-white rounded-full shadow-lg flex items-center justify-center hover:bg-indigo-700 transition-transform duration-200 ease-in-out hover:rotate-90 z-[140]" style="right: 8px; width: 45px; height: 45px;">
        <svg xmlns="http://www.w3.org/2000/svg" style="width: 32px; height: 32px;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
        </svg>
    </button>

    <!-- Data Management Panel -->
    <div id="dataPanel" class="fixed top-0 left-0 w-full h-full bg-black bg-opacity-40 flex justify-center items-center z-[150] hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md" id="dataPanelContent">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold">데이터 관리</h2>
                <button id="closeDataPanelBtn" class="text-gray-400 hover:text-gray-700">&times;</button>
            </div>

            <div class="space-y-3">
                <p class="text-sm text-center text-gray-500 pb-2">새로운 데이터를 불러오거나 현재 데이터를 저장하세요.</p>

                <div class="bg-gray-50 p-3 rounded-md space-y-2">
                    <div class="flex items-center justify-center gap-2">
                        <label for="headerRowCount" class="text-sm font-medium text-gray-700 flex-shrink-0">헤더 시작 행:</label>
                        <input type="number" id="headerRowCount" value="1" min="1" class="w-20 p-1 border border-gray-300 rounded-md text-center focus:ring-2 focus:ring-violet-500 focus:border-violet-500" title="헤더가 시작되는 실제 행 번호를 입력하세요 (예: 1)">
                    </div>
                    <div class="flex items-center justify-center gap-2">
                        <input type="checkbox" id="saveDataPanelHeaderSettings" class="w-4 h-4 text-violet-600 border-gray-300 rounded focus:ring-violet-500">
                        <label for="saveDataPanelHeaderSettings" class="text-sm text-gray-700 cursor-pointer">이 선택을 저장하기</label>
                    </div>
                </div>

                <!-- Upload -->
                <button id="uploadBtn" class="w-full flex items-center justify-center gap-3 p-3 bg-violet-50 text-violet-700 rounded-lg hover:bg-violet-100 font-semibold transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>
                    <span>데이터 업로드 (.csv, .xlsx)</span>
                </button>
                <input type="file" id="fileInput" accept=".csv, .xls, .xlsx" multiple class="hidden"/>

                <!-- Download Template -->
                <div class="flex gap-2 justify-center pt-2">
                     <button data-format="csv" class="download-template-btn flex-1 p-2 bg-gray-100 text-gray-700 text-sm rounded hover:bg-gray-200 transition">양식 (.csv)</button>
                     <button data-format="xlsx" class="download-template-btn flex-1 p-2 bg-gray-100 text-gray-700 text-sm rounded hover:bg-gray-200 transition">양식 (.xlsx)</button>
                </div>

                <!-- Export Data Section -->
                <div class="space-y-3 pb-2">
                    <p class="text-sm text-center text-gray-500">현재 데이터를 엑셀 또는 CSV로 내보내기</p>
                    <div class="flex gap-2">
                        <button id="exportToExcelBtn" class="flex-1 flex items-center justify-center gap-2 p-3 bg-indigo-50 text-indigo-700 rounded-lg hover:bg-indigo-100 font-semibold transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                            <span>Excel 다운로드</span>
                        </button>
                        <button id="exportToCsvBtn" class="flex-1 flex items-center justify-center gap-2 p-3 bg-blue-50 text-blue-700 rounded-lg hover:bg-blue-100 font-semibold transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                            <span>CSV 다운로드</span>
                        </button>
                    </div>
                </div>
                
                <!-- Separator -->
                <hr class="my-4 border-t border-gray-200"/>

                <!-- Save current state -->
                <button id="saveHtmlBtn" class="w-full flex items-center justify-center gap-3 p-3 bg-green-50 text-green-700 rounded-lg hover:bg-green-100 font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed group relative" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6a1 1 0 10-2 0v5.586L7.707 10.293zM3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 11-2 0V5H5v1a1 1 0 11-2 0V4z" />
                    </svg>
                    <span>현재 작업 내용 저장</span>
                    <div class="opacity-0 group-hover:opacity-100 transition-opacity absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-1 bg-gray-800 text-white text-xs rounded whitespace-nowrap">
                        모든 데이터와 설정이 저장되며, 나중에 이어서 작업할 수 있습니다
                    </div>
                </button>
                <p id="saveMessage" class="text-sm text-center text-gray-600 pt-2 pb-1 hidden flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>
                    <span>저장된 파일은 인터넷 없이도 단독으로 실행되며 모든 작업 내용이 보존됩니다</span>
                </p>
                <!-- Auto-upload URL 설정 (사용자가 변경 가능) -->
                <div class="mt-4 border-t pt-3 space-y-3">
                    <div>
                        <label class="text-sm font-medium text-gray-700 block mb-2">자동 업로딩 URL (GitHub 등)</label>
                        <div class="mb-3">
                            <div class="flex items-center gap-3 mb-2">
                                <input type="radio" id="autoUploadTypeExcel" name="autoUploadType" value="excel" class="w-4 h-4" checked />
                                <label for="autoUploadTypeExcel" class="text-sm text-gray-700 cursor-pointer">Excel</label>
                                <input type="radio" id="autoUploadTypeCsv" name="autoUploadType" value="csv" class="w-4 h-4" />
                                <label for="autoUploadTypeCsv" class="text-sm text-gray-700 cursor-pointer">CSV</label>
                            </div>
                        </div>
                        <!-- Excel URL -->
                        <div id="excelUrlSection" class="space-y-2">
                            <label for="autoUploadUrlInput" class="text-xs font-medium text-gray-600">Excel 파일 URL</label>
                            <input id="autoUploadUrlInput" type="text" class="w-full p-2 border border-gray-300 rounded-md text-sm" placeholder="자동 불러올 Excel 파일의 URL을 입력하세요" />
                        </div>
                        <!-- CSV URLs -->
                        <div id="csvUrlSection" class="space-y-2 hidden">
                            <div>
                                <label for="csvProjectUrlInput" class="text-xs font-medium text-gray-600">CSV 파일 URL (입력 데이터)</label>
                                <input id="csvProjectUrlInput" type="text" class="w-full p-2 border border-gray-300 rounded-md text-sm" placeholder="프로젝트 데이터 CSV URL" />
                            </div>
                            <div>
                                <label for="csvMilestoneUrlInput" class="text-xs font-medium text-gray-600">CSV 파일 URL (마일스톤)</label>
                                <input id="csvMilestoneUrlInput" type="text" class="w-full p-2 border border-gray-300 rounded-md text-sm" placeholder="마일스톤 데이터 CSV URL" />
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                        <input id="autoUploadEnabled" type="checkbox" class="w-4 h-4" />
                        <label for="autoUploadEnabled" class="text-sm text-gray-600">페이지 로드 시 자동으로 불러오기</label>
                        <button id="autoUploadNowBtn" class="ml-auto px-3 py-1 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700">지금 불러오기</button>
                    </div>
                    <p class="text-xs text-gray-500">인터넷 연결이 없거나 파일이 없을 경우 기존 로컬 업로드 방식이 동작합니다.</p>
                    <button id="resetDateChangesBtn" class="w-full px-3 py-2 bg-orange-100 text-orange-700 text-sm rounded hover:bg-orange-200 transition disabled:opacity-50 disabled:cursor-not-allowed">날짜 변경 표시 초기화</button>
                </div>
                
            </div>
        </div>
    </div>

    <!-- Revision History Panel -->
    <div id="revisionHistoryPanel" class="fixed top-0 left-0 w-full h-full bg-black bg-opacity-40 z-[150] hidden">
        <div id="revisionHistoryPanelContent" class="bg-white rounded-lg shadow-xl p-6 flex flex-col absolute" style="width: 800px; height: 600px; top: 50%; left: 50%; transform: translate(-50%, -50%); min-width: 400px; min-height: 300px; max-width: 95vw; max-height: 95vh;">
            <!-- Resizer handles -->
            <div class="resizer-handle n"></div>
            <div class="resizer-handle s"></div>
            <div class="resizer-handle e"></div>
            <div class="resizer-handle w"></div>
            <div class="resizer-handle ne"></div>
            <div class="resizer-handle nw"></div>
            <div class="resizer-handle se"></div>
            <div class="resizer-handle sw"></div>
            
            <div id="revisionHistoryPanelHeader" class="flex justify-between items-center mb-4 cursor-move" style="user-select: none;">
                <h2 class="text-xl font-bold">변경 이력 (Revision History)</h2>
                <button id="closeRevisionHistoryPanelBtn" class="text-gray-400 hover:text-gray-700 text-3xl leading-none">&times;</button>
            </div>
            
            <!-- Toolbar -->
            <div class="flex flex-wrap gap-2 mb-4 pb-3 border-b">
                <button id="exportRevisionHistoryBtn" class="px-3 py-1.5 bg-green-600 text-white text-sm rounded hover:bg-green-700 transition flex items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd"/>
                    </svg>
                    엑셀 다운로드
                </button>
                <button id="importRevisionHistoryBtn" class="px-3 py-1.5 bg-blue-600 text-white text-sm rounded hover:bg-blue-700 transition flex items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"/>
                    </svg>
                    엑셀 업로드
                </button>
                <input type="file" id="revisionHistoryFileInput" accept=".xlsx,.xls" class="hidden"/>
                <button id="revisionHistorySearchBtn" class="px-3 py-1.5 bg-purple-600 text-white text-sm rounded hover:bg-purple-700 transition flex items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"/>
                    </svg>
                    검색
                </button>
                <button id="revisionHistoryStatsBtn" class="px-3 py-1.5 bg-orange-600 text-white text-sm rounded hover:bg-orange-700 transition flex items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z"/>
                    </svg>
                    통계
                </button>
                <button id="revisionHistoryCompareBtn" class="px-3 py-1.5 bg-indigo-600 text-white text-sm rounded hover:bg-indigo-700 transition flex items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 5a2 2 0 012-2h10a2 2 0 012 2v8a2 2 0 01-2 2h-2.22l.123.489.804.804A1 1 0 0113 18H7a1 1 0 01-.707-1.707l.804-.804L7.22 15H5a2 2 0 01-2-2V5zm5.771 7H5V5h10v7H8.771z" clip-rule="evenodd"/>
                    </svg>
                    비교
                </button>
                <button id="resetRevisionHistoryBtn" class="px-3 py-1.5 bg-red-600 text-white text-sm rounded hover:bg-red-700 transition flex items-center gap-1 cursor-pointer" style="pointer-events: auto; z-index: 10;">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"/>
                    </svg>
                    초기화
                </button>
                <button id="revisionHistorySettingsBtn" class="px-3 py-1.5 bg-gray-600 text-white text-sm rounded hover:bg-gray-700 transition flex items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"/>
                    </svg>
                    설정
                </button>
            </div>
            
            <!-- Revision History Settings (Auto Upload) -->
            <div id="revisionHistorySettingsPanel" class="mb-4 p-3 bg-gray-100 rounded-lg border border-gray-200 hidden">
                <h3 class="text-sm font-bold text-gray-700 mb-2">변경 이력 자동 업로드 설정</h3>
                <div class="space-y-2">
                    <div>
                        <label class="text-xs font-medium text-gray-600 block mb-1">GitHub URL</label>
                        <input type="text" id="revisionHistoryAutoUrlInput" class="w-full p-1.5 border border-gray-300 rounded text-xs" placeholder="https://..."/>
                    </div>
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="revisionHistoryAutoLoadCheckbox" class="w-3 h-3"/>
                            <label for="revisionHistoryAutoLoadCheckbox" class="text-xs text-gray-600">시작 시 자동 로드</label>
                        </div>
                        <button id="revisionHistoryLoadNowBtn" class="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700">지금 로드</button>
                    </div>
                </div>
            </div>
            
            <!-- Search/Filter Bar -->
            <div id="revisionHistorySearchBar" class="hidden mb-3">
                <input type="text" id="revisionHistorySearchInput" placeholder="프로젝트명, 버전, 날짜로 검색..." class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-purple-500 focus:border-purple-500"/>
            </div>
            
            <div id="revisionHistoryContainer" class="flex-grow overflow-y-auto border rounded-lg p-4 bg-gray-50" style="min-height: 0;">
                <div class="text-gray-500 text-sm p-4">변경 이력이 없습니다.</div>
            </div>
        </div>
    </div>

    <div id="progressPopup" class="hidden absolute bg-white border rounded-lg shadow-xl p-2 grid grid-cols-4 gap-2 w-56">
    </div>

    <!-- Startup Choice Modal -->
    <div id="startupChoiceModal" class="fixed inset-0 bg-black bg-opacity-50 z-[200] hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl p-6 w-96 max-w-full relative">
            <button id="closeStartupChoiceModalBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-700 text-xl leading-none">&times;</button>
            <h2 class="text-lg font-bold mb-4 text-gray-800">데이터 로드 방식 선택</h2>
            <p class="text-sm text-gray-600 mb-6">변경 이력 데이터를 어떻게 불러오시겠습니까?</p>
            
            <div class="mb-4">
                <label for="startupChoiceUrlInput" class="block text-xs font-medium text-gray-700 mb-1">자동 업로드 URL</label>
                <input type="text" id="startupChoiceUrlInput" class="w-full p-2 border border-gray-300 rounded text-sm focus:ring-blue-500 focus:border-blue-500" />
            </div>

            <div class="space-y-3">
                <button id="startupChoiceAutoBtn" class="w-full p-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" />
                    </svg>
                    자동 업로드 (GitHub)
                </button>
                <button id="startupChoiceManualBtn" class="w-full p-3 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 font-medium flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    수동 업로드 (파일 선택)
                </button>
            </div>
            
            <div class="mt-4 pt-4 border-t flex flex-col gap-3">
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="startupChoiceRemember" class="w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"/>
                    <label for="startupChoiceRemember" class="text-sm text-gray-600">이 선택을 기억하기</label>
                </div>
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="startupChoiceAutoExecute" class="w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"/>
                    <label for="startupChoiceAutoExecute" class="text-sm text-gray-600">자동실행</label>
                </div>
            </div>
        </div>
    </div>

    <!-- Network Status Indicator -->
    <div id="network-status" class="online">
        <div id="network-status-icon"></div>
        <span id="network-status-text">온라인</span>
    </div>

    <div id="toast-container"></div>

    <!-- [DELETED] The template is no longer needed as we move the actual element. -->

    <!-- EMBEDDED_DATA_PLACEHOLDER -->
    <!-- EMBEDDED_MILESTONES_PLACEHOLDER -->
    <!-- EMBEDDED_SETTINGS_PLACEHOLDER -->

    <script>
        // Data Management Panel Elements
        const fabMenuBtn = document.getElementById('fabMenuBtn');
        const filterTimelineFabBtn = document.getElementById('filterTimelineFabBtn');
        const revisionHistoryFabBtn = document.getElementById('revisionHistoryFabBtn');
        const dataPanel = document.getElementById('dataPanel');
        const dataPanelContent = document.getElementById('dataPanelContent');
        const closeDataPanelBtn = document.getElementById('closeDataPanelBtn');
        
        // Revision History Panel Elements
        const revisionHistoryPanel = document.getElementById('revisionHistoryPanel');
        const closeRevisionHistoryPanelBtn = document.getElementById('closeRevisionHistoryPanelBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const saveHtmlBtn = document.getElementById('saveHtmlBtn');
        const saveMessage = document.getElementById('saveMessage');
        const downloadTemplateBtns = document.querySelectorAll('.download-template-btn');
        const headerRowCountInput = document.getElementById('headerRowCount');
        const saveDataPanelHeaderSettings = document.getElementById('saveDataPanelHeaderSettings');
        const saveMappingHeaderSettings = document.getElementById('saveMappingHeaderSettings');
        const resetDateChangesBtn = document.getElementById('resetDateChangesBtn');

        const fileInput = document.getElementById('fileInput');
        const dashboardContent = document.getElementById('dashboardContent');
        const ganttChartWrapper = document.getElementById('ganttChartWrapper');
        const ganttChartContainer = document.getElementById('ganttChart');
        const exportToExcelBtn = document.getElementById('exportToExcelBtn');
        const exportToCsvBtn = document.getElementById('exportToCsvBtn');
        // Selectors updated after DOM changes for controls
        let taskTypeFilter, customFilterContainer, progressFilter, sortBy, searchInput;
        const SORT_DIRECTIONS = Object.freeze({ ASC: 'asc', DESC: 'desc' });
        let sortState = { mode: 'default', direction: SORT_DIRECTIONS.DESC };

        // Timeline controls (Selector might need update if ID changes)
        let goToTodayBtn;

        // Data Detail Modal
        const dataDetailModal = document.getElementById('dataDetailModal');
        const closeDataDetailModalBtn = document.getElementById('closeDataDetailModalBtn');
        const dataDetailTitle = document.getElementById('dataDetailTitle');
        const dataDetailTableContainer = document.getElementById('dataDetailTableContainer');

        // View Controls (Selectors might need update)
        let expandAllBtn, collapseAllBtn;
        let toggleHierarchyOrderBtn;
        let showChangesBtn;

        // Fullscreen Modal
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const fullscreenModal = document.getElementById('fullscreenModal');
        const fullscreenModalContent = fullscreenModal.querySelector('.resizable-modal-content');
        const fullscreenModalBody = document.getElementById('fullscreenModalBody');
        const closeFullscreenModalBtn = document.getElementById('closeFullscreenModalBtn');

        // Milestone Modal
        const milestoneBtn = document.getElementById('milestoneBtn');
        const legendGoToTodayBtn = document.getElementById('legendGoToTodayBtn');
        const milestoneModal = document.getElementById('milestoneModal');
        const closeMilestoneModalBtn = document.getElementById('closeMilestoneModalBtn');
        const addMilestoneForm = document.getElementById('addMilestoneForm');
        const milestoneList = document.getElementById('milestoneList');

        // Mapping Modal
        const mappingModal = document.getElementById('mappingModal');
        const closeMappingModalBtn = document.getElementById('closeMappingModalBtn');
        const cancelMappingBtn = document.getElementById('cancelMappingBtn');
        const applyMappingBtn = document.getElementById('applyMappingBtn');
        const mappingHeaderRowCount = document.getElementById('mappingHeaderRowCount');
        const mappingHeaderRowCountNumber = document.getElementById('mappingHeaderRowCountNumber');
        const mappingPreviewContainer = document.getElementById('mappingPreviewContainer');

        // Date Settings Modal
        const zoomModal = document.getElementById('zoomModal');
        const zoomModalContent = zoomModal.querySelector('.modal-content');
        const closeZoomModalBtn = document.getElementById('closeZoomModalBtn');

        // Error Correction Modal
        const errorCorrectionModal = document.getElementById('errorCorrectionModal');
        const closeErrorCorrectionModalBtn = document.getElementById('closeErrorCorrectionModalBtn');
        const errorCorrectionInfo = document.getElementById('errorCorrectionInfo');
        const errorCorrectionContainer = document.getElementById('errorCorrectionContainer');
        const discardErrorsBtn = document.getElementById('discardErrorsBtn');
        const retryImportBtn = document.getElementById('retryImportBtn');

        // 개선 사항: 컨트롤 패널 요소
        const controlsPanel = document.getElementById('controlsPanel');
        const controlsPanelOverlay = document.getElementById('controlsPanelOverlay');
        const closeControlsPanelBtn = document.getElementById('closeControlsPanelBtn');
        
        // 개선 사항 1: 바로가기 메뉴 요소
        const shortcutContainer = document.getElementById('shortcutContainer');


        const progressPopup = document.getElementById('progressPopup');
        let floatingTooltip = document.getElementById('ganttFloatingTooltip');
        if (!floatingTooltip && typeof document !== 'undefined') {
            floatingTooltip = document.createElement('div');
            floatingTooltip.id = 'ganttFloatingTooltip';
            document.body.appendChild(floatingTooltip);
        }
        let hoverTooltip = document.getElementById('ganttHoverTooltip');
        if (!hoverTooltip && typeof document !== 'undefined') {
            hoverTooltip = document.createElement('div');
            hoverTooltip.id = 'ganttHoverTooltip';
            document.body.appendChild(hoverTooltip);
        }
        let activeTooltipBar = null;

    // Auto-upload controls
    const autoUploadUrlInput = document.getElementById('autoUploadUrlInput');
    const autoUploadEnabled = document.getElementById('autoUploadEnabled');
    const autoUploadNowBtn = document.getElementById('autoUploadNowBtn');
    const autoUploadTypeExcel = document.getElementById('autoUploadTypeExcel');
    const autoUploadTypeCsv = document.getElementById('autoUploadTypeCsv');
    const csvProjectUrlInput = document.getElementById('csvProjectUrlInput');
    const csvMilestoneUrlInput = document.getElementById('csvMilestoneUrlInput');
    const excelUrlSection = document.getElementById('excelUrlSection');
    const csvUrlSection = document.getElementById('csvUrlSection');

    // Dashboard settings persistence (localStorage)
    const DASHBOARD_SETTINGS_KEY = 'ganttDashboardSettings';

    function saveDashboardSettings() {
        try {
            const settings = {
                autoUploadUrl: autoUploadUrlInput ? (autoUploadUrlInput.value || '').trim() : '',
                autoUploadEnabled: !!(autoUploadEnabled && autoUploadEnabled.checked),
                autoUploadType: (autoUploadTypeExcel && autoUploadTypeExcel.checked) ? 'excel' : 'csv',
                csvProjectUrl: csvProjectUrlInput ? (csvProjectUrlInput.value || '').trim() : '',
                csvMilestoneUrl: csvMilestoneUrlInput ? (csvMilestoneUrlInput.value || '').trim() : '',
                controlsPanelOpen: controlsPanel ? !controlsPanel.classList.contains('translate-x-full') : false
            };
            localStorage.setItem(DASHBOARD_SETTINGS_KEY, JSON.stringify(settings));
        } catch (e) {
            console.warn('Failed to save dashboard settings', e);
        }
    }

    function loadDashboardSettings() {
        try {
            const raw = localStorage.getItem(DASHBOARD_SETTINGS_KEY);
            if (!raw) return null;
            const s = JSON.parse(raw);
            if (s) {
                if (autoUploadUrlInput && typeof s.autoUploadUrl !== 'undefined') autoUploadUrlInput.value = s.autoUploadUrl || '';
                if (autoUploadEnabled && typeof s.autoUploadEnabled !== 'undefined') autoUploadEnabled.checked = !!s.autoUploadEnabled;
                if (csvProjectUrlInput && typeof s.csvProjectUrl !== 'undefined') csvProjectUrlInput.value = s.csvProjectUrl || '';
                if (csvMilestoneUrlInput && typeof s.csvMilestoneUrl !== 'undefined') csvMilestoneUrlInput.value = s.csvMilestoneUrl || '';
                if (s.autoUploadType === 'csv' && autoUploadTypeCsv) {
                    autoUploadTypeCsv.checked = true;
                    if (excelUrlSection) excelUrlSection.classList.add('hidden');
                    if (csvUrlSection) csvUrlSection.classList.remove('hidden');
                } else if (autoUploadTypeExcel) {
                    autoUploadTypeExcel.checked = true;
                    if (excelUrlSection) excelUrlSection.classList.remove('hidden');
                    if (csvUrlSection) csvUrlSection.classList.add('hidden');
                }
                // controlsPanelOpen handled in initializeDashboard merge with existing savedSettings
            }
            return s;
        } catch (e) {
            console.warn('Failed to load dashboard settings', e);
            return null;
        }
    }

    // Save settings when user changes inputs
    if (autoUploadEnabled) {
        autoUploadEnabled.addEventListener('change', () => {
            saveDashboardSettings();
        });
    }
    if (autoUploadUrlInput) {
        autoUploadUrlInput.addEventListener('change', () => {
            saveDashboardSettings();
        });
    }
    if (csvProjectUrlInput) {
        csvProjectUrlInput.addEventListener('change', () => {
            saveDashboardSettings();
        });
    }
    if (csvMilestoneUrlInput) {
        csvMilestoneUrlInput.addEventListener('change', () => {
            saveDashboardSettings();
        });
    }
    // 라디오 버튼 이벤트 처리
    if (autoUploadTypeExcel) {
        autoUploadTypeExcel.addEventListener('change', () => {
            if (autoUploadTypeExcel.checked) {
                if (excelUrlSection) excelUrlSection.classList.remove('hidden');
                if (csvUrlSection) csvUrlSection.classList.add('hidden');
            }
            saveDashboardSettings();
        });
    }
    if (autoUploadTypeCsv) {
        autoUploadTypeCsv.addEventListener('change', () => {
            if (autoUploadTypeCsv.checked) {
                if (excelUrlSection) excelUrlSection.classList.add('hidden');
                if (csvUrlSection) csvUrlSection.classList.remove('hidden');
            }
            saveDashboardSettings();
        });
    }

    // Zoom controls (Selector might need update)
    let zoomBtn, zoomPopover, zoomStartDate, zoomEndDate, zoomApplyBtn, zoomResetBtn;
        let zoomPrevWeek, zoomThisWeek, zoomNextWeek, zoomThreeWeeksToday, zoomThreeWeeksSelected;

        let projectData = [];
        let latestFilteredData = [];
        let milestones = [];
        let openTaskGroups = new Set();
        let minDate, maxDate;
        let viewMinDate, viewMaxDate;
        let savedSettings = null;
        let hierarchyOrder = 'top'; // 'top': 헤더가 위, 'bottom': 헤더가 아래
        let showOnlyChanged = false;
        let isCustomZoomActive = false;
        const shortcutState = {
            expandAll: false,
            collapseAll: false
        };
        // Temporary automatic diagnostic flags. These are non-destructive and intended
        // to help collect runtime mapping mismatches in the user's browser console.
        // Set to true to enable automatic logging; remove or set to false after debug.
        if (typeof window !== 'undefined') {
            // 기본적으로 콘솔 스팸을 방지하기 위해 자동 진단은 비활성화합니다.
            // 문제가 발생하면 개발자 도구에서 수동으로 true로 바꿔주세요.
            window.__GANTT_AUTO_DEBUG = false; // 자동 진단 로그 기본 비활성화
            window.__GANTT_STRICT_DEBUG = false; // strict reorder 내부 디버깅 로그 (옵션)
        }
        let rawImportData = null;
        let importMapping = null;
        let failedImportRows = [];
        let legendStatusFilter = null;
        let pinnedShortcuts = new Set(); // 개선 사항 1: 바로가기 상태 저장
        const accordionHintState = {};
        let accordionStateObserver = null;
        const ANALYSIS_PREFS_STORAGE_KEY = 'ganttAnalysisHeaderPrefs';
        const HEADER_ROW_SETTINGS_STORAGE_KEY = 'ganttHeaderRowSettings';
        let analysisHeaderPreferences = new Set();
        let analysisHeaderPreferenceLabels = {};
        let analysisHeaderUsage = Object.create(null);

        function loadAnalysisHeaderPrefsFromStorage() {
            if (typeof window === 'undefined' || typeof localStorage === 'undefined') return;
            try {
                const raw = localStorage.getItem(ANALYSIS_PREFS_STORAGE_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (parsed) {
                    if (Array.isArray(parsed.keys)) {
                        analysisHeaderPreferences = new Set(parsed.keys);
                        analysisHeaderPreferenceLabels = parsed.labels || {};
                    } else if (Array.isArray(parsed)) {
                        analysisHeaderPreferences = new Set(parsed);
                        analysisHeaderPreferenceLabels = {};
                    }
                }
            } catch (e) {
                console.warn('Failed to load analysis header prefs', e);
            }
        }

        function persistAnalysisHeaderPrefs() {
            if (typeof window === 'undefined' || typeof localStorage === 'undefined') return;
            try {
                const payload = {
                    keys: Array.from(analysisHeaderPreferences),
                    labels: analysisHeaderPreferenceLabels
                };
                localStorage.setItem(ANALYSIS_PREFS_STORAGE_KEY, JSON.stringify(payload));
            } catch (e) {
                console.warn('Failed to save analysis header prefs', e);
            }
        }

        loadAnalysisHeaderPrefsFromStorage();
        
        // 페이지 로드 시 헤더 행 설정 불러오기
        // DOM이 로드된 후에 호출 (이벤트 리스너는 나중에 추가됨)
        if (typeof document !== 'undefined' && document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeHeaderRowSettings);
        } else {
            // 이미 로드된 경우 즉시 호출
            setTimeout(initializeHeaderRowSettings, 100);
        }

        // 헤더 행 설정 저장 및 불러오기 함수
        function loadHeaderRowSettings() {
            if (typeof window === 'undefined' || typeof localStorage === 'undefined') return null;
            try {
                const raw = localStorage.getItem(HEADER_ROW_SETTINGS_STORAGE_KEY);
                if (!raw) return null;
                return JSON.parse(raw);
            } catch (e) {
                console.warn('Failed to load header row settings', e);
                return null;
            }
        }

        function saveHeaderRowSettings(settings) {
            if (typeof window === 'undefined' || typeof localStorage === 'undefined') return;
            try {
                localStorage.setItem(HEADER_ROW_SETTINGS_STORAGE_KEY, JSON.stringify(settings));
            } catch (e) {
                console.warn('Failed to save header row settings', e);
            }
        }

        // 헤더 행 설정 초기화 및 불러오기
        function initializeHeaderRowSettings() {
            const savedSettings = loadHeaderRowSettings();
            
            // 데이터 관리 패널 설정 불러오기
            if (savedSettings && savedSettings.dataPanel) {
                if (savedSettings.dataPanel.saveEnabled && headerRowCountInput) {
                    headerRowCountInput.value = savedSettings.dataPanel.headerRowCount || '1';
                    if (saveDataPanelHeaderSettings) {
                        saveDataPanelHeaderSettings.checked = true;
                    }
                }
            }
            
            // 데이터 매핑 및 미리보기 패널 설정 불러오기
            if (savedSettings && savedSettings.mappingPanel) {
                if (savedSettings.mappingPanel.saveEnabled && mappingHeaderRowCount) {
                    mappingHeaderRowCount.value = savedSettings.mappingPanel.headerRowCount || '1';
                    if (mappingHeaderRowCountNumber) {
                        mappingHeaderRowCountNumber.value = savedSettings.mappingPanel.headerRowCountNumber || '2';
                    }
                    if (saveMappingHeaderSettings) {
                        saveMappingHeaderSettings.checked = true;
                    }
                }
            }
        }

        function updateAnalysisHeaderPreference(key, label, isSelected) {
            if (!key) return;
            if (isSelected) {
                analysisHeaderPreferences.add(key);
                if (label) {
                    analysisHeaderPreferenceLabels[key] = label;
                }
            } else {
                analysisHeaderPreferences.delete(key);
                delete analysisHeaderPreferenceLabels[key];
            }
            persistAnalysisHeaderPrefs();
        }

        function resetAnalysisHeaderUsage() {
            analysisHeaderUsage = Object.create(null);
        }

        function registerAnalysisHeaderUsage(fieldKey, displayName, section) {
            if (!fieldKey) return;
            const normalizedKey = fieldKey;
            if (!analysisHeaderUsage[normalizedKey]) {
                analysisHeaderUsage[normalizedKey] = {
                    displayName: displayName || fieldKey,
                    overview: false,
                    settlement: false
                };
            }
            analysisHeaderUsage[normalizedKey][section] = true;
        }

        function ensureShortcutOrderRules() {
            if (!(pinnedShortcuts instanceof Set)) return;
            let order = Array.from(pinnedShortcuts);
            if (!order.length) return;

            const moveToStart = (ids) => {
                const existing = ids.filter(id => order.includes(id));
                if (!existing.length) return;
                order = existing.concat(order.filter(id => !existing.includes(id)));
            };

            const moveAfter = (ids, anchorId, fallbackAtStart = false) => {
                const filtered = order.filter(id => !ids.includes(id));
                const anchorIndex = filtered.indexOf(anchorId);
                const existing = ids.filter(id => order.includes(id));
                if (!existing.length) {
                    order = filtered;
                    return;
                }
                if (anchorIndex >= 0) {
                    filtered.splice(anchorIndex + 1, 0, ...existing);
                } else if (fallbackAtStart) {
                    filtered.unshift(...existing);
                } else {
                    filtered.push(...existing);
                }
                order = filtered;
            };

            const ensurePresence = (id) => order.includes(id);

            moveToStart(['fullscreenBtn', 'expandAllBtn', 'collapseAllBtn']);

            if (ensurePresence('showChangesBtn')) {
                let filtered = order.filter(id => id !== 'showChangesBtn');
                const expandIdx = filtered.indexOf('expandAllBtn');
                if (expandIdx >= 0) {
                    filtered.splice(expandIdx, 0, 'showChangesBtn');
                } else {
                    filtered.unshift('showChangesBtn');
                }
                order = filtered;
            }

            // '마일스톤'을 '전체 화면' 바로 옆에 배치
            if (ensurePresence('milestoneBtn')) {
                moveAfter(['milestoneBtn'], 'fullscreenBtn', true);
            }

            // '계층순서'를 '마일스톤'과 '펼치기' 사이 중앙에 배치
            if (ensurePresence('toggleHierarchyOrderBtn')) {
                const first = 'milestoneBtn';
                const second = 'expandAllBtn';
                if (ensurePresence(first) && ensurePresence(second)) {
                    const idxFirst = order.indexOf(first);
                    const idxSecond = order.indexOf(second);
                    const insertIndex = idxFirst >= 0 && idxSecond >= 0
                        ? Math.floor((idxFirst + idxSecond + 1) / 2)
                        : idxSecond;
                    const filtered = order.filter(id => id !== 'toggleHierarchyOrderBtn');
                    filtered.splice(Math.max(insertIndex, 0), 0, 'toggleHierarchyOrderBtn');
                    order = filtered;
                } else {
                    const anchorId = ensurePresence(first) ? first : (ensurePresence('fullscreenBtn') ? 'fullscreenBtn' : second);
                    moveAfter(['toggleHierarchyOrderBtn'], anchorId, true);
                }
            }

            if (ensurePresence('cost-account-filter') && ensurePresence('contractor-filter')) {
                moveAfter(['cost-account-filter'], 'contractor-filter', true);
            }

            const typeAdjacent = ['sortBy', 'progressFilter'].filter(ensurePresence);
            if (typeAdjacent.length > 0) {
                moveAfter(typeAdjacent, 'taskTypeFilter', false);
            }
            if (ensurePresence('zoomBtn') && ensurePresence('collapseAllBtn')) {
                moveAfter(['zoomBtn'], 'collapseAllBtn', true);
            }

            pinnedShortcuts = new Set(order);
        }
    const originalDateRegistry = new Map();
    const originalProgressRegistry = new Map();
    let projectRegistrySequence = 0;
    
    // ===== Revision History Management System =====
    let revisionHistory = [];
    let currentRevisionIndex = -1;
    let revisionHistoryEnabled = true;
    let baselineProjectDataSnapshot = null; // Snapshot of project data structure for reset detection
    
    // Initialize baseline snapshot
    function updateBaselineSnapshot() {
        if (!projectData || projectData.length === 0) {
            baselineProjectDataSnapshot = null;
            return;
        }
        baselineProjectDataSnapshot = projectData.map(p => ({
            id: p.id,
            name: p.name || '',
            startDate: p.startDate ? formatDateYMD(p.startDate) : '',
            endDate: p.endDate ? formatDateYMD(p.endDate) : '',
            progress: typeof p.progress === 'number' ? p.progress : 0,
            dependsOn: p.dependsOn ? JSON.parse(JSON.stringify(p.dependsOn)) : [] // 의존성 데이터 포함
        }));
    }
    
    // Check if data structure has changed (rows added/removed/edited, names changed)
    function hasDataStructureChanged() {
        if (!baselineProjectDataSnapshot) return false;
        if (!projectData || projectData.length !== baselineProjectDataSnapshot.length) return true;
        
        for (let i = 0; i < projectData.length; i++) {
            const current = projectData[i];
            const baseline = baselineProjectDataSnapshot[i];
            if (!baseline) return true;
            
            // Check if ID or name changed (structural change)
            if (String(current.id) !== String(baseline.id) || 
                String(current.name || '') !== String(baseline.name || '')) {
                return true;
            }
        }
        return false;
    }
    
    // Reset revision history when data structure changes
    function resetRevisionHistoryIfNeeded() {
        if (hasDataStructureChanged()) {
            revisionHistory = [];
            currentRevisionIndex = -1;
            updateBaselineSnapshot();
            if (revisionHistoryEnabled) {
                // Create initial revision (Rev0) after reset
                createInitialRevision();
            }
        }
    }
    
    // Create initial revision (Rev0) from current state
    function createInitialRevision() {
        if (!projectData || projectData.length === 0) return;
        
        const snapshot = createProjectSnapshot();
        const revision = {
            version: 'Rev0',
            date: new Date().toLocaleDateString('ko-KR'),
            timestamp: new Date().toISOString(),
            changes: [],
            snapshot: snapshot,
            description: '초기 상태'
        };
        
        revisionHistory = [revision];
        currentRevisionIndex = 0;
        updateBaselineSnapshot();
        updateRevisionHistoryUI();
    }
    
    // [성능 최적화] Create a snapshot of all projects' Period and Progress values
    // 변경사항만 저장하거나 이전 snapshot과 비교하여 차이만 저장하는 방식으로 메모리 최적화
    let lastSnapshotCache = null;
    function createProjectSnapshot() {
        // 최소한의 데이터만 저장 (메모리 최적화)
        const snapshot = projectData.map(p => ({
            id: p.id,
            name: p.name || '',
            startDate: getNormalizedProjectDateString(p, 'startDate'),
            endDate: getNormalizedProjectDateString(p, 'endDate'),
            progress: typeof p.progress === 'number' ? p.progress : 0,
            dependsOn: p.dependsOn ? (Array.isArray(p.dependsOn) ? p.dependsOn.map(d => ({ projectId: d.projectId, type: d.type })) : []) : []
        }));
        
        // 캐시 업데이트 (다음 비교를 위해)
        lastSnapshotCache = snapshot;
        return snapshot;
    }
    
    // [성능 최적화] 변경사항만 포함하는 경량 snapshot 생성
    function createLightweightSnapshot(previousSnapshot) {
        // [핵심 수정] previousSnapshot 검증 및 변환 - Delta snapshot 확장 포함
        let previousSnapshotArray = [];
        if (previousSnapshot) {
            if (Array.isArray(previousSnapshot)) {
                previousSnapshotArray = previousSnapshot;
            } else if (typeof previousSnapshot === 'string') {
                // JSON 문자열인 경우 파싱 시도
                try {
                    const parsed = JSON.parse(previousSnapshot);
                    if (Array.isArray(parsed)) {
                        previousSnapshotArray = parsed;
                    } else if (parsed && parsed.type === 'delta' && parsed.baseSnapshot) {
                        // [핵심 수정] Delta snapshot인 경우 확장
                        previousSnapshotArray = expandSnapshot(parsed);
                    } else {
                        previousSnapshotArray = [];
                    }
                } catch (e) {
                    console.warn('[snapshot] Failed to parse previousSnapshot as JSON:', e);
                    previousSnapshotArray = [];
                }
            } else if (typeof previousSnapshot === 'object') {
                // [핵심 수정] Delta snapshot인지 확인
                if (previousSnapshot.type === 'delta' && previousSnapshot.baseSnapshot) {
                    // Delta snapshot인 경우 확장
                    previousSnapshotArray = expandSnapshot(previousSnapshot);
                } else {
                    // 일반 객체인 경우 배열로 변환 시도
                    previousSnapshotArray = Object.values(previousSnapshot);
                }
            } else {
                console.warn('[snapshot] previousSnapshot is not an array:', typeof previousSnapshot);
                previousSnapshotArray = [];
            }
        }
        
        // [핵심 수정] expandSnapshot 함수가 정의되어 있는지 확인하고 사용 (재시도)
        if (previousSnapshotArray.length === 0 && previousSnapshot && typeof expandSnapshot === 'function') {
            const expanded = expandSnapshot(previousSnapshot);
            if (expanded && expanded.length > 0) {
                previousSnapshotArray = expanded;
                console.log('[snapshot] Expanded delta snapshot (retry):', previousSnapshotArray.length, 'items');
            }
        }
        
        if (!previousSnapshotArray || previousSnapshotArray.length === 0) {
            console.warn('[snapshot] previousSnapshot is empty, creating full snapshot');
            return createProjectSnapshot();
        }
        
        // 이전 snapshot을 Map으로 변환하여 빠른 조회
        const prevMap = new Map();
        previousSnapshotArray.forEach(item => {
            prevMap.set(String(item.id), item);
        });
        
        // 변경된 항목만 추출
        const changes = [];
        projectData.forEach(p => {
            const id = String(p.id);
            const prev = prevMap.get(id);
            const current = {
                id: p.id,
                name: p.name || '',
                startDate: getNormalizedProjectDateString(p, 'startDate'),
                endDate: getNormalizedProjectDateString(p, 'endDate'),
                progress: typeof p.progress === 'number' ? p.progress : 0,
                dependsOn: p.dependsOn ? (Array.isArray(p.dependsOn) ? p.dependsOn.map(d => ({ projectId: d.projectId, type: d.type })) : []) : []
            };
            
            // 변경사항이 있으면 추가
            // [성능 최적화] dependsOn 비교 최적화 (JSON.stringify 대신 직접 비교)
            let dependsOnChanged = false;
            if (!prev) {
                dependsOnChanged = true;
            } else {
                const prevDependsOn = prev.dependsOn || [];
                const currentDependsOn = current.dependsOn || [];
                if (prevDependsOn.length !== currentDependsOn.length) {
                    dependsOnChanged = true;
                } else {
                    // 길이가 같으면 각 항목 비교
                    for (let i = 0; i < prevDependsOn.length; i++) {
                        if (prevDependsOn[i].projectId !== currentDependsOn[i].projectId ||
                            prevDependsOn[i].type !== currentDependsOn[i].type) {
                            dependsOnChanged = true;
                            break;
                        }
                    }
                }
            }
            
            if (!prev || 
                prev.startDate !== current.startDate ||
                prev.endDate !== current.endDate ||
                prev.progress !== current.progress ||
                dependsOnChanged) {
                changes.push(current);
            }
        });
        
        // 새로 추가된 항목도 확인
        projectData.forEach(p => {
            const id = String(p.id);
            if (!prevMap.has(id)) {
                changes.push({
                    id: p.id,
                    name: p.name || '',
                    startDate: getNormalizedProjectDateString(p, 'startDate'),
                    endDate: getNormalizedProjectDateString(p, 'endDate'),
                    progress: typeof p.progress === 'number' ? p.progress : 0,
                    dependsOn: p.dependsOn ? (Array.isArray(p.dependsOn) ? p.dependsOn.map(d => ({ projectId: d.projectId, type: d.type })) : []) : []
                });
            }
        });
        
        // 변경사항이 많으면 전체 snapshot 반환 (성능 고려)
        if (changes.length > projectData.length * 0.5) {
            console.log('[snapshot] Too many changes, creating full snapshot:', changes.length, '/', projectData.length);
            return createProjectSnapshot();
        }
        
        // [핵심 수정] baseSnapshot은 확장된 배열로 저장 (Delta 중첩 방지)
        // previousSnapshotArray는 이미 확장된 배열이므로 그대로 사용
        return { type: 'delta', changes: changes, baseSnapshot: previousSnapshotArray };
    }
    
    // [성능 최적화] Delta snapshot을 전체 snapshot으로 확장하는 헬퍼 함수
    // [핵심 수정] 재귀적으로 확장하여 중첩된 Delta snapshot도 처리
    function expandSnapshot(snapshot) {
        if (!snapshot) return [];
        if (Array.isArray(snapshot)) return snapshot;
        if (snapshot.type === 'delta' && snapshot.baseSnapshot) {
            // [핵심 수정] baseSnapshot도 재귀적으로 확장 (중첩된 Delta 처리)
            let baseSnapshotArray = [];
            if (Array.isArray(snapshot.baseSnapshot)) {
                baseSnapshotArray = snapshot.baseSnapshot;
            } else if (snapshot.baseSnapshot && typeof snapshot.baseSnapshot === 'object') {
                // baseSnapshot이 Delta일 수 있으므로 재귀적으로 확장
                baseSnapshotArray = expandSnapshot(snapshot.baseSnapshot);
            } else {
                baseSnapshotArray = [];
            }
            
            // Delta snapshot을 전체 snapshot으로 확장
            const baseMap = new Map();
            baseSnapshotArray.forEach(item => {
                baseMap.set(String(item.id), item);
            });
            
            // changes 추가
            if (Array.isArray(snapshot.changes)) {
            snapshot.changes.forEach(item => {
                baseMap.set(String(item.id), item);
            });
            }
            
            return Array.from(baseMap.values());
        }
        return [];
    }
    
    // Track changes and create a new revision
    function createRevisionEntry(projectId, fieldType, beforeValue, afterValue) {
        if (!revisionHistoryEnabled) return;
        
        resetRevisionHistoryIfNeeded();
        
        // If no revisions exist, create initial one
        if (revisionHistory.length === 0) {
            createInitialRevision();
        }
        
        // [핵심 수정] 최신 데이터 소스 사용 (window.projectData 우선)
        const dataSource = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                          window.projectData : projectData;
        
        const project = dataSource.find(p => String(p.id) === String(projectId));
        if (!project) {
            console.warn(`[revision] Project not found: ${projectId}`);
            return;
        }
        
        const projectName = project.name || '알 수 없음';
        const now = new Date();
        const revisionNumber = revisionHistory.length;
        const version = `Rev${revisionNumber}`;
        
        // Find existing revision for today or create new one
        let currentRevision = revisionHistory[revisionHistory.length - 1];
        const today = now.toLocaleDateString('ko-KR');
        
        // [핵심 수정] 디버깅: 변경 이력 생성 확인
        console.log(`[revision] Creating revision entry for project ${projectId} (${projectName}):`, {
            fieldType: fieldType,
            beforeValue: beforeValue,
            afterValue: afterValue
        });
        
        // Create new revision entry
        // [성능 최적화] 의존성 필드 타입 처리
        let beforeValueStr = String(beforeValue !== undefined && beforeValue !== null ? beforeValue : '');
        let afterValueStr = String(afterValue !== undefined && afterValue !== null ? afterValue : '');
        
        if (fieldType === 'dependency' || fieldType === 'dependency-cancelled') {
            // 의존성 데이터를 읽기 쉬운 형식으로 변환
            const formatDependency = (depStr) => {
                if (!depStr || depStr === '없음' || depStr === '') return '없음';
                
                try {
                    const dependsOn = JSON.parse(depStr);
                    if (!Array.isArray(dependsOn) || dependsOn.length === 0) return '없음';
                    
                    return dependsOn.map(dep => {
                        // [핵심 수정] 최신 데이터 소스 사용
                        const depProject = dataSource.find(p => String(p.id) === String(dep.projectId));
                        const typeMap = {
                            'start-to-start': 'SS',
                            'end-to-start': 'FS',
                            'end-to-end': 'FF',
                            'start-to-end': 'SF'
                        };
                        const typeLabel = typeMap[dep.type] || dep.type;
                        return depProject ? `${depProject.name}(${typeLabel})` : `ID:${dep.projectId}(${typeLabel})`;
                    }).join('; ');
                } catch (e) {
                    return depStr; // 파싱 실패 시 원본 반환
                }
            };
            
            beforeValueStr = formatDependency(beforeValueStr);
            afterValueStr = formatDependency(afterValueStr);
        }
        
        const changeEntry = {
            projectId: String(projectId),
            projectName: projectName,
            fieldType: fieldType, // 'startDate', 'endDate', 'progress', 'dependency', 'dependency-cancelled'
            before: beforeValueStr,
            after: afterValueStr
        };
        
        // [핵심 수정] 스냅샷 생성 전에 projectData를 window.projectData와 동기화
        // window.projectData가 있으면 최신 상태를 projectData에 반영 (스냅샷 생성 전)
        if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) {
            // window.projectData의 최신 상태를 projectData에 반영 (스냅샷 생성 전)
            window.projectData.forEach(wp => {
                const p = projectData.find(p => String(p.id) === String(wp.id));
                if (p) {
                    // 날짜 동기화
                    if (wp.startDate) {
                        p.startDate = wp.startDate;
                        p.startDateStr = wp.startDateStr;
                    }
                    if (wp.endDate) {
                        p.endDate = wp.endDate;
                        p.endDateStr = wp.endDateStr;
                    }
                    // 진행률 동기화
                    if (typeof wp.progress === 'number') {
                        p.progress = wp.progress;
                    }
                    // 의존성 동기화
                    if (wp.dependsOn && Array.isArray(wp.dependsOn)) {
                        p.dependsOn = JSON.parse(JSON.stringify(wp.dependsOn));
                    } else if (!wp.dependsOn) {
                        p.dependsOn = [];
                    }
                }
            });
            console.log('[revision] Synchronized projectData with window.projectData before snapshot creation');
        }
        
        // [성능 최적화] Check if we should create a new revision or add to the last one
        // 이전 snapshot과 비교하여 변경사항만 저장 (메모리 최적화)
        const previousSnapshot = revisionHistory.length > 0 ? revisionHistory[revisionHistory.length - 1].snapshot : null;
        let snapshot;
        
        // 변경사항이 적으면 경량 snapshot 사용, 많으면 전체 snapshot 사용
        if (previousSnapshot && revisionHistory.length > 0) {
            const lightweight = createLightweightSnapshot(previousSnapshot);
            snapshot = lightweight;
        } else {
            snapshot = createProjectSnapshot();
        }
        
        // [핵심 수정] 디버깅: 스냅샷 생성 확인
        if (snapshot) {
            if (Array.isArray(snapshot)) {
                console.log(`[revision] Created full snapshot for ${version}:`, snapshot.length, 'items');
                // 샘플 항목 확인
                if (snapshot.length > 0) {
                    const sample = snapshot[0];
                    console.log(`[revision] Sample snapshot item:`, {
                        id: sample.id,
                        name: sample.name,
                        hasStartDate: !!sample.startDate,
                        hasEndDate: !!sample.endDate,
                        hasDependsOn: !!(sample.dependsOn && Array.isArray(sample.dependsOn) && sample.dependsOn.length > 0)
                    });
                }
            } else if (snapshot.type === 'delta') {
                console.log(`[revision] Created delta snapshot for ${version}:`, snapshot.changes.length, 'changes');
                // 샘플 변경 확인
                if (snapshot.changes.length > 0) {
                    const sample = snapshot.changes[0];
                    console.log(`[revision] Sample delta change:`, {
                        id: sample.id,
                        name: sample.name,
                        hasStartDate: !!sample.startDate,
                        hasEndDate: !!sample.endDate,
                        hasDependsOn: !!(sample.dependsOn && Array.isArray(sample.dependsOn) && sample.dependsOn.length > 0)
                    });
                }
            }
        } else {
            console.error(`[revision] ❌ Failed to create snapshot for ${version}`);
        }
        
        const newRevision = {
            version: version,
            date: today,
            timestamp: now.toISOString(),
            changes: [changeEntry],
            snapshot: snapshot,
            description: `${projectName}: ${getFieldDisplayName(fieldType)} 변경 (${beforeValueStr} → ${afterValueStr})`,
            isLoaded: true
        };
        
        // [핵심 수정] 디버깅: 리비전 생성 확인
        console.log(`[revision] Creating new revision ${version}:`, {
            projectId: projectId,
            projectName: projectName,
            fieldType: fieldType,
            beforeValue: beforeValueStr,
            afterValue: afterValueStr,
            changesCount: newRevision.changes.length,
            snapshotType: Array.isArray(snapshot) ? 'full' : (snapshot.type || 'unknown'),
            snapshotSize: Array.isArray(snapshot) ? snapshot.length : (snapshot.changes ? snapshot.changes.length : 0)
        });
        
        // Remove any revisions after current index (if we're restoring and then making new changes)
        if (currentRevisionIndex < revisionHistory.length - 1) {
            revisionHistory = revisionHistory.slice(0, currentRevisionIndex + 1);
        }
        
        revisionHistory.push(newRevision);
        currentRevisionIndex = revisionHistory.length - 1;
        
        // [핵심 수정] 디버깅: 리비전 히스토리 상태 확인
        console.log(`[revision] Revision history updated. Total revisions: ${revisionHistory.length}, Current index: ${currentRevisionIndex}`);
        
        // [성능 최적화] revisionHistory 크기 제한 (최근 100개만 유지하여 메모리 누적 방지)
        const MAX_REVISION_HISTORY = 100;
        if (revisionHistory.length > MAX_REVISION_HISTORY) {
            // 오래된 이력 제거 (최신 것부터 유지)
            const removedCount = revisionHistory.length - MAX_REVISION_HISTORY;
            revisionHistory = revisionHistory.slice(-MAX_REVISION_HISTORY);
            currentRevisionIndex = revisionHistory.length - 1;
            console.info(`[성능 최적화] 오래된 변경 이력 ${removedCount}개를 제거하여 메모리 사용량을 최적화했습니다.`);
        }
        
        updateBaselineSnapshot();
        updateRevisionHistoryUI();
        
        // Auto-save to localStorage (디바운싱 적용)
        debouncedSaveRevisionHistory();
    }
    
    function getFieldDisplayName(fieldType) {
        const names = {
            'startDate': '시작일',
            'endDate': '종료일',
            'progress': '진행률',
            'dependency': '의존성',
            'dependency-cancelled': '의존성 (취소됨)'
        };
        return names[fieldType] || fieldType;
    }
    
        // [성능 최적화] Load a specific revision
    function loadRevision(revisionIndex) {
        if (revisionIndex < 0 || revisionIndex >= revisionHistory.length) return;
        
        const revision = revisionHistory[revisionIndex];
        if (!revision || !revision.snapshot) return;
        
        // Store current state as "original" before loading revision
        // This allows the change highlighting to work correctly
        originalDateRegistry.clear();
        originalProgressRegistry.clear();
        
        // [성능 최적화] projectData를 Map으로 변환하여 O(n²) → O(n)으로 개선
        const projectDataMap = new Map();
        projectData.forEach(p => {
            if (p.id) {
                projectDataMap.set(String(p.id), p);
            }
        });
        
        // [성능 최적화] 경량 snapshot 처리
        let snapshotToApply = revision.snapshot;
        if (snapshotToApply && snapshotToApply.type === 'delta' && snapshotToApply.baseSnapshot) {
            // Delta snapshot인 경우: baseSnapshot을 먼저 적용하고 변경사항만 업데이트
            snapshotToApply.baseSnapshot.forEach(snapshotItem => {
                const project = projectDataMap.get(String(snapshotItem.id));
                if (project) {
                    // Base snapshot 적용
                    if (snapshotItem.startDate) {
                        const startDate = parseLocalDateString(snapshotItem.startDate);
                        if (startDate && !isNaN(startDate.getTime())) {
                            project.startDate = startDate;
                            project.startDateStr = formatDateYMD(startDate);
                        }
                    }
                    if (snapshotItem.endDate) {
                        const endDate = parseLocalDateString(snapshotItem.endDate);
                        if (endDate && !isNaN(endDate.getTime())) {
                            project.endDate = endDate;
                            project.endDateStr = formatDateYMD(endDate);
                        }
                    }
                    if (typeof snapshotItem.progress === 'number') {
                        project.progress = snapshotItem.progress;
                    }
                    if (snapshotItem.dependsOn !== undefined) {
                        project.dependsOn = snapshotItem.dependsOn ? JSON.parse(JSON.stringify(snapshotItem.dependsOn)) : [];
                    }
                }
            });
            // 변경사항 적용
            snapshotToApply = snapshotToApply.changes;
        }
        
        // Apply snapshot to projectData (Map 기반으로 O(n) 시간 복잡도)
        const snapshotArray = Array.isArray(snapshotToApply) ? snapshotToApply : [];
        snapshotArray.forEach(snapshotItem => {
            const project = projectDataMap.get(String(snapshotItem.id));
            if (!project) return;
            
            // Store current values as "original" before restoring
            const uniqueKey = getProjectRegistryKey(project);
            if (uniqueKey) {
                const currentStart = getNormalizedProjectDateString(project, 'startDate');
                const currentEnd = getNormalizedProjectDateString(project, 'endDate');
                const currentProgress = typeof project.progress === 'number' ? project.progress : 0;
                
                originalDateRegistry.set(uniqueKey, {
                    start: currentStart,
                    end: currentEnd
                });
                originalProgressRegistry.set(uniqueKey, currentProgress);
            }
            
            // Restore dates from snapshot
            if (snapshotItem.startDate) {
                const startDate = parseLocalDateString(snapshotItem.startDate);
                if (startDate && !isNaN(startDate.getTime())) {
                    project.startDate = startDate;
                    project.startDateStr = formatDateYMD(startDate);
                }
            }
            if (snapshotItem.endDate) {
                const endDate = parseLocalDateString(snapshotItem.endDate);
                if (endDate && !isNaN(endDate.getTime())) {
                    project.endDate = endDate;
                    project.endDateStr = formatDateYMD(endDate);
                }
            }
            
            // Restore progress from snapshot
            if (typeof snapshotItem.progress === 'number') {
                project.progress = snapshotItem.progress;
            }
            // 의존성 데이터 복원
            if (snapshotItem.dependsOn !== undefined) {
                project.dependsOn = snapshotItem.dependsOn ? JSON.parse(JSON.stringify(snapshotItem.dependsOn)) : [];
            }
        });
        
        currentRevisionIndex = revisionIndex;
        
        // Update baseline snapshot to the loaded revision state
        updateBaselineSnapshot();
        
        // Re-render to show the loaded state with proper change highlighting
        pendingScrollRestore = captureScrollState(true);
        updateAndApplyDateRange();
        render();
        updateRevisionHistoryUI();
        
        showToast(`리비전 ${revision.version}이 로드되었습니다.`, 'success');
    }
    
    // Search filter for revision history
    let revisionHistorySearchFilter = '';
    let isApplyingRevisions = false; // [성능 최적화] 중복 호출 방지 플래그
    
    // Apply loaded revisions to project data and original registry
    function applyLoadedRevisions() {
        // [성능 최적화] 이미 적용 중이면 중복 호출 방지
        if (isApplyingRevisions) {
            return;
        }
        isApplyingRevisions = true;
        
        try {
            // Filter loaded revisions (default to true if undefined)
            const loadedRevisions = revisionHistory.filter(rev => rev.isLoaded !== false);
            
            // Clear registries
            originalDateRegistry.clear();
            originalProgressRegistry.clear();

            if (loadedRevisions.length === 0) {
                // If no revisions loaded, reset originals to current projectData
                resetOriginalDatesForProjects(projectData);
                // Update UI only (chart rendering is done below)
                updateBaselineSnapshot();
                updateRevisionHistoryUI(); 
                
                pendingScrollRestore = captureScrollState(true);
                updateAndApplyDateRange();
                render();
                // [성능 최적화] 플래그 해제
                isApplyingRevisions = false;
                return;
            }
        
            // [성능 최적화] projectData를 Map으로 변환하여 O(n²) → O(n)으로 개선
            const projectDataMap = new Map();
            projectData.forEach(p => {
                if (p.id) {
                    projectDataMap.set(String(p.id), p);
                }
            });
            
            // Determine baseline (first loaded) and target (last loaded)
            // Sort by version index if needed, but revisionHistory should be sorted
            const baselineRev = loadedRevisions[0];
            const targetRev = loadedRevisions[loadedRevisions.length - 1];
            
            // [성능 최적화] expandSnapshot 함수는 전역에 정의되어 있으므로 여기서는 사용만 함
            
            // 1. Apply target revision snapshot to projectData (Current View)
            if (targetRev && targetRev.snapshot) {
                 const expandedSnapshot = expandSnapshot(targetRev.snapshot);
                 expandedSnapshot.forEach(snapshotItem => {
                     const project = projectDataMap.get(String(snapshotItem.id));
                     if (project) {
                         if (snapshotItem.startDate) {
                             const d = parseLocalDateString(snapshotItem.startDate);
                             if (d && !isNaN(d.getTime())) { 
                                 project.startDate = d; 
                                 project.startDateStr = formatDateYMD(d); 
                             }
                         }
                         if (snapshotItem.endDate) {
                             const d = parseLocalDateString(snapshotItem.endDate);
                             if (d && !isNaN(d.getTime())) { 
                                 project.endDate = d; 
                                 project.endDateStr = formatDateYMD(d); 
                             }
                         }
                         if (typeof snapshotItem.progress === 'number') {
                             project.progress = snapshotItem.progress;
                         }
                         // [핵심 수정] 의존성 정보 적용 및 동기화
                         if (snapshotItem.dependsOn && Array.isArray(snapshotItem.dependsOn)) {
                             const dependsOn = snapshotItem.dependsOn.map(dep => {
                                 // 프로젝트 ID로 프로젝트 찾기 (Map 사용으로 O(1) 조회)
                                 const depProject = projectDataMap.get(String(dep.projectId));
                                 if (depProject) {
                                     return {
                                         projectId: dep.projectId,
                                         type: dep.type
                                     };
                                 }
                                 return null;
                             }).filter(Boolean);
                             
                             // [핵심 수정] 배열 깊은 복사하여 할당
                             project.dependsOn = JSON.parse(JSON.stringify(dependsOn));
                             
                             // [핵심 수정] window.projectData 동기화
                             if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData)) {
                                 const windowProject = window.projectData.find(p => String(p.id) === String(project.id));
                                 if (windowProject) {
                                     windowProject.dependsOn = JSON.parse(JSON.stringify(dependsOn));
                                     // 날짜도 동기화
                                     if (project.startDate) {
                                         windowProject.startDate = project.startDate;
                                         windowProject.startDateStr = project.startDateStr;
                                     }
                                     if (project.endDate) {
                                         windowProject.endDate = project.endDate;
                                         windowProject.endDateStr = project.endDateStr;
                                     }
                                     if (typeof project.progress === 'number') {
                                         windowProject.progress = project.progress;
                                     }
                                     console.log('[apply-revisions] Synchronized window.projectData for project', project.id);
                                 }
                             }
                         } else {
                             project.dependsOn = [];
                             // [핵심 수정] window.projectData도 동기화
                             if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData)) {
                                 const windowProject = window.projectData.find(p => String(p.id) === String(project.id));
                                 if (windowProject) {
                                     windowProject.dependsOn = [];
                                 }
                             }
                         }
                     }
                 });
                 
                 // For projects NOT in the target snapshot, what to do?
                 // Usually they remain as is, or should be reset?
                 // Assuming snapshot contains all projects. If not, existing data persists.
            }
            
            // 2. Apply baseline revision snapshot to originalDateRegistry (Comparison Base)
            if (baselineRev && baselineRev.snapshot) {
                const expandedBaseline = expandSnapshot(baselineRev.snapshot);
                expandedBaseline.forEach(snapshotItem => {
                    const project = projectDataMap.get(String(snapshotItem.id));
                    if (project) {
                         const uniqueKey = getProjectRegistryKey(project);
                         if (uniqueKey) {
                             originalDateRegistry.set(uniqueKey, {
                                 start: snapshotItem.startDate || '',
                                 end: snapshotItem.endDate || ''
                             });
                             originalProgressRegistry.set(uniqueKey, typeof snapshotItem.progress === 'number' ? snapshotItem.progress : 0);
                         }
                    }
                });
            }
            
            // Handle projects not in baseline (use current as original)
            projectData.forEach(project => {
                 const uniqueKey = getProjectRegistryKey(project);
                 if (uniqueKey && !originalDateRegistry.has(uniqueKey)) {
                      originalDateRegistry.set(uniqueKey, {
                          start: getNormalizedProjectDateString(project, 'startDate'),
                          end: getNormalizedProjectDateString(project, 'endDate')
                      });
                      originalProgressRegistry.set(uniqueKey, typeof project.progress === 'number' ? project.progress : 0);
                 }
            });
            
            // Update UI
            currentRevisionIndex = revisionHistory.indexOf(targetRev);
            updateBaselineSnapshot();
            updateRevisionHistoryUI();
            
            pendingScrollRestore = captureScrollState(true);
            updateAndApplyDateRange();
            render();
            
            // [성능 최적화] 플래그 해제
            isApplyingRevisions = false;
            
            // [핵심 수정] 의존성 화살표 렌더링 보장 (렌더링 완료 후 - 여러 단계로 확인)
            // 접힌 항목도 포함하여 모든 데이터를 렌더링하기 위해 원본 데이터 사용
            const renderDependencies = () => {
                try {
                const isInFullscreen = !fullscreenModal.classList.contains('hidden');
                const container = isInFullscreen ? fullscreenModalBody : document.getElementById('ganttViewContent');
                    if (!container) return;
                    
                    const ganttBody = container.querySelector('.gantt-body');
                    if (!ganttBody) return;
                    
                    // [핵심 수정] 필터링된 데이터 대신 원본 데이터 사용 (접힌 항목 포함)
                    const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                        window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                    if (dataToRender && Array.isArray(dataToRender)) {
                        if (typeof window.renderDependencyArrows === 'function') {
                            window.renderDependencyArrows(ganttBody, dataToRender);
                        } else if (typeof renderDependencyArrows === 'function') {
                            renderDependencyArrows(ganttBody, dataToRender);
                        }
                    }
                } catch (e) {
                    console.error('[apply-revisions] Error rendering dependencies:', e);
                }
            };
            
            // 첫 번째 시도: render() 함수 내부의 렌더링 후
            setTimeout(renderDependencies, 100);
            
            // 두 번째 시도: DOM이 완전히 업데이트된 후
            setTimeout(renderDependencies, 500);
            
            // 세 번째 시도: 추가 보장
            setTimeout(renderDependencies, 1000);
            
            // 세 번째 시도: 최종 확인 (레이아웃 업데이트 완료 후)
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        const isInFullscreen = !fullscreenModal.classList.contains('hidden');
                        const container = isInFullscreen ? fullscreenModalBody : document.getElementById('ganttViewContent');
                        if (container) {
                            const ganttBody = container.querySelector('.gantt-body');
                            if (ganttBody) {
                                const filteredData = getFilteredAndSortedData ? getFilteredAndSortedData() : 
                                                   (latestFilteredData || projectData);
                                if (filteredData && Array.isArray(filteredData)) {
                                    if (window.renderDependencyArrows) {
                                        window.renderDependencyArrows(ganttBody, filteredData);
                                    }
                                }
                            }
                        }
                    }, 100);
                });
            });
        } catch (error) {
            console.error('Error in applyLoadedRevisions:', error);
            isApplyingRevisions = false;
        }
    }

    // Update revision history UI
    function updateRevisionHistoryUI() {
        const container = document.getElementById('revisionHistoryContainer');
        if (!container) return;
        
        if (revisionHistory.length === 0) {
            container.innerHTML = '<div class="text-gray-500 text-sm p-4">변경 이력이 없습니다.</div>';
            return;
        }
        
        // Filter revisions based on search
        let filteredRevisions = revisionHistory;
        if (revisionHistorySearchFilter) {
            const searchLower = revisionHistorySearchFilter.toLowerCase();
            filteredRevisions = revisionHistory.filter(rev => {
                return rev.version.toLowerCase().includes(searchLower) ||
                       rev.description.toLowerCase().includes(searchLower) ||
                       rev.date.toLowerCase().includes(searchLower) ||
                       rev.changes.some(change => change.projectName.toLowerCase().includes(searchLower));
            });
        }
        
        // Rev0를 제외하고 나머지를 Rev 숫자 기준 역순으로 정렬 (최신부터)
        filteredRevisions = filteredRevisions.filter(rev => rev.version !== 'Rev0');
        filteredRevisions.sort((a, b) => {
            const aNum = parseInt(a.version.replace('Rev', ''), 10);
            const bNum = parseInt(b.version.replace('Rev', ''), 10);
            if (isNaN(aNum)) return 1; // 숫자가 아닌 경우 뒤로
            if (isNaN(bNum)) return -1; // 숫자가 아닌 경우 뒤로
            return bNum - aNum; // 역순 정렬 (큰 숫자부터)
        });
        
        if (filteredRevisions.length === 0) {
            container.innerHTML = '<div class="text-gray-500 text-sm p-4">검색 결과가 없습니다.</div>';
            return;
        }
        
        let html = `
        <div class="flex justify-between items-center mb-2 px-1 sticky top-0 bg-gray-50 z-10 pb-2 border-b border-gray-200">
            <div class="space-x-1">
                <button class="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200" id="revCheckAllBtn">전체 선택</button>
                <button class="text-xs bg-gray-100 text-gray-700 px-2 py-1 rounded hover:bg-gray-200" id="revUncheckAllBtn">전체 해제</button>
            </div>
            <span class="text-xs text-gray-500">체크하여 로드/언로드</span>
        </div>
        <div class="space-y-2">`;
        
        filteredRevisions.forEach((rev, filteredIndex) => {
            const originalIndex = revisionHistory.indexOf(rev);
            const isActive = originalIndex === currentRevisionIndex;
            const isLatest = originalIndex === revisionHistory.length - 1;
            const isLoaded = rev.isLoaded !== false;
            
            html += `
                <div class="border rounded-lg p-3 ${isActive ? 'bg-blue-50 border-blue-300' : (isLoaded ? 'bg-white border-gray-200' : 'bg-gray-100 border-gray-200 opacity-75')} cursor-pointer hover:bg-gray-50 transition-colors" 
                     data-revision-index="${originalIndex}">
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center gap-2">
                             <div class="flex items-center justify-center p-1" onclick="event.stopPropagation()">
                                <input type="checkbox" class="rev-toggle w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500" 
                                      data-revision-index="${originalIndex}" ${isLoaded ? 'checked' : ''}>
                             </div>
                            <span class="font-bold text-sm ${isActive ? 'text-blue-700' : 'text-gray-700'}">${rev.version}</span>
                            ${isLatest ? '<span class="text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded">최신</span>' : ''}
                            ${isActive ? '<span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded">현재</span>' : ''}
                             ${!isLoaded ? '<span class="text-xs bg-gray-200 text-gray-600 px-2 py-0.5 rounded">언로드됨</span>' : ''}
                        </div>
                        <span class="text-xs text-gray-500">${rev.date}</span>
                    </div>
                    <div class="text-xs text-gray-600 mb-1">${rev.description}</div>
                    <div class="text-xs text-gray-500">${new Date(rev.timestamp).toLocaleTimeString('ko-KR')}</div>
                    ${rev.changes.length > 0 ? `
                        <div class="mt-2 pt-2 border-t border-gray-200" style="display:${isLoaded ? 'block' : 'none'}">
                            ${rev.changes.map(change => `
                                <div class="text-xs text-gray-600">
                                    <span class="font-medium">${change.projectName}</span>: 
                                    ${getFieldDisplayName(change.fieldType)} 
                                    <span class="text-red-600">${change.before}</span> → 
                                    <span class="text-green-600">${change.after}</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        });
        html += '</div>';
        
        container.innerHTML = html;
        
        // Add event handlers
        
        // Toggle Checkbox Handler
        container.querySelectorAll('.rev-toggle').forEach(el => {
            el.addEventListener('change', (e) => {
                const index = parseInt(e.target.dataset.revisionIndex, 10);
                if (revisionHistory[index]) {
                    revisionHistory[index].isLoaded = e.target.checked;
                    applyLoadedRevisions();
                }
            });
        });

        // Select All
        const checkAllBtn = container.querySelector('#revCheckAllBtn');
        if (checkAllBtn) {
            checkAllBtn.addEventListener('click', () => {
                revisionHistory.forEach(rev => rev.isLoaded = true);
                applyLoadedRevisions();
            });
        }

        // Uncheck All
        const uncheckAllBtn = container.querySelector('#revUncheckAllBtn');
        if (uncheckAllBtn) {
            uncheckAllBtn.addEventListener('click', () => {
                revisionHistory.forEach(rev => rev.isLoaded = false);
                applyLoadedRevisions();
            });
        }

        // Row click handler - toggle checkbox
        container.querySelectorAll('[data-revision-index]').forEach(el => {
            el.addEventListener('click', (e) => {
                // If click target is checkbox or inside checkbox container, ignore (handled by change event)
                if (e.target.closest('.rev-toggle') || e.target.closest('.rev-toggle-container')) return;
                if (e.target.tagName === 'INPUT' && e.target.type === 'checkbox') return;

                const index = parseInt(el.dataset.revisionIndex, 10);
                if (revisionHistory[index]) {
                    revisionHistory[index].isLoaded = !(revisionHistory[index].isLoaded !== false);
                    applyLoadedRevisions();
                }
            });
        });
    }
    
    // Export revision history to Excel
    function exportRevisionHistoryToExcel() {
        try {
            // [성능 최적화] XLSX 라이브러리 로드 확인
            if (typeof XLSX === 'undefined') {
                console.error('[export-revision] XLSX library is not loaded');
                if (typeof showToast === 'function') {
                    showToast('엑셀 라이브러리가 로드되지 않았습니다. 온라인 모드로 전환하거나 페이지를 새로고침해주세요.', 'error');
                } else {
                    alert('엑셀 라이브러리가 로드되지 않았습니다. 온라인 모드로 전환하거나 페이지를 새로고침해주세요.');
                }
                return;
            }
            
            // [성능 최적화] 변경 이력 데이터 확인 (여러 방법으로 접근 시도)
            const revisionHistoryData = (typeof revisionHistory !== 'undefined' ? revisionHistory : 
                                       (typeof window.revisionHistory !== 'undefined' ? window.revisionHistory : null));
            
            if (!revisionHistoryData) {
                console.warn('[export-revision] revisionHistory is not defined');
                if (typeof showToast === 'function') {
                    showToast('변경 이력 데이터가 없습니다.', 'warning');
                } else {
                    alert('변경 이력 데이터가 없습니다.');
                }
                return;
            }
            
            if (!Array.isArray(revisionHistoryData)) {
                console.error('[export-revision] revisionHistory is not an array:', typeof revisionHistoryData);
                if (typeof showToast === 'function') {
                    showToast('변경 이력 데이터 형식이 올바르지 않습니다.', 'error');
                } else {
                    alert('변경 이력 데이터 형식이 올바르지 않습니다.');
                }
                return;
            }
            
            if (revisionHistoryData.length === 0) {
                console.warn('[export-revision] revisionHistory is empty');
                if (typeof showToast === 'function') {
                    showToast('내보낼 변경 이력이 없습니다.', 'warning');
                } else {
                    alert('내보낼 변경 이력이 없습니다.');
                }
                return;
            }
            
            // [성능 최적화] projectData 확인 (여러 방법으로 접근 시도)
            const projectDataSource = (typeof projectData !== 'undefined' ? projectData : 
                                      (typeof window.projectData !== 'undefined' ? window.projectData : null));
            
            if (!projectDataSource || !Array.isArray(projectDataSource)) {
                console.warn('[export-revision] projectData is not available, some features may not work correctly');
            }
            
            // [성능 최적화] 디버깅: 내보낼 데이터 확인
            console.log('[export-revision] Exporting', revisionHistoryData.length, 'revision entries');
            
            const workbook = XLSX.utils.book_new();
            
            // [핵심 수정] REV 번호 파싱 함수 (100번 이상도 처리)
            const parseRevNumber = (version) => {
                if (!version) return NaN;
                const match = String(version).match(/Rev(\d+)/i);
                if (match) {
                    return parseInt(match[1], 10);
                }
                return NaN;
            };
            
            // Rev 넘버링 기준으로 정렬된 복사본 생성
            const sortedRevisions = [...revisionHistoryData].sort((a, b) => {
                const aNum = parseRevNumber(a.version);
                const bNum = parseRevNumber(b.version);
                if (isNaN(aNum)) return 1;
                if (isNaN(bNum)) return -1;
                return aNum - bNum;
            });
            
            // Summary sheet
            const summaryData = [
                ['변경 이력 요약'],
                ['총 리비전 수', sortedRevisions.length],
                ['생성일', new Date().toLocaleString('ko-KR')],
                [''],
                ['버전', '날짜', '시간', '설명', '변경 항목 수']
            ];
            
            sortedRevisions.forEach(rev => {
                summaryData.push([
                    rev.version,
                    rev.date,
                    new Date(rev.timestamp).toLocaleTimeString('ko-KR'),
                    rev.description,
                    rev.changes.length
                ]);
            });
            
            const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(workbook, summarySheet, '요약');
            
            // Detailed changes sheet
            const detailData = [
                ['버전', '날짜', '시간', '프로젝트 ID', '프로젝트명', '변경 필드', '변경 전', '변경 후']
            ];
            
            // [핵심 수정] 디버깅: 변경 이력 확인
            let totalChanges = 0;
            let changesByType = {
                'startDate': 0,
                'endDate': 0,
                'dependency': 0,
                'dependency-cancelled': 0,
                'progress': 0,
                'other': 0
            };
            
            sortedRevisions.forEach(rev => {
                if (!rev.changes || !Array.isArray(rev.changes)) {
                    console.warn(`[export-revision] Revision ${rev.version} has no changes array:`, rev);
                    return;
                }
                
                rev.changes.forEach(change => {
                    totalChanges++;
                    const fieldType = change.fieldType || 'unknown';
                    if (changesByType.hasOwnProperty(fieldType)) {
                        changesByType[fieldType]++;
                    } else {
                        changesByType.other++;
                    }
                    
                    // [핵심 수정] 디버깅: 각 변경사항 로그
                    console.log(`[export-revision] Processing change:`, {
                        version: rev.version,
                        projectId: change.projectId,
                        projectName: change.projectName,
                        fieldType: fieldType,
                        before: change.before,
                        after: change.after
                    });
                    
                    // 의존성 필드의 경우 JSON 문자열을 읽기 쉬운 형식으로 변환
                    let beforeValue = change.before;
                    let afterValue = change.after;
                    
                    // [핵심 수정] 의존성 필드 처리 개선
                    if (change.fieldType === 'dependency' || change.fieldType === 'dependency-cancelled') {
                        // 이미 읽기 쉬운 형식으로 변환되어 있을 수 있으므로 확인
                        if (beforeValue && beforeValue !== '없음' && beforeValue !== '') {
                            // JSON 형식인지 확인 (시작이 [ 또는 {)
                            if (beforeValue.trim().startsWith('[') || beforeValue.trim().startsWith('{')) {
                                try {
                                const beforeDep = JSON.parse(beforeValue);
                                    if (Array.isArray(beforeDep)) {
                                const typeMap = {
                                    'start-to-start': 'SS',
                                    'end-to-start': 'FS',
                                    'end-to-end': 'FF',
                                    'start-to-end': 'SF'
                                };
                                beforeValue = beforeDep.map(dep => {
                                            const depProject = projectDataSource ? projectDataSource.find(p => String(p.id) === String(dep.projectId)) : null;
                                    const typeLabel = typeMap[dep.type] || dep.type;
                                    return depProject ? `${depProject.name}(${typeLabel})` : `ID:${dep.projectId}(${typeLabel})`;
                                }).join('; ') || '없음';
                            }
                                } catch (e) {
                                    // JSON 파싱 실패 시 원본 값 사용 (이미 읽기 쉬운 형식일 수 있음)
                                    console.warn(`[export-revision] Failed to parse dependency beforeValue for ${rev.version}:`, e);
                                }
                            }
                            // 이미 읽기 쉬운 형식이면 그대로 사용
                        }
                        
                        if (afterValue && afterValue !== '없음' && afterValue !== '') {
                            // JSON 형식인지 확인 (시작이 [ 또는 {)
                            if (afterValue.trim().startsWith('[') || afterValue.trim().startsWith('{')) {
                                try {
                                const afterDep = JSON.parse(afterValue);
                                    if (Array.isArray(afterDep)) {
                                const typeMap = {
                                    'start-to-start': 'SS',
                                    'end-to-start': 'FS',
                                    'end-to-end': 'FF',
                                    'start-to-end': 'SF'
                                };
                                afterValue = afterDep.map(dep => {
                                            const depProject = projectDataSource ? projectDataSource.find(p => String(p.id) === String(dep.projectId)) : null;
                                    const typeLabel = typeMap[dep.type] || dep.type;
                                    return depProject ? `${depProject.name}(${typeLabel})` : `ID:${dep.projectId}(${typeLabel})`;
                                }).join('; ') || '없음';
                            }
                        } catch (e) {
                                    // JSON 파싱 실패 시 원본 값 사용 (이미 읽기 쉬운 형식일 수 있음)
                                    console.warn(`[export-revision] Failed to parse dependency afterValue for ${rev.version}:`, e);
                                }
                            }
                            // 이미 읽기 쉬운 형식이면 그대로 사용
                        }
                    }
                    
                    // [핵심 수정] 날짜 필드 처리 개선
                    if (change.fieldType === 'startDate' || change.fieldType === 'endDate') {
                        // 날짜 형식이 이미 문자열이면 그대로 사용
                        // Date 객체인 경우 문자열로 변환
                        if (beforeValue && typeof beforeValue === 'object' && beforeValue instanceof Date) {
                            beforeValue = formatDateYMD ? formatDateYMD(beforeValue) : beforeValue.toISOString().split('T')[0];
                        }
                        if (afterValue && typeof afterValue === 'object' && afterValue instanceof Date) {
                            afterValue = formatDateYMD ? formatDateYMD(afterValue) : afterValue.toISOString().split('T')[0];
                        }
                    }
                    
                    detailData.push([
                        rev.version,
                        rev.date,
                        new Date(rev.timestamp).toLocaleTimeString('ko-KR'),
                        change.projectId,
                        change.projectName,
                        (typeof getFieldDisplayName === 'function' ? getFieldDisplayName(change.fieldType) : (change.fieldType || '알 수 없음')),
                        String(beforeValue || ''),
                        String(afterValue || '')
                    ]);
                });
            });
            
            // [핵심 수정] 디버깅: 변경 이력 통계 출력
            console.log('[export-revision] Changes summary:', {
                totalChanges: totalChanges,
                byType: changesByType,
                detailDataRows: detailData.length - 1 // 헤더 제외
            });
            
            const detailSheet = XLSX.utils.aoa_to_sheet(detailData);
            XLSX.utils.book_append_sheet(workbook, detailSheet, '상세 변경 내역');
            
            // Snapshot data sheet (for each revision) - Rev 넘버링 기준으로 정렬
            // [성능 최적화] 사용된 워크시트 이름 추적 (중복 방지)
            const usedSheetNames = new Set();
            sortedRevisions.forEach((rev, index) => {
                const snapshotData = [
                    [`리비전 ${rev.version} 스냅샷`],
                    ['생성일', rev.date],
                    ['생성 시간', new Date(rev.timestamp).toLocaleString('ko-KR')],
                    [''],
                    ['프로젝트 ID', '프로젝트명', '시작일', '종료일', '진행률(%)', '의존성']
                ];
                
                // [핵심 수정] rev.snapshot 검증 및 변환 - Delta snapshot 확장 포함
                let snapshotArray = [];
                if (rev.snapshot) {
                    if (Array.isArray(rev.snapshot)) {
                        snapshotArray = rev.snapshot;
                    } else if (typeof rev.snapshot === 'string') {
                        // JSON 문자열인 경우 파싱 시도
                        try {
                            const parsed = JSON.parse(rev.snapshot);
                            if (Array.isArray(parsed)) {
                                snapshotArray = parsed;
                            } else if (parsed && parsed.type === 'delta' && parsed.baseSnapshot) {
                                // [핵심 수정] Delta snapshot인 경우 확장
                                if (typeof expandSnapshot === 'function') {
                                    snapshotArray = expandSnapshot(parsed);
                                } else {
                                    // expandSnapshot이 없으면 직접 확장
                                    const baseMap = new Map();
                                    if (Array.isArray(parsed.baseSnapshot)) {
                                        parsed.baseSnapshot.forEach(item => {
                                            baseMap.set(String(item.id), item);
                                        });
                                    }
                                    if (Array.isArray(parsed.changes)) {
                                        parsed.changes.forEach(item => {
                                            baseMap.set(String(item.id), item);
                                        });
                                    }
                                    snapshotArray = Array.from(baseMap.values());
                                }
                            } else {
                                snapshotArray = [];
                            }
                        } catch (e) {
                            console.warn(`[export-revision] Failed to parse snapshot for ${rev.version} as JSON:`, e);
                            snapshotArray = [];
                        }
                    } else if (typeof rev.snapshot === 'object') {
                        // Delta snapshot인지 확인
                        if (rev.snapshot.type === 'delta' && rev.snapshot.baseSnapshot) {
                            // [핵심 수정] Delta snapshot을 전체 snapshot으로 확장
                            if (typeof expandSnapshot === 'function') {
                                snapshotArray = expandSnapshot(rev.snapshot);
                            } else {
                                // expandSnapshot이 없으면 직접 확장
                                const baseMap = new Map();
                                // baseSnapshot 확장 (이것도 Delta일 수 있음)
                                let baseSnapshotArray = [];
                                if (Array.isArray(rev.snapshot.baseSnapshot)) {
                                    baseSnapshotArray = rev.snapshot.baseSnapshot;
                                } else if (rev.snapshot.baseSnapshot && typeof rev.snapshot.baseSnapshot === 'object') {
                                    if (rev.snapshot.baseSnapshot.type === 'delta') {
                                        // 재귀적으로 확장
                                        baseSnapshotArray = expandSnapshot ? expandSnapshot(rev.snapshot.baseSnapshot) : [];
                                    } else {
                                        baseSnapshotArray = Object.values(rev.snapshot.baseSnapshot);
                                    }
                                }
                                
                                baseSnapshotArray.forEach(item => {
                                    baseMap.set(String(item.id), item);
                                });
                                
                                // changes 추가
                                if (Array.isArray(rev.snapshot.changes)) {
                                    rev.snapshot.changes.forEach(item => {
                                        baseMap.set(String(item.id), item);
                                    });
                                }
                                
                                snapshotArray = Array.from(baseMap.values());
                            }
                            console.log(`[export-revision] Expanded delta snapshot for ${rev.version}:`, snapshotArray.length, 'items');
                        } else {
                            // 일반 객체인 경우 배열로 변환 시도
                            snapshotArray = Object.values(rev.snapshot);
                        }
                    } else {
                        console.warn(`[export-revision] snapshot for ${rev.version} is not an array:`, typeof rev.snapshot);
                        snapshotArray = [];
                    }
                }
                
                // [핵심 수정] expandSnapshot 함수가 정의되어 있는지 확인하고 사용 (재시도)
                if (snapshotArray.length === 0 && rev.snapshot && typeof expandSnapshot === 'function') {
                    // Delta snapshot일 가능성이 있으므로 확장 시도
                    const expanded = expandSnapshot(rev.snapshot);
                    if (expanded && expanded.length > 0) {
                        snapshotArray = expanded;
                        console.log(`[export-revision] Expanded delta snapshot for ${rev.version} (retry):`, snapshotArray.length, 'items');
                    }
                }
                
                // [핵심 수정] 스냅샷이 비어있으면 현재 projectData로부터 생성 시도
                if (snapshotArray.length === 0 && projectDataSource && Array.isArray(projectDataSource) && projectDataSource.length > 0) {
                    console.warn(`[export-revision] Snapshot is empty for ${rev.version}, generating from current projectData`);
                    snapshotArray = projectDataSource.map(p => ({
                        id: p.id,
                        name: p.name || '',
                        startDate: getNormalizedProjectDateString ? getNormalizedProjectDateString(p, 'startDate') : (p.startDateStr || ''),
                        endDate: getNormalizedProjectDateString ? getNormalizedProjectDateString(p, 'endDate') : (p.endDateStr || ''),
                        progress: typeof p.progress === 'number' ? p.progress : 0,
                        dependsOn: p.dependsOn ? (Array.isArray(p.dependsOn) ? p.dependsOn.map(d => ({ projectId: d.projectId, type: d.type })) : []) : []
                    }));
                }
                
                // [핵심 수정] 디버깅: 스냅샷 데이터 확인
                if (snapshotArray.length > 0) {
                    const sampleItem = snapshotArray[0];
                    console.log(`[export-revision] Snapshot for ${rev.version}:`, {
                        totalItems: snapshotArray.length,
                        sampleItem: {
                            id: sampleItem.id,
                            name: sampleItem.name,
                            hasStartDate: !!sampleItem.startDate,
                            hasEndDate: !!sampleItem.endDate,
                            hasDependsOn: !!(sampleItem.dependsOn && Array.isArray(sampleItem.dependsOn) && sampleItem.dependsOn.length > 0)
                        }
                    });
                } else {
                    console.error(`[export-revision] ❌ No snapshot data for ${rev.version} even after fallback`);
                }
                
                if (snapshotArray.length > 0) {
                    snapshotArray.forEach(snapshot => {
                        // 의존성 데이터를 읽기 쉬운 형식으로 변환
                        let dependencyStr = '';
                        if (snapshot.dependsOn && Array.isArray(snapshot.dependsOn) && snapshot.dependsOn.length > 0) {
                            dependencyStr = snapshot.dependsOn.map(dep => {
                                const depProject = projectDataSource ? projectDataSource.find(p => String(p.id) === String(dep.projectId)) : null;
                                const typeMap = {
                                    'start-to-start': 'SS',
                                    'end-to-start': 'FS',
                                    'end-to-end': 'FF',
                                    'start-to-end': 'SF'
                                };
                                const typeLabel = typeMap[dep.type] || dep.type;
                                return depProject ? `${depProject.name}(${typeLabel})` : `ID:${dep.projectId}(${typeLabel})`;
                            }).join('; ');
                        } else {
                            dependencyStr = '없음';
                        }
                        // [핵심 수정] 날짜 형식 확인 및 변환
                        let startDateStr = '';
                        let endDateStr = '';
                        
                        if (snapshot.startDate) {
                            // Date 객체인 경우 문자열로 변환
                            if (snapshot.startDate instanceof Date) {
                                startDateStr = formatDateYMD ? formatDateYMD(snapshot.startDate) : snapshot.startDate.toISOString().split('T')[0];
                            } else {
                                startDateStr = String(snapshot.startDate);
                            }
                        }
                        
                        if (snapshot.endDate) {
                            // Date 객체인 경우 문자열로 변환
                            if (snapshot.endDate instanceof Date) {
                                endDateStr = formatDateYMD ? formatDateYMD(snapshot.endDate) : snapshot.endDate.toISOString().split('T')[0];
                            } else {
                                endDateStr = String(snapshot.endDate);
                            }
                        }
                        
                        snapshotData.push([
                            snapshot.id,
                            snapshot.name,
                            startDateStr,
                            endDateStr,
                            snapshot.progress || 0,
                            dependencyStr
                        ]);
                    });
                }
                
                const snapshotSheet = XLSX.utils.aoa_to_sheet(snapshotData);
                
                // [핵심 수정] REV 번호 파싱 함수 사용 (100번 이상도 처리)
                const parseRevNumber = (version) => {
                    if (!version) return NaN;
                    const match = String(version).match(/Rev(\d+)/i);
                    if (match) {
                        return parseInt(match[1], 10);
                    }
                    return NaN;
                };
                
                // [성능 최적화] 고유한 워크시트 이름 생성 (중복 방지)
                const revNum = parseRevNumber(rev.version);
                let sheetName = isNaN(revNum) ? `Rev${index}` : rev.version;
                
                // [성능 최적화] 중복 이름 처리
                let uniqueSheetName = sheetName;
                let counter = 1;
                while (usedSheetNames.has(uniqueSheetName)) {
                    uniqueSheetName = `${sheetName}_${counter}`;
                    counter++;
                }
                usedSheetNames.add(uniqueSheetName);
                
                // [성능 최적화] 워크시트 이름 길이 제한 (Excel 제한: 31자)
                if (uniqueSheetName.length > 31) {
                    uniqueSheetName = uniqueSheetName.substring(0, 31);
                    // 길이 제한 후 다시 중복 확인
                    let finalSheetName = uniqueSheetName;
                    let finalCounter = 1;
                    while (usedSheetNames.has(finalSheetName)) {
                        const suffix = `_${finalCounter}`;
                        finalSheetName = uniqueSheetName.substring(0, 31 - suffix.length) + suffix;
                        finalCounter++;
                    }
                    uniqueSheetName = finalSheetName;
                    usedSheetNames.add(uniqueSheetName);
                }
                
                XLSX.utils.book_append_sheet(workbook, snapshotSheet, uniqueSheetName);
            });
            
            const fileName = `변경이력_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(workbook, fileName, { compression: true });
            showToast('변경 이력이 엑셀 파일로 내보내졌습니다.', 'success');
        } catch (error) {
            console.error('[export-revision] Error exporting revision history:', error);
            console.error('[export-revision] Error stack:', error.stack);
            
            // [성능 최적화] 구체적인 오류 메시지 제공
            let errorMessage = '엑셀 내보내기 중 오류가 발생했습니다.';
            if (error.message) {
                errorMessage += ' 오류: ' + error.message;
            }
            
            if (typeof showToast === 'function') {
                showToast(errorMessage, 'error');
            } else {
                alert(errorMessage);
            }
        }
    }
    
    // Compare uploaded data with current data
    function compareRevisionHistoryData(uploadedData, currentData) {
        const comparison = {
            structureMatch: true,
            dataMatch: true,
            differences: [],
            warnings: [],
            errors: []
        };
        
        // Compare data structure
        if (!uploadedData || !Array.isArray(uploadedData)) {
            comparison.errors.push('업로드된 데이터 형식이 올바르지 않습니다.');
            comparison.structureMatch = false;
            return comparison;
        }
        
        // Compare project count
        const uploadedProjectCount = uploadedData.length;
        const currentProjectCount = currentData ? currentData.length : 0;
        
        if (uploadedProjectCount !== currentProjectCount) {
            comparison.warnings.push(`프로젝트 수가 다릅니다: 업로드 ${uploadedProjectCount}개, 현재 ${currentProjectCount}개`);
            comparison.dataMatch = false;
        }
        
        // Compare project IDs, names, and structure
        const currentProjectsMap = new Map();
        if (currentData) {
            currentData.forEach(p => {
                currentProjectsMap.set(String(p.id), {
                    id: p.id,
                    name: p.name || '',
                    startDate: p.startDate ? formatDateYMD(p.startDate) : '',
                    endDate: p.endDate ? formatDateYMD(p.endDate) : '',
                    progress: typeof p.progress === 'number' ? p.progress : 0
                });
            });
        }
        
        const uploadedProjectsMap = new Map();
        uploadedData.forEach(p => {
            uploadedProjectsMap.set(String(p.id), {
                id: p.id,
                name: p.name || '',
                startDate: p.startDate || '',
                endDate: p.endDate || '',
                progress: typeof p.progress === 'number' ? p.progress : 0
            });
        });
        
        // Find missing projects
        currentProjectsMap.forEach((current, id) => {
            if (!uploadedProjectsMap.has(id)) {
                comparison.differences.push(`프로젝트 ID ${id} (${current.name})가 업로드 데이터에 없습니다.`);
                comparison.dataMatch = false;
            }
        });
        
        // Find new projects
        uploadedProjectsMap.forEach((uploaded, id) => {
            if (!currentProjectsMap.has(id)) {
                comparison.differences.push(`새로운 프로젝트 ID ${id} (${uploaded.name})가 업로드 데이터에 있습니다.`);
                comparison.dataMatch = false;
            }
        });
        
        // Compare project details
        currentProjectsMap.forEach((current, id) => {
            const uploaded = uploadedProjectsMap.get(id);
            if (uploaded) {
                if (String(current.name) !== String(uploaded.name)) {
                    comparison.differences.push(`프로젝트 ID ${id}: 명칭이 다릅니다 (현재: ${current.name}, 업로드: ${uploaded.name})`);
                    comparison.dataMatch = false;
                }
                if (current.startDate !== uploaded.startDate) {
                    comparison.warnings.push(`프로젝트 ID ${id}: 시작일이 다릅니다 (현재: ${current.startDate}, 업로드: ${uploaded.startDate})`);
                }
                if (current.endDate !== uploaded.endDate) {
                    comparison.warnings.push(`프로젝트 ID ${id}: 종료일이 다릅니다 (현재: ${current.endDate}, 업로드: ${uploaded.endDate})`);
                }
                if (current.progress !== uploaded.progress) {
                    comparison.warnings.push(`프로젝트 ID ${id}: 진행률이 다릅니다 (현재: ${current.progress}%, 업로드: ${uploaded.progress}%)`);
                }
            }
        });
        
        return comparison;
    }
    
    // Import revision history from Excel
    function importRevisionHistoryFromExcel(file, isStartup = false) {
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                
                // Try to read summary sheet first
                let summarySheet = workbook.Sheets['요약'];
                if (!summarySheet) {
                    summarySheet = workbook.Sheets[workbook.SheetNames[0]];
                }
                
                const summaryData = XLSX.utils.sheet_to_json(summarySheet, { header: 1, raw: true });
                
                // Read detailed changes
                let detailSheet = workbook.Sheets['상세 변경 내역'];
                if (!detailSheet) {
                    detailSheet = workbook.Sheets[workbook.SheetNames.find(name => name.includes('상세') || name.includes('변경'))] || workbook.Sheets[workbook.SheetNames[1]];
                }
                
                const detailData = detailSheet ? XLSX.utils.sheet_to_json(detailSheet, { header: 1, raw: true }) : [];
                
                // Parse revision history
                const importedRevisions = [];
                const revisionsMap = new Map();
                
                // [성능 최적화] projectData를 이름 기반 Map으로 변환 (의존성 매핑 최적화)
                const projectDataByNameMap = new Map();
                if (typeof projectData !== 'undefined' && Array.isArray(projectData)) {
                    projectData.forEach(p => {
                        if (p.name) {
                            projectDataByNameMap.set(p.name, p);
                        }
                    });
                }
                
                // Parse detail data
                if (detailData.length > 1) {
                    const headers = detailData[0];
                    for (let i = 1; i < detailData.length; i++) {
                        const row = detailData[i];
                        // [수정됨] 데이터 필수 항목 체크를 완화 (최소 6개 컬럼: 버전~변경필드)
                        if (!row || row.length < 6) continue;
                        
                        const version = String(row[0] || '').trim();
                        const date = String(row[1] || '').trim();
                        const time = String(row[2] || '').trim();
                        const projectId = String(row[3] || '').trim();
                        const projectName = String(row[4] || '').trim();
                        const fieldTypeStr = String(row[5] || '').trim();
                        // [수정됨] 변경 전/후 값이 비어있을 수 있으므로 안전하게 처리
                        const before = row[6] !== undefined ? row[6] : '';
                        const after = row[7] !== undefined ? row[7] : '';
                        
                        if (!version || !projectId) continue;
                        
                        // Map field type from Korean to English
                        let fieldType = fieldTypeStr;
                        if (fieldTypeStr === '시작일') fieldType = 'startDate';
                        else if (fieldTypeStr === '종료일') fieldType = 'endDate';
                        else if (fieldTypeStr === '진행률') fieldType = 'progress';
                        else if (fieldTypeStr === '의존성') fieldType = 'dependency';
                        
                        // Parse timestamp more robustly
                        let timestamp;
                        try {
                            if (date && time) {
                                // Try parsing date and time together
                                const dateTimeStr = `${date} ${time}`;
                                const parsedDate = new Date(dateTimeStr);
                                if (!isNaN(parsedDate.getTime())) {
                                    timestamp = parsedDate.toISOString();
                                } else {
                                    // Fallback: use current time
                                    timestamp = new Date().toISOString();
                                }
                            } else if (date) {
                                const parsedDate = new Date(date);
                                if (!isNaN(parsedDate.getTime())) {
                                    timestamp = parsedDate.toISOString();
                                } else {
                                    timestamp = new Date().toISOString();
                                }
                            } else {
                                timestamp = new Date().toISOString();
                            }
                        } catch (e) {
                            timestamp = new Date().toISOString();
                        }
                        
                        if (!revisionsMap.has(version)) {
                            revisionsMap.set(version, {
                                version: version,
                                date: date || new Date().toLocaleDateString('ko-KR'),
                                timestamp: timestamp,
                                changes: [],
                                snapshot: null,
                                description: ''
                            });
                        }
                        
                        const rev = revisionsMap.get(version);
                        
                        // 의존성 필드의 경우 파싱하여 JSON 형식으로 변환
                        let beforeValue = String(before !== undefined && before !== null ? before : '');
                        let afterValue = String(after !== undefined && after !== null ? after : '');
                        
                        if (fieldType === 'dependency' || fieldType === 'dependency-cancelled') {
                            // "작업명(type); 작업명2(type2)" 형식을 JSON 배열로 변환
                            const parseDependency = (depStr) => {
                                if (!depStr || depStr === '없음' || depStr.trim() === '') {
                                    return '없음';
                                }
                                try {
                                    const typeMap = {
                                        'SS': 'start-to-start',
                                        'FS': 'end-to-start',
                                        'FF': 'end-to-end',
                                        'SF': 'start-to-end'
                                    };
                                    const depParts = depStr.split(';');
                                    const dependsOn = depParts.map(part => {
                                        const trimmed = part.trim();
                                        // "작업명(type)" 또는 "작업명 (type)" 형식 매칭
                                        const match = trimmed.match(/^(.+?)\s*[\(（](.+?)[\)）]$/);
                                        if (match) {
                                            const depName = match[1].trim();
                                            const depTypeLabel = match[2].trim();
                                            // SS, FS, FF, SF 형식을 full type으로 변환
                                            const depType = typeMap[depTypeLabel] || depTypeLabel;
                                            // 프로젝트 이름으로 ID 찾기 (Map 사용으로 O(1) 조회)
                                            const depProject = projectDataByNameMap.get(depName);
                                            if (depProject) {
                                                return {
                                                    projectId: depProject.id,
                                                    type: depType
                                                };
                                            }
                                        }
                                        return null;
                                    }).filter(Boolean);
                                    
                                    return dependsOn.length > 0 ? JSON.stringify(dependsOn) : '없음';
                                } catch (e) {
                                    return depStr; // 파싱 실패 시 원본 반환
                                }
                            };
                            
                            beforeValue = parseDependency(beforeValue);
                            afterValue = parseDependency(afterValue);
                        }
                        
                        rev.changes.push({
                            projectId: projectId,
                            projectName: projectName,
                            fieldType: fieldType,
                            before: beforeValue,
                            after: afterValue
                        });
                        
                        // Update description if empty
                        if (!rev.description && projectName) {
                            rev.description = `${projectName}: ${getFieldDisplayName(fieldType)} 변경`;
                        }
                    }
                }
                
                // Read snapshot data - improved matching
                // Rev 시트를 먼저 수집하고 Rev 넘버링 순서대로 처리
                const revSheets = [];
                workbook.SheetNames.forEach(sheetName => {
                    // Match Rev0, Rev1, etc. or any sheet starting with "Rev"
                    if (sheetName.startsWith('Rev') || /^Rev\d+$/.test(sheetName)) {
                        revSheets.push(sheetName);
                    }
                });
                
                // Rev 시트를 숫자 순서로 정렬
                revSheets.sort((a, b) => {
                    const aNum = parseInt(a.replace('Rev', ''), 10);
                    const bNum = parseInt(b.replace('Rev', ''), 10);
                    if (isNaN(aNum)) return 1;
                    if (isNaN(bNum)) return -1;
                    return aNum - bNum;
                });
                
                // Rev 넘버링 순서대로 처리 (역순 배치와 상관없이)
                revSheets.forEach((sheetName) => {
                    const snapshotSheet = workbook.Sheets[sheetName];
                    const snapshotData = XLSX.utils.sheet_to_json(snapshotSheet, { header: 1, raw: true });
                    
                    if (snapshotData && snapshotData.length > 4) {
                        // Extract version from first row or sheet name
                        let version = '';
                        if (snapshotData[0] && snapshotData[0][0]) {
                            const firstRowText = String(snapshotData[0][0]);
                            // Try to extract version from "리비전 Rev0 스냅샷" or "Rev0" format
                            const versionMatch = firstRowText.match(/Rev\d+/);
                            if (versionMatch) {
                                version = versionMatch[0];
                            } else {
                                // Fallback: use sheet name
                                version = sheetName;
                            }
                        } else {
                            version = sheetName;
                        }
                        
                        // Rev 넘버링 그대로 사용 (역순 변환 없음)
                        const actualVersion = version;
                        
                        const rev = revisionsMap.get(actualVersion);
                        if (rev) {
                            const snapshot = [];
                            // 먼저 모든 스냅샷 항목을 수집 (이름으로 ID 매핑을 위해)
                            const snapshotMap = new Map();
                            
                            // Start from row 4 (index 4) where data starts
                            for (let i = 4; i < snapshotData.length; i++) {
                                const row = snapshotData[i];
                                if (!row || row.length < 5) continue;
                                
                                const id = String(row[0] || '').trim();
                                const name = String(row[1] || '').trim();
                                if (!id) continue; // Skip rows without ID
                                
                                snapshotMap.set(name, id);
                                
                                snapshot.push({
                                    id: id,
                                    name: name,
                                    startDate: row[2] ? String(row[2]).trim() : '',
                                    endDate: row[3] ? String(row[3]).trim() : '',
                                    progress: typeof row[4] === 'number' ? row[4] : (typeof row[4] === 'string' ? parseInt(String(row[4]).replace('%', ''), 10) || 0 : 0),
                                    dependsOn: [] // 나중에 채움
                                });
                            }
                            
                            // 의존성 데이터 파싱 (스냅샷 항목을 다시 순회)
                            for (let i = 4; i < snapshotData.length; i++) {
                                const row = snapshotData[i];
                                if (!row || row.length < 5) continue;
                                
                                const id = String(row[0] || '').trim();
                                if (!id) continue;
                                
                                const snapshotItem = snapshot.find(s => String(s.id) === String(id));
                                if (!snapshotItem) continue;
                                
                                // 의존성 데이터 파싱 (6번째 컬럼이 있으면)
                                let dependsOn = [];
                                if (row.length > 5 && row[5]) {
                                    const dependencyStr = String(row[5]).trim();
                                    if (dependencyStr && dependencyStr !== '없음') {
                                        // "작업명(type); 작업명2(type2)" 또는 "작업명 (type); 작업명2 (type2)" 형식을 파싱
                                        const depParts = dependencyStr.split(';');
                                        const typeMap = {
                                            'SS': 'start-to-start',
                                            'FS': 'end-to-start',
                                            'FF': 'end-to-end',
                                            'SF': 'start-to-end'
                                        };
                                        dependsOn = depParts.map(part => {
                                            const trimmed = part.trim();
                                            // "작업명(type)" 또는 "작업명 (type)" 형식 매칭
                                            const match = trimmed.match(/^(.+?)\s*[\(（](.+?)[\)）]$/);
                                            if (match) {
                                                const depName = match[1].trim();
                                                const depTypeLabel = match[2].trim();
                                                // SS, FS, FF, SF 형식을 full type으로 변환
                                                const depType = typeMap[depTypeLabel] || depTypeLabel;
                                                // 스냅샷 맵에서 프로젝트 이름으로 ID 찾기
                                                const depId = snapshotMap.get(depName);
                                                if (depId) {
                                                    return {
                                                        projectId: depId,
                                                        type: depType
                                                    };
                                                }
                                                // 스냅샷 맵에 없으면 현재 projectData에서 찾기 (Map 사용으로 O(1) 조회)
                                                const depProject = projectDataByNameMap.get(depName);
                                                if (depProject) {
                                                    return {
                                                        projectId: depProject.id,
                                                        type: depType
                                                    };
                                                }
                                            }
                                            return null;
                                        }).filter(Boolean);
                                    }
                                }
                                
                                snapshotItem.dependsOn = dependsOn;
                            }
                            
                            rev.snapshot = snapshot;
                        } else {
                            // If revision not found in map, try to create from actualVersion
                            if (!revisionsMap.has(actualVersion)) {
                                revisionsMap.set(actualVersion, {
                                    version: actualVersion,
                                    date: new Date().toLocaleDateString('ko-KR'),
                                    timestamp: new Date().toISOString(),
                                    changes: [],
                                    snapshot: [],
                                    description: '엑셀에서 가져온 스냅샷'
                                });
                            }
                            const newRev = revisionsMap.get(actualVersion);
                            const snapshot = [];
                            // 먼저 모든 스냅샷 항목을 수집 (이름으로 ID 매핑을 위해)
                            const snapshotMap = new Map();
                            
                            for (let i = 4; i < snapshotData.length; i++) {
                                const row = snapshotData[i];
                                if (!row || row.length < 5) continue;
                                
                                const id = String(row[0] || '').trim();
                                const name = String(row[1] || '').trim();
                                if (!id) continue;
                                
                                snapshotMap.set(name, id);
                                
                                snapshot.push({
                                    id: id,
                                    name: name,
                                    startDate: row[2] ? String(row[2]).trim() : '',
                                    endDate: row[3] ? String(row[3]).trim() : '',
                                    progress: typeof row[4] === 'number' ? row[4] : (typeof row[4] === 'string' ? parseInt(String(row[4]).replace('%', ''), 10) || 0 : 0),
                                    dependsOn: [] // 나중에 채움
                                });
                            }
                            
                            // 의존성 데이터 파싱 (스냅샷 항목을 다시 순회)
                            for (let i = 4; i < snapshotData.length; i++) {
                                const row = snapshotData[i];
                                if (!row || row.length < 5) continue;
                                
                                const id = String(row[0] || '').trim();
                                if (!id) continue;
                                
                                const snapshotItem = snapshot.find(s => String(s.id) === String(id));
                                if (!snapshotItem) continue;
                                
                                // 의존성 데이터 파싱 (6번째 컬럼이 있으면)
                                let dependsOn = [];
                                if (row.length > 5 && row[5]) {
                                    const dependencyStr = String(row[5]).trim();
                                    if (dependencyStr && dependencyStr !== '없음') {
                                        // "작업명(type); 작업명2(type2)" 또는 "작업명 (type); 작업명2 (type2)" 형식을 파싱
                                        const depParts = dependencyStr.split(';');
                                        const typeMap = {
                                            'SS': 'start-to-start',
                                            'FS': 'end-to-start',
                                            'FF': 'end-to-end',
                                            'SF': 'start-to-end'
                                        };
                                        dependsOn = depParts.map(part => {
                                            const trimmed = part.trim();
                                            // "작업명(type)" 또는 "작업명 (type)" 형식 매칭
                                            const match = trimmed.match(/^(.+?)\s*[\(（](.+?)[\)）]$/);
                                            if (match) {
                                                const depName = match[1].trim();
                                                const depTypeLabel = match[2].trim();
                                                // SS, FS, FF, SF 형식을 full type으로 변환
                                                const depType = typeMap[depTypeLabel] || depTypeLabel;
                                                // 스냅샷 맵에서 프로젝트 이름으로 ID 찾기
                                                const depId = snapshotMap.get(depName);
                                                if (depId) {
                                                    return {
                                                        projectId: depId,
                                                        type: depType
                                                    };
                                                }
                                                // 스냅샷 맵에 없으면 현재 projectData에서 찾기 (Map 사용으로 O(1) 조회)
                                                const depProject = projectDataByNameMap.get(depName);
                                                if (depProject) {
                                                    return {
                                                        projectId: depProject.id,
                                                        type: depType
                                                    };
                                                }
                                            }
                                            return null;
                                        }).filter(Boolean);
                                    }
                                }
                                
                                snapshotItem.dependsOn = dependsOn;
                            }
                            
                            newRev.snapshot = snapshot;
                        }
                    }
                });
                
                // [핵심 수정] REV 번호 파싱 함수 (100번 이상도 처리)
                const parseRevNumber = (version) => {
                    if (!version) return NaN;
                    const match = String(version).match(/Rev(\d+)/i);
                    if (match) {
                        return parseInt(match[1], 10);
                    }
                    return NaN;
                };
                
                // Sort revisions by version number
                importedRevisions.push(...Array.from(revisionsMap.values()));
                importedRevisions.sort((a, b) => {
                    const aNum = parseRevNumber(a.version);
                    const bNum = parseRevNumber(b.version);
                    if (isNaN(aNum)) return 1;
                    if (isNaN(bNum)) return -1;
                    return aNum - bNum;
                });
                
                if (importedRevisions.length === 0) {
                    if (!isStartup) showToast('업로드된 파일에서 변경 이력을 찾을 수 없습니다.', 'error');
                    return;
                }
                
                // Compare with current data - check all snapshots
                const currentSnapshot = createProjectSnapshot();
                const currentProjectData = projectData;
                
                // Compare with the latest snapshot from imported revisions
                // [성능 최적화] Delta snapshot을 전체 snapshot으로 확장
                let latestImportedSnapshot = importedRevisions.length > 0 && importedRevisions[importedRevisions.length - 1].snapshot 
                    ? importedRevisions[importedRevisions.length - 1].snapshot 
                    : [];
                latestImportedSnapshot = expandSnapshot(latestImportedSnapshot);
                
                const comparison = compareRevisionHistoryData(
                    latestImportedSnapshot,
                    currentSnapshot
                );
                
                // Also check if imported revisions match current revision history structure
                if (revisionHistory.length > 0) {
                    let currentLatestSnapshot = revisionHistory[revisionHistory.length - 1]?.snapshot || [];
                    currentLatestSnapshot = expandSnapshot(currentLatestSnapshot);
                    const structureComparison = compareRevisionHistoryData(
                        latestImportedSnapshot,
                        currentLatestSnapshot
                    );
                    
                    // Merge comparison results
                    comparison.warnings.push(...structureComparison.warnings);
                    comparison.differences.push(...structureComparison.differences);
                    if (!structureComparison.structureMatch) {
                        comparison.structureMatch = false;
                    }
                    if (!structureComparison.dataMatch) {
                        comparison.dataMatch = false;
                    }
                }
                
                // Show comparison modal
                // [Modified] Check if this is an initial load or user-initiated import
                // If we have baseline data and it's an import action, show comparison
                // For auto-load on startup, skip comparison modal and load directly if mostly matching
                if (isStartup) {
                    // Auto-load: skip modal, just load
                    // Import revisions
                    revisionHistory = importedRevisions;
                    
                    // Initialize isLoaded property
                    revisionHistory.forEach(rev => rev.isLoaded = true);
                    
                    // Apply revisions using the shared logic
                    applyLoadedRevisions();
                    
                    // [성능 최적화] 의존성 복원 후 렌더링 보장 (applyLoadedRevisions 내부에서도 처리되지만 추가 보장)
                    setTimeout(() => {
                        const renderDependencies = () => {
                            try {
                                const container = document.getElementById('ganttViewContent');
                                if (!container) return;
                                
                                const ganttBody = container.querySelector('.gantt-body');
                                if (!ganttBody) return;
                                
                                const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                                    window.projectData : projectData;
                                
                                if (dataToRender && Array.isArray(dataToRender)) {
                                    if (typeof window.renderDependencyArrows === 'function') {
                                        window.renderDependencyArrows(ganttBody, dataToRender);
                                    } else if (typeof renderDependencyArrows === 'function') {
                                        renderDependencyArrows(ganttBody, dataToRender);
                                    }
                                }
                            } catch (e) {
                                console.error('[import-revision] Error rendering dependencies:', e);
                            }
                        };
                        
                        // 첫 번째 시도: 즉시
                        renderDependencies();
                        
                        // 두 번째 시도: DOM 업데이트 완료 후
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                setTimeout(renderDependencies, 150);
                            });
                        });
                        
                        // 세 번째 시도: 레이아웃 업데이트 완료 후
                        setTimeout(renderDependencies, 300);
                    }, 200);
                    
                    saveRevisionHistoryToStorage(); // Save imported revisions
                    // showToast('변경 이력이 성공적으로 로드되었습니다.', 'success');
                } else {
                     showRevisionHistoryComparisonModal(comparison, importedRevisions, currentProjectData);
                }
                
            } catch (error) {
                console.error('Import error:', error);
                if (!isStartup) showToast('엑셀 파일 읽기 중 오류가 발생했습니다.', 'error');
            }
        };
        reader.readAsArrayBuffer(file);
    }
    
    // Show comparison modal
    function showRevisionHistoryComparisonModal(comparison, importedRevisions, currentProjectData) {
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[200]';
        modal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-3xl max-h-[90vh] overflow-y-auto" style="width: 90%;">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold">데이터 비교 결과</h3>
                    <button class="text-gray-400 hover:text-gray-700 text-2xl leading-none close-comparison-modal">&times;</button>
                </div>
                
                <div class="space-y-4">
                    <div class="p-4 rounded-lg ${comparison.structureMatch && comparison.dataMatch ? 'bg-green-50 border border-green-200' : 'bg-yellow-50 border border-yellow-200'}">
                        <div class="font-semibold mb-2">${comparison.structureMatch && comparison.dataMatch ? '✓ 데이터 구조가 일치합니다' : '⚠ 데이터 차이점이 발견되었습니다'}</div>
                    </div>
                    
                    ${comparison.errors.length > 0 ? `
                        <div class="p-4 bg-red-50 border border-red-200 rounded-lg">
                            <div class="font-semibold text-red-700 mb-2">오류:</div>
                            <ul class="list-disc list-inside text-sm text-red-600 space-y-1">
                                ${comparison.errors.map(e => `<li>${e}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    
                    ${comparison.warnings.length > 0 ? `
                        <div class="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                            <div class="font-semibold text-yellow-700 mb-2">경고 (${comparison.warnings.length}개):</div>
                            <ul class="list-disc list-inside text-sm text-yellow-600 space-y-1 max-h-40 overflow-y-auto">
                                ${comparison.warnings.slice(0, 10).map(w => `<li>${w}</li>`).join('')}
                                ${comparison.warnings.length > 10 ? `<li class="text-xs text-gray-500">... 외 ${comparison.warnings.length - 10}개</li>` : ''}
                            </ul>
                        </div>
                    ` : ''}
                    
                    ${comparison.differences.length > 0 ? `
                        <div class="p-4 bg-orange-50 border border-orange-200 rounded-lg">
                            <div class="font-semibold text-orange-700 mb-2">차이점 (${comparison.differences.length}개):</div>
                            <ul class="list-disc list-inside text-sm text-orange-600 space-y-1 max-h-40 overflow-y-auto">
                                ${comparison.differences.slice(0, 10).map(d => `<li>${d}</li>`).join('')}
                                ${comparison.differences.length > 10 ? `<li class="text-xs text-gray-500">... 외 ${comparison.differences.length - 10}개</li>` : ''}
                            </ul>
                        </div>
                    ` : ''}
                    
                    <div class="flex gap-3 justify-end pt-4 border-t">
                        <button class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 cancel-import-btn">취소</button>
                        <button class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 confirm-import-btn">업로드 진행</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        modal.querySelector('.close-comparison-modal').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        modal.querySelector('.cancel-import-btn').addEventListener('click', () => {
            document.body.removeChild(modal);
            showToast('업로드가 취소되었습니다.', 'info');
        });
        
        modal.querySelector('.confirm-import-btn').addEventListener('click', () => {
            // Import revisions
            revisionHistory = importedRevisions;
            
            // Initialize isLoaded property
            revisionHistory.forEach(rev => rev.isLoaded = true);
            
            // Apply revisions using the shared logic
            applyLoadedRevisions();
            
            // [성능 최적화] 의존성 복원 후 렌더링 보장 (applyLoadedRevisions 내부에서도 처리되지만 추가 보장)
            setTimeout(() => {
                const renderDependencies = () => {
                    try {
                        const container = document.getElementById('ganttViewContent');
                        if (!container) return;
                        
                        const ganttBody = container.querySelector('.gantt-body');
                        if (!ganttBody) return;
                        
                        const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                            window.projectData : projectData;
                        
                        if (dataToRender && Array.isArray(dataToRender)) {
                            if (typeof window.renderDependencyArrows === 'function') {
                                window.renderDependencyArrows(ganttBody, dataToRender);
                            } else if (typeof renderDependencyArrows === 'function') {
                                renderDependencyArrows(ganttBody, dataToRender);
                            }
                        }
                    } catch (e) {
                        console.error('[import-revision] Error rendering dependencies:', e);
                    }
                };
                
                // 첫 번째 시도: 즉시
                renderDependencies();
                
                // 두 번째 시도: DOM 업데이트 완료 후
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        setTimeout(renderDependencies, 150);
                    });
                });
                
                // 세 번째 시도: 레이아웃 업데이트 완료 후
                setTimeout(renderDependencies, 300);
            }, 200);
            
            saveRevisionHistoryToStorage(); // Save imported revisions
            
            document.body.removeChild(modal);
            showToast('변경 이력이 성공적으로 업로드되었습니다. 간트 차트에서 변경 사항을 확인할 수 있습니다.', 'success');
            
            // [성능 최적화] 변경 이력 업로드 후 즉시 의존성 표시
            setTimeout(() => {
                const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                if (container) {
                    const ganttBody = container.querySelector('.gantt-body');
                    if (ganttBody) {
                        // [핵심 수정] 필터링된 데이터가 아닌 원본 데이터 사용
                        const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                            window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                        if (dataToRender && Array.isArray(dataToRender)) {
                            if (typeof window.renderDependencyArrows === 'function') {
                                window.renderDependencyArrows(ganttBody, dataToRender);
                            } else if (typeof renderDependencyArrows === 'function') {
                                renderDependencyArrows(ganttBody, dataToRender);
                            }
                        }
                    }
                }
            }, 200);
            
            // [성능 최적화] 추가 보장: DOM 업데이트 완료 후 재시도
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                        const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                        if (container) {
                            const ganttBody = container.querySelector('.gantt-body');
                            if (ganttBody) {
                                // [핵심 수정] 필터링된 데이터가 아닌 원본 데이터 사용
                                const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                                    window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                                if (dataToRender && Array.isArray(dataToRender)) {
                                    if (typeof window.renderDependencyArrows === 'function') {
                                        window.renderDependencyArrows(ganttBody, dataToRender);
                                    } else if (typeof renderDependencyArrows === 'function') {
                                        renderDependencyArrows(ganttBody, dataToRender);
                                    }
                                }
                            }
                        }
                    }, 300);
                });
            });
        });
        
        // Close on background click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }
    
    // Show revision history statistics
    function showRevisionHistoryStats() {
        if (revisionHistory.length === 0) {
            showToast('통계를 표시할 변경 이력이 없습니다.', 'warning');
            return;
        }
        
        // Calculate statistics
        const totalRevisions = revisionHistory.length;
        const totalChanges = revisionHistory.reduce((sum, rev) => sum + rev.changes.length, 0);
        const projectChangeCount = new Map();
        const fieldTypeCount = { 'startDate': 0, 'endDate': 0, 'progress': 0 };
        const dateChanges = [];
        
        revisionHistory.forEach(rev => {
            rev.changes.forEach(change => {
                // Count by project
                const count = projectChangeCount.get(change.projectId) || 0;
                projectChangeCount.set(change.projectId, count + 1);
                
                // Count by field type
                if (fieldTypeCount.hasOwnProperty(change.fieldType)) {
                    fieldTypeCount[change.fieldType]++;
                }
                
                // Track dates
                dateChanges.push(new Date(rev.timestamp));
            });
        });
        
        const mostChangedProjects = Array.from(projectChangeCount.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
        
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[200]';
        modal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-2xl max-h-[90vh] overflow-y-auto" style="width: 90%;">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold">변경 이력 통계</h3>
                    <button class="text-gray-400 hover:text-gray-700 text-2xl leading-none close-stats-modal">&times;</button>
                </div>
                
                <div class="space-y-4">
                    <div class="grid grid-cols-3 gap-4">
                        <div class="p-4 bg-blue-50 rounded-lg">
                            <div class="text-sm text-gray-600">총 리비전</div>
                            <div class="text-2xl font-bold text-blue-700">${totalRevisions}</div>
                        </div>
                        <div class="p-4 bg-green-50 rounded-lg">
                            <div class="text-sm text-gray-600">총 변경 횟수</div>
                            <div class="text-2xl font-bold text-green-700">${totalChanges}</div>
                        </div>
                        <div class="p-4 bg-purple-50 rounded-lg">
                            <div class="text-sm text-gray-600">변경된 프로젝트</div>
                            <div class="text-2xl font-bold text-purple-700">${projectChangeCount.size}</div>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-gray-50 rounded-lg">
                        <div class="font-semibold mb-2">필드별 변경 횟수</div>
                        <div class="space-y-2">
                            <div class="flex justify-between">
                                <span>시작일</span>
                                <span class="font-bold">${fieldTypeCount.startDate}회</span>
                            </div>
                            <div class="flex justify-between">
                                <span>종료일</span>
                                <span class="font-bold">${fieldTypeCount.endDate}회</span>
                            </div>
                            <div class="flex justify-between">
                                <span>진행률</span>
                                <span class="font-bold">${fieldTypeCount.progress}회</span>
                            </div>
                        </div>
                    </div>
                    
                    ${mostChangedProjects.length > 0 ? `
                        <div class="p-4 bg-gray-50 rounded-lg">
                            <div class="font-semibold mb-2">가장 많이 변경된 프로젝트 (상위 5개)</div>
                            <div class="space-y-2">
                                ${mostChangedProjects.map(([projectId, count], index) => {
                                    const project = projectData.find(p => String(p.id) === String(projectId));
                                    const projectName = project ? project.name : projectId;
                                    return `
                                        <div class="flex justify-between items-center">
                                            <span>${index + 1}. ${projectName}</span>
                                            <span class="font-bold text-orange-600">${count}회</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <div class="flex justify-end pt-4 border-t">
                        <button class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 close-stats-modal">닫기</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        modal.querySelectorAll('.close-stats-modal').forEach(btn => {
            btn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        });
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }
    
    // Show revision comparison
    function showRevisionHistoryCompare() {
        if (revisionHistory.length < 2) {
            showToast('비교할 리비전이 2개 이상 필요합니다.', 'warning');
            return;
        }
        
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[200]';
        modal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-4xl max-h-[90vh] overflow-y-auto" style="width: 90%;">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold">리비전 비교</h3>
                    <button class="text-gray-400 hover:text-gray-700 text-2xl leading-none close-compare-modal">&times;</button>
                </div>
                
                <div class="space-y-4">
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">첫 번째 리비전</label>
                            <select id="compareRevision1" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                                ${revisionHistory.map((rev, index) => 
                                    `<option value="${index}">${rev.version} - ${rev.date}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">두 번째 리비전</label>
                            <select id="compareRevision2" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                                ${revisionHistory.map((rev, index) => 
                                    `<option value="${index}" ${index === revisionHistory.length - 1 ? 'selected' : ''}>${rev.version} - ${rev.date}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    
                    <button id="executeCompareBtn" class="w-full px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">비교 실행</button>
                    
                    <div id="compareResults" class="hidden mt-4 p-4 bg-gray-50 rounded-lg">
                        <!-- Comparison results will be shown here -->
                    </div>
                    
                    <div class="flex justify-end pt-4 border-t">
                        <button class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 close-compare-modal">닫기</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        const executeCompareBtn = modal.querySelector('#executeCompareBtn');
        const compareResults = modal.querySelector('#compareResults');
        
        executeCompareBtn.addEventListener('click', () => {
            const rev1Index = parseInt(modal.querySelector('#compareRevision1').value, 10);
            const rev2Index = parseInt(modal.querySelector('#compareRevision2').value, 10);
            
            if (rev1Index === rev2Index) {
                showToast('서로 다른 리비전을 선택해주세요.', 'warning');
                return;
            }
            
            const rev1 = revisionHistory[rev1Index];
            const rev2 = revisionHistory[rev2Index];
            
            if (!rev1 || !rev2 || !rev1.snapshot || !rev2.snapshot) {
                showToast('비교할 스냅샷 데이터가 없습니다.', 'error');
                return;
            }
            
            // Compare snapshots
            const differences = [];
            const rev1Map = new Map(rev1.snapshot.map(s => [String(s.id), s]));
            const rev2Map = new Map(rev2.snapshot.map(s => [String(s.id), s]));
            
            // Find all unique project IDs
            const allIds = new Set([...rev1Map.keys(), ...rev2Map.keys()]);
            
            allIds.forEach(id => {
                const p1 = rev1Map.get(id);
                const p2 = rev2Map.get(id);
                
                if (!p1) {
                    differences.push({
                        projectId: id,
                        projectName: p2.name,
                        type: 'added',
                        changes: [`프로젝트가 ${rev2.version}에 추가됨`]
                    });
                } else if (!p2) {
                    differences.push({
                        projectId: id,
                        projectName: p1.name,
                        type: 'removed',
                        changes: [`프로젝트가 ${rev2.version}에서 제거됨`]
                    });
                } else {
                    const changes = [];
                    if (p1.name !== p2.name) {
                        changes.push(`명칭: ${p1.name} → ${p2.name}`);
                    }
                    if (p1.startDate !== p2.startDate) {
                        changes.push(`시작일: ${p1.startDate} → ${p2.startDate}`);
                    }
                    if (p1.endDate !== p2.endDate) {
                        changes.push(`종료일: ${p1.endDate} → ${p2.endDate}`);
                    }
                    if (p1.progress !== p2.progress) {
                        changes.push(`진행률: ${p1.progress}% → ${p2.progress}%`);
                    }
                    
                    if (changes.length > 0) {
                        differences.push({
                            projectId: id,
                            projectName: p1.name,
                            type: 'modified',
                            changes: changes
                        });
                    }
                }
            });
            
            // Display results
            compareResults.innerHTML = `
                <div class="font-semibold mb-3">비교 결과: ${rev1.version} vs ${rev2.version}</div>
                <div class="text-sm text-gray-600 mb-3">총 ${differences.length}개의 차이점 발견</div>
                <div class="space-y-2 max-h-96 overflow-y-auto">
                    ${differences.map(diff => `
                        <div class="p-3 border rounded-lg ${diff.type === 'added' ? 'bg-green-50 border-green-200' : diff.type === 'removed' ? 'bg-red-50 border-red-200' : 'bg-yellow-50 border-yellow-200'}">
                            <div class="font-medium mb-1">${diff.projectName} (ID: ${diff.projectId})</div>
                            <div class="text-xs space-y-1">
                                ${diff.changes.map(c => `<div>• ${c}</div>`).join('')}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            compareResults.classList.remove('hidden');
        });
        
        modal.querySelectorAll('.close-compare-modal').forEach(btn => {
            btn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        });
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }
    
    // [성능 최적화] localStorage 저장 디바운싱
    let saveRevisionHistoryTimeout = null;
    function debouncedSaveRevisionHistory() {
        if (saveRevisionHistoryTimeout) {
            clearTimeout(saveRevisionHistoryTimeout);
        }
        saveRevisionHistoryTimeout = setTimeout(() => {
            saveRevisionHistoryToStorage();
            saveRevisionHistoryTimeout = null;
        }, 500); // 500ms 디바운싱
    }
    
    // Auto-save revision history to localStorage
    function saveRevisionHistoryToStorage() {
        try {
            // [성능 최적화] localStorage 크기 제한 체크 (약 5MB 제한)
            const MAX_STORAGE_SIZE = 5 * 1024 * 1024; // 5MB
            const dataToSave = JSON.stringify(revisionHistory);
            const indexToSave = String(currentRevisionIndex);
            
            // 예상 크기 체크
            const estimatedSize = new Blob([dataToSave, indexToSave]).size;
            if (estimatedSize > MAX_STORAGE_SIZE) {
                // 크기가 너무 크면 오래된 이력 추가 제거
                const targetSize = Math.floor(MAX_STORAGE_SIZE * 0.8); // 80% 목표
                let reducedHistory = [...revisionHistory];
                while (reducedHistory.length > 10 && new Blob([JSON.stringify(reducedHistory)]).size > targetSize) {
                    reducedHistory = reducedHistory.slice(-Math.floor(reducedHistory.length * 0.9)); // 10%씩 제거
                }
                revisionHistory = reducedHistory;
                currentRevisionIndex = revisionHistory.length - 1;
                console.warn(`[성능 최적화] localStorage 크기 제한으로 인해 변경 이력을 ${revisionHistory.length}개로 축소했습니다.`);
            }
            
            localStorage.setItem('revisionHistory', JSON.stringify(revisionHistory));
            localStorage.setItem('revisionHistoryCurrentIndex', String(currentRevisionIndex));
        } catch (e) {
            // QuotaExceededError 처리
            if (e.name === 'QuotaExceededError' || e.code === 22) {
                // 오래된 이력 제거 후 재시도
                if (revisionHistory.length > 10) {
                    revisionHistory = revisionHistory.slice(-50); // 최근 50개만 유지
                    currentRevisionIndex = revisionHistory.length - 1;
                    try {
                        localStorage.setItem('revisionHistory', JSON.stringify(revisionHistory));
                        localStorage.setItem('revisionHistoryCurrentIndex', String(currentRevisionIndex));
                        console.warn('[성능 최적화] localStorage 용량 초과로 변경 이력을 축소했습니다.');
                    } catch (e2) {
                        console.error('Failed to save revision history after reduction:', e2);
                    }
                } else {
                    console.error('Failed to save revision history: storage quota exceeded', e);
                }
            } else {
                console.warn('Failed to save revision history to localStorage:', e);
            }
        }
    }
    
    // Load revision history from localStorage
    function loadRevisionHistoryFromStorage() {
        try {
            const saved = localStorage.getItem('revisionHistory');
            const savedIndex = localStorage.getItem('revisionHistoryCurrentIndex');
            if (saved) {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed) && parsed.length > 0) {
                    revisionHistory = parsed;
                    currentRevisionIndex = savedIndex ? parseInt(savedIndex, 10) : revisionHistory.length - 1;
                    updateBaselineSnapshot();
                    return true;
                }
            }
        } catch (e) {
            console.warn('Failed to load revision history from localStorage:', e);
        }
        return false;
    }
    
    // Reset revision history completely
    function resetRevisionHistory() {
        // 1. Clear all revision history data
        revisionHistory = [];
        currentRevisionIndex = -1;
        revisionHistorySearchFilter = '';
        
        // 2. Clear localStorage completely
        try {
            localStorage.removeItem('revisionHistory');
            localStorage.removeItem('revisionHistoryCurrentIndex');
        } catch (e) {
            console.warn('Failed to remove revision history from localStorage:', e);
        }
        
        // 3. Reset original registries (change tracking)
        originalDateRegistry.clear();
        originalProgressRegistry.clear();
        
        // 4. Reset baseline snapshot
        baselineProjectDataSnapshot = null;
        
        // 5. Clear search input if exists
        const searchInput = document.getElementById('revisionHistorySearchInput');
        if (searchInput) {
            searchInput.value = '';
        }
        
        // 6. Hide search bar
        const searchBar = document.getElementById('revisionHistorySearchBar');
        if (searchBar) {
            searchBar.classList.add('hidden');
        }
        
        // 7. Update UI to show empty state
        updateRevisionHistoryUI();
        
        // 8. DO NOT create initial revision - complete reset means no history at all
        
        showToast('변경 이력이 완전히 초기화되었습니다.', 'success');
    }
    
    // Show reset confirmation modal
    function showResetRevisionHistoryConfirm() {
        if (revisionHistory.length === 0) {
            showToast('초기화할 변경 이력이 없습니다.', 'info');
            return;
        }
        
        // Calculate statistics for detailed information
        const totalRevisions = revisionHistory.length;
        const totalChanges = revisionHistory.reduce((sum, rev) => sum + rev.changes.length, 0);
        const totalSnapshots = revisionHistory.filter(rev => rev.snapshot && rev.snapshot.length > 0).length;
        const uniqueProjects = new Set();
        revisionHistory.forEach(rev => {
            rev.changes.forEach(change => uniqueProjects.add(change.projectId));
        });
        
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[200]';
        modal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-2xl max-h-[90vh] overflow-y-auto" style="width: 90%;">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-red-600">⚠️ 변경 이력 완전 초기화</h3>
                    <button class="text-gray-400 hover:text-gray-700 text-2xl leading-none close-reset-modal">&times;</button>
                </div>
                
                <div class="space-y-4">
                    <div class="p-4 bg-red-50 border-2 border-red-300 rounded-lg">
                        <div class="font-bold text-red-700 mb-2 text-lg">🚨 중요 경고</div>
                        <div class="text-sm text-red-600 space-y-1">
                            <p>• 모든 변경 이력이 <strong>영구적으로 삭제</strong>됩니다.</p>
                            <p>• 이 작업은 <strong>되돌릴 수 없습니다</strong>.</p>
                            <p>• 컴퓨터 내부 저장소(localStorage)에서도 완전히 제거됩니다.</p>
                            <p>• 초기 리비전(Rev0)도 생성되지 않습니다.</p>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-gray-50 border border-gray-200 rounded-lg">
                        <div class="font-semibold text-gray-800 mb-3">📊 현재 변경 이력 통계</div>
                        <div class="grid grid-cols-2 gap-3 text-sm">
                            <div class="flex justify-between">
                                <span class="text-gray-600">총 리비전 수:</span>
                                <span class="font-bold text-gray-800">${totalRevisions}개</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-600">총 변경 횟수:</span>
                                <span class="font-bold text-gray-800">${totalChanges}회</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-600">스냅샷 데이터:</span>
                                <span class="font-bold text-gray-800">${totalSnapshots}개</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-600">변경된 프로젝트:</span>
                                <span class="font-bold text-gray-800">${uniqueProjects.size}개</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-orange-50 border border-orange-200 rounded-lg">
                        <div class="font-semibold text-orange-800 mb-2">🗑️ 삭제될 내용 상세</div>
                        <ul class="list-disc list-inside text-sm text-orange-700 space-y-1">
                            <li><strong>메모리 내 변경 이력 배열</strong> - 모든 리비전 객체 삭제</li>
                            <li><strong>localStorage 저장 데이터</strong> - 브라우저 저장소에서 완전 제거</li>
                            <li><strong>변경 추적 레지스트리</strong> - originalDateRegistry, originalProgressRegistry 초기화</li>
                            <li><strong>기준 스냅샷 데이터</strong> - baselineProjectDataSnapshot 초기화</li>
                            <li><strong>검색 필터 설정</strong> - 검색어 및 필터 상태 초기화</li>
                            <li><strong>현재 리비전 인덱스</strong> - currentRevisionIndex 초기화</li>
                            <li><strong>UI 표시 내용</strong> - 변경 이력 패널의 모든 목록 제거</li>
                        </ul>
                    </div>
                    
                    <div class="p-4 bg-blue-50 border border-blue-200 rounded-lg">
                        <div class="font-semibold text-blue-800 mb-2">💾 초기화 후 상태</div>
                        <ul class="list-disc list-inside text-sm text-blue-700 space-y-1">
                            <li>변경 이력 패널에 "변경 이력이 없습니다." 메시지 표시</li>
                            <li>모든 변경 추적 기능이 초기 상태로 리셋</li>
                            <li>새로운 변경 사항부터 다시 이력 추적 시작 가능</li>
                            <li>프로젝트 데이터 자체는 유지됨 (날짜, 진행률 등은 그대로)</li>
                        </ul>
                    </div>
                    
                    <div class="p-4 bg-yellow-50 border-2 border-yellow-300 rounded-lg">
                        <div class="font-bold text-yellow-800 mb-2">💡 백업 권장사항</div>
                        <div class="text-sm text-yellow-700 space-y-2">
                            <p>초기화 전에 반드시 다음을 수행하시기 바랍니다:</p>
                            <ol class="list-decimal list-inside space-y-1 ml-2">
                                <li><strong>엑셀 다운로드</strong> - "엑셀 다운로드" 버튼으로 현재 변경 이력 백업</li>
                                <li><strong>스크린샷</strong> - 중요한 변경 이력이 있다면 화면 캡처</li>
                                <li><strong>확인</strong> - 백업 파일이 정상적으로 저장되었는지 확인</li>
                            </ol>
                        </div>
                    </div>
                    
                    <div class="p-3 bg-gray-100 border border-gray-300 rounded-lg">
                        <div class="text-xs text-gray-600">
                            <strong>주의:</strong> 이 작업은 코드 내부의 모든 변경 이력 관련 변수와 데이터를 완전히 초기화합니다. 
                            브라우저를 새로고침해도 초기화된 상태가 유지됩니다.
                        </div>
                    </div>
                    
                    <div class="flex gap-3 justify-end pt-4 border-t">
                        <button class="px-5 py-2.5 bg-gray-500 text-white rounded hover:bg-gray-600 transition cancel-reset-btn font-medium">취소</button>
                        <button class="px-5 py-2.5 bg-red-600 text-white rounded hover:bg-red-700 transition confirm-reset-btn font-bold">완전 초기화 실행</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        modal.querySelector('.close-reset-modal').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        modal.querySelector('.cancel-reset-btn').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        modal.querySelector('.confirm-reset-btn').addEventListener('click', () => {
            resetRevisionHistory();
            document.body.removeChild(modal);
        });
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }
    
    // Load revision history from localStorage on initialization
    if (revisionHistory.length === 0) {
        loadRevisionHistoryFromStorage();
    }
    // ===== End Revision History Management System =====
        let pendingScrollRestore = null;
        
        // [성능 최적화] 렌더링 디바운싱 및 쓰로틀링을 위한 변수
        let renderTimeout = null;
        let isRendering = false;
        let lastRenderTime = 0;
        const RENDER_THROTTLE_MS = 50; // 최소 렌더링 간격 50ms
        
        // 개선 사항: 검색 입력 디바운싱을 위한 변수
        let searchInputTimeout = null;
        
        // 개선 사항: 검색 입력 디바운싱 래퍼 함수
        function debouncedRender() {
            if (searchInputTimeout) {
                clearTimeout(searchInputTimeout);
            }
            searchInputTimeout = setTimeout(() => {
                render();
            }, 300); // 300ms 디바운싱
        }

        let DAY_WIDTH = 40;

    // 기본 자동 업로드 URL
    const DEFAULT_AUTO_UPLOAD_URL = 'https://jonggunelee.github.io/wyggkr04/RawData/25년 잔여 공사 공정관리_(입력).xlsx';
    const DEFAULT_CSV_PROJECT_URL = 'https://jonggunelee.github.io/wyggkr04/RawData/25년 잔여 공사 공정관리_(입력).CSV';
    const DEFAULT_CSV_MILESTONE_URL = 'https://jonggunelee.github.io/wyggkr04/RawData/25년 잔여 공사 공정관리_(마일스톤).CSV';
    // 변경 이력 자동 업로드 URL
    const DEFAULT_REVISION_HISTORY_URL = 'https://jonggunelee.github.io/wyggkr04/RawData/25년 잔여 공사 공정관리_(변경 이력).xlsx';

        // 안전한 키 생성: 한글(또는 다른 유니코드 문자)과 숫자는 보존하고
        // 그 외 특수문자는 '_'로 대체합니다. 전역에서 재사용합니다.
        let customFieldDisplayNames = {}; // sanitizedKey -> original display name
        function sanitizeKey(key) {
            if (key === undefined || key === null) return '';
            try {
                // Keep Unicode letters and numbers, replace other chars with underscore
                return String(key).trim().replace(/[^\p{L}\p{N}]+/gu, '_').replace(/^_+|_+$/g, '').replace(/_+/g, '_');
            } catch (e) {
                // Fallback for environments without Unicode property escapes
                return String(key).trim().replace(/[^a-zA-Z0-9가-힣]+/g, '_').replace(/^_+|_+$/g, '').replace(/_+/g, '_');
            }
        }

        function getAnalysisHeaderKey(label) {
            return sanitizeKey(label || '');
        }

        const statusColors = {
            '공사중': 'bg-blue-500',
            '착공전': 'bg-gray-400',
            '완료': 'bg-green-500',
            '지연': 'bg-red-500',
            'default': 'bg-sky-500'
        };

        let columnVisibility = {
            'project-name': true, 'project-po': false, 'project-progress': true, 'project-dates': true,
            'project-progress-summary': true // 새로 추가된 진행률 요약 열 가시성
        };

        // Ensure any floating popovers are hidden before opening the data panel
        function hideFloatingPopovers() {
            try {
                if (zoomModal) {
                    zoomModal.classList.add('hidden');
                }
            } catch (e) {
                console.warn('hideFloatingPopovers error', e);
            }
        }

        function hideFloatingTooltip() {
            if (!floatingTooltip) return;
            floatingTooltip.classList.remove('visible');
            floatingTooltip.style.left = '';
            floatingTooltip.style.top = '';
            activeTooltipBar = null;
        }

        function hideHoverTooltip() {
            if (!hoverTooltip) return;
            hoverTooltip.classList.remove('visible');
            hoverTooltip.textContent = '';
        }

        function getActiveTimelineContainer() {
            if (!fullscreenModal.classList.contains('hidden')) {
                return fullscreenModalBody.querySelector('.gantt-timeline-body-wrapper');
            }
            const host = document.getElementById('ganttViewContent');
            return host ? host.querySelector('.gantt-timeline-body-wrapper') : document.querySelector('.gantt-timeline-body-wrapper');
        }

        function positionFloatingTooltip(barRect, options = {}) {
            if (!floatingTooltip) return;
            const { pointerX = null, pointerY = null, preferTopEdge = false } = options;
            const margin = 12;
            let topBoundary = 0;
            let bottomBoundary = window.innerHeight;
            const container = getActiveTimelineContainer();
            if (container) {
                const rect = container.getBoundingClientRect();
                topBoundary = Math.max(0, rect.top);
                bottomBoundary = Math.min(window.innerHeight, rect.bottom);
            }
            const tooltipRect = floatingTooltip.getBoundingClientRect();
            let left;
            if (typeof pointerX === 'number') {
                left = pointerX - tooltipRect.width / 2;
            } else {
                left = barRect.left + (barRect.width / 2) - tooltipRect.width / 2;
            }
            const maxLeft = window.innerWidth - tooltipRect.width - margin;
            left = Math.max(margin, Math.min(left, maxLeft));

            let top;
            if (preferTopEdge) {
                top = Math.max(8, topBoundary + margin);
            } else if (typeof pointerY === 'number') {
                top = pointerY - tooltipRect.height - margin;
                if (top < topBoundary + margin) {
                    top = pointerY + margin;
                }
            } else {
                top = barRect.top - tooltipRect.height - margin;
                if (top < topBoundary + margin) {
                    top = barRect.bottom + margin;
                }
            }
            if (top + tooltipRect.height > bottomBoundary - margin) {
                top = bottomBoundary - tooltipRect.height - margin;
            }

            floatingTooltip.style.left = `${left}px`;
            floatingTooltip.style.top = `${top}px`;
        }

        function showFloatingTooltip(bar, tooltipSource, options = {}) {
            if (!floatingTooltip || !tooltipSource || !bar) return;
            activeTooltipBar = bar;
            floatingTooltip.innerHTML = tooltipSource.innerHTML;
            floatingTooltip.classList.add('visible');
            requestAnimationFrame(() => {
                positionFloatingTooltip(bar.getBoundingClientRect(), options);
            });
        }

        if (typeof window !== 'undefined') {
            window.addEventListener('scroll', () => {
                if (floatingTooltip && floatingTooltip.classList.contains('visible')) {
                    hideFloatingTooltip();
                }
                hideHoverTooltip();
            }, true);
            window.addEventListener('resize', () => {
                hideFloatingTooltip();
                hideHoverTooltip();
            });
        }

        function initializeAccordionHints() {
            const hintElements = document.querySelectorAll('[data-accordion-hint]');
            hintElements.forEach(hint => {
                const key = hint.dataset.accordionHint;
                if (!key) return;
                if (accordionHintState[key]) {
                    hint.classList.remove('hint-visible');
                    hint.classList.add('hint-hidden');
                } else {
                    hint.classList.remove('hint-hidden');
                    requestAnimationFrame(() => hint.classList.add('hint-visible'));
                }
            });
        }

        function dismissAccordionHint(key) {
            if (!key || accordionHintState[key]) return;
            accordionHintState[key] = true;
            const hintElement = document.querySelector(`[data-accordion-hint="${key}"]`);
            if (hintElement) {
                hintElement.classList.remove('hint-visible');
                hintElement.classList.add('hint-hidden');
            }
        }

        function buildAccordionHintHTML(key, label = '클릭하면 펼쳐져요') {
            if (!key) return '';
            return `
                <span class="accordion-hint-chip hint-hidden" data-accordion-hint="${key}">
                    <span aria-hidden="true">👆</span>
                    <span>${label}</span>
                </span>
            `;
        }

        function buildAccordionStatePillHTML(key, targetSelector = '', isOpen = false) {
            if (!key) return '';
            const state = isOpen ? 'open' : 'closed';
            const text = isOpen ? '펼쳐짐' : '접힘';
            const targetAttr = targetSelector ? ` data-accordion-target="${targetSelector}"` : '';
            return `<span class="accordion-state-pill" data-accordion-state="${key}"${targetAttr} data-state="${state}" aria-live="polite">${text}</span>`;
        }

        function setCustomAccordionState(key, isOpen, context = document) {
            if (!key) return;
            const searchRoot = context && typeof context.querySelector === 'function' ? context : document;
            const pill = searchRoot.querySelector(`[data-accordion-state="${key}"]`) || document.querySelector(`[data-accordion-state="${key}"]`);
            if (!pill) return;
            const state = isOpen ? 'open' : 'closed';
            const text = isOpen ? '펼쳐짐' : '접힘';
            pill.dataset.state = state;
            pill.textContent = text;
        }

        function handleAccordionTitleKeydown(event) {
            if (event.defaultPrevented) return;
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                event.currentTarget.click();
            }
        }

        function attachAccordionTitleInteractions() {
            const titleButtons = document.querySelectorAll('.accordion-title-btn');
            titleButtons.forEach(button => {
                if (!button.hasAttribute('data-keydown-listener')) {
                    button.addEventListener('keydown', handleAccordionTitleKeydown);
                    button.setAttribute('data-keydown-listener', 'true');
                }
            });
        }

        function updateAccordionAriaStates() {
            const titleButtons = document.querySelectorAll('.accordion-title-btn');
            titleButtons.forEach(button => {
                const parentItem = button.closest('.accordion-item');
                const isOpen = parentItem ? parentItem.classList.contains('open') : false;
                button.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
            });
            updateAccordionStatePills();
        }

        function updateAccordionStatePills() {
            document.querySelectorAll('.accordion-state-pill').forEach(pill => {
                const key = pill.dataset.accordionState;
                if (!key) return;
                const targetSelector = pill.dataset.accordionTarget;
                let isOpen = false;
                if (targetSelector) {
                    const target = document.querySelector(targetSelector);
                    if (target) {
                        if (target.classList.contains('expanded')) {
                            isOpen = true;
                        } else if (target.classList.contains('collapsed')) {
                            isOpen = false;
                        } else {
                            isOpen = target.classList.contains('open');
                        }
                    }
                } else {
                    const titleButton = document.querySelector(`.accordion-title-btn[data-accordion-id="${key}"]`);
                    const parentItem = titleButton ? titleButton.closest('.accordion-item') : null;
                    isOpen = parentItem ? parentItem.classList.contains('open') : false;
                }
                pill.dataset.state = isOpen ? 'open' : 'closed';
                pill.textContent = isOpen ? '펼쳐짐' : '접힘';
            });
        }

        function setupAccordionStateObserver() {
            if (typeof MutationObserver === 'undefined') {
                updateAccordionAriaStates();
                return;
            }
            if (accordionStateObserver) {
                accordionStateObserver.disconnect();
            }
            const items = document.querySelectorAll('#dashboardContent > .accordion-item');
            accordionStateObserver = new MutationObserver(updateAccordionAriaStates);
            items.forEach(item => accordionStateObserver.observe(item, { attributes: true, attributeFilter: ['class'] }));
            updateAccordionAriaStates();
        }

        fabMenuBtn.addEventListener('click', () => {
            hideFloatingPopovers();
            dataPanel.classList.remove('hidden');
        });
        closeDataPanelBtn.addEventListener('click', () => dataPanel.classList.add('hidden'));
        dataPanel.addEventListener('click', (e) => {
            if (e.target === dataPanel) dataPanel.classList.add('hidden');
        });
        // Revision History Panel Event Listeners
        // Variable to hold previous accordion inline states while Revision History panel is open
        let revisionHistoryPrevAccordionStates = null;

        if (revisionHistoryFabBtn) {
            revisionHistoryFabBtn.addEventListener('click', () => {
                hideFloatingPopovers();
                
                // Save current accordion inline states so we can restore them on close
                try {
                    const allAccordionItemsBefore = Array.from(document.querySelectorAll('#dashboardContent > .accordion-item'));
                    const states = {};
                    allAccordionItemsBefore.forEach((item, idx) => {
                        const key = item.id || `accordion_idx_${idx}`;
                        const content = item.querySelector('.accordion-content');
                        states[key] = {
                            inlineDisplay: item.style.display ?? null,
                            inlineContentDisplay: content ? (content.style.display ?? null) : null,
                            wasOpen: item.classList.contains('open')
                        };
                    });
                    revisionHistoryPrevAccordionStates = states;
                } catch (e) {
                    console.warn('Failed to capture accordion states before opening revision history', e);
                    revisionHistoryPrevAccordionStates = null;
                }

                // [Step 1] Force close 'Overview' and 'Settlement' accordions FIRST
                // 다른 아코디언들을 시각적으로 완전히 숨겨서 '집중 모드' 준비를 합니다.
                const allAccordionItems = Array.from(document.querySelectorAll('#dashboardContent > .accordion-item'));
                allAccordionItems.forEach(item => {
                    if (item.id !== 'projectView') {
                        // 클래스 제거
                        item.classList.remove('open', 'is-focused');
                        // 강제 숨김 (접힘 효과)
                        item.style.display = 'none';
                        
                        // 내부 컨텐츠 숨김
                        const content = item.querySelector('.accordion-content');
                        if (content) content.style.display = 'none';

                        // 상태 표시 업데이트 (접힘)
                        const statePill = item.querySelector('.accordion-state-pill');
                        if (statePill) {
                            statePill.setAttribute('data-state', 'closed');
                            statePill.textContent = '접힘';
                        }
                        const titleBtn = item.querySelector('.accordion-title-btn');
                        if (titleBtn) titleBtn.setAttribute('aria-expanded', 'false');
                    }
                });

                // [Step 2] Open 'Schedule' accordion explicitly
                const projectView = document.getElementById('projectView');
                if (projectView) {
                    // 헤더 접힘 상태 해제
                    projectView.classList.remove('schedule-header-collapsed');
                    
                    // 열림 및 집중 모드 클래스 추가
                    projectView.classList.add('open', 'is-focused');
                    
                    // 요소 표시 (none -> block/flex)
                    projectView.style.display = ''; 
                    
                    // 내부 컨텐츠 표시 보장
                    const content = projectView.querySelector('.accordion-content');
                    if (content) content.style.display = '';

                    // 헤더 토글 버튼 상태 업데이트
                    const scheduleHeaderToggle = document.getElementById('scheduleHeaderToggle');
                    if (scheduleHeaderToggle) {
                        scheduleHeaderToggle.setAttribute('aria-expanded', 'true');
                        scheduleHeaderToggle.title = '접기';
                    }
                    
                    // 타이틀 버튼 상태 업데이트
                    const titleBtn = projectView.querySelector('.accordion-title-btn');
                    if (titleBtn) titleBtn.setAttribute('aria-expanded', 'true');
                    
                    // 상태 텍스트 업데이트 (열림)
                    const statePill = projectView.querySelector('.accordion-state-pill');
                    if (statePill) {
                        statePill.setAttribute('data-state', 'open');
                        statePill.textContent = '열림';
                    }
                    
                    // 컨트롤 섹션 토글 초기화
                    const controlsSection = projectView.querySelector('#controlsSection');
                    if (controlsSection && typeof setupControlSectionToggles === 'function') {
                        setupControlSectionToggles(controlsSection);
                    }
                    
                    // 간트 차트가 올바르게 렌더링되도록 트리거
                    if (typeof render === 'function') {
                         requestAnimationFrame(() => render());
                    }
                }

                // [Step 3] Show Revision History Panel
                // 아코디언 전환이 완료된 후 패널을 표시합니다.
                setTimeout(() => {
                    if (revisionHistoryPanel && revisionHistoryPanelContent) {
                        // 패널 위치 초기화 (화면 중앙)
                        const panelWidth = 800;
                        const panelHeight = 600;
                        const centerX = (window.innerWidth - panelWidth) / 2;
                        const centerY = (window.innerHeight - panelHeight) / 2;
                        
                        revisionHistoryPanelContent.style.width = `${panelWidth}px`;
                        revisionHistoryPanelContent.style.height = `${panelHeight}px`;
                        revisionHistoryPanelContent.style.left = `${centerX}px`;
                        revisionHistoryPanelContent.style.top = `${centerY}px`;
                        revisionHistoryPanelContent.style.transform = 'none';
                        
                        // 드래그 오프셋 초기화
                        if (revisionHistoryPanelHeader) {
                            // @ts-ignore
                            if (revisionHistoryPanelHeader._xOffset !== undefined) {
                                // @ts-ignore
                                revisionHistoryPanelHeader._xOffset = centerX;
                                // @ts-ignore
                                revisionHistoryPanelHeader._yOffset = centerY;
                            }
                        }
                        
                        revisionHistoryPanel.classList.remove('hidden');
                        updateRevisionHistoryUI();

                        // [Added] Show Startup Choice Modal
                        // 사용자의 요청에 따라 버튼 클릭 시 항상 로드 방식 선택 모달을 표시합니다.
                        if (startupChoiceModal) {
                            startupChoiceModal.classList.remove('hidden');
                        }
                    }
                }, 50); // 약간의 지연을 주어 UI 렌더링 충돌 방지
            });
        }
        // Revision History Toolbar Event Listeners
        const exportRevisionHistoryBtn = document.getElementById('exportRevisionHistoryBtn');
        const importRevisionHistoryBtn = document.getElementById('importRevisionHistoryBtn');
        const revisionHistoryFileInput = document.getElementById('revisionHistoryFileInput');
        const revisionHistorySearchBtn = document.getElementById('revisionHistorySearchBtn');
        const revisionHistorySearchBar = document.getElementById('revisionHistorySearchBar');
        const revisionHistorySearchInput = document.getElementById('revisionHistorySearchInput');
        const revisionHistoryStatsBtn = document.getElementById('revisionHistoryStatsBtn');
        const revisionHistoryCompareBtn = document.getElementById('revisionHistoryCompareBtn');
        
        if (exportRevisionHistoryBtn) {
            exportRevisionHistoryBtn.addEventListener('click', exportRevisionHistoryToExcel);
        }
        
        if (importRevisionHistoryBtn && revisionHistoryFileInput) {
            importRevisionHistoryBtn.addEventListener('click', () => {
                revisionHistoryFileInput.click();
            });
            
            revisionHistoryFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    importRevisionHistoryFromExcel(file);
                    e.target.value = ''; // Reset input
                }
            });
        }
        
        if (revisionHistorySearchBtn && revisionHistorySearchBar) {
            revisionHistorySearchBtn.addEventListener('click', () => {
                const isHidden = revisionHistorySearchBar.classList.contains('hidden');
                if (isHidden) {
                    revisionHistorySearchBar.classList.remove('hidden');
                    if (revisionHistorySearchInput) {
                        setTimeout(() => revisionHistorySearchInput.focus(), 100);
                    }
                } else {
                    revisionHistorySearchBar.classList.add('hidden');
                    if (revisionHistorySearchInput) {
                        revisionHistorySearchInput.value = '';
                        revisionHistorySearchFilter = '';
                        updateRevisionHistoryUI();
                    }
                }
            });
        }
        
        if (revisionHistorySearchInput) {
            revisionHistorySearchInput.addEventListener('input', (e) => {
                revisionHistorySearchFilter = e.target.value;
                updateRevisionHistoryUI();
            });
        }
        
        if (revisionHistoryStatsBtn) {
            revisionHistoryStatsBtn.addEventListener('click', showRevisionHistoryStats);
        }
        
        if (revisionHistoryCompareBtn) {
            revisionHistoryCompareBtn.addEventListener('click', showRevisionHistoryCompare);
        }
        
        // Reset revision history button
        const resetRevisionHistoryBtn = document.getElementById('resetRevisionHistoryBtn');
        if (resetRevisionHistoryBtn) {
            resetRevisionHistoryBtn.addEventListener('click', showResetRevisionHistoryConfirm);
        }
        
        // Function to restore accordion inline states saved when opening Revision History
        function restoreAccordionsFromRevisionHistory() {
            try {
                // 일정 아코디언은 항상 열린 상태로 유지
                const projectView = document.getElementById('projectView');
                if (projectView) {
                    projectView.classList.add('open');
                    projectView.classList.remove('is-focused');
                    projectView.style.display = '';
                    const content = projectView.querySelector('.accordion-content');
                    if (content) content.style.display = '';
                    const titleBtn = projectView.querySelector('.accordion-title-btn');
                    if (titleBtn) titleBtn.setAttribute('aria-expanded', 'true');
                    const statePill = projectView.querySelector('.accordion-state-pill');
                    if (statePill) {
                        statePill.setAttribute('data-state', 'open');
                        statePill.textContent = '열림';
                    }
                    const scheduleHeaderToggle = document.getElementById('scheduleHeaderToggle');
                    if (scheduleHeaderToggle) {
                        scheduleHeaderToggle.setAttribute('aria-expanded', 'true');
                        scheduleHeaderToggle.title = '접기';
                    }
                }
                
                // 총괄과 정산 아코디언 숨김 처리
                const allAccordionItems = Array.from(document.querySelectorAll('#dashboardContent > .accordion-item'));
                allAccordionItems.forEach((item) => {
                    // 일정 아코디언은 건너뛰기
                    if (item.id === 'projectView') return;
                    
                    // 총괄과 정산 아코디언 찾기
                    const accordionId = item.querySelector('.accordion-title-btn')?.getAttribute('data-accordion-id');
                    if (accordionId === 'overview' || accordionId === 'settlement') {
                        // 일정 아코디언이 열려있으면 총괄/정산 숨김 (open 클래스와 schedule-header-collapsed 클래스 모두 확인)
                        const isScheduleOpen = projectView.classList.contains('open') && 
                                              !projectView.classList.contains('schedule-header-collapsed');
                        if (isScheduleOpen) {
                            item.style.display = 'none';
                            item.classList.remove('open');
                            item.classList.remove('is-focused');
                            const content = item.querySelector('.accordion-content');
                            if (content) content.style.display = 'none';
                            const titleBtn = item.querySelector('.accordion-title-btn');
                            if (titleBtn) titleBtn.setAttribute('aria-expanded', 'false');
                            const statePill = item.querySelector('.accordion-state-pill');
                            if (statePill) {
                                statePill.setAttribute('data-state', 'closed');
                                statePill.textContent = '접힘';
                            }
                        } else {
                            // 일정 아코디언이 접혀있으면 총괄/정산 표시 (저장된 상태로 복원)
                            if (!revisionHistoryPrevAccordionStates) {
                                item.style.display = '';
                                const content = item.querySelector('.accordion-content');
                                if (content) content.style.display = '';
                                return;
                            }
                            
                            const key = item.id || `accordion_${accordionId}`;
                            const saved = revisionHistoryPrevAccordionStates[key];
                            const content = item.querySelector('.accordion-content');
                            if (saved) {
                                if (saved.inlineDisplay !== null && typeof saved.inlineDisplay !== 'undefined') item.style.display = saved.inlineDisplay;
                                else item.style.display = '';
                                if (content) {
                                    if (saved.inlineContentDisplay !== null && typeof saved.inlineContentDisplay !== 'undefined') content.style.display = saved.inlineContentDisplay;
                                    else content.style.display = '';
                                }
                                if (saved.wasOpen) item.classList.add('open'); else item.classList.remove('open');
                                item.classList.remove('is-focused');
                                const titleBtn = item.querySelector('.accordion-title-btn');
                                if (titleBtn) titleBtn.setAttribute('aria-expanded', saved.wasOpen ? 'true' : 'false');
                                const statePill = item.querySelector('.accordion-state-pill');
                                if (statePill) {
                                    statePill.setAttribute('data-state', saved.wasOpen ? 'open' : 'closed');
                                    statePill.textContent = saved.wasOpen ? '열림' : '접힘';
                                }
                            } else {
                                item.style.display = '';
                                if (content) content.style.display = '';
                                item.classList.remove('is-focused');
                            }
                        }
                    }
                });
            } catch (e) {
                console.warn('Failed to restore accordion states after closing revision history', e);
            } finally {
                revisionHistoryPrevAccordionStates = null;
                try { updateAccordionAriaStates(); } catch (e) {}
                // 변경 이력 패널 닫기 후 배타적 표시 로직 적용
                try { updateExclusiveAccordionVisibility(); } catch (e) {}
                try { render(true); } catch (e) {} // 캐시 무효화로 강제 렌더링
            }
        }

        // 아코디언 배타적 표시 제어 함수 (하나가 열리면 나머지는 숨김)
        function updateExclusiveAccordionVisibility() {
            try {
                const allAccordionItems = Array.from(document.querySelectorAll('#dashboardContent > .accordion-item'));
                const projectView = document.getElementById('projectView');

                // 실제로 콘텐츠가 보이는 아코디언을 식별
                // 일정 아코디언이 헤더만 보이는 상태(schedule-header-collapsed)라도 다른 아코디언은 노출되지 않도록 유지
                const isScheduleHeaderOnly = !!(projectView &&
                    projectView.classList.contains('open') &&
                    projectView.classList.contains('schedule-header-collapsed'));
                let visibleItem = null;
                allAccordionItems.forEach(item => {
                    if (!item.classList.contains('open')) return;

                    if (item.id === 'projectView') {
                        visibleItem = item;
                        return;
                    }

                    if (!isScheduleHeaderOnly) {
                        visibleItem = item;
                    }
                });

                // 일정이 헤더만 보이는 상태에서는 일정만 표시되도록 강제
                if (isScheduleHeaderOnly && projectView) {
                    visibleItem = projectView;
                }

                allAccordionItems.forEach(item => {
                    if (item === visibleItem) {
                        // 콘텐츠가 보이는 아코디언만 표시
                        item.style.display = '';
                        item.classList.remove('hidden');
                    } else {
                        // 다른 모든 아코디언은 숨김
                        item.style.display = 'none';
                        item.classList.add('hidden');
                    }
                });

                // 예외: 아무 아코디언의 콘텐츠도 보이지 않는다면 모두 표시
                if (!visibleItem) {
                    allAccordionItems.forEach(item => {
                        item.style.display = '';
                        item.classList.remove('hidden');
                    });
                }

            } catch (e) {
                console.warn('updateExclusiveAccordionVisibility error:', e);
            }
        }

        if (closeRevisionHistoryPanelBtn) {
            closeRevisionHistoryPanelBtn.addEventListener('click', () => {
                // Restore accordions to their previous inline/display state
                restoreAccordionsFromRevisionHistory();
                if (revisionHistoryPanel) {
                    revisionHistoryPanel.classList.add('hidden');
                }

                // 렌더링 잠금 해제 및 강제 렌더링 준비
                if (typeof isRendering !== 'undefined') isRendering = false;
                if (typeof renderTimeout !== 'undefined' && renderTimeout) clearTimeout(renderTimeout);

                // 변경 이력 패널 닫기 후 배타적 표시 및 렌더링 보장
                setTimeout(() => {
                    try {
                        // 배타적 표시 업데이트
                        updateExclusiveAccordionVisibility();

                        // 렌더링 강제 실행 (캐시 무효화 포함)
                        if (typeof render === 'function') {
                            render(true);
                        }
                    } catch (e) {
                        console.warn('Failed to render and update accordions after closing revision history', e);
                    }
                }, 50); // 지연 시간 단축
            });
        }

        // Close revision history panel when clicking outside
        if (revisionHistoryPanel) {
            revisionHistoryPanel.addEventListener('click', (e) => {
                if (e.target === revisionHistoryPanel) {
                    restoreAccordionsFromRevisionHistory();
                    revisionHistoryPanel.classList.add('hidden');
                    
                    // 렌더링 잠금 해제 및 강제 렌더링 준비
                    if (typeof isRendering !== 'undefined') isRendering = false;
                    if (typeof renderTimeout !== 'undefined' && renderTimeout) clearTimeout(renderTimeout);

                    // 변경 이력 패널 닫기 후 총괄/정산 아코디언 내부 섹션 렌더링 보장 (조건 없이 강제 렌더링)
                    setTimeout(() => {
                        try {
                             // 렌더링 강제 실행 (캐시 무효화 포함)
                            if (typeof render === 'function') {
                                render(true);
                            }
                             
                            // 총괄/정산 컨테이너가 비어있으면 다시 확인하여 렌더링
                            const overviewGroupSummaries = document.getElementById('overview-group-summaries');
                            if (overviewGroupSummaries && overviewGroupSummaries.innerHTML.trim() === '') {
                                 render(true);
                            }
                        } catch (e) {
                            console.warn('Failed to render overview/settlement after closing revision history', e);
                        }
                    }, 50); // 지연 시간 단축
                }
            });
        }
        
        // Revision History Panel Drag and Resize functionality
        const revisionHistoryPanelContent = document.getElementById('revisionHistoryPanelContent');
        const revisionHistoryPanelHeader = document.getElementById('revisionHistoryPanelHeader');
        
        // Drag functionality
        if (revisionHistoryPanelHeader && revisionHistoryPanelContent) {
            let isDragging = false;
            let currentX = 0;
            let currentY = 0;
            let initialX = 0;
            let initialY = 0;
            let xOffset = 0;
            let yOffset = 0;
            
            // Initialize offsets from current position
            const updateOffsets = () => {
                const rect = revisionHistoryPanelContent.getBoundingClientRect();
                xOffset = rect.left;
                yOffset = rect.top;
            };
            
            revisionHistoryPanelHeader.addEventListener('mousedown', (e) => {
                if (e.target.closest('button')) return; // Don't drag when clicking buttons
                
                updateOffsets();
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                
                if (e.target === revisionHistoryPanelHeader || revisionHistoryPanelHeader.contains(e.target)) {
                    isDragging = true;
                    revisionHistoryPanelContent.style.cursor = 'move';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    
                    xOffset = currentX;
                    yOffset = currentY;
                    
                    // Calculate boundaries
                    const panelRect = revisionHistoryPanelContent.getBoundingClientRect();
                    const panelWidth = panelRect.width;
                    const panelHeight = panelRect.height;
                    const maxX = window.innerWidth - panelWidth;
                    const maxY = window.innerHeight - panelHeight;
                    
                    // Constrain to viewport
                    const constrainedX = Math.max(0, Math.min(currentX, maxX));
                    const constrainedY = Math.max(0, Math.min(currentY, maxY));
                    
                    revisionHistoryPanelContent.style.left = `${constrainedX}px`;
                    revisionHistoryPanelContent.style.top = `${constrainedY}px`;
                    revisionHistoryPanelContent.style.transform = 'none';
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    revisionHistoryPanelContent.style.cursor = '';
                    updateOffsets();
                }
            });
        }
        
        // Resize functionality
        if (revisionHistoryPanelContent) {
            const resizerHandles = revisionHistoryPanelContent.querySelectorAll('.resizer-handle');
            
            resizerHandles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const direction = handle.classList[1]; // n, s, e, w, ne, nw, se, sw
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const startWidth = parseInt(document.defaultView.getComputedStyle(revisionHistoryPanelContent).width, 10);
                    const startHeight = parseInt(document.defaultView.getComputedStyle(revisionHistoryPanelContent).height, 10);
                    const startLeft = parseInt(document.defaultView.getComputedStyle(revisionHistoryPanelContent).left, 10);
                    const startTop = parseInt(document.defaultView.getComputedStyle(revisionHistoryPanelContent).top, 10);
                    
                    const minWidth = 400;
                    const minHeight = 300;
                    const maxWidth = window.innerWidth * 0.95;
                    const maxHeight = window.innerHeight * 0.95;
                    
                    const doResize = (moveEvent) => {
                        const deltaX = moveEvent.clientX - startX;
                        const deltaY = moveEvent.clientY - startY;
                        
                        let newWidth = startWidth;
                        let newHeight = startHeight;
                        let newLeft = startLeft;
                        let newTop = startTop;
                        
                        // Handle horizontal resizing
                        if (direction.includes('e')) {
                            newWidth = Math.min(maxWidth, Math.max(minWidth, startWidth + deltaX));
                        }
                        if (direction.includes('w')) {
                            newWidth = Math.min(maxWidth, Math.max(minWidth, startWidth - deltaX));
                            newLeft = startLeft + (startWidth - newWidth);
                        }
                        
                        // Handle vertical resizing
                        if (direction.includes('s')) {
                            newHeight = Math.min(maxHeight, Math.max(minHeight, startHeight + deltaY));
                        }
                        if (direction.includes('n')) {
                            newHeight = Math.min(maxHeight, Math.max(minHeight, startHeight - deltaY));
                            newTop = startTop + (startHeight - newHeight);
                        }
                        
                        // Apply constraints
                        if (newLeft < 0) {
                            newWidth += newLeft;
                            newLeft = 0;
                        }
                        if (newTop < 0) {
                            newHeight += newTop;
                            newTop = 0;
                        }
                        if (newLeft + newWidth > window.innerWidth) {
                            newWidth = window.innerWidth - newLeft;
                        }
                        if (newTop + newHeight > window.innerHeight) {
                            newHeight = window.innerHeight - newTop;
                        }
                        
                        revisionHistoryPanelContent.style.width = `${newWidth}px`;
                        revisionHistoryPanelContent.style.height = `${newHeight}px`;
                        revisionHistoryPanelContent.style.left = `${newLeft}px`;
                        revisionHistoryPanelContent.style.top = `${newTop}px`;
                        revisionHistoryPanelContent.style.transform = 'none';
                    };
                    
                    const stopResize = () => {
                        document.removeEventListener('mousemove', doResize);
                        document.removeEventListener('mouseup', stopResize);
                    };
                    
                    document.addEventListener('mousemove', doResize);
                    document.addEventListener('mouseup', stopResize);
                });
            });
        }
        uploadBtn.addEventListener('click', () => fileInput.click());
        saveHtmlBtn.addEventListener('click', saveAsStandaloneHTML);
        downloadTemplateBtns.forEach(btn => {
            btn.addEventListener('click', () => downloadTemplate(btn.dataset.format));
        });
        initializeAccordionHints();
        attachAccordionTitleInteractions();
        setupAccordionStateObserver();
        initializeSortDirectionButtons();
        updateSortDirectionIndicators();
        updateShowChangesButtonState();
        if (resetDateChangesBtn) {
            resetDateChangesBtn.addEventListener('click', async () => {
                if (resetDateChangesBtn.disabled) return;
                resetDateChangesBtn.disabled = true;
                try {
                    rebaselineOriginalDates(true, false);
                    render();
                    showToast('모든 작업의 날짜 변경 표시가 초기화되었습니다.', 'success');
                } catch (error) {
                    console.error('resetDateChangesBtn error', error);
                    showToast('초기화 중 오류가 발생했습니다.', 'error');
                } finally {
                    setTimeout(() => { resetDateChangesBtn.disabled = false; }, 300);
                }
            });
        }

        // Main Accordion Click Logic
        dashboardContent.addEventListener('click', e => {
            // 개선 사항 1: 바로가기 메뉴 클릭 시 아코디언 토글 방지
            if (e.target.closest('#shortcutContainer')) {
                return;
            }

            // 제목 버튼을 직접 클릭했을 때만 토글
            const titleElement = e.target.closest('.accordion-title-btn');
            if (titleElement && titleElement.closest('.accordion-header')) {
                e.stopPropagation();
                const accordionHeader = titleElement.closest('.accordion-header');
                const allAccordionItems = Array.from(dashboardContent.querySelectorAll('.accordion-item'));
                const clickedItem = accordionHeader ? accordionHeader.parentElement : null;
                if (!clickedItem) return;

                const accordionId = titleElement.dataset.accordionId;
                if (accordionId) {
                    dismissAccordionHint(accordionId);
                }

                // 배타적 표시: 클릭된 아코디언만 열고 나머지는 모두 숨김
                const isCurrentlyOpen = clickedItem.classList.contains('open');

                // 모든 아코디언을 닫음
                allAccordionItems.forEach(item => {
                    item.classList.remove('open', 'is-focused');
                    const content = item.querySelector('.accordion-content');
                    if (content) content.style.display = 'none';
                    const titleBtn = item.querySelector('.accordion-title-btn');
                    if (titleBtn) titleBtn.setAttribute('aria-expanded', 'false');
                    const statePill = item.querySelector('.accordion-state-pill');
                    if (statePill) {
                        statePill.setAttribute('data-state', 'closed');
                        statePill.textContent = '접힘';
                    }
                });

                // 클릭된 아코디언을 염 (닫혀있었다면)
                if (!isCurrentlyOpen) {
                    clickedItem.classList.add('open', 'is-focused');
                    const content = clickedItem.querySelector('.accordion-content');
                    if (content) content.style.display = '';
                    const titleBtn = clickedItem.querySelector('.accordion-title-btn');
                    if (titleBtn) titleBtn.setAttribute('aria-expanded', 'true');
                    const statePill = clickedItem.querySelector('.accordion-state-pill');
                    if (statePill) {
                        statePill.setAttribute('data-state', 'open');
                        statePill.textContent = '열림';
                    }
                }

                // 배타적 표시 업데이트
                updateExclusiveAccordionVisibility();
                // Ensure sub-accordions inside the just-opened/focused section are rendered correctly (if applicable)
                if (clickedItem.id === 'settlement-accordion' && clickedItem.classList.contains('open')) {
                    setupSettlementAccordions(); // Re-setup listeners if needed
                }
                 // Add listeners for control section toggles if schedule accordion is opened
                if (clickedItem.id === 'projectView' && clickedItem.classList.contains('open')) {
                    setupControlSectionToggles(clickedItem.querySelector('#controlsSection'));
                }
                updateAccordionAriaStates();
                updateExclusiveAccordionVisibility(); // 아코디언 토글 시 배타적 표시 업데이트
                setTimeout(render, 350); // Delay render slightly
                return;
            }

             // Sub-accordion click logic within Settlement
            const subAccordionHeader = e.target.closest('.sub-accordion-header');
            if (subAccordionHeader) {
                e.stopPropagation();
                const subAccordionItem = subAccordionHeader.parentElement;
                subAccordionItem.classList.toggle('open');
            }


            const card = e.target.closest('[data-filter-type]');
            if (card) {
                handleCardClick(e);
            }

             // Control Section Toggle Logic
            const controlHeader = e.target.closest('.control-section-header');
            if (controlHeader) {
                e.stopPropagation();
                controlHeader.classList.toggle('open');
            }
        });

        // Function to set up control section toggles
        function setupControlSectionToggles(controlsSectionElement) {
            if (!controlsSectionElement) return;
            controlsSectionElement.querySelectorAll('.control-section-header').forEach(header => {
                // Remove existing listener first to avoid duplicates
                header.removeEventListener('click', toggleControlSection);
                header.addEventListener('click', toggleControlSection);
            });
        }

        // Event handler for control section toggles
        function toggleControlSection(e) {
             // Only toggle if the click is directly on the header or the icon, not inputs inside
             if (e.target.closest('select, input, button') && !e.target.closest('.control-section-icon')) {
                 return;
             }
            e.currentTarget.classList.toggle('open');
        }
        
        // 개선 사항: 컨트롤 패널 이벤트 리스너
        function closeControlsPanel() {
            controlsPanel.classList.add('translate-x-full');
            controlsPanelOverlay.classList.add('hidden');
            // network-status의 z-index를 원래대로 복원
            const networkStatus = document.getElementById('network-status');
            if (networkStatus) {
                networkStatus.classList.remove('panel-open');
            }
            // 패널을 닫을 때 현재 자동 업로드 설정을 저장
            try {
                saveDashboardSettings();
            } catch (e) {
                console.warn('saveDashboardSettings failed', e);
            }
        }
        function openControlsPanel(e) {
            if (e) e.stopPropagation(); // 아코디언 토글 방지
            hideFloatingPopovers();
            controlsPanel.classList.remove('translate-x-full');
            controlsPanelOverlay.classList.remove('hidden');
            // network-status의 z-index를 낮춰서 X 닫기 버튼이 클릭 가능하도록
            const networkStatus = document.getElementById('network-status');
            if (networkStatus) {
                networkStatus.classList.add('panel-open');
            }
            // 패널 오픈 시 컨트롤 참조와 토글, 바로가기 초기화 보장
            updateControlReferences();
            setupControlSectionToggles(document.getElementById('controlsSection'));
            if (typeof setupPinnableControls === 'function') setupPinnableControls();
            
            // 추가: 줌 버튼 이벤트 리스너 직접 확인 및 재설정
            setTimeout(() => {
                const zoomBtn = document.getElementById('zoomBtn');
                if (zoomBtn && !zoomBtn.hasAttribute('data-listener-attached')) {
                    zoomBtn.addEventListener('click', handleZoomButtonClick);
                    zoomBtn.setAttribute('data-listener-attached', 'true');
                }
            }, 100);
        }
        if (filterTimelineFabBtn) {
            filterTimelineFabBtn.addEventListener('click', openControlsPanel);
        }
        if (legendGoToTodayBtn) {
            legendGoToTodayBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (typeof scrollToToday === 'function') {
                    scrollToToday();
                } else if (goToTodayBtn) {
                    goToTodayBtn.click();
                }
            });
        }
        closeControlsPanelBtn.addEventListener('click', closeControlsPanel);
        controlsPanelOverlay.addEventListener('click', closeControlsPanel);

        // 검색 바로가기 입력 폭 자동 조절 헬퍼
        function autoResizeShortcutSearch(inputEl) {
            if (!inputEl) return;
            const minWidth = 75;
            const maxWidth = 260;
            const buffer = 32;
            const value = inputEl.value || inputEl.getAttribute('placeholder') || '';
            const approxWidth = Math.min(maxWidth, Math.max(minWidth, value.length * 9 + buffer));
            inputEl.style.width = approxWidth + 'px';
        }

        // 개선 사항 1: 바로가기 메뉴 업데이트 함수
        function updateShortcuts() {
    const shortcutContainer = document.getElementById('shortcutContainer');
    if (!shortcutContainer) return;
    
    shortcutContainer.innerHTML = '';
    const controlContainer = document.getElementById('controlsPanel');
    if (!controlContainer) return;

    pinnedShortcuts.forEach(id => {
        const originalElement = controlContainer.querySelector(`#${id}`);
        if (!originalElement) return;

        const shortcutWrapper = document.createElement('div');
        shortcutWrapper.className = 'shortcut-item';
        shortcutWrapper.dataset.shortcutId = id;
        shortcutWrapper.addEventListener('click', e => e.stopPropagation());

        const clonedElement = originalElement.cloneNode(true);
        clonedElement.id = `shortcut-${id}`;
        clonedElement.dataset.shortcutCloneId = id;
        const updateWrapperTooltip = () => {
            const tip = getShortcutTooltipText(originalElement);
            if (tip) {
                shortcutWrapper.title = tip;
                clonedElement.title = tip;
            } else {
                shortcutWrapper.removeAttribute('title');
                clonedElement.removeAttribute('title');
            }
        };
        updateWrapperTooltip();

        // 현재 값 복사
        if (clonedElement.tagName === 'SELECT' || clonedElement.tagName === 'INPUT') {
            clonedElement.value = originalElement.value;
        }

        // 이벤트 리스너 강화
        if (clonedElement.classList.contains('js-zoom-btn')) {
            clonedElement.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                toggleZoomPopover(clonedElement);
                updateWrapperTooltip();
            });
        } else if (clonedElement.tagName === 'SELECT') {
            clonedElement.addEventListener('change', (e) => {
                e.stopPropagation();
                originalElement.value = clonedElement.value;
                originalElement.dispatchEvent(new Event('change', { bubbles: true })); // 이벤트 전파
                updateWrapperTooltip();
            });
        } else if (clonedElement.tagName === 'INPUT') {
            clonedElement.addEventListener('input', (e) => {
                e.stopPropagation();
                originalElement.value = clonedElement.value;
                originalElement.dispatchEvent(new Event('input')); // 이벤트 전파
                render();
                if (originalElement.id === 'searchInput') {
                    autoResizeShortcutSearch(clonedElement);
                }
                updateWrapperTooltip();
            });
            if (originalElement.id === 'searchInput') {
                clonedElement.addEventListener('focus', () => autoResizeShortcutSearch(clonedElement));
            }
        } else if (clonedElement.tagName === 'BUTTON') {
            clonedElement.addEventListener('click', (e) => {
                e.stopPropagation();
                originalElement.click();
                updateWrapperTooltip();
            });
        }
        
        // If this is the task type filter, contractor filter, progress filter, or sort by, wrap it in a compact wrapper so long labels are truncated
        if (originalElement.id === 'taskTypeFilter' || originalElement.id === 'contractor-filter' || originalElement.id === 'cost-account-filter' ||
            originalElement.id === 'progressFilter' || originalElement.id === 'sortBy') {
            try {
                const smallWrap = document.createElement('div');
                if (originalElement.id === 'taskTypeFilter') {
                    smallWrap.className = 'shortcut-type-small-wrapper';
                    clonedElement.classList.add('shortcut-type-small');
                } else if (originalElement.id === 'contractor-filter') {
                    smallWrap.className = 'shortcut-contractor-small-wrapper';
                    clonedElement.classList.add('shortcut-contractor-small');
                } else if (originalElement.id === 'cost-account-filter') {
                    smallWrap.className = 'shortcut-cost-account-small-wrapper';
                    clonedElement.classList.add('shortcut-cost-account-small');
                } else if (originalElement.id === 'progressFilter') {
                    smallWrap.className = 'shortcut-progress-small-wrapper';
                    clonedElement.classList.add('shortcut-progress-small');
                } else if (originalElement.id === 'sortBy') {
                    smallWrap.className = 'shortcut-sort-small-wrapper sort-control-wrapper';
                    clonedElement.classList.add('shortcut-sort-small');
                }
                // copy visible selected option as tooltip for full value
                if (originalElement.options && originalElement.selectedIndex >= 0) {
                    clonedElement.title = originalElement.options[originalElement.selectedIndex].text || originalElement.value || '';
                } else {
                    clonedElement.title = originalElement.value || '';
                }
                if (originalElement.id === 'sortBy') {
                    const inner = document.createElement('div');
                    inner.className = 'sort-control-inner';
                    inner.appendChild(clonedElement);
                    const toggleBtn = createSortDirectionButton();
                    inner.appendChild(toggleBtn);
                    smallWrap.appendChild(inner);
                    initializeSortDirectionButtons(inner);
                } else {
                    smallWrap.appendChild(clonedElement);
                }
                shortcutWrapper.appendChild(smallWrap);
            } catch (e) {
                // Fallback to default append if anything goes wrong
                shortcutWrapper.appendChild(clonedElement);
            }
        } else if (originalElement.id === 'searchInput') {
            const searchWrap = document.createElement('div');
            searchWrap.className = 'shortcut-search-wrapper';
            clonedElement.classList.add('shortcut-search-input');
            searchWrap.appendChild(clonedElement);
            shortcutWrapper.appendChild(searchWrap);
            requestAnimationFrame(() => autoResizeShortcutSearch(clonedElement));
        } else {
            shortcutWrapper.appendChild(clonedElement);
        }
        shortcutContainer.appendChild(shortcutWrapper);
    });

    initializeSortDirectionButtons(shortcutContainer);
    updateSortDirectionIndicators();
    updateShowChangesButtonState();
    updateShortcutActiveStates();

    // 핀 버튼 상태 업데이트
    controlContainer.querySelectorAll('.pin-shortcut-btn').forEach(btn => {
        const controlId = btn.dataset.controlId;
        if (pinnedShortcuts.has(controlId)) {
            btn.classList.add('pinned');
            btn.innerHTML = '&#128205;'; // 핀 이모지
        } else {
            btn.classList.remove('pinned');
            btn.innerHTML = '&#128278;'; // 링크 이모지
        }
        
        // 툴팁 추가
        btn.title = pinnedShortcuts.has(controlId) ? 
            '바로가기에서 제거' : 
            '바로가기로 추가';
    });
}
        
        // 개선사항 2: 원본 컨트롤에서 바로가기로 동기화하는 함수
        function syncShortcutsFromOriginal() {
            const controlContainer = document.getElementById('controlsPanel');
            
            pinnedShortcuts.forEach(id => {
                const originalElement = controlContainer.querySelector(`#${id}`);
                const shortcutElement = document.querySelector(`#shortcut-${id}`);
                
                if (!originalElement || !shortcutElement) return;
                
                // SELECT나 INPUT의 경우 값 동기화
                if ((originalElement.tagName === 'SELECT' || originalElement.tagName === 'INPUT') && 
                    (shortcutElement.tagName === 'SELECT' || shortcutElement.tagName === 'INPUT')) {
                    if (shortcutElement.value !== originalElement.value) {
                        shortcutElement.value = originalElement.value;
                        if (id === 'searchInput') {
                            autoResizeShortcutSearch(shortcutElement);
                        }
                    }
                }
            });
        }
        
        // 개선 사항 1: 바로가기 핀 설정 함수
        function setupPinnableControls() {
            const controlContainer = document.getElementById('controlsPanel');
            controlContainer.querySelectorAll('.pinnable-control-wrapper').forEach(wrapper => {
                const control = wrapper.querySelector('select, input, button');
                if (!control) return;

                // If a pin button already exists, ensure it has a dataset.controlId set
                let existingPin = wrapper.querySelector('.pin-shortcut-btn');
                // Ensure control has a stable id for referencing
                if (!control.id) {
                    // Generate a stable-ish id using the control type and a short random suffix
                    control.id = `ctrl-${(control.tagName || 'el').toLowerCase()}-${Math.random().toString(36).slice(2,8)}`;
                }

                if (existingPin) {
                    existingPin.dataset.controlId = control.id;
                } else {
                    const pinBtn = document.createElement('button');
                    pinBtn.className = 'pin-shortcut-btn';
                    pinBtn.title = '헤더에 바로가기로 고정';
                    pinBtn.dataset.controlId = control.id;
                    pinBtn.setAttribute('type', 'button');
                    pinBtn.innerHTML = '&#128278;';
                    wrapper.appendChild(pinBtn);
                }
            });
            updateShortcuts(); // Initial render of shortcuts
        }

        // **개선 사항 1 수정: 줌 버튼 클릭 핸들러**
        function handleZoomButtonClick(e) {
            e.stopPropagation();
            e.preventDefault();
            toggleZoomPopover(e.currentTarget);
        }

        // **개선 사항 1 수정: 날짜 설정 모달 토글 함수**
        function toggleZoomPopover(buttonEl) {
            if (!zoomModal) return;
            
            const isHidden = zoomModal.classList.contains('hidden');

            if (isHidden) {
                zoomModal.classList.remove('hidden');
                // 팝오버 내부 이벤트 리스너 재설정
                setupZoomPopoverListeners();
            } else {
                zoomModal.classList.add('hidden');
            }
        }

        // 줌 팝오버 내부 이벤트 리스너 설정
        function setupZoomPopoverListeners() {
            if (!zoomPopover) return;
            
            // 기존 리스너 제거
            const applyBtn = zoomPopover.querySelector('#zoomApplyBtn');
            const resetBtn = zoomPopover.querySelector('#zoomResetBtn');
            const prevWeekBtn = zoomPopover.querySelector('#zoomPrevWeek');
            const thisWeekBtn = zoomPopover.querySelector('#zoomThisWeek');
            const nextWeekBtn = zoomPopover.querySelector('#zoomNextWeek');
            const threeWeeksTodayBtn = zoomPopover.querySelector('#zoomThreeWeeksToday');
            const threeWeeksSelectedBtn = zoomPopover.querySelector('#zoomThreeWeeksSelected');
            
            // 새 리스너 추가
            if (applyBtn) {
                applyBtn.removeEventListener('click', handleZoomApply);
                applyBtn.addEventListener('click', handleZoomApply);
            }
            if (resetBtn) {
                resetBtn.removeEventListener('click', handleZoomReset);
                resetBtn.addEventListener('click', handleZoomReset);
            }
            if (prevWeekBtn) {
                prevWeekBtn.removeEventListener('click', () => applyWeekZoom(-1));
                prevWeekBtn.addEventListener('click', () => applyWeekZoom(-1));
            }
            if (thisWeekBtn) {
                thisWeekBtn.removeEventListener('click', () => applyWeekZoom(0));
                thisWeekBtn.addEventListener('click', () => applyWeekZoom(0));
            }
            if (nextWeekBtn) {
                nextWeekBtn.removeEventListener('click', () => applyWeekZoom(1));
                nextWeekBtn.addEventListener('click', () => applyWeekZoom(1));
            }
            if (threeWeeksTodayBtn) {
                threeWeeksTodayBtn.removeEventListener('click', handleZoomThreeWeeksToday);
                threeWeeksTodayBtn.addEventListener('click', handleZoomThreeWeeksToday);
            }
            if (threeWeeksSelectedBtn) {
                threeWeeksSelectedBtn.removeEventListener('click', handleZoomThreeWeeksSelected);
                threeWeeksSelectedBtn.addEventListener('click', handleZoomThreeWeeksSelected);
            }
        }


        // Function to update control element references
        function updateControlReferences(container = document) {
            // 컨트롤 요소들은 이제 메인 document 또는 컨트롤 패널 내에 있음
            const controlContainer = document.getElementById('controlsPanel');

            taskTypeFilter = controlContainer.querySelector('#taskTypeFilter');
            customFilterContainer = controlContainer.querySelector('#customFilterContainer');
            progressFilter = controlContainer.querySelector('#progressFilter');
            sortBy = controlContainer.querySelector('#sortBy');
            searchInput = controlContainer.querySelector('#searchInput');
            goToTodayBtn = controlContainer.querySelector('#goToTodayBtn');
            expandAllBtn = controlContainer.querySelector('#expandAllBtn');
            collapseAllBtn = controlContainer.querySelector('#collapseAllBtn');
            showChangesBtn = controlContainer.querySelector('#showChangesBtn');
            // Prefer a document-level reference (covers the main control and any cloned shortcuts).
            toggleHierarchyOrderBtn = document.querySelector('#toggleHierarchyOrderBtn') || (controlContainer && controlContainer.querySelector('#toggleHierarchyOrderBtn'));
            zoomBtn = controlContainer.querySelector('#zoomBtn');
            zoomPopover = document.getElementById('zoomPopover'); // **수정: 항상 document에서 찾도록**
            zoomStartDate = document.getElementById('zoomStartDate');
            zoomEndDate = document.getElementById('zoomEndDate');
            zoomApplyBtn = document.getElementById('zoomApplyBtn');
            zoomResetBtn = document.getElementById('zoomResetBtn');
            zoomPrevWeek = document.getElementById('zoomPrevWeek');
            zoomThisWeek = document.getElementById('zoomThisWeek');
            zoomNextWeek = document.getElementById('zoomNextWeek');
            zoomThreeWeeksToday = document.getElementById('zoomThreeWeeksToday');
            zoomThreeWeeksSelected = document.getElementById('zoomThreeWeeksSelected');

            // Re-attach listeners if elements exist
            if (taskTypeFilter) {
                taskTypeFilter.removeEventListener('change', render);
                taskTypeFilter.addEventListener('change', () => {
                    invalidateFilteredDataCache();
                    render(true);
                });
                ensureControlDefaultValue(taskTypeFilter);
            }
            if (progressFilter) {
                progressFilter.removeEventListener('change', render);
                progressFilter.addEventListener('change', () => {
                    invalidateFilteredDataCache();
                    render(true);
                });
                ensureControlDefaultValue(progressFilter);
            }
            if (sortBy) {
                sortBy.removeEventListener('change', handleSortControlChange);
                sortBy.addEventListener('change', (e) => {
                    invalidateFilteredDataCache();
                    handleSortControlChange(e);
                });
                ensureControlDefaultValue(sortBy);
            }
            // 개선 사항: 검색 입력에 디바운싱 적용하여 대량 데이터 처리 시 성능 최적화
            if (searchInput) {
                searchInput.removeEventListener('input', debouncedRender);
                searchInput.removeEventListener('input', render);
                searchInput.addEventListener('input', () => {
                    invalidateFilteredDataCache();
                    debouncedRender();
                });
                ensureControlDefaultValue(searchInput);
            }
            if (goToTodayBtn) goToTodayBtn.addEventListener('click', scrollToToday);
            attachShortcutToggleListener(expandAllBtn, 'expand');
            attachShortcutToggleListener(collapseAllBtn, 'collapse');
            if (showChangesBtn) {
                showChangesBtn.removeEventListener('click', toggleShowChangesFilter);
                showChangesBtn.addEventListener('click', toggleShowChangesFilter);
                updateShowChangesButtonState();
            }
            if (toggleHierarchyOrderBtn) {
                toggleHierarchyOrderBtn.removeEventListener('click', toggleHierarchyOrder);
                toggleHierarchyOrderBtn.addEventListener('click', toggleHierarchyOrder);
                // 버튼 텍스트 및 스타일 초기화 (현재 상태를 시각적으로 명확히 표시)
                const isBottomMode = hierarchyOrder === 'bottom';
                // Update all matching buttons in the document (main control + any cloned shortcut buttons)
                const allToggleButtons = Array.from(document.querySelectorAll('#toggleHierarchyOrderBtn, [id*="toggleHierarchyOrderBtn"]'));
                allToggleButtons.forEach(btn => {
                    try {
                        btn.textContent = isBottomMode ? '계층순서 (하→상)' : '계층순서 (상→하)';
                        if (isBottomMode) {
                            btn.style.backgroundColor = '#dbeafe';
                            btn.style.border = '2px solid #3b82f6';
                            btn.style.fontWeight = 'bold';
                            btn.style.color = '#1e40af';
                        } else {
                            btn.style.backgroundColor = '#fef3c7';
                            btn.style.border = '2px solid #f59e0b';
                            btn.style.fontWeight = 'bold';
                            btn.style.color = '#92400e';
                        }
                    } catch (e) {
                        // ignore individual button style failures
                    }
                });
            }
            
            // **개선 사항 1 수정: 원본 줌 버튼 이벤트 리스너**
            if(zoomBtn) {
                // Remove any existing listeners to prevent duplicates
                zoomBtn.removeEventListener('click', handleZoomButtonClick);
                zoomBtn.addEventListener('click', handleZoomButtonClick);
            }

            // 줌 팝오버 내부 버튼들은 팝오버가 열릴 때 setupZoomPopoverListeners에서 처리

             // Add listeners for custom filters
             if(customFilterContainer) {
                 customFilterContainer.querySelectorAll('select').forEach(select => {
                     select.removeEventListener('change', render); // Prevent duplicates
                     select.addEventListener('change', () => {
                         invalidateFilteredDataCache();
                         render(true);
                     });
                 });
             }
             setupControlSectionToggles(controlContainer.querySelector('#controlsSection'));

            // 개선 사항: 헤더 타이틀 옆 바로가기 필터들 동기화
            const headerCustomFilter = document.getElementById('header-customer-filter-shortcut');
            const headerContractorFilter = document.getElementById('header-contractor-filter-shortcut');
            const headerCostFilter = document.getElementById('header-cost-account-filter-shortcut');
            const mainCustomerFilter = controlContainer.querySelector('#customer-filter');
            const mainContractorFilter = controlContainer.querySelector('#contractor-filter');
            const mainCostFilter = controlContainer.querySelector('#cost-account-filter');

            // 헤더 바로가기 동기화
            if (headerCustomFilter && mainCustomerFilter) {
                headerCustomFilter.innerHTML = mainCustomerFilter.innerHTML;
                // 초기 설정을 '고객사'로 강제 설정
                if (headerCustomFilter.querySelector('option[value="고객사"]')) {
                    // 메인 필터를 먼저 '고객사'로 설정 (change 이벤트 발생 방지를 위해 직접 설정)
                    mainCustomerFilter.value = '고객사';
                    headerCustomFilter.value = '고객사';
                    ensureControlDefaultValue(mainCustomerFilter);
                    // 필터 변경을 반영하기 위해 render 호출
                    if (typeof render === 'function') {
                        render();
                    }
                } else {
                    headerCustomFilter.value = mainCustomerFilter.value;
                }
                
                // 클릭 시 이벤트 전파 방지
                headerCustomFilter.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                headerCustomFilter.addEventListener('change', (e) => {
                    e.stopPropagation();
                    mainCustomerFilter.value = e.target.value;
                    mainCustomerFilter.dispatchEvent(new Event('change'));
                    updateHeaderShortcutHighlight();
                });
                mainCustomerFilter.addEventListener('change', () => {
                    headerCustomFilter.innerHTML = mainCustomerFilter.innerHTML;
                    // 사용자가 직접 변경한 경우에만 동기화 (초기화 시점이 아닌 경우)
                    headerCustomFilter.value = mainCustomerFilter.value;
                    updateHeaderShortcutHighlight();
                });
                updateHeaderShortcutHighlight();
            }

            if (headerContractorFilter && mainContractorFilter) {
                headerContractorFilter.innerHTML = mainContractorFilter.innerHTML;
                headerContractorFilter.value = mainContractorFilter.value;
                ensureControlDefaultValue(mainContractorFilter);
                
                // 클릭 시 이벤트 전파 방지
                headerContractorFilter.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                headerContractorFilter.addEventListener('change', (e) => {
                    e.stopPropagation();
                    mainContractorFilter.value = e.target.value;
                    mainContractorFilter.dispatchEvent(new Event('change'));
                    updateHeaderShortcutHighlight();
                });
                mainContractorFilter.addEventListener('change', () => {
                    headerContractorFilter.innerHTML = mainContractorFilter.innerHTML;
                    headerContractorFilter.value = mainContractorFilter.value;
                    updateHeaderShortcutHighlight();
                });
                updateHeaderShortcutHighlight();
            }

            if (headerCostFilter) {
                const syncCostShortcut = () => {
                    if (!mainCostFilter) {
                        updateHeaderShortcutHighlight();
                        return;
                    }
                    headerCostFilter.innerHTML = mainCostFilter.innerHTML;
                    headerCostFilter.value = mainCostFilter.value;
                    headerCostFilter.disabled = false;
                    updateHeaderShortcutHighlight();
                };

                if (mainCostFilter) {
                    ensureControlDefaultValue(mainCostFilter);
                    syncCostShortcut();

                    headerCostFilter.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    headerCostFilter.addEventListener('change', (e) => {
                        e.stopPropagation();
                        mainCostFilter.value = e.target.value;
                        mainCostFilter.dispatchEvent(new Event('change'));
                        updateHeaderShortcutHighlight();
                    });
                    mainCostFilter.addEventListener('change', () => {
                        syncCostShortcut();
                    });
                } else {
                    headerCostFilter.innerHTML = '<option value="all">비용계정</option>';
                    headerCostFilter.value = 'all';
                    headerCostFilter.disabled = true;
                    updateHeaderShortcutHighlight();
                }
            }

            updateGroupToggleButtons();
            updateZoomButtonState();
            updateShortcutActiveStates();

        }

        function getPrimarySortControl() {
            return sortBy || document.querySelector('#sortBy');
        }

        function handleSortControlChange(event) {
            sortState.mode = event.target.value || 'default';
            sortState.direction = SORT_DIRECTIONS.DESC;
            updateSortDirectionIndicators();
            invalidateFilteredDataCache();
            render(true);
        }

        function handleSortDirectionButtonClick(event) {
            event.stopPropagation();
            event.preventDefault();
            const sortControl = getPrimarySortControl();
            if (!sortControl) return;
            const currentMode = sortControl.value || 'default';
            if (!currentMode || currentMode === 'default') {
                showToast('정렬 기준을 먼저 선택하세요.', 'info');
                return;
            }
            sortState.mode = currentMode;
            sortState.direction = sortState.direction === SORT_DIRECTIONS.DESC ? SORT_DIRECTIONS.ASC : SORT_DIRECTIONS.DESC;
            updateSortDirectionIndicators();
            invalidateFilteredDataCache();
            render(true);
        }

        function initializeSortDirectionButtons(context = document) {
            if (!context) return;
            context.querySelectorAll('.sort-direction-toggle').forEach(btn => {
                if (btn.dataset.listenerAttached === 'true') return;
                btn.addEventListener('click', handleSortDirectionButtonClick);
                btn.dataset.listenerAttached = 'true';
            });
        }

        function syncSortStateWithSelect(options = {}) {
            const { preserveDirection = true } = options;
            const sortControl = getPrimarySortControl();
            if (!sortControl) return;
            const currentMode = sortControl.value || 'default';
            if (sortState.mode !== currentMode) {
                sortState.mode = currentMode;
                if (!preserveDirection) {
                    sortState.direction = SORT_DIRECTIONS.DESC;
                }
            }
            updateSortDirectionIndicators();
        }

        function updateSortDirectionIndicators() {
            const sortControl = getPrimarySortControl();
            const mode = sortControl ? sortControl.value : 'default';
            const isActive = mode && mode !== 'default';
            const effectiveDirection = (sortState.mode === mode ? sortState.direction : SORT_DIRECTIONS.DESC);
            document.querySelectorAll('.sort-direction-toggle').forEach(btn => {
                if (!isActive) {
                    btn.classList.add('sort-direction-toggle--disabled');
                    btn.setAttribute('aria-disabled', 'true');
                } else {
                    btn.classList.remove('sort-direction-toggle--disabled');
                    btn.setAttribute('aria-disabled', 'false');
                }
                const up = btn.querySelector('.sort-arrow-up');
                const down = btn.querySelector('.sort-arrow-down');
                if (up) up.classList.toggle('active', isActive && effectiveDirection === SORT_DIRECTIONS.ASC);
                if (down) down.classList.toggle('active', isActive && effectiveDirection === SORT_DIRECTIONS.DESC);
            });
        }

        function updateShowChangesButtonState() {
            const buttons = document.querySelectorAll('#showChangesBtn, #shortcut-showChangesBtn');
            buttons.forEach(btn => {
                if (!btn) return;
                btn.classList.toggle('filter-toggle-active', showOnlyChanged);
                btn.textContent = showOnlyChanged ? '변경 (필터중)' : '변경';
            });
            updateShortcutActiveStates();
        }

        function toggleShowChangesFilter() {
            showOnlyChanged = !showOnlyChanged;
            updateShowChangesButtonState();
            render();
        }

        function updateShortcutActiveStates() {
            if (shortcutContainer) {
                shortcutContainer.querySelectorAll('.shortcut-item').forEach(wrapper => {
                    const controlId = wrapper.dataset.shortcutId;
                    if (!controlId) return;
                    const original = document.getElementById(controlId);
                    const isActive = isControlActive(controlId, original);
                    wrapper.classList.toggle('active-shortcut', !!isActive);
                });
            }
            refreshShortcutTooltips();
            updateHeaderShortcutHighlight();
        }

        function refreshShortcutTooltips() {
            if (!shortcutContainer) return;
            shortcutContainer.querySelectorAll('.shortcut-item').forEach(wrapper => {
                const controlId = wrapper.dataset.shortcutId;
                if (!controlId) return;
                const original = document.getElementById(controlId);
                if (!original) return;
                const tip = getShortcutTooltipText(original);
                const clone = wrapper.querySelector(`[data-shortcut-clone-id="${controlId}"]`);
                if (tip) {
                    wrapper.title = tip;
                    if (clone) clone.title = tip;
                } else {
                    wrapper.removeAttribute('title');
                    if (clone) clone.removeAttribute('title');
                }
            });
        }

        function updateHeaderShortcutHighlight() {
            const headerMappings = [
                { headerId: 'header-customer-filter-shortcut', controlId: 'customer-filter' },
                { headerId: 'header-contractor-filter-shortcut', controlId: 'contractor-filter' },
                { headerId: 'header-cost-account-filter-shortcut', controlId: 'cost-account-filter' }
            ];
            headerMappings.forEach(({ headerId, controlId }) => {
                const headerEl = document.getElementById(headerId);
                if (!headerEl) return;
                const controlEl = document.getElementById(controlId);
                const isActive = controlEl ? isControlActive(controlId, controlEl) : false;
                headerEl.classList.toggle('header-shortcut-active', !!isActive);
            });
        }
        function getShortcutTooltipText(element) {
            if (!element) return '';
            if (element.tagName === 'SELECT') {
                const option = element.options && element.options[element.selectedIndex];
                return (option && option.text && option.text.trim()) || element.value || '';
            }
            if (element.tagName === 'INPUT') {
                return element.value || element.placeholder || '';
            }
            if (element.tagName === 'BUTTON') {
                return (element.textContent || '').trim();
            }
            return element.getAttribute('title') || (element.textContent || '').trim();
        }

        function ensureControlDefaultValue(control) {
            if (!control) return;
            if (typeof control.dataset.defaultValue === 'undefined') {
                control.dataset.defaultValue = control.value ?? '';
            }
        }

        function updateGroupToggleButtons() {
            if (expandAllBtn) {
                expandAllBtn.classList.toggle('filter-toggle-active', !!shortcutState.expandAll);
            }
            if (collapseAllBtn) {
                collapseAllBtn.classList.toggle('filter-toggle-active', !!shortcutState.collapseAll);
            }
        }

        function updateZoomButtonState() {
            if (!zoomBtn) return;
            zoomBtn.classList.toggle('filter-toggle-active', isCustomZoomActive);
        }

        function isControlActive(controlId, controlElement) {
            if (!controlId || !controlElement) return false;
            if (controlElement.classList.contains('filter-toggle-active') || controlElement.classList.contains('legend-filter-active')) {
                return true;
            }
            switch (controlId) {
                case 'expandAllBtn':
                    return !!shortcutState.expandAll;
                case 'collapseAllBtn':
                    return !!shortcutState.collapseAll;
                case 'zoomBtn':
                    return isCustomZoomActive;
                case 'toggleHierarchyOrderBtn':
                    // 계층순서 버튼은 '계층순서 (하->상)' 모드일 때만 활성 상태로 표시
                    // '계층순서 (상->하)'는 기본값이므로 비활성화 상태 (깜빡임 및 테두리 표시 안 함)
                    return hierarchyOrder === 'bottom';
                case 'sortBy':
                case 'progressFilter':
                case 'taskTypeFilter':
                case 'customer-filter':
                case 'contractor-filter':
                case 'cost-account-filter':
                    const defaultValue = controlElement.dataset.defaultValue ?? (controlId === 'sortBy' ? 'default' : 'all');
                    return (controlElement.value || '').trim() !== (defaultValue || '').trim();
                case 'searchInput':
                    return !!(controlElement.value || '').trim();
                case 'showChangesBtn':
                    return showOnlyChanged;
                default:
                    return false;
            }
        }

        function attachShortcutToggleListener(button, type) {
            if (!button) return;
            if (button.__shortcutHandler) {
                button.removeEventListener('click', button.__shortcutHandler);
            }
            const handler = () => {
                if (type === 'expand') {
                    const togglingOn = !shortcutState.expandAll;
                    shortcutState.expandAll = togglingOn;
                    if (togglingOn) {
                        shortcutState.collapseAll = false;
                        toggleAllGroups(true);
                    }
                } else if (type === 'collapse') {
                    const togglingOn = !shortcutState.collapseAll;
                    shortcutState.collapseAll = togglingOn;
                    if (togglingOn) {
                        shortcutState.expandAll = false;
                        toggleAllGroups(false);
                    }
                }
                updateGroupToggleButtons();
                updateShortcutActiveStates();
            };
            button.addEventListener('click', handler);
            button.__shortcutHandler = handler;
        }

        function compareValuesWithDirection(valueA, valueB, direction = SORT_DIRECTIONS.DESC) {
            const isAscending = direction === SORT_DIRECTIONS.ASC;
            const fallback = isAscending ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
            const safeA = (typeof valueA === 'number' && !Number.isNaN(valueA)) ? valueA : fallback;
            const safeB = (typeof valueB === 'number' && !Number.isNaN(valueB)) ? valueB : fallback;
            return isAscending ? safeA - safeB : safeB - safeA;
        }

        function getProjectMetricValue(project, mode) {
            if (!project || !mode) return null;
            switch (mode) {
                case 'startDate':
                    return project.startDate instanceof Date && !isNaN(project.startDate) ? project.startDate.getTime() : null;
                case 'endDate':
                    return project.endDate instanceof Date && !isNaN(project.endDate) ? project.endDate.getTime() : null;
                case 'duration':
                    if (project.startDate instanceof Date && project.endDate instanceof Date && !isNaN(project.startDate) && !isNaN(project.endDate)) {
                        return dateDiffInDays(project.startDate, project.endDate) + 1;
                    }
                    return null;
                case 'progress':
                    return typeof project.progress === 'number' ? project.progress : (project.progress || 0);
                default:
                    return null;
            }
        }

        function createSortDirectionButton() {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'sort-direction-toggle';
            btn.dataset.sortTarget = 'sortBy';
            btn.setAttribute('aria-label', '정렬 방향 전환');
            btn.title = '정렬 방향 전환';
            btn.innerHTML = '<span class="sort-arrow sort-arrow-up" aria-hidden="true">▲</span><span class="sort-arrow sort-arrow-down" aria-hidden="true">▼</span>';
            return btn;
        }

        // --- Functions for Zoom Popover Handlers ---
        function handleZoomApply() {
            const start = zoomStartDate.value;
            const end = zoomEndDate.value;
            if (start && end) {
                const newMinDate = parseLocalDateString(start);
                const newMaxDate = parseLocalDateString(end);
                if (newMinDate > newMaxDate) {
                    showToast('시작일은 종료일보다 늦을 수 없습니다.', 'error');
                    return;
                }
                viewMinDate = newMinDate;
                viewMaxDate = newMaxDate;
                isCustomZoomActive = true;
                updateZoomButtonState();
                render();
                updateShortcutActiveStates();
                if(zoomModal) zoomModal.classList.add('hidden');
            } else {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'warning');
            }
        }

        function handleZoomReset() {
             if (minDate && maxDate) {
                viewMinDate = new Date(minDate);
                viewMaxDate = new Date(maxDate);
                isCustomZoomActive = false;
                updateZoomButtonState();
                render();
                updateShortcutActiveStates();
                if(zoomModal) zoomModal.classList.add('hidden');
                if(zoomStartDate) zoomStartDate.value = '';
                if(zoomEndDate) zoomEndDate.value = '';
                
                // 개선사항 3: 경고 상태 제거
                const zoomBtn = document.getElementById('zoomBtn');
                if (zoomBtn) {
                    zoomBtn.classList.remove('bg-yellow-200');
                }
                showToast('날짜 설정이 초기화되었습니다.', 'success');
            }
        }

        function handleZoomThreeWeeksToday() {
             const today = new Date();
            today.setHours(0, 0, 0, 0);
            const getStartOfWeek = (date) => {
                const d = new Date(date); const day = d.getDay(); const diff = d.getDate() - day;
                return new Date(d.setDate(diff));
            };
            const startOfCurrentWeek = getStartOfWeek(today);
            const startOfView = new Date(startOfCurrentWeek);
            startOfView.setDate(startOfCurrentWeek.getDate() - 7);
            const endOfView = new Date(startOfView);
            endOfView.setDate(startOfView.getDate() + 20);
            viewMinDate = startOfView; viewMaxDate = endOfView;
            isCustomZoomActive = true;
            updateZoomButtonState();
            render();
            updateShortcutActiveStates();
            if(zoomModal) zoomModal.classList.add('hidden');
        }

        function handleZoomThreeWeeksSelected() {
             const start = zoomStartDate.value;
            if (!start) {
                showToast('기간 설정에서 시작일을 먼저 선택해주세요.', 'warning');
                return;
            }
            const startDate = parseLocalDateString(start);
            // ensure local midnight
            if (startDate) startDate.setHours(0,0,0,0);
            const threeWeeksLater = startDate ? new Date(startDate) : null;
            threeWeeksLater.setDate(startDate.getDate() + 21);
            viewMinDate = startDate; viewMaxDate = threeWeeksLater;
            isCustomZoomActive = true;
            updateZoomButtonState();
            render();
            updateShortcutActiveStates();
            if(zoomModal) zoomModal.classList.add('hidden');
        }

        function applyWeekZoom(weekOffset) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const getStartOfWeek = (date) => {
                const d = new Date(date);
                const day = d.getDay();
                const diff = d.getDate() - day;
                return new Date(d.setDate(diff));
            };
            
            const startOfCurrentWeek = getStartOfWeek(today);
            const targetWeekStart = new Date(startOfCurrentWeek);
            targetWeekStart.setDate(startOfCurrentWeek.getDate() + (weekOffset * 7));
            
            const targetWeekEnd = new Date(targetWeekStart);
            targetWeekEnd.setDate(targetWeekStart.getDate() + 6);
            
            viewMinDate = targetWeekStart;
            viewMaxDate = targetWeekEnd;
            isCustomZoomActive = true;
            updateZoomButtonState();
            render();
            updateShortcutActiveStates();
            if(zoomModal) zoomModal.classList.add('hidden');
        }
        // --- End Zoom Popover Handlers ---


        fileInput.addEventListener('change', handleFileSelect, false);
        // Event listeners for controls are now attached in updateControlReferences


        // ============================================
        // 새로운 통합 모달 시스템 - 날짜 및 진척률 입력
        // ============================================
        
        // 전역 모달 관리자
        const UnifiedEditModal = {
            currentModal: null,
            scrollHandler: null,
            outsideClickHandler: null,
            
            // 모달 생성 및 표시
            show: function(editorElement, editType, project) {
                // 기존 모달이 있으면 제거
                this.close();
                
                if (!editorElement || !project) return;
                
                const projectId = String(project.id);
                const rect = editorElement.getBoundingClientRect();
                
                // 모달 컨테이너 생성
                const modal = document.createElement('div');
                modal.className = 'unified-edit-modal';
                modal.setAttribute('data-edit-type', editType);
                modal.setAttribute('data-project-id', projectId);
                
                // 스타일 설정 (인라인으로 완전히 격리)
                Object.assign(modal.style, {
                    position: 'fixed',
                    zIndex: '99999',
                    background: '#ffffff',
                    backgroundColor: '#ffffff',
                    backgroundImage: 'none',
                    opacity: '1',
                    border: '1px solid #c7d2fe',
                    boxShadow: '0 8px 18px rgba(79, 70, 229, 0.25)',
                    borderRadius: '8px',
                    padding: '12px',
                    minWidth: editType === 'progress' ? '200px' : '220px',
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '8px',
                    margin: '0',
                    boxSizing: 'border-box',
                    pointerEvents: 'auto',
                    isolation: 'isolate',
                    backdropFilter: 'none',
                    webkitBackdropFilter: 'none',
                    mixBlendMode: 'normal',
                    willChange: 'auto',
                    transform: 'none',
                    fontFamily: 'inherit'
                });
                
                // 모달 내용 생성
                let labelText = '';
                let inputHTML = '';
                let originalValueHTML = '';
                
                if (editType === 'date') {
                    const dateType = editorElement.dataset.dateType;
                    labelText = dateType === 'startDate' ? '시작일' : '종료일';
                    const dateValue = dateType === 'startDate' ? 
                        (project.startDate ? formatDateYMD(project.startDate) : '') :
                        (project.endDate ? formatDateYMD(project.endDate) : '');
                    
                    // 원본 날짜 가져오기
                    const registryKey = getProjectRegistryKey(project);
                    const originalDates = registryKey ? (originalDateRegistry.get(registryKey) || {}) : {};
                    const originalDateStr = dateType === 'startDate' ? originalDates.start : originalDates.end;
                    
                    inputHTML = `<input type="date" class="unified-modal-input" value="${dateValue}" data-date-type="${dateType}" />`;
                    if (originalDateStr) {
                        originalValueHTML = `<div class="unified-modal-original">원본: ${originalDateStr}</div>`;
                    }
                } else if (editType === 'progress') {
                    labelText = '진척률 (%)';
                    let currentProgress = project.progress || 0;
                    // 10의 배수로 정규화
                    let normalizedProgress = Math.round(currentProgress / 10) * 10;
                    // 최소값 10% 적용
                    if (normalizedProgress === 0 && currentProgress === 0) {
                        normalizedProgress = 10;
                    } else if (normalizedProgress < 10) {
                        normalizedProgress = 10;
                    }
                    
                    // 원본 진척률 가져오기
                    const registryKey = getProjectRegistryKey(project);
                    const originalProgress = registryKey ? originalProgressRegistry.get(registryKey) : null;
                    
                    inputHTML = `<input type="number" class="unified-modal-input" min="10" max="100" step="10" value="${normalizedProgress}" data-edit-type="progress" />`;
                    if (typeof originalProgress === 'number') {
                        originalValueHTML = `<div class="unified-modal-original">원본: ${originalProgress}%</div>`;
                    }
                }
                
                modal.innerHTML = `
                    <label class="unified-modal-label">${labelText}</label>
                    ${inputHTML}
                    ${originalValueHTML}
                    <div class="unified-modal-actions">
                        <button class="unified-modal-cancel">취소</button>
                        <button class="unified-modal-save">저장</button>
                    </div>
                `;
                
                // 입력 필드 스타일
                const input = modal.querySelector('.unified-modal-input');
                if (input) {
                    Object.assign(input.style, {
                        opacity: '1',
                        backgroundColor: '#f8fafc',
                        border: '1px solid #cbd5e1',
                        borderRadius: '4px',
                        padding: '6px 8px',
                        fontSize: '13px',
                        pointerEvents: 'auto',
                        backgroundImage: 'none',
                        width: '100%',
                        boxSizing: 'border-box'
                    });
                }
                
                // 레이블 스타일
                const label = modal.querySelector('.unified-modal-label');
                if (label) {
                    Object.assign(label.style, {
                        fontSize: '12px',
                        fontWeight: '600',
                        color: '#4338ca',
                        opacity: '1',
                        background: 'transparent',
                        pointerEvents: 'auto',
                        margin: '0'
                    });
                }
                
                // 원본 정보 스타일
                const originalDiv = modal.querySelector('.unified-modal-original');
                if (originalDiv) {
                    Object.assign(originalDiv.style, {
                        fontSize: '11px',
                        color: '#64748b',
                        opacity: '1',
                        background: 'transparent',
                        pointerEvents: 'auto',
                        margin: '0'
                    });
                }
                
                // 버튼 스타일
                const actions = modal.querySelector('.unified-modal-actions');
                if (actions) {
                    Object.assign(actions.style, {
                        display: 'flex',
                        gap: '6px',
                        justifyContent: 'flex-end',
                        marginTop: '4px'
                    });
                }
                
                const cancelBtn = modal.querySelector('.unified-modal-cancel');
                const saveBtn = modal.querySelector('.unified-modal-save');
                
                if (cancelBtn) {
                    Object.assign(cancelBtn.style, {
                        padding: '6px 12px',
                        fontSize: '12px',
                        backgroundColor: '#f1f5f9',
                        color: '#475569',
                        border: '1px solid #cbd5e1',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        opacity: '1',
                        pointerEvents: 'auto'
                    });
                }
                
                if (saveBtn) {
                    Object.assign(saveBtn.style, {
                        padding: '6px 12px',
                        fontSize: '12px',
                        backgroundColor: '#4338ca',
                        color: '#ffffff',
                        border: '1px solid #4338ca',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        opacity: '1',
                        pointerEvents: 'auto'
                    });
                }
                
                // body에 추가
                document.body.appendChild(modal);
                this.currentModal = modal;
                
                // 위치 계산 및 설정
                this.updatePosition(editorElement, modal);
                
                // 이벤트 리스너 설정
                this.setupEventListeners(modal, editorElement, editType, project);
                
                // 입력 필드 포커스
                setTimeout(() => {
                    if (input) input.focus();
                }, 50);
            },
            
            // 위치 업데이트
            updatePosition: function(editorElement, modal) {
                const rect = editorElement.getBoundingClientRect();
                const modalRect = modal.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                
                let top = rect.bottom + scrollY + 6;
                let left = rect.left + scrollX;
                
                const spaceBelow = viewportHeight - rect.bottom;
                const spaceAbove = rect.top;
                const modalHeight = modalRect.height || 180;
                const minSpace = 20;
                
                // 위/아래 위치 조정
                if (spaceBelow < (modalHeight + minSpace) && spaceAbove > (modalHeight + minSpace)) {
                    top = rect.top + scrollY - modalHeight - 6;
                } else if (spaceBelow < (modalHeight + minSpace)) {
                    const maxTop = scrollY + minSpace;
                    top = Math.max(maxTop, rect.top + scrollY - modalHeight - 6);
                }
                
                // 좌/우 위치 조정
                const spaceRight = viewportWidth - rect.right;
                const modalWidth = modalRect.width || 220;
                if (spaceRight < (modalWidth + minSpace)) {
                    left = Math.max(scrollX + minSpace, rect.right + scrollX - modalWidth);
                }
                
                modal.style.top = `${top}px`;
                modal.style.left = `${left}px`;
            },
            
            // 이벤트 리스너 설정
            setupEventListeners: function(modal, editorElement, editType, project) {
                const projectId = String(project.id);
                const input = modal.querySelector('.unified-modal-input');
                const cancelBtn = modal.querySelector('.unified-modal-cancel');
                const saveBtn = modal.querySelector('.unified-modal-save');
                
                // 입력 필드 이벤트 전파 차단
                if (input) {
                    const stopPropagation = (e) => {
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                    };
                    ['click', 'change', 'focus', 'blur', 'keydown', 'keyup', 'keypress', 'mousedown', 'mouseup', 'mousemove', 'input'].forEach(eventType => {
                        input.addEventListener(eventType, stopPropagation, true);
                    });
                }
                
                // 저장 버튼
                if (saveBtn) {
                    saveBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.handleSave(modal, editorElement, editType, project);
                    });
                }
                
                // 취소 버튼
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.close();
                    });
                }
                
                // Enter 키로 저장
                if (input) {
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.handleSave(modal, editorElement, editType, project);
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.close();
                        }
                    });
                    
                    // 진척률 입력 시 10의 배수로 자동 조정 (최소 10%)
                    if (editType === 'progress') {
                        input.addEventListener('input', (e) => {
                            let value = parseInt(e.target.value, 10);
                            if (!isNaN(value)) {
                                // 10의 배수로 반올림
                                value = Math.round(value / 10) * 10;
                                // 10~100 범위 제한 (최소 10%)
                                value = Math.max(10, Math.min(100, value));
                                e.target.value = value;
                            }
                        });
                        
                        input.addEventListener('blur', (e) => {
                            let value = parseInt(e.target.value, 10);
                            if (!isNaN(value)) {
                                // 10의 배수로 반올림
                                value = Math.round(value / 10) * 10;
                                // 10~100 범위 제한 (최소 10%)
                                value = Math.max(10, Math.min(100, value));
                                e.target.value = value;
                            } else {
                                // 값이 없으면 최소값 10으로 설정
                                e.target.value = 10;
                            }
                        });
                    }
                }
                
                // 스크롤 핸들러
                this.scrollHandler = () => {
                    if (modal.parentElement && editorElement.isConnected) {
                        this.updatePosition(editorElement, modal);
                    } else {
                        this.close();
                    }
                };
                window.addEventListener('scroll', this.scrollHandler, true);
                
                // 외부 클릭 핸들러
                this.outsideClickHandler = (e) => {
                    if (!modal.contains(e.target) && !editorElement.contains(e.target)) {
                        let target = e.target;
                        let isInsideEditor = false;
                        while (target && target !== document.body) {
                            if (target === editorElement || 
                                (editType === 'date' && target.closest('.date-editor') === editorElement) ||
                                (editType === 'progress' && target.closest('.progress-editor') === editorElement)) {
                                isInsideEditor = true;
                                break;
                            }
                            target = target.parentElement;
                        }
                        if (!isInsideEditor) {
                            this.close();
                        }
                    }
                };
                setTimeout(() => {
                    document.addEventListener('click', this.outsideClickHandler, true);
                }, 100);
            },
            
            // 저장 처리
            handleSave: function(modal, editorElement, editType, project) {
                const input = modal.querySelector('.unified-modal-input');
                if (!input) return;
                
                const projectId = String(project.id);
                
                // 현재 스크롤 위치 저장 (render() 전에 저장하여 상단 이동 방지)
                const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                const currentContainer = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                const savedWindowScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const savedWindowScrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                const savedContainerScrollTop = currentContainer ? currentContainer.scrollTop : 0;
                const savedContainerScrollLeft = currentContainer ? currentContainer.scrollLeft : 0;
                
                if (editType === 'date') {
                    const dateType = input.dataset.dateType;
                    const newDateStr = input.value;
                    
                    if (!newDateStr) {
                        showToast('날짜를 입력해주세요.', 'warning');
                        input.focus();
                        return;
                    }
                    
                    const newDate = parseLocalDateString(newDateStr);
                    if (!newDate || isNaN(newDate.getTime())) {
                        showToast('올바른 날짜 형식이 아닙니다.', 'error');
                        input.focus();
                        return;
                    }
                    
                    // 날짜 유효성 검사
                    if (dateType === 'startDate' && project.endDate && newDate > project.endDate) {
                        showToast('시작일은 종료일보다 늦을 수 없습니다.', 'error');
                        input.focus();
                        return;
                    }
                    if (dateType === 'endDate' && project.startDate && newDate < project.startDate) {
                        showToast('종료일은 시작일보다 빠를 수 없습니다.', 'error');
                        input.focus();
                        return;
                    }
                    
                    // 프로젝트 데이터 업데이트
                    if (dateType === 'startDate') {
                        project.startDate = newDate;
                        project.startDateStr = formatDateYMD(newDate);
                    } else {
                        project.endDate = newDate;
                        project.endDateStr = formatDateYMD(newDate);
                    }
                    
                    // 원본 날짜 레지스트리 업데이트
                    const registryKey = getProjectRegistryKey(project);
                    if (registryKey) {
                        const entry = originalDateRegistry.get(registryKey) || { start: '', end: '' };
                        if (dateType === 'startDate') {
                            if (!entry.start) entry.start = formatDateYMD(newDate);
                        } else {
                            if (!entry.end) entry.end = formatDateYMD(newDate);
                        }
                        originalDateRegistry.set(registryKey, entry);
                    }
                    
                    // window.projectData 동기화
                    if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData)) {
                        const wp = window.projectData.find(p => String(p.id) === projectId);
                        if (wp) {
                            if (dateType === 'startDate') {
                                wp.startDate = newDate;
                                wp.startDateStr = formatDateYMD(newDate);
                            } else {
                                wp.endDate = newDate;
                                wp.endDateStr = formatDateYMD(newDate);
                            }
                        }
                    }
                    
                    // 변경 이력 생성
                    if (typeof createRevisionEntry === 'function') {
                        createRevisionEntry();
                    }
                    
                    this.close();
                    
                    // 스크롤 보호 플래그 설정 (render() 호출 전에 설정하여 scrollToToday 방지)
                    if (typeof captureScrollState === 'function') {
                        pendingScrollRestore = captureScrollState(true); // skipAutoScroll = true
                    }
                    
                    // 렌더링 및 하이라이트 처리
                    setTimeout(() => {
                        render();
                        
                        // 요소 찾기 및 스크롤 함수 (지속적으로 실행)
                        const findAndScrollToElement = () => {
                            // 현재 활성화된 컨테이너 확인
                            const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                            
                            // 여러 컨테이너에서 요소 찾기 시도
                            let updatedEditor = null;
                            if (container) {
                                updatedEditor = container.querySelector(`[data-project-id="${projectId}"][data-date-type="${dateType}"]`);
                            }
                            if (!updatedEditor) {
                                updatedEditor = document.querySelector(`[data-project-id="${projectId}"][data-date-type="${dateType}"]`);
                            }
                            
                            if (updatedEditor) {
                                const registryKey = getProjectRegistryKey(project);
                                if (registryKey) {
                                    const entry = originalDateRegistry.get(registryKey);
                                    if (entry) {
                                        const originalDateStr = dateType === 'startDate' ? entry.start : entry.end;
                                        const currentDateStr = dateType === 'startDate' ? 
                                            (project.startDateStr || '') : 
                                            (project.endDateStr || '');
                                        
                                        if (originalDateStr && currentDateStr && originalDateStr !== currentDateStr) {
                                            updatedEditor.classList.add('date-changed');
                                        } else {
                                            updatedEditor.classList.remove('date-changed');
                                        }
                                    }
                                }
                                
                                // 하이라이트 클래스 추가
                                updatedEditor.classList.add('cell-updated-highlight');
                                
                                // 즉시 스크롤 (상단 이동 방지)
                                this.scrollToElement(updatedEditor, container);
                                
                                return true; // 요소를 찾았음
                            }
                            return false; // 요소를 찾지 못함
                        };
                        
                        // 스크롤 모니터링 및 보호 함수 (지속적으로 실행)
                        let scrollProtectionActive = true;
                        let scrollProtectionCount = 0;
                        const maxScrollProtectionCount = 100; // 최대 5초간 보호 (50ms * 100)
                        let lastScrollTop = savedWindowScrollTop;
                        let lastContainerScrollTop = savedContainerScrollTop;
                        let scrollProtectionInterval = null;
                        let scrollEventListener = null;
                        
                        // 즉시 스크롤 실행 함수 (여러 번 호출)
                        const forceScrollToElement = () => {
                            // 여러 번 즉시 실행하여 확실하게 스크롤
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    findAndScrollToElement();
                                }, i * 10);
                            }
                        };
                        
                        // 스크롤 이벤트 리스너 (실시간 감지)
                        scrollEventListener = () => {
                            if (!scrollProtectionActive) {
                                if (scrollEventListener) {
                                    window.removeEventListener('scroll', scrollEventListener, true);
                                    if (currentContainer) {
                                        currentContainer.removeEventListener('scroll', scrollEventListener, true);
                                    }
                                }
                                return;
                            }
                            
                            const currentWindowScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                            const currentContainerScrollTop = currentContainer ? currentContainer.scrollTop : 0;
                            
                            // 상단으로 이동했는지 확인
                            const isAtTop = currentWindowScrollTop < 10 || currentContainerScrollTop < 10;
                            const movedToTop = (savedWindowScrollTop > 50 && currentWindowScrollTop < 50) || 
                                              (savedContainerScrollTop > 50 && currentContainerScrollTop < 50);
                            const suddenMoveToTop = (lastScrollTop > 100 && currentWindowScrollTop < 50) ||
                                                   (lastContainerScrollTop > 100 && currentContainerScrollTop < 50);
                            
                            if (isAtTop || movedToTop || suddenMoveToTop) {
                                // 즉시 스크롤
                                forceScrollToElement();
                            }
                            
                            lastScrollTop = currentWindowScrollTop;
                            lastContainerScrollTop = currentContainerScrollTop;
                        };
                        
                        // 스크롤 이벤트 리스너 등록
                        window.addEventListener('scroll', scrollEventListener, true);
                        if (currentContainer) {
                            currentContainer.addEventListener('scroll', scrollEventListener, true);
                        }
                        
                        const monitorAndProtectScroll = () => {
                            if (!scrollProtectionActive || scrollProtectionCount >= maxScrollProtectionCount) {
                                scrollProtectionActive = false;
                                if (scrollProtectionInterval) {
                                    clearInterval(scrollProtectionInterval);
                                    scrollProtectionInterval = null;
                                }
                                if (scrollEventListener) {
                                    window.removeEventListener('scroll', scrollEventListener, true);
                                    if (currentContainer) {
                                        currentContainer.removeEventListener('scroll', scrollEventListener, true);
                                    }
                                }
                                return;
                            }
                            
                            scrollProtectionCount++;
                            
                            // 현재 스크롤 위치 확인
                            const currentWindowScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                            const currentContainerScrollTop = currentContainer ? currentContainer.scrollTop : 0;
                            
                            // 상단으로 이동했는지 확인
                            const isAtTop = currentWindowScrollTop < 10 || currentContainerScrollTop < 10;
                            const movedToTop = (savedWindowScrollTop > 50 && currentWindowScrollTop < 50) || 
                                              (savedContainerScrollTop > 50 && currentContainerScrollTop < 50);
                            const suddenMoveToTop = (lastScrollTop > 100 && currentWindowScrollTop < 50) ||
                                                   (lastContainerScrollTop > 100 && currentContainerScrollTop < 50);
                            
                            // 스크롤 위치 업데이트
                            lastScrollTop = currentWindowScrollTop;
                            lastContainerScrollTop = currentContainerScrollTop;
                            
                            if (isAtTop || movedToTop || suddenMoveToTop) {
                                // 즉시 스크롤
                                forceScrollToElement();
                            }
                        };
                        
                        // 즉시 요소 찾기 및 스크롤 시도
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                // 즉시 여러 번 스크롤 시도
                                forceScrollToElement();
                                
                                if (!findAndScrollToElement()) {
                                    // 요소를 찾지 못했으면 계속 시도
                                    let attempts = 0;
                                    const maxAttempts = 15;
                                    const retryFind = () => {
                                        if (findAndScrollToElement() || attempts >= maxAttempts) {
                                            // 요소를 찾았거나 최대 시도 횟수에 도달하면 모니터링 시작
                                            scrollProtectionInterval = setInterval(monitorAndProtectScroll, 50);
                                        } else {
                                            attempts++;
                                            setTimeout(retryFind, 30);
                                        }
                                    };
                                    retryFind();
                                } else {
                                    // 요소를 찾았으면 모니터링 시작 (50ms 간격으로 더 빠르게)
                                    scrollProtectionInterval = setInterval(monitorAndProtectScroll, 50);
                                }
                            });
                        });
                    }, 100);
                    
                } else if (editType === 'progress') {
                    let newProgress = parseInt(input.value, 10);
                    
                    if (isNaN(newProgress) || newProgress < 10 || newProgress > 100) {
                        showToast('10~100 사이의 숫자를 입력해주세요. (10% 단위)', 'error');
                        input.focus();
                        return;
                    }
                    
                    // 10의 배수로 정규화
                    newProgress = Math.round(newProgress / 10) * 10;
                    // 최소값 10% 적용
                    newProgress = Math.max(10, Math.min(100, newProgress));
                    
                    // 원본 진척률 레지스트리 업데이트
                    const registryKey = getProjectRegistryKey(project);
                    if (registryKey) {
                        if (!originalProgressRegistry.has(registryKey)) {
                            originalProgressRegistry.set(registryKey, newProgress);
                        }
                    }
                    
                    // 프로젝트 데이터 업데이트
                    project.progress = newProgress;
                    
                    // window.projectData 동기화
                    if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData)) {
                        const wp = window.projectData.find(p => String(p.id) === projectId);
                        if (wp) {
                            wp.progress = newProgress;
                        }
                    }
                    
                    // 변경 이력 생성
                    if (typeof createRevisionEntry === 'function') {
                        createRevisionEntry();
                    }
                    
                    this.close();
                    
                    // 스크롤 보호 플래그 설정 (render() 호출 전에 설정하여 scrollToToday 방지)
                    if (typeof captureScrollState === 'function') {
                        pendingScrollRestore = captureScrollState(true); // skipAutoScroll = true
                    }
                    
                    // 렌더링 및 하이라이트 처리
                    setTimeout(() => {
                        render();
                        
                        // 요소 찾기 및 스크롤 함수 (지속적으로 실행)
                        const findAndScrollToElement = () => {
                            // 현재 활성화된 컨테이너 확인
                            const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                            
                            // 여러 컨테이너에서 요소 찾기 시도
                            let updatedEditor = null;
                            if (container) {
                                updatedEditor = container.querySelector(`[data-project-id="${projectId}"].progress-editor`);
                            }
                            if (!updatedEditor) {
                                updatedEditor = document.querySelector(`[data-project-id="${projectId}"].progress-editor`);
                            }
                            
                            if (updatedEditor) {
                                const registryKey = getProjectRegistryKey(project);
                                if (registryKey) {
                                    const originalProgress = originalProgressRegistry.get(registryKey);
                                    const currentProgress = project.progress || 0;
                                    
                                    if (typeof originalProgress === 'number' && originalProgress !== currentProgress) {
                                        updatedEditor.classList.add('date-changed');
                                    } else {
                                        updatedEditor.classList.remove('date-changed');
                                    }
                                }
                                
                                // 하이라이트 클래스 추가
                                updatedEditor.classList.add('cell-updated-highlight');
                                
                                // 즉시 스크롤 (상단 이동 방지)
                                this.scrollToElement(updatedEditor, container);
                                
                                return true; // 요소를 찾았음
                            }
                            return false; // 요소를 찾지 못함
                        };
                        
                        // 스크롤 모니터링 및 보호 함수 (지속적으로 실행)
                        let scrollProtectionActive = true;
                        let scrollProtectionCount = 0;
                        const maxScrollProtectionCount = 100; // 최대 5초간 보호 (50ms * 100)
                        let lastScrollTop = savedWindowScrollTop;
                        let lastContainerScrollTop = savedContainerScrollTop;
                        let scrollProtectionInterval = null;
                        let scrollEventListener = null;
                        
                        // 즉시 스크롤 실행 함수 (여러 번 호출)
                        const forceScrollToElement = () => {
                            // 여러 번 즉시 실행하여 확실하게 스크롤
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    findAndScrollToElement();
                                }, i * 10);
                            }
                        };
                        
                        // 스크롤 이벤트 리스너 (실시간 감지)
                        scrollEventListener = () => {
                            if (!scrollProtectionActive) {
                                if (scrollEventListener) {
                                    window.removeEventListener('scroll', scrollEventListener, true);
                                    if (currentContainer) {
                                        currentContainer.removeEventListener('scroll', scrollEventListener, true);
                                    }
                                }
                                return;
                            }
                            
                            const currentWindowScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                            const currentContainerScrollTop = currentContainer ? currentContainer.scrollTop : 0;
                            
                            // 상단으로 이동했는지 확인
                            const isAtTop = currentWindowScrollTop < 10 || currentContainerScrollTop < 10;
                            const movedToTop = (savedWindowScrollTop > 50 && currentWindowScrollTop < 50) || 
                                              (savedContainerScrollTop > 50 && currentContainerScrollTop < 50);
                            const suddenMoveToTop = (lastScrollTop > 100 && currentWindowScrollTop < 50) ||
                                                   (lastContainerScrollTop > 100 && currentContainerScrollTop < 50);
                            
                            if (isAtTop || movedToTop || suddenMoveToTop) {
                                // 즉시 스크롤
                                forceScrollToElement();
                            }
                            
                            lastScrollTop = currentWindowScrollTop;
                            lastContainerScrollTop = currentContainerScrollTop;
                        };
                        
                        // 스크롤 이벤트 리스너 등록
                        window.addEventListener('scroll', scrollEventListener, true);
                        if (currentContainer) {
                            currentContainer.addEventListener('scroll', scrollEventListener, true);
                        }
                        
                        const monitorAndProtectScroll = () => {
                            if (!scrollProtectionActive || scrollProtectionCount >= maxScrollProtectionCount) {
                                scrollProtectionActive = false;
                                if (scrollProtectionInterval) {
                                    clearInterval(scrollProtectionInterval);
                                    scrollProtectionInterval = null;
                                }
                                if (scrollEventListener) {
                                    window.removeEventListener('scroll', scrollEventListener, true);
                                    if (currentContainer) {
                                        currentContainer.removeEventListener('scroll', scrollEventListener, true);
                                    }
                                }
                                return;
                            }
                            
                            scrollProtectionCount++;
                            
                            // 현재 스크롤 위치 확인
                            const currentWindowScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                            const currentContainerScrollTop = currentContainer ? currentContainer.scrollTop : 0;
                            
                            // 상단으로 이동했는지 확인
                            const isAtTop = currentWindowScrollTop < 10 || currentContainerScrollTop < 10;
                            const movedToTop = (savedWindowScrollTop > 50 && currentWindowScrollTop < 50) || 
                                              (savedContainerScrollTop > 50 && currentContainerScrollTop < 50);
                            const suddenMoveToTop = (lastScrollTop > 100 && currentWindowScrollTop < 50) ||
                                                   (lastContainerScrollTop > 100 && currentContainerScrollTop < 50);
                            
                            // 스크롤 위치 업데이트
                            lastScrollTop = currentWindowScrollTop;
                            lastContainerScrollTop = currentContainerScrollTop;
                            
                            if (isAtTop || movedToTop || suddenMoveToTop) {
                                // 즉시 스크롤
                                forceScrollToElement();
                            }
                        };
                        
                        // 즉시 요소 찾기 및 스크롤 시도
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                // 즉시 여러 번 스크롤 시도
                                forceScrollToElement();
                                
                                if (!findAndScrollToElement()) {
                                    // 요소를 찾지 못했으면 계속 시도
                                    let attempts = 0;
                                    const maxAttempts = 15;
                                    const retryFind = () => {
                                        if (findAndScrollToElement() || attempts >= maxAttempts) {
                                            // 요소를 찾았거나 최대 시도 횟수에 도달하면 모니터링 시작
                                            scrollProtectionInterval = setInterval(monitorAndProtectScroll, 50);
                                        } else {
                                            attempts++;
                                            setTimeout(retryFind, 30);
                                        }
                                    };
                                    retryFind();
                                } else {
                                    // 요소를 찾았으면 모니터링 시작 (50ms 간격으로 더 빠르게)
                                    scrollProtectionInterval = setInterval(monitorAndProtectScroll, 50);
                                }
                            });
                        });
                    }, 100);
                }
            },
            
            // 요소로 즉시 스크롤 (상단 이동 방지) - 여러 번 실행하여 확실하게
            scrollToElement: function(element, container) {
                if (!element) return;
                
                // 여러 번 즉시 실행하여 확실하게 스크롤
                const performScroll = () => {
                    // 요소가 여전히 DOM에 있는지 확인
                    let targetElement = element;
                    if (!targetElement.isConnected) {
                        const projectId = element.dataset.projectId;
                        const dateType = element.dataset.dateType;
                        let foundElement = null;
                        
                        const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                        const activeContainer = container || (isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent'));
                        
                        if (activeContainer) {
                            if (dateType) {
                                foundElement = activeContainer.querySelector(`[data-project-id="${projectId}"][data-date-type="${dateType}"]`);
                            } else {
                                foundElement = activeContainer.querySelector(`[data-project-id="${projectId}"].progress-editor`);
                            }
                        }
                        
                        if (!foundElement) {
                            if (dateType) {
                                foundElement = document.querySelector(`[data-project-id="${projectId}"][data-date-type="${dateType}"]`);
                            } else {
                                foundElement = document.querySelector(`[data-project-id="${projectId}"].progress-editor`);
                            }
                        }
                        
                        if (!foundElement) return;
                        targetElement = foundElement;
                    }
                    
                    const rect = targetElement.getBoundingClientRect();
                    
                    // 요소가 제대로 렌더링되지 않았으면 재시도
                    if (rect.width === 0 && rect.height === 0) {
                        return;
                    }
                    
                    const elementHeight = rect.height || 30;
                    const elementWidth = rect.width || 100;
                    
                    const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                    const scrollContainer = container || (isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : null);
                    
                    if (scrollContainer && scrollContainer !== document.body) {
                        const containerRect = scrollContainer.getBoundingClientRect();
                        const containerScrollTop = scrollContainer.scrollTop;
                        const containerScrollLeft = scrollContainer.scrollLeft;
                        
                        const elementTopInContainer = rect.top - containerRect.top + containerScrollTop;
                        const elementLeftInContainer = rect.left - containerRect.left + containerScrollLeft;
                        
                        const containerHeight = scrollContainer.clientHeight;
                        const containerWidth = scrollContainer.clientWidth;
                        
                        const targetScrollTop = elementTopInContainer - (containerHeight / 2) + (elementHeight / 2);
                        const targetScrollLeft = elementLeftInContainer - (containerWidth / 2) + (elementWidth / 2);
                        
                        scrollContainer.scrollTo({
                            top: Math.max(0, targetScrollTop),
                            left: Math.max(0, targetScrollLeft),
                            behavior: 'auto' // 즉시 스크롤
                        });
                    } else {
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                        const viewportHeight = window.innerHeight;
                        const viewportWidth = window.innerWidth;
                        
                        const elementTop = rect.top + scrollTop;
                        const elementLeft = rect.left + scrollLeft;
                        
                        const targetScrollTop = elementTop - (viewportHeight / 2) + (elementHeight / 2);
                        const targetScrollLeft = elementLeft - (viewportWidth / 2) + (elementWidth / 2);
                        
                        window.scrollTo({
                            top: Math.max(0, targetScrollTop),
                            left: Math.max(0, targetScrollLeft),
                            behavior: 'auto' // 즉시 스크롤
                        });
                    }
                };
                
                // 즉시 실행
                performScroll();
                
                // requestAnimationFrame으로 여러 번 실행
                requestAnimationFrame(() => {
                    performScroll();
                    requestAnimationFrame(() => {
                        performScroll();
                        requestAnimationFrame(() => {
                            performScroll();
                        });
                    });
                });
            },
            
            // 하이라이트 및 스크롤 처리
            highlightAndScroll: function(element, container) {
                if (!element) return;
                
                // 하이라이트 클래스 추가
                element.classList.add('cell-updated-highlight');
                
                // 즉시 스크롤 (상단 이동 방지)
                this.scrollToElement(element, container);
                
                // 2초 후 하이라이트 제거
                setTimeout(() => {
                    if (element && element.isConnected) {
                        element.classList.remove('cell-updated-highlight');
                    }
                }, 2000);
            },
            
            // 모달 닫기
            close: function() {
                if (this.scrollHandler) {
                    window.removeEventListener('scroll', this.scrollHandler, true);
                    this.scrollHandler = null;
                }
                
                if (this.outsideClickHandler) {
                    document.removeEventListener('click', this.outsideClickHandler, true);
                    this.outsideClickHandler = null;
                }
                
                if (this.currentModal && this.currentModal.parentElement) {
                    this.currentModal.remove();
                }
                this.currentModal = null;
            }
        };
        
        // 날짜 편집 핸들러 (새로운 통합 모달 사용)
        function handleDateEditClick(dateEditor) {
            if (!dateEditor) return;
            
            const projectId = dateEditor.dataset.projectId;
            const dateType = dateEditor.dataset.dateType;
            
            if (!projectId || !dateType) return;
            
            const project = projectData.find(p => String(p.id) === String(projectId));
            if (!project) return;
            
            // 원본 날짜 기록
            recordOriginalDates(project);
            
            UnifiedEditModal.show(dateEditor, 'date', project);
        }
        
        // 진척률 편집 핸들러 (새로운 통합 모달 사용)
        function handleProgressEditClick(progressEditor) {
            if (!progressEditor) return;
            
            const projectId = progressEditor.dataset.projectId;
            if (!projectId) return;
            
            const project = projectData.find(p => String(p.id) === String(projectId));
            if (!project) return;
            
            // 원본 진척률 기록
            recordOriginalDates(project);
            
            UnifiedEditModal.show(progressEditor, 'progress', project);
        }

        function globalClickListener(e) {
            // 통합 모달 내부 클릭 시 처리하지 않음
            if (e.target.closest('.unified-edit-modal')) {
                return;
            }
            
            const toggleBtn = e.target.closest('.toggle-col-btn');
            const dateEditor = e.target.closest('.date-editor');
            const progressEditor = e.target.closest('.progress-editor');

            // 날짜 설정 모달 숨기기 로직 (배경 클릭 시)
            if (zoomModal && !zoomModal.classList.contains('hidden') && e.target === zoomModal && !e.target.closest('.modal-content')) {
                zoomModal.classList.add('hidden');
            }

            if (toggleBtn) {
                e.stopPropagation();
                handleColumnToggle(toggleBtn);
            }
            else if (dateEditor && !dateEditor.closest('.group-header')) {
                e.stopPropagation();
                handleDateEditClick(dateEditor);
            }
            else if (progressEditor) {
                e.stopPropagation();
                handleProgressEditClick(progressEditor);
            }
        }

        function globalMousedownListener(e) {
            if (e.target.classList.contains('resizer')) handleResizeMousedown(e);
            if (e.target.classList.contains('col-resizer')) handleColResizeMousedown(e);
        }

        // Attach listeners once to the body, they will work even when elements move
        document.body.addEventListener('click', globalClickListener);
        document.body.addEventListener('mousedown', globalMousedownListener);

        // 모달 닫기 함수 정의
        function closeDetailModal() {
            dataDetailModal.classList.add('hidden');
            // 모달 스타일 초기화
            dataDetailModal.style.display = '';
            dataDetailModal.style.justifyContent = '';
            dataDetailModal.style.alignItems = '';
            
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.position = '';
                modalContent.style.width = '';
                modalContent.style.maxWidth = '';
                modalContent.style.height = '';
                modalContent.style.maxHeight = '';
                modalContent.style.margin = '';
                modalContent.style.transform = '';
                modalContent.style.top = '';
                modalContent.style.left = '';
                modalContent.style.overflow = '';
            }
            
            // 스크롤바 위치 초기화
            if (dataDetailTableContainer) {
                dataDetailTableContainer.scrollTop = 0;
                dataDetailTableContainer.style.maxHeight = '';
            }
        }

        // 모달 닫기 버튼 이벤트
        closeDataDetailModalBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeDetailModal();
        });

        // ESC 키로 모달 닫기
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !dataDetailModal.classList.contains('hidden')) {
                closeDetailModal();
            }
        });

        // Date Settings Modal close button
        closeZoomModalBtn.addEventListener('click', () => {
            if (zoomModal) zoomModal.classList.add('hidden');
        });
        // Close modal on background click
        zoomModal.addEventListener('click', (e) => {
            if (e.target === zoomModal) {
                zoomModal.classList.add('hidden');
            }
        });
        // ESC key to close modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && zoomModal && !zoomModal.classList.contains('hidden')) {
                zoomModal.classList.add('hidden');
            }
        });

        fullscreenBtn.addEventListener('click', openFullscreenModal);
        closeFullscreenModalBtn.addEventListener('click', closeFullscreenModal);

        milestoneBtn.addEventListener('click', (e) => { // 개선 사항 1: 마일스톤 버튼 클릭 로직 개선
            e.stopPropagation(); // 아코디언 헤더의 클릭 이벤트가 바로 실행되는 것을 방지

            const projectViewAccordion = document.getElementById('projectView');
            const isAccordionOpen = projectViewAccordion.classList.contains('open');

            // 아코디언이 닫혀 있으면, 먼저 열어줍니다.
            if (!isAccordionOpen) {
                const accordionHeader = projectViewAccordion.querySelector('.accordion-header');
                if (accordionHeader) {
                    // 메인 아코디언 로직을 트리거하여 간트 뷰로 전환합니다.
                    accordionHeader.click();
                }
            }

            // 마일스톤 모달을 렌더링하고 표시합니다.
            renderMilestoneModal();
            milestoneModal.classList.remove('hidden');

            // 아코디언이 열리는 애니메이션 시간을 고려하여,
            // 잠시 후 간트 차트를 다시 렌더링하여 스크롤 기능의 안정성을 보장합니다.
            setTimeout(() => render(), 350);
        });
        closeMilestoneModalBtn.addEventListener('click', () => milestoneModal.classList.add('hidden'));
        // 배경 클릭으로 인한 닫기 기능 제거 (milestoneModal click 이벤트 제거)
        addMilestoneForm.addEventListener('submit', handleAddMilestone);
        milestoneList.addEventListener('click', (e) => {
            // 개선 사항 1: 마일스톤 이동 기능과 삭제 기능을 분리하여 처리
            if (e.target.closest('.delete-milestone-btn')) handleMilestoneDelete(e);
            else if (e.target.closest('.milestone-nav-item')) handleMilestoneNavigate(e);
        });

        closeMappingModalBtn.addEventListener('click', () => mappingModal.classList.add('hidden'));
        cancelMappingBtn.addEventListener('click', () => mappingModal.classList.add('hidden'));
        applyMappingBtn.addEventListener('click', applyMapping);
        mappingHeaderRowCount.addEventListener('change', () => {
            if (rawImportData && rawImportData.length > 0) {
                openMappingModal(rawImportData);
            }
            // 저장 설정이 체크되어 있으면 저장
            if (saveMappingHeaderSettings && saveMappingHeaderSettings.checked && mappingHeaderRowCount && mappingHeaderRowCountNumber) {
                const savedSettings = loadHeaderRowSettings() || {};
                savedSettings.mappingPanel = {
                    saveEnabled: true,
                    headerRowCount: mappingHeaderRowCount.value,
                    headerRowCountNumber: mappingHeaderRowCountNumber.value
                };
                saveHeaderRowSettings(savedSettings);
            }
        });
        mappingHeaderRowCountNumber.addEventListener('change', () => {
            if (rawImportData && rawImportData.length > 0) {
                openMappingModal(rawImportData);
            }
            // 저장 설정이 체크되어 있으면 저장
            if (saveMappingHeaderSettings && saveMappingHeaderSettings.checked && mappingHeaderRowCount && mappingHeaderRowCountNumber) {
                const savedSettings = loadHeaderRowSettings() || {};
                savedSettings.mappingPanel = {
                    saveEnabled: true,
                    headerRowCount: mappingHeaderRowCount.value,
                    headerRowCountNumber: mappingHeaderRowCountNumber.value
                };
                saveHeaderRowSettings(savedSettings);
            }
        });
        
        // 데이터 매핑 및 미리보기 패널 체크박스 변경 이벤트 처리
        if (saveMappingHeaderSettings) {
            saveMappingHeaderSettings.addEventListener('change', (e) => {
                if (e.target.checked && mappingHeaderRowCount && mappingHeaderRowCountNumber) {
                    // 체크되면 현재 값을 저장
                    const savedSettings = loadHeaderRowSettings() || {};
                    savedSettings.mappingPanel = {
                        saveEnabled: true,
                        headerRowCount: mappingHeaderRowCount.value,
                        headerRowCountNumber: mappingHeaderRowCountNumber.value
                    };
                    saveHeaderRowSettings(savedSettings);
                } else {
                    // 체크 해제되면 저장된 설정 제거
                    const savedSettings = loadHeaderRowSettings() || {};
                    if (savedSettings.mappingPanel) {
                        delete savedSettings.mappingPanel;
                        saveHeaderRowSettings(savedSettings);
                    }
                }
            });
        }
        
        // 데이터 관리 패널 체크박스 및 입력 필드 변경 이벤트 처리
        if (saveDataPanelHeaderSettings && headerRowCountInput) {
            headerRowCountInput.addEventListener('change', () => {
                // 저장 설정이 체크되어 있으면 저장
                if (saveDataPanelHeaderSettings.checked) {
                    const savedSettings = loadHeaderRowSettings() || {};
                    savedSettings.dataPanel = {
                        saveEnabled: true,
                        headerRowCount: headerRowCountInput.value
                    };
                    saveHeaderRowSettings(savedSettings);
                }
            });
            
            saveDataPanelHeaderSettings.addEventListener('change', (e) => {
                if (e.target.checked) {
                    // 체크되면 현재 값을 저장
                    const savedSettings = loadHeaderRowSettings() || {};
                    savedSettings.dataPanel = {
                        saveEnabled: true,
                        headerRowCount: headerRowCountInput.value
                    };
                    saveHeaderRowSettings(savedSettings);
                } else {
                    // 체크 해제되면 저장된 설정 제거
                    const savedSettings = loadHeaderRowSettings() || {};
                    if (savedSettings.dataPanel) {
                        delete savedSettings.dataPanel;
                        saveHeaderRowSettings(savedSettings);
                    }
                }
            });
        }

        closeErrorCorrectionModalBtn.addEventListener('click', () => errorCorrectionModal.classList.add('hidden'));
        discardErrorsBtn.addEventListener('click', () => errorCorrectionModal.classList.add('hidden'));
        retryImportBtn.addEventListener('click', handleRetryImport);

        const holidays = new Set([]);

        function isHoliday(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return holidays.has(`${yyyy}-${mm}-${dd}`);
        }

        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toast-container');
            if (!container) {
                const newContainer = document.createElement('div');
                newContainer.id = 'toast-container';
                document.body.appendChild(newContainer);
            }
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type} flex items-center gap-2`;
            
            // Add appropriate icon based on type
            let icon = '';
            switch(type) {
                case 'success':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>';
                    break;
                case 'error':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/></svg>';
                    break;
                case 'warning':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/></svg>';
                    break;
                default:
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>';
            }
            
            toast.innerHTML = `${icon}<span>${message}</span>`;
            document.getElementById('toast-container').appendChild(toast);

            requestAnimationFrame(() => toast.classList.add('show'));

            const timer = setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);

            // 호버 시 타이머 일시 중지
            toast.addEventListener('mouseenter', () => clearTimeout(timer));
            toast.addEventListener('mouseleave', () => {
                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => toast.remove());
                }, duration / 2);
            });
        }

        // --- Online/Offline Detection and Management ---
        let isOnline = navigator.onLine;
        let networkStatusElement = null;
        let networkStatusText = null;

        function updateNetworkStatus(online) {
            isOnline = online;
            if (!networkStatusElement) {
                networkStatusElement = document.getElementById('network-status');
                networkStatusText = document.getElementById('network-status-text');
            }
            if (networkStatusElement && networkStatusText) {
                if (online) {
                    networkStatusElement.className = 'online';
                    networkStatusText.textContent = '온라인';
                    showToast('인터넷 연결이 복구되었습니다.', 'success', 3000);
                } else {
                    networkStatusElement.className = 'offline';
                    networkStatusText.textContent = '오프라인';
                    showToast('인터넷 연결이 끊어졌습니다. 오프라인 모드로 전환됩니다.', 'warning', 5000);
                }
            }
        }

        // Check network status on page load
        function checkNetworkStatus() {
            // navigator.onLine은 신뢰할 수 없으므로 실제 네트워크 요청으로 확인
            if (navigator.onLine) {
                // 실제 연결 확인을 위한 가벼운 요청 시도
                fetch('https://www.google.com/favicon.ico', { 
                    method: 'HEAD', 
                    mode: 'no-cors',
                    cache: 'no-cache'
                }).then(() => {
                    updateNetworkStatus(true);
                }).catch(() => {
                    updateNetworkStatus(false);
                });
            } else {
                updateNetworkStatus(false);
            }
        }

        // Listen for online/offline events
        window.addEventListener('online', () => {
            checkNetworkStatus();
        });

        window.addEventListener('offline', () => {
            updateNetworkStatus(false);
        });

        // Initial check
        if (typeof document !== 'undefined') {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    setTimeout(checkNetworkStatus, 500);
                });
            } else {
                setTimeout(checkNetworkStatus, 500);
            }
        }

        // Wrapper for fetch to handle offline mode
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            // Check if we're actually online before attempting fetch
            if (!isOnline && args[0] && typeof args[0] === 'string' && (args[0].startsWith('http://') || args[0].startsWith('https://'))) {
                // For external URLs, check if we're offline
                if (!navigator.onLine) {
                    throw new Error('오프라인 상태입니다. 네트워크 연결을 확인해주세요.');
                }
                // Try to verify connection with a quick check
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 3000);
                    await originalFetch('https://www.google.com/favicon.ico', { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        cache: 'no-cache',
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    isOnline = true;
                    updateNetworkStatus(true);
                } catch (e) {
                    isOnline = false;
                    updateNetworkStatus(false);
                    throw new Error('오프라인 상태입니다. 네트워크 연결을 확인해주세요.');
                }
            }
            try {
                const response = await originalFetch.apply(this, args);
                // If fetch succeeds, we're online
                if (isOnline !== true) {
                    isOnline = true;
                    updateNetworkStatus(true);
                }
                return response;
            } catch (error) {
                // If fetch fails, check if it's a network error
                if (error.name === 'TypeError' && (error.message.includes('fetch') || error.message.includes('Failed to fetch'))) {
                    isOnline = false;
                    updateNetworkStatus(false);
                }
                throw error;
            }
        };

        function formatDate(date) {
            if (!(date instanceof Date) || isNaN(date)) return '';
            const year = date.getFullYear().toString().slice(-2);
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Full YYYY-MM-DD local format (avoids timezone-to-UTC issues from toISOString)
        function formatDateYMD(date) {
            if (!(date instanceof Date) || isNaN(date)) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            // 날짜를 YYYY-MM-DD 형식으로만 반환
            return `${year}-${month}-${day}`;
        }

        function normalizeDateInput(value) {
            if (value instanceof Date && !isNaN(value)) {
                return formatDateYMD(value);
            }
            if (value === null || value === undefined) return '';
            const str = String(value).trim();
            if (!str) return '';
            const normalizedSeparators = str.replace(/[년월일.\/\-]/g, '-').replace(/\s+/g, '-');
            const fullYearMatch = normalizedSeparators.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
            if (fullYearMatch) {
                const [, y, m, d] = fullYearMatch;
                return `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
            }
            const twoDigitMatch = normalizedSeparators.match(/^(\d{2})-(\d{1,2})-(\d{1,2})$/);
            if (twoDigitMatch) {
                const [, yy, m, d] = twoDigitMatch;
                const year = (parseInt(yy, 10) >= 70 ? 1900 : 2000) + parseInt(yy, 10);
                return `${year}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
            }
            const compactMatch = str.match(/^(\d{2,4})(\d{2})(\d{2})$/);
            if (compactMatch) {
                let [, y, m, d] = compactMatch;
                if (y.length === 2) {
                    const yearNum = parseInt(y, 10);
                    y = ((yearNum >= 70 ? 1900 : 2000) + yearNum).toString();
                }
                return `${y}-${m}-${d}`;
            }
            const parsed = new Date(str);
            if (!isNaN(parsed)) {
                return formatDateYMD(parsed);
            }
            return str;
        }

        function getNormalizedProjectDateString(project, dateKey) {
            if (!project) return '';
            const dateValue = project[dateKey];
            if (dateValue instanceof Date && !isNaN(dateValue)) {
                return formatDateYMD(dateValue);
            }
            const stringKey = `${dateKey}Str`;
            if (project[stringKey]) {
                const normalized = normalizeDateInput(project[stringKey]);
                project[stringKey] = normalized;
                return normalized;
            }
            return '';
        }

        function escapeAttribute(value) {
            if (value === null || value === undefined) return '';
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function getProjectRegistryKey(project, fallbackId = '', fallbackName = '') {
            if (project?.__registryKey) return project.__registryKey;
            if (!project && !fallbackId && !fallbackName) return '';
            let idSource = (project && typeof project.id !== 'undefined' && project.id !== null && project.id !== '') ? project.id : fallbackId;
            if (idSource === undefined || idSource === null || idSource === '') {
                idSource = fallbackName ? `name:${fallbackName}` : `auto:${projectRegistrySequence}`;
            }
            if (idSource === '') return '';
            const idPart = String(idSource);
            const nameSource = project?.name ?? fallbackName ?? '';
            const namePart = nameSource ? `__${String(nameSource).trim()}` : '';
            const key = `${idPart}${namePart}__seq${projectRegistrySequence++}`;
            if (project) {
                project.__registryKey = key;
            }
            return key;
        }

        function ensureProjectHasStableId(project, fallbackId = '', fallbackName = '') {
            if (!project) return '';
            const existingId = project.id;
            if (existingId !== undefined && existingId !== null && String(existingId).trim() !== '') {
                return existingId;
            }
            const generatedId = getProjectRegistryKey(project, fallbackId, fallbackName || project.name || '');
            if (generatedId) {
                project.id = generatedId;
                return generatedId;
            }
            return '';
        }

        function recordOriginalDates(project) {
            if (!project || typeof project.id === 'undefined' || project === null) return;
            const uniqueKey = getProjectRegistryKey(project);
            if (!uniqueKey) return;
            if (!originalDateRegistry.has(uniqueKey)) {
                originalDateRegistry.set(uniqueKey, {
                    start: getNormalizedProjectDateString(project, 'startDate'),
                    end: getNormalizedProjectDateString(project, 'endDate')
                });
                originalProgressRegistry.set(uniqueKey, typeof project.progress === 'number' ? project.progress : (project.progress || 0));
            }
        }

        // 개선 사항: 데이터 로드 시 원본 날짜를 현재 날짜로 강제 재설정하는 함수
        function ensureProjectDateField(project, dateKey) {
            if (!project) return;
            const stringKey = `${dateKey}Str`;
            const currentDate = project[dateKey];
            let normalizedString = '';
            if (currentDate instanceof Date && !isNaN(currentDate)) {
                normalizedString = formatDateYMD(new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate()));
            } else if (project[stringKey]) {
                normalizedString = normalizeDateInput(project[stringKey]);
            } else if (typeof currentDate === 'string' && currentDate.trim()) {
                normalizedString = normalizeDateInput(currentDate);
            }
            if (normalizedString) {
                project[stringKey] = normalizedString;
                project[dateKey] = parseLocalDateString(normalizedString);
            } else {
                project[stringKey] = '';
                project[dateKey] = null;
            }
        }

        function normalizeAllProjectDates(projects) {
            if (!Array.isArray(projects)) return;
            projects.forEach(project => {
                ensureProjectDateField(project, 'startDate');
                ensureProjectDateField(project, 'endDate');
            });
        }

        function resetOriginalDatesForProjects(projects) {
            if (!Array.isArray(projects)) return;
            projects.forEach((project, index) => {
                if (!project || typeof project.id === 'undefined' || project === null) return;
                
                const uniqueKey = getProjectRegistryKey(project, project.id ?? index, project.name ?? `project_${index}`);
                if (!uniqueKey) return;
                if (originalDateRegistry.has(uniqueKey)) return;
                
                const startDateStr = getNormalizedProjectDateString(project, 'startDate');
                const endDateStr = getNormalizedProjectDateString(project, 'endDate');
                
                originalDateRegistry.set(uniqueKey, {
                    start: startDateStr,
                    end: endDateStr
                });
                originalProgressRegistry.set(uniqueKey, typeof project.progress === 'number' ? project.progress : (project.progress || 0));
            });
        }

        function rebaselineOriginalDates(skipRender = true, showToastMessage = false) {
            originalDateRegistry.clear();
            normalizeAllProjectDates(projectData);
            resetOriginalDatesForProjects(projectData);
            if (!skipRender) {
                render();
            }
            if (showToastMessage) {
                showToast('모든 작업의 날짜 변경 표시가 초기화되었습니다.', 'success');
            }
        }

        function getOriginalProgress(project) {
            if (!project || typeof project.id === 'undefined') return '';
            const uniqueKey = getProjectRegistryKey(project);
            if (!uniqueKey) return '';
            const v = originalProgressRegistry.get(uniqueKey);
            return (typeof v === 'number') ? v : '';
        }

        function projectHasChanges(project) {
            if (!project) return false;
            const startCurrent = getNormalizedProjectDateString(project, 'startDate');
            const endCurrent = getNormalizedProjectDateString(project, 'endDate');
            const originalStart = getOriginalDateValue(project, 'startDate');
            const originalEnd = getOriginalDateValue(project, 'endDate');
            const currentProgress = typeof project.progress === 'number' ? project.progress : (project.progress || 0);
            const originalProgress = getOriginalProgress(project);

            const startChanged = originalStart && startCurrent && originalStart !== startCurrent;
            const endChanged = originalEnd && endCurrent && originalEnd !== endCurrent;
            const progressChanged = typeof originalProgress === 'number' && originalProgress !== currentProgress;

            return !!(startChanged || endChanged || progressChanged);
        }

        function ensureOriginalDatesForProjects(projects) {
            if (!Array.isArray(projects)) return;
            projects.forEach(recordOriginalDates);
        }

        function getOriginalDateValue(project, dateType) {
            if (!project || typeof project.id === 'undefined' || dateType === undefined) return '';
            const uniqueKey = getProjectRegistryKey(project);
            if (!uniqueKey) return '';
            const entry = originalDateRegistry.get(uniqueKey);
            if (!entry) return '';
            const raw = dateType === 'startDate' ? entry.start : entry.end;
            return normalizeDateInput(raw);
        }

        function isProjectDateChanged(project, dateType) {
            if (!project || typeof project.id === 'undefined') return false;
            const originalValue = getOriginalDateValue(project, dateType);
            if (!originalValue) return false;
            const currentDateRaw = project[dateType] instanceof Date && !isNaN(project[dateType])
                ? formatDateYMD(project[dateType])
                : (project[`${dateType}Str`] || '');
            const currentValue = normalizeDateInput(currentDateRaw);
            if (!currentValue && !originalValue) return false;
            
            return currentValue !== originalValue;
        }

        function captureScrollState(skipAutoScroll = false) {
            const state = { skipAutoScroll };
            const containerCandidate = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (containerCandidate) {
                state.containerId = containerCandidate.id || (containerCandidate === fullscreenModalBody ? 'fullscreenModalBody' : null);
                state.scrollTop = containerCandidate.scrollTop;
                const timeline = containerCandidate.querySelector('.gantt-timeline-body-wrapper');
                if (timeline) {
                    state.timelineScrollLeft = timeline.scrollLeft;
                    state.timelineScrollTop = timeline.scrollTop;
                }
            }
            if (typeof window !== 'undefined') {
                state.windowScrollX = window.scrollX;
                state.windowScrollY = window.scrollY;
            }
            return state;
        }

        function restoreScrollState() {
            if (!pendingScrollRestore) return;
            const { containerId, scrollTop, timelineScrollLeft, timelineScrollTop, windowScrollX, windowScrollY } = pendingScrollRestore;
            let container = null;
            if (containerId) {
                if (containerId === 'fullscreenModalBody') {
                    container = fullscreenModalBody;
                } else {
                    container = document.getElementById(containerId);
                }
            }
            if (!container) {
                container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            }
            if (container && typeof scrollTop === 'number') {
                container.scrollTop = scrollTop;
            }
            if (container) {
                const timeline = container.querySelector('.gantt-timeline-body-wrapper');
                if (timeline) {
                    if (typeof timelineScrollLeft === 'number') timeline.scrollLeft = timelineScrollLeft;
                    if (typeof timelineScrollTop === 'number') timeline.scrollTop = timelineScrollTop;
                }
            }
            if (typeof window !== 'undefined') {
                const targetX = typeof windowScrollX === 'number' ? windowScrollX : window.scrollX;
                const targetY = typeof windowScrollY === 'number' ? windowScrollY : window.scrollY;
                window.scrollTo(targetX, targetY);
            }
            pendingScrollRestore = null;
        }

        function getExportCustomFieldDescriptors() {
            const descriptors = [];
            if (customFieldDisplayNames && typeof customFieldDisplayNames === 'object') {
                Object.keys(customFieldDisplayNames).forEach(key => {
                    if (!key) return;
                    descriptors.push({
                        key,
                        label: customFieldDisplayNames[key] || key
                    });
                });
            }
            return descriptors.sort((a, b) => a.label.localeCompare(b.label, 'ko-KR'));
        }

        function buildProjectExportRows() {
            ensureOriginalDatesForProjects(projectData);

            const rows = [];
            const customDescriptors = getExportCustomFieldDescriptors();
            let changedProjectCount = 0;

            const headerLabels = [
                'No.',
                '프로젝트 ID',
                '프로젝트 명',
                '작업 유형',
                '상태',
                '시작일(현재)',
                '시작일(원본)',
                '종료일(현재)',
                '종료일(원본)',
                '날짜 변경 여부',
                '변경 상세',
                '기간(일)',
                '정산 금액',
                '진행률(%)'
            ];

            customDescriptors.forEach(desc => headerLabels.push(desc.label));

            headerLabels.push('비고');

            projectData.forEach((project, index) => {
                const startCurrent = project.startDate instanceof Date && !isNaN(project.startDate) ? formatDateYMD(project.startDate) : (project.startDateStr || '');
                const endCurrent = project.endDate instanceof Date && !isNaN(project.endDate) ? formatDateYMD(project.endDate) : (project.endDateStr || '');

                const registryKey = getProjectRegistryKey(project);
                const originalDates = registryKey ? (originalDateRegistry.get(registryKey) || {}) : {};
                const startOriginal = originalDates.start || startCurrent;
                const endOriginal = originalDates.end || endCurrent;

                const changeDetails = [];
                const changedStart = startOriginal && startCurrent && startOriginal !== startCurrent;
                const changedEnd = endOriginal && endCurrent && endOriginal !== endCurrent;

                if (changedStart) {
                    changeDetails.push(`시작일: ${startOriginal} → ${startCurrent}`);
                }
                if (changedEnd) {
                    changeDetails.push(`종료일: ${endOriginal} → ${endCurrent}`);
                }

                const hasDateChange = changeDetails.length > 0;
                if (hasDateChange) changedProjectCount += 1;

                const durationDays = (project.startDate instanceof Date && project.endDate instanceof Date && !isNaN(project.startDate) && !isNaN(project.endDate))
                    ? (dateDiffInDays(project.startDate, project.endDate) + 1)
                    : '';

                const row = {
                    'No.': index + 1,
                    '프로젝트 ID': project.id || '',
                    '프로젝트 명': project.name || '',
                    '작업 유형': project.taskType || '',
                    '상태': project.status || '',
                    '시작일(현재)': startCurrent || '',
                    '시작일(원본)': startOriginal || '',
                    '종료일(현재)': endCurrent || '',
                    '종료일(원본)': endOriginal || '',
                    '날짜 변경 여부': hasDateChange ? '변경' : '유지',
                    '변경 상세': changeDetails.join(' / '),
                    '기간(일)': durationDays,
                    '정산 금액': typeof project.poAmount === 'number' ? project.poAmount : (project.poAmount || 0),
                    '진행률(%)': typeof project.progress === 'number' ? project.progress : (project.progress || 0),
                    '비고': project.memo || ''
                };

                customDescriptors.forEach(desc => {
                    row[desc.label] = project.customFields?.[desc.key] ?? '';
                });

                rows.push(row);
            });

            return { headerLabels, rows, changedProjectCount };
        }

        function createWorkbookFromRows(headerLabels, rows, changedProjectCount) {
            const workbook = XLSX.utils.book_new();

            const aoa = [headerLabels];
            rows.forEach(row => {
                const rowValues = headerLabels.map(header => row[header] ?? '');
                aoa.push(rowValues);
            });

            const worksheet = XLSX.utils.aoa_to_sheet(aoa);
            worksheet['!cols'] = headerLabels.map(label => {
                const baseWidth = label.length + 6;
                const minWidth = 12;
                return { wch: Math.max(baseWidth, minWidth) };
            });

            XLSX.utils.book_append_sheet(workbook, worksheet, '프로젝트');

            const now = new Date();
            const summarySheetData = [
                ['생성 일시', now.toLocaleString('ko-KR')],
                ['총 프로젝트 수', projectData.length],
                ['날짜가 변경된 프로젝트 수', changedProjectCount],
                ['안내', '날짜 변경 여부/변경 상세 열을 확인하여 현장 수정된 항목을 파악하세요.'],
                ['설명', '원본 날짜는 최초 입력값을 나타내며, 현재 날짜와 다를 경우 변경으로 표기됩니다.']
            ];

            const summarySheet = XLSX.utils.aoa_to_sheet(summarySheetData);
            summarySheet['!cols'] = [{ wch: 24 }, { wch: 60 }];
            XLSX.utils.book_append_sheet(workbook, summarySheet, '요약');

            return workbook;
        }

        function handleExcelExport() {
            if (!Array.isArray(projectData) || projectData.length === 0) {
                showToast('내보낼 데이터가 없습니다.', 'warning');
                return;
            }

                try {
                    const { headerLabels, rows, changedProjectCount } = buildProjectExportRows();
                    const workbook = createWorkbookFromRows(headerLabels, rows, changedProjectCount);

                    // Append 업데이트 이력 시트 (일관된 전/후 컬럼: 시작/종료일, 진행률)
                    try {
                        const updatedProjectIds = window.__getUpdatedProjects ? window.__getUpdatedProjects() : [];
                        if (Array.isArray(updatedProjectIds) && updatedProjectIds.length > 0) {
                            const updateHistoryData = [];
                            updateHistoryData.push(['업데이트 항목 상세 이력']);
                            updateHistoryData.push(['']);
                            updateHistoryData.push([
                                '프로젝트 ID', '명칭',
                                '변경전 시작일', '변경후 시작일',
                                '변경전 종료일', '변경후 종료일',
                                '변경전 진행률(%)', '변경후 진행률(%)',
                                '변경 시간'
                            ]);

                            // Helper to format current date fields consistently
                            const fmtDateForProject = (p, type) => {
                                if (!p) return '';
                                if (p[type] instanceof Date && !isNaN(p[type])) return formatDateYMD(p[type]);
                                return p[`${type}Str`] || '';
                            };

                            // Compute overall original/current progress if requested
                            const includeOverall = updatedProjectIds.includes('overall');
                            if (includeOverall) {
                                const totalPo = projectData.reduce((s, p) => s + (p.poAmount || 0), 0);
                                const origWeighted = projectData.reduce((s, p) => {
                                    const op = getOriginalProgress(p);
                                    return s + ((Number(op) || 0) * (p.poAmount || 0));
                                }, 0);
                                const currentWeighted = projectData.reduce((s, p) => s + ((p.progress || 0) * (p.poAmount || 0)), 0);
                                const origOverall = totalPo > 0 ? Math.round(origWeighted / totalPo * 100) / 100 : 0;
                                const currOverall = totalPo > 0 ? Math.round(currentWeighted / totalPo * 100) / 100 : 0;
                                updateHistoryData.push(['overall', '전체 진행률', '', '', '', '', origOverall + '%', currOverall + '%', new Date().toLocaleString('ko-KR')]);
                            }

                            updatedProjectIds.forEach(pid => {
                                if (pid === 'overall') return; // already handled
                                const project = projectData.find(p => p.id === pid);
                                if (!project) return;

                                const registryKey = getProjectRegistryKey(project, pid, project.name);
                                const originalDates = registryKey ? (originalDateRegistry.get(registryKey) || { start: '', end: '' }) : { start: '', end: '' };
                                const originalStart = originalDates.start || '';
                                const originalEnd = originalDates.end || '';
                                const currentStart = fmtDateForProject(project, 'startDate');
                                const currentEnd = fmtDateForProject(project, 'endDate');

                                const originalProg = getOriginalProgress(project);
                                const currentProg = (typeof project.progress === 'number') ? project.progress : (project.progress || 0);

                                // Only include rows where something actually changed
                                const changed = (originalStart !== currentStart) || (originalEnd !== currentEnd) || (Number(originalProg) !== Number(currentProg));
                                if (changed) {
                                    updateHistoryData.push([
                                        pid,
                                        project.name || '',
                                        originalStart || '', currentStart || '',
                                        originalEnd || '', currentEnd || '',
                                        (originalProg === '' ? '' : String(originalProg) + '%'), String(currentProg) + '%',
                                        new Date().toLocaleString('ko-KR')
                                    ]);
                                }
                            });

                            if (updateHistoryData.length > 3) {
                                const updateHistorySheet = XLSX.utils.aoa_to_sheet(updateHistoryData);
                                XLSX.utils.book_append_sheet(workbook, updateHistorySheet, '업데이트 이력');
                            }
                        }
                    } catch (e) {
                        console.warn('update history sheet creation failed', e);
                    }

                    const now = new Date();
                    const fileNameTimestamp = [
                        now.getFullYear(),
                        String(now.getMonth() + 1).padStart(2, '0'),
                        String(now.getDate()).padStart(2, '0'),
                        String(now.getHours()).padStart(2, '0'),
                        String(now.getMinutes()).padStart(2, '0')
                    ].join('');
                    const fileName = `공정관리_내보내기_${fileNameTimestamp}.xlsx`;
                    XLSX.writeFile(workbook, fileName, { compression: true });
                    showToast('엑셀 파일로 내보냈습니다.', 'success');
                } catch (error) {
                    console.error('Excel export failed:', error);
                    showToast('엑셀 내보내기 중 오류가 발생했습니다.', 'error');
                }
        }

        if (exportToExcelBtn && !exportToExcelBtn.dataset.enhancedExportAttached) {
            exportToExcelBtn.dataset.enhancedExportAttached = 'true';
            exportToExcelBtn.addEventListener('click', (event) => {
                event.preventDefault();
                handleExcelExport();
            });
        }

        // Parse a local YYYY-MM-DD (or similar) string into a Date at local midnight.
        // If input is already a Date, returns a copy normalized to local midnight.
        function parseLocalDateString(s) {
            if (!s) return null;
            
            // 날짜가 이미 Date 객체인 경우, 로컬 자정으로 맞춰 복제
            if (s instanceof Date && !isNaN(s)) {
                return new Date(s.getFullYear(), s.getMonth(), s.getDate());
            }

            // Excel 시리얼 날짜 번호 처리 (1900년 기준) - 로컬 날짜로 직접 변환
            if (typeof s === 'number' && s > 0) {
                try {
                    const msPerDay = 24 * 60 * 60 * 1000;
                    const jan1_1900 = new Date(1900, 0, 1);
                    const daysSince1900 = s - 1; // Excel의 1은 1900년 1월 1일
                    const localDate = new Date(jan1_1900.getTime() + (daysSince1900 * msPerDay));
                    return new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate());
                } catch (e) {
                    console.error('Excel date parsing error:', e);
                    return null;
                }
            }

            // 문자열 처리
            try {
                const str = String(s).trim();
                const normalized = normalizeDateInput(str);
                if (normalized && /^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
                    const [year, month, day] = normalized.split('-').map(n => parseInt(n, 10));
                    return new Date(year, month - 1, day);
                }

                // 다른 형식의 날짜 문자열 처리
                const tempDate = new Date(str);
                if (!isNaN(tempDate)) {
                    return new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());
                }
            } catch (e) {
                console.error('Date string parsing error:', e);
            }
            
            return null;
        }

        function formatCurrency(amount) {
            if (amount === null || amount === undefined || isNaN(amount)) {
                return '0원';
            }
            return `${parseInt(amount, 10).toLocaleString('ko-KR')}원`;
        }

        function formatAmountWithUnit(amount) {
            if (!amount || isNaN(amount)) return '';
            if (amount >= 100000000) { // 억
                return `(${(amount / 100000000).toFixed(1)}억)`;
            } else if (amount >= 1000000) { // 백만원
                return `(${(amount / 1000000).toFixed(1)}백만원)`;
            } else if (amount >= 100000) { // 십만원
                return `(${(amount / 100000).toFixed(1)}십만원)`;
            }
            return '';
        }

        function getGroupProgressColor(progress) {
            const p = Math.max(0, Math.min(100, progress));
            const gray = { r: 156, g: 163, b: 175 }; // gray-400
            const blue = { r: 59, g: 130, b: 246 };  // blue-500
            const green = { r: 34, g: 197, b: 94 }; // green-500

            let r, g, b;
            if (p < 50) {
                const t = p / 50;
                r = Math.round(gray.r + t * (blue.r - gray.r));
                g = Math.round(gray.g + t * (blue.g - gray.g));
                b = Math.round(gray.b + t * (blue.b - gray.b));
            } else {
                const t = (p - 50) / 50;
                r = Math.round(blue.r + t * (green.r - blue.r));
                g = Math.round(blue.g + t * (green.g - blue.g));
                b = Math.round(blue.b + t * (green.b - blue.b));
            }
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Returns a CSS linear-gradient string based on progress value (0-100)
        function getProgressGradient(progress) {
            const p = Math.max(0, Math.min(100, Number(progress) || 0));
            // Use distinct, high-contrast color stops for start/mid/end
            const red = '#ef4444';   // red-500
            const orange = '#fb923c';// orange-400
            const amber = '#f59e0b'; // amber-500
            const green = '#10b981'; // emerald-500

            if (p < 30) {
                // low progress: red -> orange (strong warning)
                return `linear-gradient(90deg, ${red}, ${orange})`;
            } else if (p < 70) {
                // mid progress: orange -> amber -> green (transition)
                return `linear-gradient(90deg, ${orange}, ${amber}, ${green})`;
            } else {
                // high progress: amber -> green (success)
                return `linear-gradient(90deg, ${amber}, ${green})`;
            }
        }

        function updateAndApplyDateRange() {
            if (projectData.length === 0 && milestones.length === 0) {
                minDate = null; maxDate = null;
                viewMinDate = null; viewMaxDate = null;
                return;
            }

            const allDates = [
                ...projectData.map(p => p.startDate),
                ...projectData.map(p => p.endDate),
                ...milestones.map(m => parseLocalDateString(m.date))
            ].filter(d => d && !isNaN(d));

            if (allDates.length > 0) {
                const oldMinDateStr = minDate ? formatDateYMD(minDate) : null;
                const oldMaxDateStr = maxDate ? formatDateYMD(maxDate) : null;
                const viewMinDateStr = viewMinDate ? formatDateYMD(viewMinDate) : null;
                const viewMaxDateStr = viewMaxDate ? formatDateYMD(viewMaxDate) : null;

                const wasShowingFullRange = (viewMinDateStr === oldMinDateStr) && (viewMaxDateStr === oldMaxDateStr);

                minDate = new Date(Math.min(...allDates));
                maxDate = new Date(Math.max(...allDates));
                minDate.setDate(minDate.getDate() - 7);
                maxDate.setDate(maxDate.getDate() + 14);

                if (wasShowingFullRange || !viewMinDate) {
                     viewMinDate = new Date(minDate);
                     viewMaxDate = new Date(maxDate);
                }
            }
            isCustomZoomActive = false;
            updateZoomButtonState();
            updateShortcutActiveStates();
        }

        function toggleAllGroups(expand) {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody.querySelector('#ganttChartWrapper'); // Target chart wrapper
            if (!container) return;
            const groupHeaders = container.querySelectorAll('.group-header');

            groupHeaders.forEach(header => {
                const groupContainer = header.nextElementSibling;
                if (groupContainer && groupContainer.classList.contains('group-item-container')) {
                    const isCollapsed = groupContainer.classList.contains('hidden');

                    if (expand && isCollapsed) header.click();
                    else if (!expand && !isCollapsed) header.click();
                }
            });
            
            // 개선 사항: 계층순서 유지 - 모든 그룹 접기/펼치기 후에도 계층순서 재적용
            setTimeout(() => {
                const containerRef = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                if (containerRef) {
                    applyHierarchyOrder(containerRef);
                }
            }, 350); // 접기/펼치기 애니메이션 완료 후 적용

            // [핵심 수정] 펼치기 후 업데이트된 데이터 반영
            if (expand) {
                // 펼치기 후 약간의 지연을 두고 render() 호출하여 업데이트된 데이터 반영
                // 접힌 상태에서 엑셀 업로드 후 펼쳤을 때 업데이트된 데이터가 표시되도록 보장
                setTimeout(() => {
                    // [핵심 수정] window.projectData와 projectData 동기화 확인
                    if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && 
                        typeof projectData !== 'undefined' && Array.isArray(projectData)) {
                        // projectData의 최신 상태를 window.projectData에 반영
                        const projectDataMap = new Map();
                        projectData.forEach(p => {
                            if (p.id) {
                                projectDataMap.set(String(p.id), p);
                            }
                        });
                        
                        window.projectData.forEach(wp => {
                            if (wp.id) {
                                const p = projectDataMap.get(String(wp.id));
                                if (p) {
                                    // 업데이트된 데이터로 동기화
                                    if (p.startDate) {
                                        wp.startDate = p.startDate;
                                        wp.startDateStr = p.startDateStr;
                                    }
                                    if (p.endDate) {
                                        wp.endDate = p.endDate;
                                        wp.endDateStr = p.endDateStr;
                                    }
                                    if (typeof p.progress === 'number') {
                                        wp.progress = p.progress;
                                    }
                                    if (p.dependsOn && Array.isArray(p.dependsOn)) {
                                        wp.dependsOn = JSON.parse(JSON.stringify(p.dependsOn));
                                    } else if (!p.dependsOn) {
                                        wp.dependsOn = [];
                                    }
                                }
                            }
                        });
                    }
                    
                    // render() 호출하여 업데이트된 데이터 반영
                    render();
                    
                    // [핵심 수정] 의존성 표시도 업데이트
                    setTimeout(() => {
                        const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                        const ganttContainer = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                        if (ganttContainer) {
                            const ganttBody = ganttContainer.querySelector('.gantt-body');
                            if (ganttBody) {
                                const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                                    window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                                if (dataToRender && Array.isArray(dataToRender) && typeof window.renderDependencyArrows === 'function') {
                                    window.renderDependencyArrows(ganttBody, dataToRender);
                                }
                            }
                        }
                    }, 200);
                }, 400); // 접기/펼치기 애니메이션 완료 후 약간의 여유를 두고 실행
            }

            updateGroupToggleButtons();
            updateShortcutActiveStates();
        }

        // 개선 사항: 계층 순서 변경 함수
        function toggleHierarchyOrder() {
            hierarchyOrder = hierarchyOrder === 'top' ? 'bottom' : 'top';
            shortcutState.expandAll = false;
            shortcutState.collapseAll = false;
            
            // 버튼 참조 업데이트 (최신 상태 보장)
            updateControlReferences();
            
            // 버튼 텍스트 및 스타일 업데이트 (현재 상태를 시각적으로 명확히 표시)
            const isBottomMode = hierarchyOrder === 'bottom';
            const buttonText = isBottomMode ? '계층순서 (하→상)' : '계층순서 (상→하)';
            
            // Update any matching toggle buttons across the document (main control + cloned shortcuts)
            const matchingButtons = Array.from(document.querySelectorAll('#toggleHierarchyOrderBtn, [id*="toggleHierarchyOrderBtn"]'));
            matchingButtons.forEach(btn => {
                try {
                    btn.textContent = buttonText;
                    if (isBottomMode) {
                        btn.style.backgroundColor = '#dbeafe';
                        btn.style.border = '2px solid #3b82f6';
                        btn.style.fontWeight = 'bold';
                        btn.style.color = '#1e40af';
                    } else {
                        btn.style.backgroundColor = '#fef3c7';
                        btn.style.border = '2px solid #f59e0b';
                        btn.style.fontWeight = 'bold';
                        btn.style.color = '#92400e';
                    }
                } catch (e) {
                    // ignore styling errors for specific buttons
                }
            });
            
            // 전역 버튼 참조도 업데이트
            if (toggleHierarchyOrderBtn) {
                toggleHierarchyOrderBtn.textContent = buttonText;
                if (isBottomMode) {
                    toggleHierarchyOrderBtn.style.backgroundColor = '#dbeafe';
                    toggleHierarchyOrderBtn.style.border = '2px solid #3b82f6';
                    toggleHierarchyOrderBtn.style.fontWeight = 'bold';
                    toggleHierarchyOrderBtn.style.color = '#1e40af';
                } else {
                    toggleHierarchyOrderBtn.style.backgroundColor = '#fef3c7';
                    toggleHierarchyOrderBtn.style.border = '2px solid #f59e0b';
                    toggleHierarchyOrderBtn.style.fontWeight = 'bold';
                    toggleHierarchyOrderBtn.style.color = '#92400e';
                }
            }
            
            // 저장 설정에 추가
            if (savedSettings) {
                savedSettings.hierarchyOrder = hierarchyOrder;
            }
            
            // 개선 사항: 계층 순서가 'bottom'일 때는 모든 그룹을 자동으로 펼침
            if (hierarchyOrder === 'bottom') {
                // 모든 그룹을 openTaskGroups에 추가하여 펼쳐진 상태로 유지
                const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                if (container) {
                    const groupHeaders = container.querySelectorAll('.group-header');
                    groupHeaders.forEach(header => {
                        const taskTypeMatch = header.textContent.match(/📂\s*(.+?)\s*\(/);
                        if (taskTypeMatch) {
                            const taskType = taskTypeMatch[1];
                            openTaskGroups.add(taskType);
                        }
                    });
                }
                toggleAllGroups(true);
            }
            
            // 개선 사항: 기존 DOM에 즉시 적용
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (container) {
                applyHierarchyOrder(container);
                // 개선 사항: 계층순서 (하→상) 모드일 때 모든 상위 계층 그룹 헤더 숨김 처리
                if (hierarchyOrder === 'bottom') {
                    const allGroupHeaders = container.querySelectorAll('.group-header');
                    allGroupHeaders.forEach(header => {
                        header.style.display = 'none';
                    });
                } else {
                    const allGroupHeaders = container.querySelectorAll('.group-header');
                    allGroupHeaders.forEach(header => {
                        header.style.display = '';
                    });
                }
            }
            
            // 즉시 렌더링하여 순서 변경 적용
            render();
            
            // 렌더링 완료 후 확실히 적용되도록 재적용
            setTimeout(() => {
                const containerAfterRender = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                if (containerAfterRender) {
                    applyHierarchyOrder(containerAfterRender);
                    // 개선 사항: 계층순서 (하→상) 모드일 때 모든 상위 계층 그룹 헤더 숨김 처리
                    if (hierarchyOrder === 'bottom') {
                        const allGroupHeadersAfter = containerAfterRender.querySelectorAll('.group-header');
                        allGroupHeadersAfter.forEach(header => {
                            header.style.display = 'none';
                        });
                    } else {
                        const allGroupHeadersAfter = containerAfterRender.querySelectorAll('.group-header');
                        allGroupHeadersAfter.forEach(header => {
                            header.style.display = '';
                        });
                    }
                }
            }, 100);
            
            // 바로가기 메뉴의 활성화 상태 업데이트 (깜빡임 및 테두리 표시)
            updateShortcutActiveStates();
            
            showToast(`계층 순서가 ${hierarchyOrder === 'top' ? '상위→하위' : '하위→상위'}로 변경되었습니다.`, 'info');
        }

        function syncGroupSummaryVisibility(groupMap) {
            if (!groupMap) return;
            groupMap.forEach(entry => {
                if (!entry || !entry.groupBarRow) return;
                if (hierarchyOrder === 'bottom') {
                    entry.groupBarRow.classList.add('hierarchy-summary-hidden');
                } else {
                    entry.groupBarRow.classList.remove('hierarchy-summary-hidden');
                }
            });
        }

        // 개선 사항: 계층 순서에 따라 DOM 순서 조정 함수
        function applyHierarchyOrder(container) {
            if (!container) return;
            
            const titlesBody = container.querySelector('.gantt-titles-body-wrapper div');
            if (!titlesBody) return;

            // Retry guard: if DOM isn't fully ready (some gantt bar rows not present yet),
            // try again a few times with a short delay. This helps with race conditions
            // where bars are rendered slightly after the titles and avoids mis-mapping.
            if (!container.__applyHierarchyRetryCount) container.__applyHierarchyRetryCount = 0;
            
            // 그래프 영역의 막대 그래프 컨테이너 찾기
            const ganttBody = container.querySelector('.gantt-body');
            const ganttRowsBody = ganttBody ? ganttBody.querySelector('div:first-child') : null;
            
            // 개선 사항: 그룹 헤더와 컨테이너를 정확히 매칭하기 위해 data-task-type 속성 사용
            const groupHeaders = Array.from(titlesBody.querySelectorAll('.group-header'));
            const groupContainers = Array.from(titlesBody.querySelectorAll('.group-item-container'));
            
            // taskType을 기반으로 헤더와 컨테이너 매칭
            const groupsToProcess = [];
            groupHeaders.forEach(header => {
                const taskType = header.dataset.taskType;
                if (taskType) {
                    // 해당 taskType을 가진 컨테이너 찾기
                    const matchedContainer = groupContainers.find(container => {
                        return container.dataset.taskType === taskType && 
                               !groupsToProcess.some(g => g.groupContainer === container);
                    });
                    
                    if (matchedContainer) {
                        groupsToProcess.push({ header, groupContainer: matchedContainer, taskType });
                    }
                }
            });
            
            // data-task-type 속성이 없는 경우, 기존 방식으로 폴백 (텍스트 매칭)
            const unmatchedHeaders = groupHeaders.filter(h => !groupsToProcess.some(g => g.header === h));
            const unmatchedContainers = groupContainers.filter(c => !groupsToProcess.some(g => g.groupContainer === c));
            
            unmatchedHeaders.forEach(header => {
                const taskTypeMatch = header.textContent.match(/📂\s*(.+?)\s*\(/);
                if (taskTypeMatch) {
                    const taskType = taskTypeMatch[1];
                    const matchedContainer = unmatchedContainers.find(container => {
                        const firstItem = container.querySelector('.title-item');
                        if (firstItem) {
                            const projectId = firstItem.dataset.projectId;
                            if (projectId) {
                                const project = projectData.find(p => p.id === projectId);
                                if (project && project.taskType === taskType) {
                                    return !groupsToProcess.some(g => g.groupContainer === container);
                                }
                            }
                        }
                        return false;
                    });
                    
                    if (matchedContainer) {
                        groupsToProcess.push({ header, groupContainer: matchedContainer, taskType });
                    }
                }
            });
            
            // 여전히 매칭되지 않은 경우, 인접한 형제 요소로 매칭
            const stillUnmatchedHeaders = groupHeaders.filter(h => !groupsToProcess.some(g => g.header === h));
            stillUnmatchedHeaders.forEach(header => {
                let nextSibling = header.nextElementSibling;
                let groupContainer = null;
                
                while (nextSibling) {
                    if (nextSibling.classList.contains('group-item-container')) {
                        groupContainer = nextSibling;
                        break;
                    }
                    nextSibling = nextSibling.nextElementSibling;
                }
                
                if (groupContainer && !groupsToProcess.some(g => g.groupContainer === groupContainer)) {
                    groupsToProcess.push({ header, groupContainer });
                }
            });

            // supplemental matching moved later where groupToElementsMap is available
            
            // 모든 그룹에 대해 순서 적용
            // 개선 사항: 'bottom' 모드에서는 그룹 헤더를 컨테이너 바로 다음으로 이동하되, DOM 순서를 정확히 유지
            if (hierarchyOrder === 'bottom') {
                // 'bottom' 모드: 그룹 헤더를 컨테이너 아래로 이동하고 숨김
                // 역순으로 처리하여 순서 변경 충돌 방지
                groupsToProcess.reverse().forEach(({ header, groupContainer }) => {
                    // 헤더가 이미 컨테이너 다음에 있는지 확인
                    const currentContainerNext = groupContainer.nextElementSibling;
                    if (currentContainerNext !== header) {
                        // 헤더를 컨테이너 바로 다음으로 이동
                        if (currentContainerNext) {
                            titlesBody.insertBefore(header, currentContainerNext);
                        } else {
                            // 컨테이너가 마지막이면 끝에 추가
                            titlesBody.appendChild(header);
                        }
                    }
                    // 개선 사항: 계층순서 (하→상) 모드일 때 모든 상위 계층 그룹 헤더 숨김
                    header.style.display = 'none';
                });
            } else {
                // 'top' 모드: 기존 로직 유지 (역순으로 처리하여 순서 변경 충돌 방지)
                groupsToProcess.reverse().forEach(({ header, groupContainer }) => {
                    // 상위→하위: 헤더를 컨테이너 위로 이동 (기본 순서)
                    const currentHeaderNext = header.nextElementSibling;
                    if (currentHeaderNext !== groupContainer) {
                        titlesBody.insertBefore(header, groupContainer);
                    }
                    // 개선 사항: 계층순서 (상→하) 모드일 때 모든 상위 계층 그룹 헤더 표시
                    header.style.display = '';
                });
            }
            
            // 개선 사항: 매칭되지 않은 모든 그룹 헤더도 숨김/표시 처리
            const allGroupHeaders = Array.from(titlesBody.querySelectorAll('.group-header'));
            allGroupHeaders.forEach(header => {
                if (!groupsToProcess.some(g => g.header === header)) {
                    if (hierarchyOrder === 'bottom') {
                        header.style.display = 'none';
                    } else {
                        header.style.display = '';
                    }
                }
            });
            
            // 개선 사항: 작업 목록과 그래프 막대의 순서 동기화
            if (ganttRowsBody) {
                // 작업 목록에서 전체 순서 추출 (그룹 헤더, 그룹 컨테이너, title-item 포함)
                // 핵심: 그룹 헤더 재배치 후의 최신 DOM 순서를 반영하기 위해 다시 가져오기
                // DOM 조작이 완료된 후 최신 상태를 가져옴
                const allTitleElements = Array.from(titlesBody.children);
                const titleOrderMap = new Map(); // 순서 인덱스 -> 요소
                const groupToElementsMap = new Map(); // taskType -> {groupBarRow, childBarRowsContainer}
                
                // 그래프 영역의 모든 요소를 맵에 저장
                const allGraphElements = Array.from(ganttRowsBody.children);
                allGraphElements.forEach(element => {
                    if (element.classList.contains('gantt-bar-row') && !element.dataset.projectId) {
                        // 그룹 바
                        const groupBar = element.querySelector('.gantt-bar');
                        if (groupBar) {
                            const barName = groupBar.dataset.name;
                            if (barName) {
                                const taskTypeMatch = barName.match(/^(.+?)\s*\(요약\)/);
                                if (taskTypeMatch) {
                                    const taskType = taskTypeMatch[1];
                                    if (!groupToElementsMap.has(taskType)) {
                                        groupToElementsMap.set(taskType, { groupBarRow: null, childBarRowsContainer: null });
                                    }
                                    groupToElementsMap.get(taskType).groupBarRow = element;
                                }
                            }
                        }
                    } else if (element.querySelector && element.querySelector('.gantt-bar-row[data-project-id]')) {
                        // 자식 바 컨테이너
                        const firstBarRow = element.querySelector('.gantt-bar-row[data-project-id]');
                        if (firstBarRow) {
                            const projectId = firstBarRow.dataset.projectId;
                            const titleItem = titlesBody.querySelector(`.title-item[data-project-id="${projectId}"]`);
                            if (titleItem) {
                                const groupContainer = titleItem.closest('.group-item-container');
                                if (groupContainer) {
                                    const taskType = groupContainer.dataset.taskType;
                                    if (taskType) {
                                        if (!groupToElementsMap.has(taskType)) {
                                            groupToElementsMap.set(taskType, { groupBarRow: null, childBarRowsContainer: null });
                                        }
                                        groupToElementsMap.get(taskType).childBarRowsContainer = element;
                                    }
                                }
                            }
                        }
                    }
                });

                // 추가 보강: 그래프(간트) 쪽에서 그룹 요약 바나 자식 컨테이너를 못 찾는 경우
                // 점검하여 groupToElementsMap을 보완합니다. (프로젝트 id 기반 탐색)
                try {
                    if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: supplemental matching START', { groupHeaders: groupHeaders.length, groupContainers: groupContainers.length });
                    const allTaskTypes = new Set();
                    groupHeaders.forEach(h => {
                        const tt = h.dataset.taskType;
                        if (tt) allTaskTypes.add(tt);
                        else {
                            const m = h.textContent.match(/📂\s*(.+?)\s*\(/);
                            if (m) allTaskTypes.add(m[1]);
                            }
                    });
                    groupContainers.forEach(c => {
                        if (c.dataset.taskType) allTaskTypes.add(c.dataset.taskType);
                    });

                    allTaskTypes.forEach(taskType => {
                        if (!groupToElementsMap.has(taskType)) {
                            groupToElementsMap.set(taskType, { groupBarRow: null, childBarRowsContainer: null });
                        }

                            // After initial setup, wire focus sync between headers and rows
                            try {
                                const allGroupHeaders = Array.from(document.querySelectorAll('.group-header'));
                                allGroupHeaders.forEach(h => {
                                    try {
                                        const taskType = h.dataset.taskType || (h.textContent.match(/📂\s*(.+?)\s*\(/)||[])[1];
                                        let row = null;
                                        if (taskType) row = findGroupBarRow(taskType);
                                        else {
                                            // fallback: nearest .gantt-bar-row sibling by visual index
                                            const firstTitle = h.nextElementSibling || h;
                                            row = document.querySelector('.gantt-bar-row');
                                        }
                                        applyFocusSync(h, row, taskType);
                                    } catch(e){}
                                });
                            } catch(e) { /* non-critical */ }

                        const entry = groupToElementsMap.get(taskType);

                        // 1) 그룹 요약 바 검색: 이름에 '(요약)'이 포함된 gantt-bar를 찾아 부모 .gantt-bar-row를 사용
                        if (!entry.groupBarRow) {
                            const candidateBar = Array.from(ganttRowsBody.querySelectorAll('.gantt-bar')).find(b => {
                                const name = b.dataset && b.dataset.name ? b.dataset.name : '';
                                return name && name.indexOf(taskType) === 0 && name.indexOf('(요약)') !== -1;
                            });
                            if (candidateBar) {
                                const barRow = candidateBar.closest('.gantt-bar-row');
                                if (barRow) entry.groupBarRow = barRow;
                            }
                        }

                        // 2) 자식 바 컨테이너 검색: titlesBody의 해당 그룹에 속한 projectId 중 하나를 포함하는 .gantt-bar-row의 부모
                        if (!entry.childBarRowsContainer) {
                            const titleItemsInGroup = Array.from(titlesBody.querySelectorAll(`.group-item-container[data-task-type="${taskType}"] .title-item`));
                            const projectIds = titleItemsInGroup.map(t => t.dataset.projectId).filter(Boolean);
                            if (projectIds.length) {
                                const candidateBarRow = Array.from(ganttRowsBody.querySelectorAll('.gantt-bar-row[data-project-id]')).find(br => projectIds.includes(br.dataset.projectId));
                                if (candidateBarRow) {
                                    // 부모가 바로 자식 컨테이너일 가능성이 높으므로 parentNode 사용
                                    entry.childBarRowsContainer = candidateBarRow.parentNode || candidateBarRow;
                                }
                            }
                        }

                        // 개발용 로그: 각 taskType별 매칭 상태 (디버그 모드에서만 출력)
                        if (window && window.__GANTT_AUTO_DEBUG) {
                            try {
                                console.debug('applyHierarchyOrder: match', taskType, {
                                    hasGroupBarRow: !!entry.groupBarRow,
                                    hasChildBarRowsContainer: !!entry.childBarRowsContainer,
                                    sampleProjectIds: (Array.from(titlesBody.querySelectorAll(`.group-item-container[data-task-type="${taskType}"] .title-item`))||[]).slice(0,3).map(t=>t.dataset.projectId)
                                });
                            } catch(e) {
                                // ignore debug failures
                            }
                        }
                    });
                    if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: supplemental matching END');
                } catch (e) {
                    // 안정성: 보강 로직에서 오류 발생 시 무시하고 기존 동작 유지
                    console.warn('applyHierarchyOrder: supplemental matching failed', e);
                }
                
                syncGroupSummaryVisibility(groupToElementsMap);
                
                // 작업 목록 순서를 기반으로 그래프 요소 재정렬
                // 개발용 상세 로그: titles 순서 및 ganttRowsBody 현재 상태 출력
                try {
                    const titleSeq = allTitleElements.map(el => {
                        if (el.classList.contains('group-header')) {
                            return { type: 'group-header', taskType: el.dataset.taskType || (el.textContent.match(/📂\s*(.+?)\s*\(/)||[])[1] };
                        } else if (el.classList.contains('group-item-container')) {
                            const ids = Array.from(el.querySelectorAll('.title-item')).map(t=>t.dataset.projectId).filter(Boolean);
                            return { type: 'group-container', taskType: el.dataset.taskType, projectIds: ids };
                        } else if (el.classList.contains('title-item')) {
                            return { type: 'title-item', projectId: el.dataset.projectId };
                        }
                        return { type: 'unknown' };
                    });

                    const ganttSeq = Array.from(ganttRowsBody.children).map(el => {
                        if (el.classList.contains('gantt-bar-row') && !el.dataset.projectId) {
                            const bar = el.querySelector('.gantt-bar');
                            const name = bar && bar.dataset ? bar.dataset.name : null;
                            return { type: 'group-bar-row', name };
                        } else if (el.querySelector && el.querySelector('.gantt-bar-row[data-project-id]')) {
                            const ids = Array.from(el.querySelectorAll('.gantt-bar-row[data-project-id]')).map(b=>b.dataset.projectId).filter(Boolean);
                            return { type: 'child-bar-container', projectIds: ids };
                        } else if (el.dataset && el.dataset.projectId) {
                            return { type: 'bar-row-project', projectId: el.dataset.projectId };
                        }
                        return { type: 'unknown' };
                    });

                    if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: TITLE SEQ', titleSeq);
                    if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: GANTT SEQ', ganttSeq);
                } catch (e) {
                    // ignore logging errors
                }
                // 개선 사항: 작업 목록의 실제 시각적 순서를 정확히 계산하여 그래프 영역과 완전히 동기화
                // Build quick lookup for project bar rows
                const projectBarRowById = new Map();
                Array.from(ganttRowsBody.querySelectorAll('.gantt-bar-row[data-project-id]')).forEach(br => {
                    if (br.dataset && br.dataset.projectId) projectBarRowById.set(br.dataset.projectId, br);
                });

                // If number of detected project bar rows is less than the number of title items,
                // it's likely rendering is still in progress or DOM structure is wrapped differently.
                // Retry a few times before proceeding to avoid incorrect ordering.
                try {
                    const expectedCount = Array.from(titlesBody.querySelectorAll('.title-item[data-project-id]')).length;
                    const foundCount = projectBarRowById.size;
                    if (foundCount < expectedCount && container.__applyHierarchyRetryCount < 3) {
                        container.__applyHierarchyRetryCount = (container.__applyHierarchyRetryCount || 0) + 1;
                        // Small delay to allow other rendering tasks to complete
                        setTimeout(() => {
                            try { applyHierarchyOrder(container); }
                            catch(e){ console.warn('applyHierarchyOrder: retry failed', e); }
                        }, 80);
                        // Avoid continuing this run; a retry will handle it
                        if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: retry scheduled', { expectedCount, foundCount, retry: container.__applyHierarchyRetryCount });
                        return;
                    }
                } catch (e) {
                    // ignore retry detection errors
                }
                // Supplemental matching: sometimes bars are wrapped or have slightly different DOM positions
                // If a title-projectId exists but not in the map, try broader searches to find any element related to that projectId.
                try {
                    const titleProjectIds = new Set();
                    Array.from(titlesBody.querySelectorAll('.title-item[data-project-id]')).forEach(t => {
                        if (t.dataset && t.dataset.projectId) titleProjectIds.add(t.dataset.projectId);
                    });

                    titleProjectIds.forEach(pid => {
                        if (!projectBarRowById.has(pid)) {
                            // 1) direct selector in ganttRowsBody for any element with dataset.projectId
                            let found = ganttRowsBody.querySelector(`.gantt-bar-row[data-project-id="${pid}"]`);
                            if (!found) {
                                // 2) broader: any element under ganttRowsBody that contains an inner .gantt-bar-row[data-project-id]
                                const candidate = Array.from(ganttRowsBody.querySelectorAll('[data-project-id], .gantt-bar-row')).find(el => {
                                    try {
                                        if (el.dataset && el.dataset.projectId === pid) return true;
                                        return !!el.querySelector && !!el.querySelector(`.gantt-bar-row[data-project-id="${pid}"]`);
                                    } catch (e) { return false; }
                                });
                                if (candidate) {
                                    // prefer the nearest .gantt-bar-row child if exists
                                    const inner = candidate.querySelector && candidate.querySelector(`.gantt-bar-row[data-project-id="${pid}"]`);
                                    found = inner || candidate;
                                }
                            }
                            if (found) {
                                projectBarRowById.set(pid, found);
                            }
                        }
                    });
                } catch (e) {
                    console.warn('applyHierarchyOrder: supplemental projectBarRowById matching failed', e);
                }
                
                // 개선 사항: 두 모드 모두에서 작업 목록의 실제 시각적 순서를 정확히 반영
                // 작업 목록의 모든 title-item과 그래프 영역의 bar-row를 1:1로 정확히 매핑
                let visibleContainers = []; // 상위 스코프로 이동하여 재배치 로직에서도 사용 가능하도록
                
                if (hierarchyOrder === 'bottom') {
                    // 'bottom' 모드: 작업 목록의 실제 시각적 순서를 정확히 계산
                    // 1단계: 모든 title-item을 DOM 순서대로 수집 (그룹 컨테이너 순서 유지)
                    visibleContainers = [];
                    const allTitleItemsOrdered = []; // 작업 목록의 모든 title-item을 순서대로
                    
                    allTitleElements.forEach(titleElement => {
                        // 숨겨진 그룹 헤더는 무시하고, group-item-container만 처리
                        if (titleElement.classList.contains('group-item-container')) {
                            visibleContainers.push(titleElement);
                            // 각 컨테이너 내부의 title-item을 순서대로 수집
                            const titleItems = Array.from(titleElement.querySelectorAll('.title-item'));
                            titleItems.forEach(item => {
                                allTitleItemsOrdered.push(item);
                            });
                        }
                    });
                    
                    // 2단계: 각 그룹 컨테이너를 순서대로 처리하고, 내부 항목 순서 정렬
                    visibleContainers.forEach(container => {
                        const taskType = container.dataset.taskType;
                        if (taskType && groupToElementsMap.has(taskType)) {
                            const graphElements = groupToElementsMap.get(taskType);
                            
                            // 하→상: 자식 컨테이너 먼저, 그룹 바 나중
                            // 먼저 자식 컨테이너 내부의 개별 프로젝트 바를 작업 목록 순서에 정확히 맞게 정렬
                            if (graphElements.childBarRowsContainer) {
                                const childContainer = graphElements.childBarRowsContainer;
                                const groupTitleItems = Array.from(container.querySelectorAll('.title-item'));
                                const groupTitleOrder = groupTitleItems.map(item => item.dataset.projectId).filter(id => id);
                                
                                // 자식 컨테이너 내부의 모든 바를 수집
                                const barRowsMap = new Map();
                                const allBarRows = Array.from(childContainer.querySelectorAll('.gantt-bar-row[data-project-id]'));
                                allBarRows.forEach(barRow => {
                                    const projectId = barRow.dataset.projectId;
                                    if (projectId) {
                                        if (!barRowsMap.has(projectId)) {
                                            barRowsMap.set(projectId, []);
                                        }
                                        barRowsMap.get(projectId).push(barRow);
                                    }
                                });
                                
                                // 작업 목록의 정확한 순서대로 바를 재배치
                                // 이렇게 하면 작업 목록의 title-item과 그래프의 bar-row가 1:1로 정확히 대응됨
                                groupTitleOrder.forEach(projectId => {
                                    if (barRowsMap.has(projectId)) {
                                        const bars = barRowsMap.get(projectId);
                                        bars.forEach(bar => {
                                            childContainer.appendChild(bar);
                                        });
                                    }
                                });
                                
                                // 나머지 바도 추가 (순서가 없는 경우, 안전장치)
                                allBarRows.forEach(barRow => {
                                    const projectId = barRow.dataset.projectId;
                                    if (projectId && !groupTitleOrder.includes(projectId)) {
                                        childContainer.appendChild(barRow);
                                    }
                                });
                            }
                        }
                    });
                } else {
                    // 'top' 모드: 각 그룹 컨테이너 내부의 개별 프로젝트 바를 작업 목록 순서에 맞게 정렬
                    allTitleElements.forEach(titleElement => {
                        if (titleElement.classList.contains('group-item-container')) {
                            const taskType = titleElement.dataset.taskType;
                            
                            if (taskType && groupToElementsMap.has(taskType)) {
                                const graphElements = groupToElementsMap.get(taskType);
                                
                                // 상→하: 그룹 바 먼저, 자식 컨테이너 나중
                                // 먼저 자식 컨테이너 내부의 개별 프로젝트 바를 작업 목록 순서에 맞게 정렬
                                if (graphElements.childBarRowsContainer) {
                                    const childContainer = graphElements.childBarRowsContainer;
                                    const groupTitleItems = Array.from(titleElement.querySelectorAll('.title-item'));
                                    const groupTitleOrder = groupTitleItems.map(item => item.dataset.projectId).filter(id => id);
                                    
                                    // 자식 컨테이너 내부의 모든 바를 수집
                                    const barRowsMap = new Map();
                                    const allBarRows = Array.from(childContainer.querySelectorAll('.gantt-bar-row[data-project-id]'));
                                    allBarRows.forEach(barRow => {
                                        const projectId = barRow.dataset.projectId;
                                        if (projectId) {
                                            if (!barRowsMap.has(projectId)) {
                                                barRowsMap.set(projectId, []);
                                            }
                                            barRowsMap.get(projectId).push(barRow);
                                        }
                                    });
                                    
                                    // 작업 목록의 정확한 순서대로 바를 재배치
                                    groupTitleOrder.forEach(projectId => {
                                        if (barRowsMap.has(projectId)) {
                                            const bars = barRowsMap.get(projectId);
                                            bars.forEach(bar => {
                                                childContainer.appendChild(bar);
                                            });
                                        }
                                    });
                                    
                                    // 나머지 바도 추가 (순서가 없는 경우, 안전장치)
                                    allBarRows.forEach(barRow => {
                                        const projectId = barRow.dataset.projectId;
                                        if (projectId && !groupTitleOrder.includes(projectId)) {
                                            childContainer.appendChild(barRow);
                                        }
                                    });
                                }
                            }
                        }
                    });
                }
                
                // 재정렬된 순서로 그래프 요소 재배치
                // 핵심 개선: 작업 목록의 실제 시각적 순서를 정확히 반영하여 그래프 영역을 완전히 재구성
                // 작업 목록의 각 행과 그래프 영역의 각 행을 1:1로 정확히 매핑
                
                // 재배치할 모든 그래프 요소 수집 (ganttRowsBody의 직접 자식 요소만)
                const allGraphElementsToReorder = Array.from(ganttRowsBody.children).filter(el => {
                    return (el.classList.contains('gantt-bar-row') && !el.dataset.projectId) ||
                           (el.querySelector && el.querySelector('.gantt-bar-row[data-project-id]'));
                });
                
                // 작업 목록의 실제 시각적 순서를 정확히 계산
                // 작업 목록에서 보이는 모든 행을 실제 DOM 순서대로 수집
                const orderedTitleRows = [];
                
                // 작업 목록의 모든 직접 자식 요소를 순서대로 순회
                const walkTitleElements = (parent) => {
                    Array.from(parent.children).forEach(element => {
                        if (element.style.display === 'none') return;
                        
                        if (element.classList.contains('group-header')) {
                            if (hierarchyOrder === 'top') {
                                // 'top' 모드에서만 그룹 헤더 표시
                                const taskType = element.dataset.taskType || element.textContent.match(/📂\s*(.+?)\s*\(/)?.[1];
                                orderedTitleRows.push({ type: 'group-header', element: element, taskType: taskType });
                            }
                        } else if (element.classList.contains('group-item-container')) {
                            const taskType = element.dataset.taskType;
                            // 그룹 컨테이너 내부의 모든 title-item을 순서대로 수집
                            const titleItems = Array.from(element.querySelectorAll('.title-item'));
                            titleItems.forEach(item => {
                                if (item.style.display !== 'none') {
                                    orderedTitleRows.push({ 
                                        type: 'title-item', 
                                        element: item, 
                                        taskType: taskType,
                                        projectId: item.dataset.projectId 
                                    });
                                }
                            });
                        } else if (element.classList.contains('title-item')) {
                            // 직접 자식인 title-item (일반적으로는 없지만 안전장치)
                            if (element.style.display !== 'none') {
                                const projectId = element.dataset.projectId;
                                const groupContainer = element.closest('.group-item-container');
                                const taskType = groupContainer ? groupContainer.dataset.taskType : null;
                                orderedTitleRows.push({ 
                                    type: 'title-item', 
                                    element: element, 
                                    taskType: taskType,
                                    projectId: projectId 
                                });
                            }
                        }
                    });
                };
                
                walkTitleElements(titlesBody);
                
                // 작업 목록의 순서대로 그래프 요소를 정확히 재배치
                // 핵심: 작업 목록의 실제 DOM 순서를 기준으로 그래프 영역 재배치
                const finalOrderedElements = [];
                const processedGraphElements = new Set();
                const processedTaskTypes = new Set();
                
                // 작업 목록의 실제 DOM 순서를 따라가면서 그래프 요소 재배치
                // 핵심: 작업 목록에서 각 그룹이 나타나는 순서를 정확히 추적
                // allTitleElements는 이미 그룹 헤더 재배치 후의 최신 순서를 반영
                
                // 먼저 작업 목록에서 보이는 모든 그룹의 순서를 정확히 추적
                const taskTypeOrder = [];
                const seenTaskTypes = new Set();
                
                allTitleElements.forEach(titleElement => {
                    if (titleElement.style.display === 'none') return;
                    
                    let taskType = null;
                    
                    if (titleElement.classList.contains('group-header')) {
                        if (hierarchyOrder === 'top') {
                            // 'top' 모드에서만 그룹 헤더 처리
                            taskType = titleElement.dataset.taskType || titleElement.textContent.match(/📂\s*(.+?)\s*\(/)?.[1];
                            if (taskType && !seenTaskTypes.has(taskType)) {
                                taskTypeOrder.push({ taskType, isGroupHeader: true, element: titleElement });
                                seenTaskTypes.add(taskType);
                            }
                        }
                    } else if (titleElement.classList.contains('group-item-container')) {
                        // 그룹 컨테이너가 보이는 경우만 처리 (숨겨진 경우 제외)
                        if (titleElement.style.display !== 'none' && !titleElement.classList.contains('hidden')) {
                            taskType = titleElement.dataset.taskType;
                            if (taskType && !seenTaskTypes.has(taskType)) {
                                taskTypeOrder.push({ taskType, isGroupHeader: false, element: titleElement });
                                seenTaskTypes.add(taskType);
                            }
                        }
                    }
                });
                
                // 작업 목록 순서대로 그래프 요소 재배치
                taskTypeOrder.forEach(({ taskType, isGroupHeader }) => {
                    if (groupToElementsMap.has(taskType)) {
                        const graphElements = groupToElementsMap.get(taskType);
                        
                        if (hierarchyOrder === 'bottom') {
                            // 하→상: 자식 컨테이너 먼저, 그룹 바 나중
                            if (graphElements.childBarRowsContainer && 
                                allGraphElementsToReorder.includes(graphElements.childBarRowsContainer) &&
                                !processedGraphElements.has(graphElements.childBarRowsContainer)) {
                                finalOrderedElements.push(graphElements.childBarRowsContainer);
                                processedGraphElements.add(graphElements.childBarRowsContainer);
                            }
                            if (graphElements.groupBarRow && 
                                allGraphElementsToReorder.includes(graphElements.groupBarRow) &&
                                !processedGraphElements.has(graphElements.groupBarRow)) {
                                finalOrderedElements.push(graphElements.groupBarRow);
                                processedGraphElements.add(graphElements.groupBarRow);
                            }
                        } else {
                            // 상→하: 그룹 바 먼저, 자식 컨테이너 나중
                            if (isGroupHeader) {
                                // 그룹 헤더가 나타나면 그룹 바 추가
                                if (graphElements.groupBarRow && 
                                    allGraphElementsToReorder.includes(graphElements.groupBarRow) &&
                                    !processedGraphElements.has(graphElements.groupBarRow)) {
                                    finalOrderedElements.push(graphElements.groupBarRow);
                                    processedGraphElements.add(graphElements.groupBarRow);
                                }
                            } else {
                                // 그룹 컨테이너가 나타나면 (그룹 헤더가 없는 경우) 그룹 바 먼저, 자식 컨테이너 나중
                                if (graphElements.groupBarRow && 
                                    allGraphElementsToReorder.includes(graphElements.groupBarRow) &&
                                    !processedGraphElements.has(graphElements.groupBarRow)) {
                                    finalOrderedElements.push(graphElements.groupBarRow);
                                    processedGraphElements.add(graphElements.groupBarRow);
                                }
                                if (graphElements.childBarRowsContainer && 
                                    allGraphElementsToReorder.includes(graphElements.childBarRowsContainer) &&
                                    !processedGraphElements.has(graphElements.childBarRowsContainer)) {
                                    finalOrderedElements.push(graphElements.childBarRowsContainer);
                                    processedGraphElements.add(graphElements.childBarRowsContainer);
                                }
                            }
                        }
                    }
                });
                
                // 매칭되지 않은 요소들도 추가 (안전장치)
                allGraphElementsToReorder.forEach(element => {
                    if (!processedGraphElements.has(element)) {
                        finalOrderedElements.push(element);
                        processedGraphElements.add(element);
                    }
                });

                // 추가 안전장치: 작업 목록(orderedTitleRows) 기반으로 더 엄밀한 1:1 재정렬을 시도
                // 기존 finalOrderedElements가 정상 동작하지 않는 경우(구조적 불일치) 이를 대체합니다.
                try {
                    const strictOrderedElements = [];

                    // Debug flag: set window.__GANTT_STRICT_DEBUG = true in the console to enable detailed matching logs
                    const debugStrict = !!(window && window.__GANTT_STRICT_DEBUG);

                    // Build mapping: taskType -> ordered list of projectIds (appearance order in titles)
                    const taskTypeToProjectOrder = new Map();
                    orderedTitleRows.forEach(row => {
                        if (row.type === 'title-item' && row.projectId) {
                            const tt = row.taskType || (row.element && row.element.closest('.group-item-container')?.dataset.taskType) || null;
                            if (tt) {
                                if (!taskTypeToProjectOrder.has(tt)) taskTypeToProjectOrder.set(tt, []);
                                const arr = taskTypeToProjectOrder.get(tt);
                                if (!arr.includes(row.projectId)) arr.push(row.projectId);
                            }
                        }
                        if (row.type === 'group-header') {
                            const tt = row.taskType;
                            if (tt && !taskTypeToProjectOrder.has(tt)) taskTypeToProjectOrder.set(tt, []);
                        }
                    });

                    if (debugStrict) console.debug('applyHierarchyOrder: taskTypeToProjectOrder', Array.from(taskTypeToProjectOrder.entries()).slice(0,50));

                    // Helper: get group entry reliable (fallback to groupToElementsMap or via supplemental searches)
                    const getGroupEntry = (taskType) => {
                        if (groupToElementsMap.has(taskType)) return groupToElementsMap.get(taskType);
                        return { groupBarRow: null, childBarRowsContainer: null };
                    };

                    // Assemble strict order based on detected taskType order (taskTypeOrder was built earlier)
                    const seenTypes = new Set();
                    taskTypeOrder.forEach(({ taskType }) => {
                        if (seenTypes.has(taskType)) return;
                        seenTypes.add(taskType);

                        const entry = getGroupEntry(taskType);
                        const projList = taskTypeToProjectOrder.get(taskType) || [];

                        // Debug: report missing mappings per taskType
                        if (debugStrict) {
                            const missingProjectIds = projList.filter(pid => !projectBarRowById.has(pid));
                            console.debug('applyHierarchyOrder: taskType', taskType, {
                                projListCount: projList.length,
                                hasGroupBarRow: !!entry.groupBarRow,
                                hasChildContainer: !!entry.childBarRowsContainer,
                                missingProjectIds: missingProjectIds.slice(0,20)
                            });
                        }

                        if (hierarchyOrder === 'bottom') {
                            // 하→상: 자식 바 먼저
                            // Append child bar rows in the exact title order (projectId order)
                            if (entry.childBarRowsContainer) {
                                projList.forEach(pid => {
                                    const br = projectBarRowById.get(pid);
                                    if (br) strictOrderedElements.push(br);
                                });
                                // Also append any remaining child bar rows that weren't listed
                                Array.from(entry.childBarRowsContainer.querySelectorAll('.gantt-bar-row[data-project-id]')).forEach(br => {
                                    if (!strictOrderedElements.includes(br)) strictOrderedElements.push(br);
                                });
                            }
                            // Then append group summary bar row
                            if (entry.groupBarRow) strictOrderedElements.push(entry.groupBarRow);
                        } else {
                            // 상→하: 그룹 바 먼저
                            if (entry.groupBarRow) strictOrderedElements.push(entry.groupBarRow);
                            if (entry.childBarRowsContainer) {
                                projList.forEach(pid => {
                                    const br = projectBarRowById.get(pid);
                                    if (br) strictOrderedElements.push(br);
                                });
                                Array.from(entry.childBarRowsContainer.querySelectorAll('.gantt-bar-row[data-project-id]')).forEach(br => {
                                    if (!strictOrderedElements.includes(br)) strictOrderedElements.push(br);
                                });
                            }
                        }
                    });

                    // Append any remaining graph elements not covered yet
                    allGraphElementsToReorder.forEach(el => {
                        if (!strictOrderedElements.includes(el)) strictOrderedElements.push(el);
                    });

                    if (debugStrict) {
                        console.debug('applyHierarchyOrder: strictOrderedElements count', strictOrderedElements.length);
                        try {
                            const sampleIds = strictOrderedElements.slice(0,30).map(el => el.dataset ? (el.dataset.projectId || (el.querySelector && el.querySelector('.gantt-bar')?.dataset?.name) || el.className) : el.className);
                            console.debug('applyHierarchyOrder: strictOrderedElements sample', sampleIds);
                        } catch(e) {}
                    }

                    // If strict ordering seems valid (non-empty), use it; otherwise fall back to finalOrderedElements
                    const toUse = strictOrderedElements.length > 0 ? strictOrderedElements : finalOrderedElements;

                    // 정확한 순서로 재삽입
                    toUse.forEach(element => {
                        ganttRowsBody.appendChild(element);
                    });
                } catch (e) {
                    // 문제 발생 시 안전하게 기존 방식으로 복구
                    console.warn('applyHierarchyOrder: strict reorder failed, falling back', e);
                    finalOrderedElements.forEach(element => {
                        ganttRowsBody.appendChild(element);
                    });
                }
                
                // 자식 바 컨테이너 내부의 개별 바도 작업 목록 순서에 맞게 재정렬
                // 개선 사항: 두 모드 모두에서 이미 위에서 처리했으므로 이 부분은 제거
                // (각 그룹 내부의 바 순서는 이미 위에서 처리됨)
            }
        }


        function openFullscreenModal() {
            const ganttViewContent = document.getElementById('ganttViewContent');
            // 개선 사항: 컨트롤 패널 대신 범례(Legend)와 간트 차트를 이동
            const legendSection = ganttViewContent.querySelector('#legendSection');
            const ganttWrapper = ganttViewContent.querySelector('#ganttChartWrapper');

            // Move Legend and Gantt Chart to the modal
            if (legendSection) fullscreenModalBody.appendChild(legendSection);
            if (ganttWrapper) fullscreenModalBody.appendChild(ganttWrapper);

            // Reset modal position and size
            const overlay = fullscreenModal;
            overlay.style.justifyContent = '';
            overlay.style.alignItems = '';
            const content = overlay.querySelector('.resizable-modal-content');
            content.style.top = '';
            content.style.left = '';
            content.style.margin = '';
            content.style.width = '95vw'; // Reset width
            content.style.height = '90vh'; // Reset height

            fullscreenModal.classList.remove('hidden');
            // 컨트롤 참조는 항상 메인 문서의 패널을 가리키므로 업데이트할 필요 없음
            render(); // Re-render Gantt in its new location
        }

        function closeFullscreenModal() {
             const ganttViewContent = document.getElementById('ganttViewContent');
             
             // 개선 사항: 범례와 간트 차트를 원래 위치로 복원
             const legendSection = fullscreenModalBody.querySelector('#legendSection');
             const ganttWrapper = fullscreenModalBody.querySelector('#ganttChartWrapper');
             
             if(legendSection) {
                 // ganttViewContent의 첫 번째 자식으로 범례를 삽입
                 ganttViewContent.insertBefore(legendSection, ganttViewContent.firstChild);
             }
             if (ganttWrapper) {
                 // ganttViewContent의 마지막 자식으로 간트 래퍼를 추가
                 ganttViewContent.appendChild(ganttWrapper);
             }

            // [NEW] Ensure the '일정' accordion is open after closing fullscreen.
            const projectViewAccordion = document.getElementById('projectView');
            if (projectViewAccordion) {
                // Hide all other main accordions to maintain the "focused" view
                document.querySelectorAll('#dashboardContent > .accordion-item').forEach(item => {
                    if (item.id !== 'projectView') {
                        item.style.display = 'none';
                        item.classList.remove('open', 'is-focused');
                    }
                });
                // Ensure the project view accordion is visible and marked as open/focused
                projectViewAccordion.style.display = '';
                projectViewAccordion.classList.add('open', 'is-focused');
            }

             fullscreenModal.classList.add('hidden');
             // 컨트롤 참조는 항상 메인 문서의 패널을 가리키므로 업데이트할 필요 없음
             render(); // Re-render Gantt in its original location
        }


        function autoDetectHeaderRow(sheetData) {
            let bestGuess = 0;
            let maxScore = -1;

            for (let i = 0; i < Math.min(sheetData.length, 10); i++) {
                let stringCells = 0;
                let nonEmptyCells = 0;
                let dateCells = 0;
                const row = sheetData[i];
                if (!row || row.length === 0) continue;

                row.forEach(cell => {
                    if (cell !== null && cell !== undefined && cell !== "") {
                        nonEmptyCells++;
                        if (cell instanceof Date) {
                            dateCells++;
                        }
                        if (typeof cell === 'string' && isNaN(cell)) {
                            stringCells++;
                        }
                    }
                });

                if (nonEmptyCells === 0) continue;

                const stringRatio = stringCells / nonEmptyCells;
                const dateRatio = dateCells / nonEmptyCells;

                const score = stringRatio - (dateRatio * 2);

                if (score > maxScore) {
                    maxScore = score;
                    bestGuess = i;
                }
            }
            return bestGuess + 1;
        }

        function initDefaultPinnedShortcuts() {
            // 기본 바로가기 순서 설정 (개선 사항: '검색'을 바로가기에 추가)
            const defaultPinnedControls = [
                'showChangesBtn',        // 변경
                'expandAllBtn',          // 펼치기
                'collapseAllBtn',        // 접기
                'fullscreenBtn',         // 전체 화면
                'milestoneBtn',          // 마일스톤
                'toggleHierarchyOrderBtn', // 계층순서
                'customer-filter',       // 고객사
                'contractor-filter',     // 시공사
                'cost-account-filter',   // 비용계정
                'taskTypeFilter',        // 유형
                'sortBy',                // 정렬
                'progressFilter',        // 진척률
                'searchInput',           // 검색 (추가됨)
                'zoomBtn'                // 날짜 설정
            ];
            
            // 기존 핀 초기화
            pinnedShortcuts.clear();
            
            // 새로운 핀 설정
            defaultPinnedControls.forEach(id => {
                pinnedShortcuts.add(id);
            });
            
            // Shortcut 고정 규칙 적용 (계층순서/정렬/진척률 위치)
            ensureShortcutOrderRules();

            // 바로가기 메뉴 업데이트
            if (typeof updateShortcuts === 'function') {
                updateShortcuts();
            }
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files || []);
            if (files.length === 0) return;

            // Reset any pending milestone sheet
            pendingMilestoneSheetData = null;
            
            // 파일을 프로젝트 파일과 마일스톤 파일로 분류
            const projectFiles = [];
            const milestoneFiles = [];
            
            files.forEach(file => {
                const fileName = file.name.toLowerCase();
                // 파일명에 'milestone', '마일스톤'이 포함되어 있으면 마일스톤 파일로 간주
                if (fileName.includes('milestone') || fileName.includes('마일스톤')) {
                    milestoneFiles.push(file);
                } else {
                    projectFiles.push(file);
                }
            });

            // 프로젝트 파일 처리 (첫 번째 프로젝트 파일만 처리, 나머지는 무시)
            if (projectFiles.length > 0) {
                const projectFile = projectFiles[0];
                if (projectFiles.length > 1) {
                    showToast(`${projectFiles.length}개의 프로젝트 파일이 선택되었습니다. 첫 번째 파일만 처리합니다.`, 'info');
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        // 개선 사항: 대용량 파일 처리를 위한 XLSX 읽기 옵션 최적화
                        const workbook = XLSX.read(data, { 
                            type: 'array', 
                            cellDates: true,
                            cellNF: false,  // 숫자 포맷 비활성화로 성능 향상
                            cellStyles: false,  // 스타일 정보 비활성화로 성능 향상
                            sheetStubs: false,  // 빈 셀 스텁 비활성화
                            dense: false  // 밀집 배열 모드 비활성화 (메모리 절약)
                        });
                        const sheetNames = workbook.SheetNames || [];

                        // Try to find a sheet that looks like a milestone sheet
                        const milestoneSheetIndex = sheetNames.findIndex(n => /milestone|마일스톤/i.test(n));

                        // Parse the primary (first) sheet as project data as before
                        const primarySheetName = sheetNames[0];
                        const primaryWorksheet = workbook.Sheets[primarySheetName];
                        const sheetData = XLSX.utils.sheet_to_json(primaryWorksheet, { header: 1, defval: "", raw: true });

                        // If a milestone sheet exists and is not the first sheet, parse and store it for later
                        if (milestoneSheetIndex > -1 && milestoneSheetIndex !== 0) {
                            try {
                                const msWorksheet = workbook.Sheets[sheetNames[milestoneSheetIndex]];
                                const msData = XLSX.utils.sheet_to_json(msWorksheet, { header: 1, defval: "", raw: true });
                                if (msData && msData.length > 0) {
                                    pendingMilestoneSheetData = msData;
                                    showToast('마일스톤 시트가 감지되었습니다. 프로젝트 매핑 완료 후 마일스톤 매핑을 시작합니다.', 'info');
                                }
                            } catch (errMs) {
                                console.warn('milestone sheet parse failed', errMs);
                            }
                        }

                        if (sheetData.length > 0) {
                            const detectedHeaderRow = autoDetectHeaderRow(sheetData);
                            headerRowCountInput.value = detectedHeaderRow;
                            // Ensure mapping modal will use project fields by default
                            mappingTarget = 'projects';
                            CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
                            // 새 파일 업로드 시 매핑 모달 초기화 플래그 리셋
                            mappingModalInitialized = false;
                            openMappingModal(sheetData);
                        } else {
                            showToast("빈 파일이거나 읽을 수 없는 형식입니다.", 'error');
                        }
                    } catch (error) {
                        console.error("Error processing file:", error);
                        showToast("파일 처리 중 오류가 발생했습니다.", 'error');
                    }
                };
                reader.onerror = () => {
                     showToast("파일을 읽는 중 오류가 발생했습니다.", 'error');
                };
                reader.readAsArrayBuffer(projectFile);
            } else {
                showToast("프로젝트 파일을 선택해주세요.", 'warning');
            }

            // 마일스톤 파일 처리 (모든 마일스톤 파일 처리)
            if (milestoneFiles.length > 0) {
                milestoneFiles.forEach((milestoneFile, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { 
                                type: 'array', 
                                cellDates: true,
                                cellNF: false,
                                cellStyles: false,
                                sheetStubs: false,
                                dense: false
                            });
                            const sheetNames = workbook.SheetNames || [];
                            
                            // 첫 번째 시트를 마일스톤 데이터로 처리
                            if (sheetNames.length > 0) {
                                const milestoneSheet = workbook.Sheets[sheetNames[0]];
                                const msData = XLSX.utils.sheet_to_json(milestoneSheet, { header: 1, defval: "", raw: true });
                                
                                if (msData && msData.length > 0) {
                                    // 기존 마일스톤 데이터가 있으면 병합, 없으면 새로 설정
                                    if (pendingMilestoneSheetData) {
                                        // 기존 데이터와 병합 (헤더 제외)
                                        const existingHeader = pendingMilestoneSheetData[0];
                                        const existingData = pendingMilestoneSheetData.slice(1);
                                        const newData = msData.slice(1);
                                        pendingMilestoneSheetData = [existingHeader, ...existingData, ...newData];
                                    } else {
                                        pendingMilestoneSheetData = msData;
                                    }
                                    
                                    if (milestoneFiles.length > 1) {
                                        showToast(`마일스톤 파일 ${index + 1}/${milestoneFiles.length} 처리 완료`, 'info');
                                    } else {
                                        showToast('마일스톤 파일이 감지되었습니다. 프로젝트 매핑 완료 후 마일스톤 매핑을 시작합니다.', 'info');
                                    }
                                }
                            }
                        } catch (error) {
                            console.error("Error processing milestone file:", error);
                            showToast(`마일스톤 파일 처리 중 오류가 발생했습니다: ${milestoneFile.name}`, 'error');
                        }
                    };
                    reader.onerror = () => {
                        showToast(`마일스톤 파일을 읽는 중 오류가 발생했습니다: ${milestoneFile.name}`, 'error');
                    };
                    reader.readAsArrayBuffer(milestoneFile);
                });
            }

            event.target.value = '';
        }

        const MAPPING_FIELDS = [
            { key: 'id', name: 'ID', aliases: ['id', '아이디', '고유번호', '유지관리번호'], required: false },
            { key: 'name', name: '명칭', aliases: ['name', '명칭', '프로젝트명', '작업명', '공사명', '유지관리명'], required: true },
            { key: 'taskType', name: '작업 유형', aliases: ['tasktype', 'task type', '작업유형', '작업 유형', '공종'], required: false },
            { key: 'status', name: '상태', aliases: ['status', '상태', '공사진행상태'], required: false },
            { key: 'startDate', name: '시작일', aliases: ['startdate', 'start date', '시작일', '착수일', '시작'], required: true },
            { key: 'endDate', name: '종료일', aliases: ['enddate', 'end date', '종료일', '완료일', '종료'], required: true },
            { key: 'poAmount', name: '정산', aliases: ['poamount', 'po amount', '정산', '금액', '계약금', 'po금액'], required: false },
            { key: 'progress', name: '진행률', aliases: ['progress', '진행률', '진척률'], required: false },
            { key: 'dependency', name: '의존성', aliases: ['dependency', '의존성', '의존작업', '선행작업'], required: false }
];

        // Current mapping fields in use by the mapping modal. Default to project mapping fields.
        let CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
        // Mapping target: 'projects' or 'milestones'
        let mappingTarget = 'projects';
        // Hold pending milestone sheet data if workbook contains a separate milestone sheet
        let pendingMilestoneSheetData = null;
        // Track if mapping modal has been initialized to avoid overwriting user input
        let mappingModalInitialized = false;

        const MILESTONE_MAPPING_FIELDS = [
            { key: 'id', name: 'ID', aliases: ['id', '아이디', '고유번호'], required: false },
            { key: '마일스톤', name: '마일스톤', aliases: ['milestone', '마일스톤', 'name', '명칭'], required: true },
            { key: '날짜', name: '날짜', aliases: ['date', '날짜', '일자'], required: true }
        ];

        // 헤더 행들을 지능적으로 결합하는 함수
        function combineHeaderRows(headerRows) {
            if (!headerRows || headerRows.length === 0) return [];
            
            // 모든 헤더 행의 최대 열 수 찾기
            const maxCols = Math.max(...headerRows.map(row => row.length));
            const combined = [];
            
            for (let colIndex = 0; colIndex < maxCols; colIndex++) {
                const columnValues = [];
                
                // 각 행에서 해당 열의 값을 수집
                for (let rowIndex = 0; rowIndex < headerRows.length; rowIndex++) {
                    const cellValue = headerRows[rowIndex][colIndex];
                    if (cellValue != null && cellValue !== '') {
                        const trimmed = String(cellValue).trim();
                        if (trimmed) {
                            columnValues.push(trimmed);
                        }
                    }
                }
                
                // 지능적으로 결합
                let combinedValue = '';
                if (columnValues.length === 0) {
                    combinedValue = `열 ${colIndex + 1}`;
                } else if (columnValues.length === 1) {
                    combinedValue = columnValues[0];
                } else {
                    // 중복 제거 및 의미있는 결합
                    const uniqueValues = [...new Set(columnValues)];
                    // 공백이나 특수문자로 연결된 경우 하나로 결합
                    if (uniqueValues.every(v => /^[\s\-\/\(\)]*$/.test(v) || uniqueValues[0].includes(v) || v.includes(uniqueValues[0]))) {
                        combinedValue = uniqueValues[0];
                    } else {
                        // 의미있는 값들만 필터링하여 결합
                        const meaningfulValues = uniqueValues.filter(v => !/^[\s\-\/\(\)]*$/.test(v));
                        if (meaningfulValues.length > 0) {
                            combinedValue = meaningfulValues.join(' ');
                        } else {
                            combinedValue = uniqueValues[0];
                        }
                    }
                }
                
                combined.push(combinedValue);
            }
            
            return combined;
        }
        
        // 헤더 행 갯수를 자동으로 감지하는 함수
        function detectHeaderRowCount(sheetData, startRowIndex) {
            if (!sheetData || startRowIndex < 0 || startRowIndex >= sheetData.length) {
                return 1;
            }
            
            // 기본값은 1행 (보수적 접근)
            let headerRowCount = 1;
            const maxRowsToCheck = Math.min(5, sheetData.length - startRowIndex - 1);
            
            if (maxRowsToCheck < 1) {
                return 1; // 데이터 행이 없으면 헤더만 1개
            }
            
            // 행의 특성을 분석하는 헬퍼 함수
            function analyzeRow(row) {
                if (!row || row.length === 0) {
                    return { textRatio: 0, numericRatio: 0, emptyRatio: 0, hasContent: false };
                }
                
                let textCount = 0;
                let numericCount = 0;
                let emptyCount = 0;
                let totalCells = row.length;
                
                row.forEach(cell => {
                    const val = String(cell || '').trim();
                    if (!val) {
                        emptyCount++;
                    } else if (/^[\d\.\-\/]+$/.test(val) || val.match(/^\d{4}[-/]\d{1,2}[-/]\d{1,2}/)) {
                        numericCount++;
                    } else {
                        textCount++;
                    }
                });
                
                return {
                    textRatio: textCount / totalCells,
                    numericRatio: numericCount / totalCells,
                    emptyRatio: emptyCount / totalCells,
                    hasContent: textCount + numericCount > 0
                };
            }
            
            // 첫 번째 헤더 행 분석
            const firstRow = analyzeRow(sheetData[startRowIndex]);
            
            // 첫 번째 행이 명확히 데이터 행이면 헤더가 아님
            if (firstRow.textRatio < 0.2 && firstRow.numericRatio > 0.5) {
                return 1;
            }
            
            // 연속된 헤더 행을 찾기 (매우 엄격한 조건으로만 증가)
            for (let i = 1; i <= maxRowsToCheck; i++) {
                const currentRow = analyzeRow(sheetData[startRowIndex + i]);
                const prevRow = analyzeRow(sheetData[startRowIndex + i - 1]);
                
                // 현재 행이 명확한 데이터 행인지 판단
                // 데이터 행의 특징: 숫자 비율이 높고 텍스트 비율이 낮음
                const isClearDataRow = currentRow.numericRatio > 0.4 || 
                                      (currentRow.numericRatio > 0.25 && currentRow.textRatio < 0.25);
                
                // 이전 행이 명확한 헤더 행인지 판단 (텍스트 비율이 높고 숫자 비율이 낮음)
                const isPrevClearHeader = prevRow.textRatio > 0.6 && prevRow.numericRatio < 0.2;
                
                // 현재 행이 명확한 헤더 행인지 판단 (매우 엄격한 조건)
                // 헤더 행은 텍스트 비율이 매우 높고 숫자 비율이 매우 낮아야 함
                const isCurrentClearHeader = currentRow.textRatio > 0.6 && currentRow.numericRatio < 0.2;
                
                // 현재 행이 데이터 행이면 무조건 헤더 종료
                if (isClearDataRow) {
                    break;
                }
                
                // 매우 엄격한 조건: 이전 행과 현재 행 모두 명확한 헤더여야 함
                if (isPrevClearHeader && isCurrentClearHeader) {
                    headerRowCount = i + 1;
                } else {
                    // 애매한 경우는 헤더로 간주하지 않음 (보수적 접근)
                    break;
                }
            }
            
            return Math.min(headerRowCount, 5); // 최대 5행까지만
        }

        function openMappingModal(sheetData) {
            rawImportData = sheetData;
            
            // 헤더 시작 행 초기화 (새 파일이거나 값이 없을 때만)
            const currentStartRow = mappingHeaderRowCount.value;
            if (!currentStartRow || currentStartRow === '1') {
                mappingHeaderRowCount.value = headerRowCountInput.value || '1';
            }
            
            // 헤더 행 갯수 자동 감지 (모달이 처음 열리거나 새 파일일 때만)
            const currentRowCount = mappingHeaderRowCountNumber.value;
            if (!mappingModalInitialized) {
                // 모달이 처음 열릴 때만 자동 감지 수행
                const headerRowIndexForDetection = parseInt(mappingHeaderRowCount.value, 10) - 1;
                if (headerRowIndexForDetection >= 0 && headerRowIndexForDetection < sheetData.length) {
                    const detectedCount = detectHeaderRowCount(sheetData, headerRowIndexForDetection);
                    // 현재 값이 없거나 초기값일 때만 자동 감지된 값으로 설정
                    if (!currentRowCount || currentRowCount === '1' || currentRowCount === '') {
                        mappingHeaderRowCountNumber.value = detectedCount;
                    }
                    // 그 외의 경우는 사용자가 설정한 값을 유지
                } else if (!currentRowCount || currentRowCount === '1' || currentRowCount === '') {
                    mappingHeaderRowCountNumber.value = '1';
                }
                mappingModalInitialized = true;
            }
            // 모달이 이미 열려있고 사용자가 값을 변경한 경우, 사용자가 설정한 값을 유지
            
            const headerRowIndex = parseInt(mappingHeaderRowCount.value, 10) - 1;

            if (headerRowIndex < 0 || headerRowIndex >= sheetData.length) {
                showToast("데이터 시작 행이 파일의 범위를 벗어납니다.", 'error');
                return;
            }

            // 헤더 행 갯수 처리 (사용자가 설정한 값을 우선 사용)
            let headerRowCount = parseInt(mappingHeaderRowCountNumber?.value || '1', 10);
            
            // 유효성 검사 및 범위 제한
            if (isNaN(headerRowCount) || headerRowCount < 1) {
                headerRowCount = 1;
                mappingHeaderRowCountNumber.value = '1';
            } else if (headerRowCount > 5) {
                headerRowCount = 5;
                mappingHeaderRowCountNumber.value = '5';
            }
            
            // 최대 5행까지 제한 (이미 위에서 처리했지만 안전장치)
            headerRowCount = Math.min(Math.max(headerRowCount, 1), 5);
            
            // 헤더 행들을 수집
            const headerRows = [];
            for (let i = 0; i < headerRowCount; i++) {
                const rowIndex = headerRowIndex + i;
                if (rowIndex >= 0 && rowIndex < sheetData.length) {
                    headerRows.push(sheetData[rowIndex] || []);
                }
            }
            
            // 헤더 행들을 지능적으로 결합
            const combinedHeaders = combineHeaderRows(headerRows);

            // 데이터 시작 행은 헤더 행 다음부터
            const dataStartIndex = headerRowIndex + headerRowCount;
            const previewData = sheetData.slice(dataStartIndex, dataStartIndex + 10);

            let tableHTML = '<table class="w-full text-left border-collapse"><thead class="bg-gray-100"><tr>';

            combinedHeaders.forEach((headerText, headerIndex) => {
                const analysisKey = getAnalysisHeaderKey(headerText) || `column_${headerIndex}`;
                tableHTML += `<th class="border"><div class="flex flex-col gap-1 p-2">`;
                tableHTML += `<select class="p-1 border rounded-md bg-white mapping-select">`;
                tableHTML += `<option value="ignore">무시</option>`;

                CURRENT_MAPPING_FIELDS.forEach(field => {
                    tableHTML += `<option value="${field.key}">${field.name}${field.required ? ' (필수)' : ''}</option>`;
                });

                // 프로젝트 매핑일 때만 새 속성 추가 옵션 표시
                if (mappingTarget === 'projects') {
                    tableHTML += `<optgroup label="---">`;
                    tableHTML += `<option value="--add-new--">새 속성으로 추가...</option>`;
                    tableHTML += `</optgroup>`;
                }
                tableHTML += `</select>`;

                tableHTML += `<input type="text" class="new-property-input hidden mt-1 p-1 border rounded-md w-full" placeholder="새 속성 이름">`;

                tableHTML += `<span class="font-normal text-gray-600 truncate pt-1" title="${headerText}">${headerText}</span>`;
                tableHTML += `
                    <div class="mapping-analysis-meta" data-analysis-key="${analysisKey}">
                        <label class="mapping-analysis-toggle">
                            <input type="checkbox" class="analysis-sync-checkbox" data-analysis-key="${analysisKey}" data-column-label="${headerText}">
                            <span>총괄·정산 반영</span>
                        </label>
                        <div class="analysis-usage-tags"></div>
                    </div>
                `;
                tableHTML += `</div></th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            previewData.forEach(row => {
                tableHTML += '<tr class="border-b">';
                combinedHeaders.forEach((_, colIndex) => {
                    let cellData = row[colIndex] || '';
                    if (cellData instanceof Date) {
                        cellData = formatDateYMD(cellData);
                    }
                    tableHTML += `<td class="p-2 border truncate" title="${cellData}">${cellData}</td>`;
                });
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table>';

            mappingPreviewContainer.innerHTML = tableHTML;

            // Now, set initial values and add listeners
            const allSelects = mappingPreviewContainer.querySelectorAll('.mapping-select');
            const allInputs = mappingPreviewContainer.querySelectorAll('.new-property-input');
            const analysisCheckboxes = mappingPreviewContainer.querySelectorAll('.analysis-sync-checkbox');

            combinedHeaders.forEach((headerText, index) => {
                const select = allSelects[index];
                const input = allInputs[index];

                // Best match logic
                let bestMatch = 'ignore';
                let highestScore = 0.1; // Set a small threshold to avoid weak matches
                CURRENT_MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    field.aliases.forEach(alias => {
                        const lowerHeaderText = headerText.toLowerCase().trim();
                        const lowerAlias = alias.toLowerCase().trim();
                        if (headerText && lowerHeaderText.includes(lowerAlias)) {
                            let score = lowerAlias.length / lowerHeaderText.length;
                            if (lowerHeaderText === lowerAlias) {
                               score = 1.1;
                            }
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) {
                        highestScore = currentScore;
                        bestMatch = field.key;
                    }
                });

                // If no good standard match, suggest as new property
                if (bestMatch === 'ignore' && headerText) {
                     bestMatch = `custom:${headerText}`;
                }

                // Apply best match to UI
                if (bestMatch.startsWith('custom:')) {
                    select.value = '--add-new--';
                    input.classList.remove('hidden');
                    input.value = bestMatch.substring(7);
                } else {
                    select.value = bestMatch;
                }

                // Add event listener
                select.addEventListener('change', (e) => {
                    if (e.target.value === '--add-new--') {
                        input.classList.remove('hidden');
                        if (!input.value) {
                            input.value = headerText; // Pre-fill if empty
                        }
                    } else {
                        input.classList.add('hidden');
                    }
                });
            });

            analysisCheckboxes.forEach(box => {
                const key = box.dataset.analysisKey;
                if (key && analysisHeaderPreferences.has(key)) {
                    box.checked = true;
                }
                box.addEventListener('change', () => {
                    if (!key) return;
                    updateAnalysisHeaderPreference(key, box.dataset.columnLabel, box.checked);
                    updateSingleMappingAnalysisMeta(box.closest('.mapping-analysis-meta'));
                });
            });

            refreshMappingAnalysisMeta();


            dataPanel.classList.add('hidden');
            mappingModal.classList.remove('hidden');
        }

        function updateSingleMappingAnalysisMeta(metaElement) {
            if (!metaElement) return;
            const key = metaElement.dataset.analysisKey || '';
            const tagsContainer = metaElement.querySelector('.analysis-usage-tags');
            if (!tagsContainer) return;
            const usage = analysisHeaderUsage[key];
            const tags = [];
            if (usage?.overview) {
                tags.push('<span class="analysis-usage-badge">총괄</span>');
            }
            if (usage?.settlement) {
                tags.push('<span class="analysis-usage-badge analysis-usage-badge--settlement">정산</span>');
            }
            if (analysisHeaderPreferences.has(key)) {
                tags.push('<span class="analysis-usage-badge analysis-usage-badge--active">선택</span>');
            }
            tagsContainer.innerHTML = tags.length ? tags.join('') : '<span class="analysis-usage-empty">미연결</span>';
        }

        function refreshMappingAnalysisMeta(context = mappingPreviewContainer) {
            if (!context || typeof context.querySelectorAll !== 'function') return;
            context.querySelectorAll('.mapping-analysis-meta').forEach(meta => {
                const key = meta.dataset.analysisKey || '';
                const checkbox = meta.querySelector('.analysis-sync-checkbox');
                if (checkbox) {
                    checkbox.checked = analysisHeaderPreferences.has(key);
                }
                updateSingleMappingAnalysisMeta(meta);
            });
        }

        function applyMapping() {
            const headerRowIndex = parseInt(mappingHeaderRowCount.value, 10) - 1;
            const headerRowCount = parseInt(mappingHeaderRowCountNumber?.value || '1', 10);
            const dataStartIndex = headerRowIndex + headerRowCount;
            
            const mappingSelectors = mappingPreviewContainer.querySelectorAll('.mapping-select');
            const mappingInputs = mappingPreviewContainer.querySelectorAll('.new-property-input');

            // Branch based on mapping target (projects or milestones)
            if (mappingTarget === 'projects') {
                const mapping = {
                    core: {},
                    custom: []
                };
                MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

                let hasError = false;
                const usedFields = new Set();

                mappingSelectors.forEach((sel, index) => {
                    const value = sel.value;
                    if (value === 'ignore') return;

                    if (value === '--add-new--') {
                        const input = mappingInputs[index];
                        const fieldName = input.value.trim();
                        if (!fieldName) {
                            showToast(`새 속성의 이름이 비어있습니다 (열 ${index + 1}).`, 'error');
                            hasError = true; return;
                        }
                        if (usedFields.has(fieldName)) { showToast(`속성 이름 '${fieldName}'이(가) 중복됩니다.`, 'error'); hasError = true; return; }
                        mapping.custom.push({ colIndex: index, fieldName: fieldName });
                        usedFields.add(fieldName);
                    } else {
                        if (usedFields.has(value)) { showToast(`필드 '${MAPPING_FIELDS.find(f=>f.key === value).name}'이(가) 중복됩니다.`, 'error'); hasError = true; return; }
                        mapping.core[value] = index;
                        usedFields.add(value);
                    }
                });

                if (hasError) return;

                const missingFields = MAPPING_FIELDS.filter(f => f.required && mapping.core[f.key] === -1);
                if (missingFields.length > 0) {
                    const missingFieldNames = missingFields.map(f => f.name).join(', ');
                    showToast(`필수 필드인 '${missingFieldNames}'을(를) 매핑해야 합니다.`, 'error');
                    return;
                }

                importMapping = mapping;
                processMappedData(rawImportData, mapping, dataStartIndex);

                // If a milestone sheet was detected earlier, open mapping for it next
                if (pendingMilestoneSheetData) {
                    // Prepare for milestone mapping
                    mappingTarget = 'milestones';
                    CURRENT_MAPPING_FIELDS = MILESTONE_MAPPING_FIELDS;
                    // Use the same detected header row value
                    mappingHeaderRowCount.value = headerRowCountInput.value;
                    // Open milestone mapping after a small delay to let UI settle
                    const msData = pendingMilestoneSheetData;
                    pendingMilestoneSheetData = null; // clear pending
                    setTimeout(() => openMappingModal(msData), 600);
                }
                return;
            }

                // Milestone mapping path
            if (mappingTarget === 'milestones') {
                const mapping = {};
                MILESTONE_MAPPING_FIELDS.forEach(f => mapping[f.key] = -1);

                let hasError = false;
                const usedFields = new Set();

                mappingSelectors.forEach((sel, index) => {
                    const value = sel.value;
                    if (value === 'ignore') return;
                    if (value === '--add-new--') {
                        showToast('마일스톤 데이터는 기본 필드만 사용할 수 있습니다.', 'info');
                        hasError = true; 
                        return;
                    }
                    if (usedFields.has(value)) { 
                        showToast('중복된 매핑이 있습니다.', 'error'); 
                        hasError = true; 
                        return; 
                    }
                    mapping[value] = index;
                    usedFields.add(value);
                });

                if (hasError) {
                    mappingTarget = 'projects';  // 에러 발생시 매핑 타겟 초기화
                    return;
                }

                const missing = MILESTONE_MAPPING_FIELDS.filter(f => f.required && mapping[f.key] === -1);
                if (missing.length > 0) {
                    const missingNames = missing.map(f => f.name).join(', ');
                    showToast(`필수 필드를 모두 매핑하세요: ${missingNames}`, 'error');
                    mappingTarget = 'projects';  // 필수 필드 누락 시 매핑 타겟 초기화
                    return;
                }
                
                const headerRowCount = parseInt(mappingHeaderRowCountNumber?.value || '1', 10);
                const dataStartIndex = headerRowIndex + headerRowCount;
                
                try {
                    const processedMilestones = [];
                    for (let i = dataStartIndex; i < rawImportData.length; i++) {
                        const row = rawImportData[i];
                        if (!row || row.every(cell => !cell)) continue;

                        const name = row[mapping['마일스톤']];
                        let dateValue = row[mapping['날짜']];

                        if (!name || !dateValue) continue;

                        // 날짜 처리 - 엑셀에 입력된 날짜를 정확하게 사용
                        let finalDate = null;
                        
                    // 매핑 성공 후 모달 닫기
                    mappingModal.classList.add('hidden');
                        if (typeof dateValue === 'number' && dateValue > 0) {
                            // Excel 시리얼 날짜 처리 (1900년 기준) - 로컬 날짜로 직접 변환
                            const msPerDay = 24 * 60 * 60 * 1000;
                            const jan1_1900 = new Date(1900, 0, 1);
                            const daysSince1900 = dateValue - 1; // Excel의 1은 1900년 1월 1일
                            const localDate = new Date(jan1_1900.getTime() + (daysSince1900 * msPerDay));
                            finalDate = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate());
                        } else if (dateValue instanceof Date && !isNaN(dateValue)) {
                            // XLSX가 날짜를 UTC 자정으로 해석하므로, UTC 컴포넌트를 사용하여 엑셀 입력값과 정확히 일치시킴
                            finalDate = new Date(
                                dateValue.getUTCFullYear(),
                                dateValue.getUTCMonth(),
                                dateValue.getUTCDate()
                            );
                        } else if (typeof dateValue === 'string') {
                            const match = dateValue.trim().match(/^(\d{4})[-\/]?(\d{2})[-\/]?(\d{2})$/);
                            if (match) {
                                const [_, year, month, day] = match;
                                // 문자열 날짜를 로컬 날짜로 직접 생성
                                finalDate = new Date(
                                    parseInt(year, 10),
                                    parseInt(month, 10) - 1,
                                    parseInt(day, 10)
                                );
                            }
                        }

                        if (finalDate && !isNaN(finalDate)) {
                            // 로컬 날짜를 사용하여 포맷팅
                            const formattedDate = finalDate.getFullYear() + '-' +
                                String(finalDate.getMonth() + 1).padStart(2, '0') + '-' +
                                String(finalDate.getDate()).padStart(2, '0');

                            processedMilestones.push({
                                name: name,
                                date: formattedDate
                            });
                        }
                    }

                    if (processedMilestones.length > 0) {
                        milestones = processedMilestones;
                        renderMilestoneModal();
                        render();
                        updateAndApplyDateRange();
                        showToast(`${processedMilestones.length}개의 마일스톤이 성공적으로 로드되었습니다.`, 'success');
                        
                        // 마일스톤 매핑 성공 시 모달 닫기
                        mappingModal.classList.add('hidden');
                    } else {
                        showToast('처리할 수 있는 마일스톤 데이터가 없습니다.', 'warning');
                    }
                    
                    // reset mapping target and fields
                    mappingTarget = 'projects';
                    CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
                } catch (e) {
                    console.error('Error processing milestone data:', e);
                    showToast('마일스톤 데이터 처리 중 오류가 발생했습니다.', 'error');
                }
                return;
            }
        }

        function validateAndParseRow(row, mapping) {
            const errors = [];
            const parsed = {};

            // 1. 필수 값 확인 및 데이터 파싱
            MAPPING_FIELDS.forEach(field => {
                if (field.required) {
                    const val = row[mapping.core[field.key]];
                    if (val === null || val === undefined || String(val).trim() === '') {
                        errors.push(`${field.name}은(는) 필수값입니다.`);
                    }
                }
            });

            // [개선 사항 1] 날짜 파싱 시 표준 시간대(Timezone) 문제 해결
            // 엑셀에서 읽어온 Date 객체는 UTC 자정으로 해석될 수 있어, 현지 시간으로 변환 시 하루 전 날짜가 되는 문제를 방지합니다.
            // UTC 시간으로 간주하고 날짜의 년, 월, 일을 추출하여 새로운 현지 시간 기준 Date 객체를 생성합니다.
            const fixTimezone = (date) => {
                return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            };
            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 2. 데이터 파싱 및 타입 검증
            // 날짜
            const startDateVal = row[mapping.core.startDate];
            const endDateVal = row[mapping.core.endDate];
            const parseDate = (val) => {
                // 날짜 파싱을 개선하여 항상 로컬 시간 기준으로 처리하고 시간대 문제 해결
                try {
                    let d = null;
                    if (val instanceof Date && !isNaN(val)) {
                        // XLSX가 날짜를 UTC 자정으로 해석하므로, UTC 컴포넌트를 사용하여 엑셀 입력값과 정확히 일치시킴
                        const year = val.getUTCFullYear();
                        const month = val.getUTCMonth();
                        const day = val.getUTCDate();
                        d = new Date(year, month, day);
                    } else if (typeof val === 'number' && val > 25569) {
                        // Excel 일련 번호를 UTC로 변환 후 로컬 날짜로 변환
                        const utcDate = new Date(Math.round((val - 25569) * 86400 * 1000));
                        const localYear = utcDate.getUTCFullYear();
                        const localMonth = utcDate.getUTCMonth();
                        const localDate = utcDate.getUTCDate();
                        d = new Date(localYear, localMonth, localDate);
                    } else {
                        const s = String(val || '').trim();
                        if (s === '') return null;
                        // YYYY-MM-DD 또는 YYYY/MM/DD 형식 우선 확인
                        const m = s.match(/^(\d{4})[-\/]?(\d{1,2})[-\/]?(\d{1,2})/);
                        if (m) {
                            const y = parseInt(m[1], 10);
                            const mo = parseInt(m[2], 10) - 1;
                            const day = parseInt(m[3], 10);
                            d = new Date(y, mo, day);
                        } else {
                            // 다른 형식의 경우 처리 (ISO 문자열 포함)
                            const tempDate = new Date(s);
                            if (!isNaN(tempDate)) {
                                // ISO 문자열인 경우 UTC 컴포넌트 사용, 그 외는 로컬 컴포넌트 사용
                                if (s.includes('T') || s.includes('Z') || s.match(/^\d{4}-\d{2}-\d{2}T/)) {
                                    // ISO 형식인 경우 UTC 컴포넌트 사용
                                    d = new Date(tempDate.getUTCFullYear(), tempDate.getUTCMonth(), tempDate.getUTCDate());
                                } else {
                                    // 일반 문자열인 경우 로컬 컴포넌트 사용
                                    d = new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());
                                }
                            }
                        }
                    }

                    if (!d || isNaN(d)) return null;
                    // Return local midnight constructed from the detected year/month/day
                    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
                } catch (e) {
                    return null;
                }
            };
            parsed.startDate = parseDate(startDateVal);
            parsed.endDate = parseDate(endDateVal);
            if (!parsed.startDate) errors.push('시작일의 날짜 형식이 올바르지 않습니다.');
            if (!parsed.endDate) errors.push('종료일의 날짜 형식이 올바르지 않습니다.');

            // 날짜 보정 불필요 - 모든 날짜는 로컬 시간대에서 처리됨

            // 금액
            if (mapping.core.poAmount > -1) {
                const poStr = String(row[mapping.core.poAmount] || '0').replace(/,/g, '');
                parsed.poAmount = parseInt(poStr, 10);
                if (isNaN(parsed.poAmount)) errors.push('정산 금액이 유효한 숫자가 아닙니다.');
            } else {
                parsed.poAmount = 0;
            }

            // 진행률
            parsed.progress = 0; // Default to 0
            if (mapping.core.progress > -1) {
                const progressStr = String(row[mapping.core.progress] || '0').replace(/%/g, '').trim();
                parsed.progress = parseInt(progressStr, 10);
                if (isNaN(parsed.progress) || parsed.progress < 0 || parsed.progress > 100) {
                    errors.push('진행률은 0과 100 사이의 숫자여야 합니다.');
                }
            }

            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 3. 논리적 오류 검증
            if (parsed.startDate > parsed.endDate) {
                errors.push('종료일은 시작일보다 빠를 수 없습니다.');
            }

            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 의존성 정보 파싱
            let dependsOn = [];
            if (mapping.core.dependency > -1) {
                const dependencyStr = String(row[mapping.core.dependency] || '').trim();
                if (dependencyStr && dependencyStr !== '없음') {
                    // "작업명(SS); 작업명2(FS)" 형식을 파싱
                    const depParts = dependencyStr.split(';');
                    dependsOn = depParts.map(part => {
                        const trimmed = part.trim();
                        // "작업명(SS)" 또는 "작업명 (SS)" 형식 매칭
                        const match = trimmed.match(/^(.+?)\s*\(([A-Z]{2})\)$/);
                        if (match) {
                            const depName = match[1].trim();
                            const depTypeAbbr = match[2].trim();
                            // 약어를 전체 타입으로 변환
                            const typeMap = {
                                'SS': 'start-to-start',
                                'FS': 'end-to-start',
                                'FF': 'end-to-end',
                                'SF': 'start-to-end'
                            };
                            const depType = typeMap[depTypeAbbr] || depTypeAbbr.toLowerCase();
                            // 프로젝트 이름으로 ID 찾기 (나중에 projectData가 로드된 후 매칭)
                            return {
                                projectName: depName,
                                type: depType
                            };
                        }
                        return null;
                    }).filter(Boolean);
                }
            }

            // 4. 최종 데이터 객체 생성
            const customFields = {};
            // Store custom fields using sanitized keys to avoid problems with special characters.
            mapping.custom.forEach(cf => {
                const originalName = cf.fieldName || '';
                const safeKey = sanitizeKey(originalName);
                // Preserve display name mapping for UI
                if (safeKey) customFieldDisplayNames[safeKey] = originalName;
                customFields[safeKey] = row[cf.colIndex] || '';
            });

            const toYMD = (d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            const projectData = {
                id: mapping.core.id > -1 && row[mapping.core.id] ? String(row[mapping.core.id]) : `gen-${Math.random().toString(36).substr(2, 9)}`,
                name: String(row[mapping.core.name]),
                taskType: mapping.core.taskType > -1 ? String(row[mapping.core.taskType] || '미분류') : '미분류',
                status: mapping.core.status > -1 ? String(row[mapping.core.status]) : '착공전',
                startDateStr: parsed.startDate ? toYMD(parsed.startDate) : '',
                endDateStr: parsed.endDate ? toYMD(parsed.endDate) : '',
                startDate: parsed.startDate,
                endDate: parsed.endDate,
                poAmount: parsed.poAmount,
                progress: parsed.progress,
                customFields: customFields,
                dependsOn: dependsOn // 의존성 정보 (이름 기반, 나중에 ID로 변환)
            };
            
            // 의존성 정보를 이름에서 ID로 변환 (projectData가 이미 로드된 경우)
            if (dependsOn.length > 0 && typeof window.projectData !== 'undefined' && window.projectData.length > 0) {
                projectData.dependsOn = dependsOn.map(dep => {
                    const depProject = window.projectData.find(p => p.name === dep.projectName);
                    if (depProject) {
                        return {
                            projectId: depProject.id,
                            type: dep.type
                        };
                    }
                    return null;
                }).filter(Boolean);
            } else {
                // projectData가 아직 로드되지 않은 경우, 이름 기반으로 저장하고 나중에 변환
                projectData._dependsOnNames = dependsOn;
                projectData.dependsOn = [];
            }
            
            return {
                success: true,
                data: projectData
            };
        }

        function processMappedData(rawData, mapping, dataStartIndex) {
            const dataRows = rawData.slice(dataStartIndex);
            const successfulData = [];
            const failedData = [];

            // 개선 사항: 대용량 데이터 처리를 위한 배치 처리 및 성능 최적화
            const BATCH_SIZE = 500; // 한 번에 처리할 행 수
            const totalRows = dataRows.length;
            let processedCount = 0;

            // 빈 행 사전 필터링으로 불필요한 처리 방지
            const nonEmptyRows = [];
            for (let i = 0; i < dataRows.length; i++) {
                const row = dataRows[i];
                if (row && row.length > 0 && !row.every(cell => cell === null || cell === undefined || String(cell).trim() === '')) {
                    nonEmptyRows.push({ row, index: i });
                }
            }

            // 배치 처리 함수
            const processBatch = (startIdx) => {
                const endIdx = Math.min(startIdx + BATCH_SIZE, nonEmptyRows.length);
                for (let i = startIdx; i < endIdx; i++) {
                    const { row } = nonEmptyRows[i];
                    const result = validateAndParseRow(row, mapping);
                    if (result.success) {
                        successfulData.push(result.data);
                    } else {
                        failedData.push(result);
                    }
                }
                processedCount = endIdx;

                // 진행 상황 업데이트 (대용량 데이터의 경우)
                if (nonEmptyRows.length > 1000 && processedCount < nonEmptyRows.length) {
                    const progress = Math.round((processedCount / nonEmptyRows.length) * 100);
                    // 주기적으로만 UI 업데이트 (성능 최적화)
                    if (processedCount % (BATCH_SIZE * 2) === 0) {
                        showToast(`데이터 처리 중... (${progress}%)`, 'info', 1000);
                    }
                    // [성능 최적화] 다음 배치를 requestIdleCallback 또는 setTimeout으로 처리
                    if (window.requestIdleCallback) {
                        requestIdleCallback(() => {
                            if (processedCount < nonEmptyRows.length) {
                                processBatch(processedCount);
                            } else {
                                finishProcessing();
                            }
                        }, { timeout: 100 });
                    } else {
                        // requestIdleCallback 미지원 시 setTimeout 사용
                        setTimeout(() => {
                            if (processedCount < nonEmptyRows.length) {
                                processBatch(processedCount);
                            } else {
                                finishProcessing();
                            }
                        }, 0);
                    }
                } else {
                    // 소량 데이터는 동기 처리
                    if (processedCount < nonEmptyRows.length) {
                        processBatch(processedCount);
                    } else {
                        finishProcessing();
                    }
                }
            };

            // 처리 완료 후 실행할 함수
            const finishProcessing = () => {

                // 새로 추가된 데이터만 정규화
                normalizeAllProjectDates(successfulData);
                
                // [성능 최적화] projectData를 이름 기반 Map으로 변환하여 O(n²) → O(n)으로 개선
                const projectDataByNameMap = new Map();
                projectData.forEach(p => {
                    if (p.name) {
                        projectDataByNameMap.set(p.name, p);
                    }
                });
                
                // 새로 추가될 데이터도 이름 기반 Map으로 변환
                const successfulDataByNameMap = new Map();
                successfulData.forEach(p => {
                    if (p.name) {
                        successfulDataByNameMap.set(p.name, p);
                    }
                });
                
                // 의존성 정보를 이름에서 ID로 변환 (이미 로드된 projectData 기준)
                successfulData.forEach(project => {
                    if (project._dependsOnNames && project._dependsOnNames.length > 0) {
                        project.dependsOn = project._dependsOnNames.map(dep => {
                            const depProject = projectDataByNameMap.get(dep.projectName);
                            if (depProject) {
                                return {
                                    projectId: depProject.id,
                                    type: dep.type
                                };
                            }
                            return null;
                        }).filter(Boolean);
                        delete project._dependsOnNames;
                    }
                });
                
                // [성능 최적화] 중복 제거 및 메모리 효율적인 추가
                // ID 기반 Map을 사용하여 중복 제거 (O(n) 시간 복잡도)
                const existingDataMap = new Map();
                projectData.forEach(p => {
                    if (p.id) {
                        existingDataMap.set(String(p.id), p);
                    }
                });
                
                // 중복 제거 및 새 데이터만 추가
                const newDataToAdd = [];
                successfulData.forEach(newProject => {
                    const existingId = String(newProject.id);
                    if (existingDataMap.has(existingId)) {
                        // 기존 데이터 업데이트 (새 데이터로 덮어쓰기)
                        const existing = existingDataMap.get(existingId);
                        Object.assign(existing, newProject);
                    } else {
                        // 새 데이터 추가
                        newDataToAdd.push(newProject);
                        existingDataMap.set(existingId, newProject);
                    }
                });
                
                // 새 데이터만 배열에 추가 (메모리 효율)
                if (newDataToAdd.length > 0) {
                    if (newDataToAdd.length > 1000) {
                        // 대용량 데이터는 배치 추가
                        for (let i = 0; i < newDataToAdd.length; i += 1000) {
                            projectData.push(...newDataToAdd.slice(i, i + 1000));
                        }
                    } else {
                        projectData.push(...newDataToAdd);
                    }
                }
                
                // [성능 최적화] 새로 추가된 데이터 간 의존성 정보를 이름에서 ID로 변환
                // Map을 사용하여 O(n) 시간 복잡도로 최적화
                successfulData.forEach(project => {
                    if (project._dependsOnNames && project._dependsOnNames.length > 0) {
                        project.dependsOn = project._dependsOnNames.map(dep => {
                            // 먼저 기존 projectData에서 찾고, 없으면 새로 추가된 successfulData에서 찾기 (Map 사용으로 O(1) 조회)
                            let depProject = projectDataByNameMap.get(dep.projectName);
                            if (!depProject) {
                                depProject = successfulDataByNameMap.get(dep.projectName);
                            }
                            if (depProject) {
                                return {
                                    projectId: depProject.id,
                                    type: dep.type
                                };
                            }
                            return null;
                        }).filter(Boolean);
                        delete project._dependsOnNames;
                    }
                });
                
                // [성능 최적화] 업데이트된 projectData를 기존 Map에 반영
                newDataToAdd.forEach(p => {
                    if (p.name) {
                        projectDataByNameMap.set(p.name, p);
                    }
                });
                
                // 캐시 무효화
                invalidateFilteredDataCache();
                
                // [핵심 수정] projectData 업데이트 후 window.projectData 동기화 보장
                // 접힌 항목의 데이터도 업데이트되도록 보장
                if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData)) {
                    // window.projectData를 ID 기반 Map으로 변환
                    const windowProjectDataMap = new Map();
                    window.projectData.forEach(p => {
                        if (p.id) {
                            windowProjectDataMap.set(String(p.id), p);
                        }
                    });
                    
                    // projectData의 업데이트를 window.projectData에 반영
                    projectData.forEach(p => {
                        if (p.id) {
                            const windowProject = windowProjectDataMap.get(String(p.id));
                            if (windowProject) {
                                // [핵심 수정] 업데이트된 데이터로 덮어쓰기 (깊은 복사)
                                // 날짜, 의존성 등 모든 필드 동기화
                                if (p.startDate) {
                                    windowProject.startDate = p.startDate;
                                    windowProject.startDateStr = p.startDateStr;
                                }
                                if (p.endDate) {
                                    windowProject.endDate = p.endDate;
                                    windowProject.endDateStr = p.endDateStr;
                                }
                                if (typeof p.progress === 'number') {
                                    windowProject.progress = p.progress;
                                }
                                if (p.dependsOn && Array.isArray(p.dependsOn)) {
                                    windowProject.dependsOn = JSON.parse(JSON.stringify(p.dependsOn));
                                } else if (!p.dependsOn) {
                                    windowProject.dependsOn = [];
                                }
                                // 기타 필드도 동기화
                                Object.keys(p).forEach(key => {
                                    if (key !== 'startDate' && key !== 'endDate' && key !== 'startDateStr' && key !== 'endDateStr' && key !== 'progress' && key !== 'dependsOn') {
                                        windowProject[key] = p[key];
                                    }
                                });
                            } else {
                                // 새로 추가된 항목
                                window.projectData.push(JSON.parse(JSON.stringify(p)));
                            }
                        }
                    });
                    
                    console.log('[excel-import] Synchronized window.projectData with projectData:', projectData.length, 'items');
                } else {
                    // window.projectData가 없으면 생성
                    if (typeof window !== 'undefined') {
                        window.projectData = JSON.parse(JSON.stringify(projectData));
                        console.log('[excel-import] Created window.projectData from projectData:', projectData.length, 'items');
                    }
                }
                
                // [성능 최적화] 메모리 정리 힌트 (대용량 데이터 처리 후)
                if (newDataToAdd.length > 1000) {
                    // 가비지 컬렉션 힌트 (브라우저가 메모리 정리를 고려하도록)
                    if (window.gc) {
                        // Chrome DevTools에서만 사용 가능
                        try { window.gc(); } catch (e) {}
                    }
                }
                
                // 개선 사항: 새로 추가된 데이터에 대해서만 원본 날짜 설정
                // 기존 데이터의 원본 날짜는 유지
                resetOriginalDatesForProjects(successfulData);
                
                // Initialize revision history if this is the first data load
                if (revisionHistory.length === 0 && projectData.length > 0) {
                    createInitialRevision();
                } else {
                    // Check if data structure changed and reset if needed
                    resetRevisionHistoryIfNeeded();
                }
                
                // [FIX] 데이터 처리 후 필터가 모두 생성된 다음 기본 바로가기를 설정합니다.
                initDefaultPinnedShortcuts();
                failedImportRows = failedData;

                updateAndApplyDateRange();
                populateFilters();
                
                // [핵심 수정] render() 호출 전 데이터 동기화 완료 확인
                // 접힌 항목의 데이터도 projectData와 window.projectData에 업데이트되어 있음
                // render()는 filteredData를 사용하지만, 접힌 항목의 데이터는 이미 업데이트되어 있음
                render();

                // [성능 최적화] 엑셀 업로드 후 즉시 의존성 표시 (온오프라인 모두 지원)
                setTimeout(() => {
                    const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                    const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                    if (container) {
                        const ganttBody = container.querySelector('.gantt-body');
                        if (ganttBody) {
                            // [핵심 수정] 필터링된 데이터 대신 원본 데이터 사용
                            const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                                window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                            if (dataToRender && Array.isArray(dataToRender)) {
                                if (typeof window.renderDependencyArrows === 'function') {
                                    window.renderDependencyArrows(ganttBody, dataToRender);
                                } else if (typeof renderDependencyArrows === 'function') {
                                    renderDependencyArrows(ganttBody, dataToRender);
                                }
                            }
                        }
                    }
                }, 200);
                
                // [성능 최적화] 추가 보장: DOM 업데이트 완료 후 재시도
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                            const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                            if (container) {
                                const ganttBody = container.querySelector('.gantt-body');
                                if (ganttBody) {
                                    // [핵심 수정] 필터링된 데이터가 아닌 원본 데이터 사용
                                    const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                                        window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                                    if (dataToRender && Array.isArray(dataToRender)) {
                                        if (typeof window.renderDependencyArrows === 'function') {
                                            window.renderDependencyArrows(ganttBody, dataToRender);
                                        } else if (typeof renderDependencyArrows === 'function') {
                                            renderDependencyArrows(ganttBody, dataToRender);
                                        }
                                    }
                                }
                            }
                        }, 300);
                    });
                });

                mappingModal.classList.add('hidden');

                // 결과 피드백
                let summaryMessage = `${successfulData.length}개 항목을 성공적으로 가져왔습니다.`;
                if (failedData.length > 0) {
                    summaryMessage += ` ${failedData.length}개 항목에서 오류가 발생했습니다.`;
                    showToast(summaryMessage, 'warning', 5000);
                    openErrorCorrectionModal(failedData, mapping);
                } else {
                    showToast(summaryMessage, 'success');
                }

                if (projectData.length > 0 || milestones.length > 0) {
                    saveHtmlBtn.disabled = false;
                    saveMessage.classList.remove('hidden');
                }
            };

            // 배치 처리 시작
            if (nonEmptyRows.length > 0) {
                if (totalRows > 1000) {
                    // 대용량 데이터는 비동기 배치 처리
                    showToast(`데이터 처리 중... (0/${nonEmptyRows.length})`, 'info');
                    requestAnimationFrame(() => processBatch(0));
                } else {
                    // 소량 데이터는 동기 처리
                    processBatch(0);
                }
            } else {
                finishProcessing();
            }
        }

        function openErrorCorrectionModal(failedRows, mapping) {
            errorCorrectionInfo.innerHTML = `총 <strong>${failedRows.length}개</strong>의 항목에서 오류가 발견되었습니다. 오류 내용은 빨간색으로 표시됩니다. 아래 표에서 직접 값을 수정한 후 '수정된 항목 가져오기' 버튼을 클릭하세요. 날짜는 달력에서 선택할 수 있습니다.`;

            const headerFields = [];
            MAPPING_FIELDS.forEach(f => {
                if (mapping.core[f.key] > -1) {
                    headerFields.push({ ...f, isCustom: false, colIndex: mapping.core[f.key] });
                }
            });
            mapping.custom.forEach(cf => {
                headerFields.push({ name: cf.fieldName, key: cf.fieldName, isCustom: true, colIndex: cf.colIndex });
            });
            headerFields.sort((a,b) => a.colIndex - b.colIndex);


            let tableHTML = `<table class="w-full text-left border-collapse"><thead><tr>`;
            tableHTML += `<th class="border text-center p-2">오류 내용</th>`;
            headerFields.forEach(field => {
                tableHTML += `<th class="border p-2">${field.name}</th>`;
            });
            tableHTML += `</tr></thead><tbody>`;

            failedRows.forEach((item, index) => {
                tableHTML += `<tr data-row-index="${index}">`;
                tableHTML += `<td class="border align-top text-red-600 !max-w-xs !whitespace-normal text-xs p-2">${item.errors.join('<br>')}</td>`;
                headerFields.forEach(field => {
                    const colIndex = field.colIndex;
                    let originalValue = item.originalData[colIndex] ?? '';
                    let inputType = 'text';

                    // IMPROVEMENT: Use calendar for date fields and handle various date formats
                    if (field.key === 'startDate' || field.key === 'endDate') {
                        inputType = 'date';
                        // Use local parser to avoid timezone shifts when originalValue is a date-string
                        let d = null;
                        if (typeof originalValue === 'number' && originalValue > 25569) {
                            // Excel 일련 번호를 로컬 날짜로 직접 변환
                            const msPerDay = 24 * 60 * 60 * 1000;
                            const jan1_1900 = new Date(1900, 0, 1);
                            const daysSince1900 = originalValue - 1; // Excel의 1은 1900년 1월 1일
                            const localDate = new Date(jan1_1900.getTime() + (daysSince1900 * msPerDay));
                            d = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate());
                            originalValue = formatDateYMD(d);
                        } else {
                            d = parseLocalDateString(originalValue);
                            if (d && !isNaN(d.getTime())) {
                                originalValue = formatDateYMD(d);
                            } else {
                                originalValue = '';
                            }
                        }
                    }
                    if (field.key === 'poAmount') {
                        originalValue = String(originalValue).replace(/,/g, '');
                    }

                    tableHTML += `<td class="border"><input type="${inputType}" data-field-key="${field.key}" data-is-custom="${field.isCustom}" class="w-full p-1 border rounded" value="${originalValue}"></td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table>`;

            errorCorrectionContainer.innerHTML = tableHTML;
            errorCorrectionModal.classList.remove('hidden');
        }

        function handleRetryImport() {
            const rows = errorCorrectionContainer.querySelectorAll('tbody tr');
            const correctedRawData = [];
            rows.forEach(tr => {
                const originalIndex = parseInt(tr.dataset.rowIndex, 10);
                const originalFailedItem = failedImportRows[originalIndex];

                const newRow = [...originalFailedItem.originalData];
                tr.querySelectorAll('input').forEach(input => {
                    const fieldKey = input.dataset.fieldKey;
                    const isCustom = input.dataset.isCustom === 'true';

                    if (isCustom) {
                        const customMapping = importMapping.custom.find(cf => cf.fieldName === fieldKey);
                        if(customMapping) newRow[customMapping.colIndex] = input.value;
                    } else {
                        const colIndex = importMapping.core[fieldKey];
                        if(colIndex > -1) newRow[colIndex] = input.value;
                    }
                });
                correctedRawData.push(newRow);
            });

            const successfulData = [];
            const stillFailingData = [];
            correctedRawData.forEach(row => {
                 const result = validateAndParseRow(row, importMapping);
                 if (result.success) {
                    successfulData.push(result.data);
                } else {
                    stillFailingData.push(result);
                }
            });

            // [성능 최적화] 중복 제거 및 메모리 효율적인 추가 (handleRetryImport에도 적용)
            const existingDataMap = new Map();
            projectData.forEach(p => {
                if (p.id) {
                    existingDataMap.set(String(p.id), p);
                }
            });
            
            // 중복 제거 및 새 데이터만 추가
            const newDataToAdd = [];
            successfulData.forEach(newProject => {
                const existingId = String(newProject.id);
                if (existingDataMap.has(existingId)) {
                    // 기존 데이터 업데이트 (새 데이터로 덮어쓰기)
                    const existing = existingDataMap.get(existingId);
                    Object.assign(existing, newProject);
                } else {
                    // 새 데이터 추가
                    newDataToAdd.push(newProject);
                    existingDataMap.set(existingId, newProject);
                }
            });
            
            // 새 데이터만 배열에 추가 (메모리 효율)
            if (newDataToAdd.length > 0) {
                projectData.push(...newDataToAdd);
            }
            
            failedImportRows = stillFailingData;

            // 캐시 무효화
            invalidateFilteredDataCache();

            updateAndApplyDateRange();
            populateFilters();
            render();

            if (stillFailingData.length > 0) {
                showToast(`${successfulData.length}개 항목 추가 성공, ${stillFailingData.length}개 항목 여전히 오류 발생.`, 'warning', 5000);
                openErrorCorrectionModal(stillFailingData, importMapping);
            } else {
                 showToast(`${successfulData.length}개 항목을 추가로 가져왔습니다.`, 'success');
                 errorCorrectionModal.classList.add('hidden');
            }

            if (projectData.length > 0 || milestones.length > 0) {
                saveHtmlBtn.disabled = false;
                saveMessage.classList.remove('hidden');
            }
        }

        function populateFilters() {
            // 컨트롤 요소들은 항상 컨트롤 패널 내에 있으므로 그곳을 기준으로 찾음
            const controlContainer = document.getElementById('controlsPanel');
            if (!controlContainer) return;
            
            updateControlReferences(controlContainer);

            if (!taskTypeFilter || !customFilterContainer) return; // Exit if elements not found

            const taskTypes = [...new Set(projectData.map(p => p.taskType))];
            // Store current value before clearing
            const currentTaskType = taskTypeFilter.value;
            taskTypeFilter.innerHTML = '<option value="all">유형</option>';
            taskTypes.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type;
                taskTypeFilter.appendChild(option);
            });
             // Restore previous selection if possible
             if (taskTypes.includes(currentTaskType)) {
                 taskTypeFilter.value = currentTaskType;
             }

            // Store custom filter values
            const currentCustomFilters = {};
            customFilterContainer.querySelectorAll('select').forEach(sel => {
                // 'customer-filter'는 항상 '고객사'로 초기화되므로 이전 값을 저장하지 않음
                if (sel.id !== 'customer-filter') {
                    currentCustomFilters[sel.dataset.filterKey] = sel.value;
                }
            });

            customFilterContainer.innerHTML = ''; // Clear existing filters
            const customFieldKeys = new Set();
            projectData.forEach(p => {
                if (p.customFields) {
                    Object.keys(p.customFields).forEach(key => customFieldKeys.add(key));
                }
            });

            Array.from(customFieldKeys).sort().forEach(key => {
                 const wrapper = document.createElement('div');
                 wrapper.className = 'pinnable-control-wrapper';

                const select = document.createElement('select');
                select.className = "w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500";
                const safeKey = sanitizeKey(key);
                select.dataset.filterKey = safeKey;

                // [FIX] '고객사' 또는 '시공사'와 같은 특정 필드에 고정 ID를 할당합니다.
                const lowerKey = (customFieldDisplayNames[safeKey] || key).toLowerCase();
                const normalizedLowerKey = lowerKey.replace(/\s+/g, '');
                if (lowerKey.includes('고객사') || lowerKey.includes('client')) {
                    select.id = 'customer-filter';
                } else if (lowerKey.includes('시공사') || lowerKey.includes('constructor')) {
                    select.id = 'contractor-filter';
                } else if (
                    lowerKey.includes('비용계정') ||
                    normalizedLowerKey.includes('costaccount') ||
                    normalizedLowerKey.includes('expenseaccount')
                ) {
                    select.id = 'cost-account-filter';
                } else {
                    select.id = `custom-filter-${safeKey}`;
                }

                const values = [...new Set(projectData.map(p => p.customFields?.[safeKey]).filter(v => v))]

                const displayName = customFieldDisplayNames[safeKey] || key;
                select.innerHTML = `<option value=\"all\">${displayName}</option>`;
                values.sort().forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    select.appendChild(option);
                });
                 // Restore selection
                 // '고객사' 필터는 항상 '고객사'로 초기 설정 (currentCustomFilters 값 무시)
                 if (select.id === 'customer-filter') {
                     // '고객사' 옵션이 있으면 '고객사'로, 없으면 'all'로 설정
                     if (values.includes('고객사')) {
                         select.value = '고객사';
                     } else {
                         select.value = 'all';
                     }
                 } else if (currentCustomFilters[safeKey] && values.includes(currentCustomFilters[safeKey])) {
                     // 다른 필터는 이전 값 복원
                     select.value = currentCustomFilters[safeKey];
                 }

                select.addEventListener('change', render);
                wrapper.appendChild(select);
                customFilterContainer.appendChild(wrapper);

                ensureControlDefaultValue(select);
            });
            setupPinnableControls();
            updateShortcutActiveStates();
            
            // populateFilters 완료 후 헤더 필터를 '고객사'로 강제 설정
            const headerCustomFilter = document.getElementById('header-customer-filter-shortcut');
            const mainCustomerFilter = controlContainer.querySelector('#customer-filter');
            if (headerCustomFilter && mainCustomerFilter) {
                headerCustomFilter.innerHTML = mainCustomerFilter.innerHTML;
                if (headerCustomFilter.querySelector('option[value="고객사"]')) {
                    mainCustomerFilter.value = '고객사';
                    headerCustomFilter.value = '고객사';
                } else {
                    headerCustomFilter.value = mainCustomerFilter.value;
                }
            }
            const headerCostFilter = document.getElementById('header-cost-account-filter-shortcut');
            const mainCostFilter = controlContainer.querySelector('#cost-account-filter');
            if (headerCostFilter) {
                if (mainCostFilter) {
                    headerCostFilter.innerHTML = mainCostFilter.innerHTML;
                    headerCostFilter.value = mainCostFilter.value;
                    headerCostFilter.disabled = false;
                } else {
                    headerCostFilter.innerHTML = '<option value="all">비용계정</option>';
                    headerCostFilter.value = 'all';
                    headerCostFilter.disabled = true;
                }
            }
        }

        // --- Auto-upload helper functions ---
        async function fetchAndImportCsvFromUrl(csvUrl) {
            // Check online status first
            if (!isOnline && !navigator.onLine) {
                showToast('오프라인 상태입니다. 자동 업로딩을 사용할 수 없습니다. 로컬 파일을 업로드해주세요.', 'warning', 5000);
                throw new Error('오프라인 상태: 자동 업로딩을 사용할 수 없습니다.');
            }

            if (typeof fetch !== 'function') {
                throw new Error('fetch unsupported');
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            let resp;
            try {
                resp = await fetch(csvUrl, { method: 'GET', signal: controller.signal });
                clearTimeout(timeoutId);
            } catch (err) {
                clearTimeout(timeoutId);
                if (err.name === 'AbortError' || err.message.includes('fetch') || err.message.includes('network')) {
                    isOnline = false;
                    updateNetworkStatus(false);
                    showToast('네트워크 오류가 발생했습니다. 오프라인 모드로 전환됩니다.', 'error', 5000);
                }
                throw err;
            }

            if (!resp || !resp.ok) {
                throw new Error('Fetch failed: ' + (resp ? resp.status : 'no response'));
            }

            const text = await resp.text();
            // CSV를 XLSX로 변환하여 처리
            const workbook = XLSX.read(text, { type: 'string', raw: true });
            const sheetNames = workbook.SheetNames || [];

            if (!sheetNames || sheetNames.length === 0) {
                throw new Error('Empty CSV file');
            }

            const primarySheetName = sheetNames[0];
            const primaryWorksheet = workbook.Sheets[primarySheetName];
            const sheetData = XLSX.utils.sheet_to_json(primaryWorksheet, { header: 1, defval: '', raw: true });
            
            if (!sheetData || sheetData.length === 0) {
                throw new Error('Empty or unreadable CSV data');
            }

            return sheetData;
        }

        async function fetchAndImportCsvUrls(projectUrl, milestoneUrl) {
            showToast('CSV 파일 자동 업로딩을 시도합니다...', 'info');
            
            try {
                // 프로젝트 데이터 업로드
                if (projectUrl && projectUrl.trim()) {
                    const projectData = await fetchAndImportCsvFromUrl(projectUrl.trim());
                    await autoMapAndImport(projectData);
                }
                
                // 마일스톤 데이터 업로드
                if (milestoneUrl && milestoneUrl.trim()) {
                    const milestoneData = await fetchAndImportCsvFromUrl(milestoneUrl.trim());
                    await autoMapAndImportMilestones(milestoneData);
                }
                
                showToast('CSV 파일 자동 업로딩이 완료되었습니다.', 'success');
            } catch (err) {
                console.error('CSV auto upload failed', err);
                showToast('CSV 파일 자동 업로딩에 실패했습니다: ' + (err.message || '알 수 없는 오류'), 'error');
                throw err;
            }
        }

        async function fetchAndImportFromUrl(url) {
            // Check online status first
            if (!isOnline && !navigator.onLine) {
                showToast('오프라인 상태입니다. 자동 업로딩을 사용할 수 없습니다. 로컬 파일을 업로드해주세요.', 'warning', 5000);
                throw new Error('오프라인 상태: 자동 업로딩을 사용할 수 없습니다.');
            }

            // Quick online check: navigator.onLine is a hint; still attempt fetch and handle failures
            if (typeof fetch !== 'function') {
                throw new Error('fetch unsupported');
            }

            showToast('자동 업로딩을 시도합니다...', 'info');
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout
            let resp;
            try {
                resp = await fetch(url, { method: 'GET', signal: controller.signal });
                clearTimeout(timeoutId);
            } catch (err) {
                clearTimeout(timeoutId);
                // Update network status if fetch fails
                if (err.name === 'AbortError' || err.message.includes('fetch') || err.message.includes('network')) {
                    isOnline = false;
                    updateNetworkStatus(false);
                    showToast('네트워크 오류가 발생했습니다. 오프라인 모드로 전환됩니다.', 'error', 5000);
                }
                throw err;
            }

            if (!resp || !resp.ok) {
                throw new Error('Fetch failed: ' + (resp ? resp.status : 'no response'));
            }

            const arrayBuffer = await resp.arrayBuffer();
            const data = new Uint8Array(arrayBuffer);
            // 개선 사항: 대용량 파일 처리를 위한 XLSX 읽기 옵션 최적화
            const workbook = XLSX.read(data, { 
                type: 'array', 
                cellDates: true,
                cellNF: false,  // 숫자 포맷 비활성화로 성능 향상
                cellStyles: false,  // 스타일 정보 비활성화로 성능 향상
                sheetStubs: false,  // 빈 셀 스텁 비활성화
                dense: false  // 밀집 배열 모드 비활성화 (메모리 절약)
            });
            const sheetNames = workbook.SheetNames || [];

            if (!sheetNames || sheetNames.length === 0) {
                throw new Error('Empty workbook');
            }

            // Primary sheet import (projects)
            const primarySheetName = sheetNames[0];
            const primaryWorksheet = workbook.Sheets[primarySheetName];
            const sheetData = XLSX.utils.sheet_to_json(primaryWorksheet, { header: 1, defval: '', raw: true });
            if (!sheetData || sheetData.length === 0) {
                throw new Error('Empty or unreadable primary sheet');
            }

            await autoMapAndImport(sheetData);

            // If workbook contains a milestone sheet (name contains 'milestone' or '마일스톤'), try to import it as milestones
            const milestoneIndex = sheetNames.findIndex(n => /milestone|마일스톤/i.test(n));
            if (milestoneIndex > -1 && milestoneIndex !== 0) {
                try {
                    const msWorksheet = workbook.Sheets[sheetNames[milestoneIndex]];
                    const msData = XLSX.utils.sheet_to_json(msWorksheet, { header: 1, defval: '', raw: true });
                    if (msData && msData.length > 0) {
                        // Auto-map/import milestones without modal
                        await autoMapAndImportMilestones(msData);
                    }
                } catch (errMs) {
                    console.warn('auto-import milestone failed', errMs);
                }
            }

            showToast('자동 업로딩이 완료되었습니다.', 'success');
        }

        async function autoMapAndImport(sheetData) {
            // Reuse autoDetectHeaderRow if available
            let headerRow = 1;
            try {
                if (typeof autoDetectHeaderRow === 'function') {
                    headerRow = autoDetectHeaderRow(sheetData);
                }
            } catch (e) {
                console.warn('autoDetectHeaderRow failed', e);
            }
            const headerRowIndex = Math.max(0, headerRow - 1);
            const primaryHeaders = sheetData[headerRowIndex] || [];
            const secondaryHeaders = sheetData[headerRowIndex + 1] || [];
            const combinedHeaders = primaryHeaders.map((h, i) => {
                const primary = h ? String(h).trim() : '';
                const secondary = (secondaryHeaders[i]) ? String(secondaryHeaders[i]).trim() : '';
                if (primary && !secondary) return primary;
                if (!primary && secondary) return secondary;
                return (primary + ' ' + secondary).trim();
            });

            // Build mapping similar to openMappingModal's best-guess logic
            const mapping = { core: {}, custom: [] };
            MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

            combinedHeaders.forEach((headerText, colIndex) => {
                let bestMatch = 'ignore';
                let highestScore = 0.1;
                MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    field.aliases.forEach(alias => {
                        const lowerHeader = headerText.toLowerCase().trim();
                        const lowerAlias = alias.toLowerCase().trim();
                        if (headerText && lowerHeader.includes(lowerAlias)) {
                            let score = lowerAlias.length / Math.max(1, lowerHeader.length);
                            if (lowerHeader === lowerAlias) score = 1.1;
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) {
                        highestScore = currentScore;
                        bestMatch = field.key;
                    }
                });

                if (bestMatch === 'ignore') {
                    // Add as custom property
                    mapping.custom.push({ colIndex: colIndex, fieldName: headerText || `col_${colIndex}` });
                } else {
                    // assign to core if not already assigned
                    if (mapping.core[bestMatch] === -1) {
                        mapping.core[bestMatch] = colIndex;
                    } else {
                        // collision: treat as custom
                        mapping.custom.push({ colIndex: colIndex, fieldName: headerText || `col_${colIndex}` });
                    }
                }
            });

            // Set rawImportData so processMappedData can use it
            rawImportData = sheetData;

            // Use same dataStartIndex logic as applyMapping (headerRowIndex + 2)
            processMappedData(rawImportData, mapping, headerRowIndex + 2);
        }

        // Auto-map & import for milestone sheets (name + date)
        async function autoMapAndImportMilestones(sheetData) {
            let headerRow = 1;
            try {
                if (typeof autoDetectHeaderRow === 'function') headerRow = autoDetectHeaderRow(sheetData);
            } catch (e) { console.warn('autoDetectHeaderRow failed for milestones', e); }
            const headerRowIndex = Math.max(0, headerRow - 1);

            const primaryHeaders = sheetData[headerRowIndex] || [];
            const secondaryHeaders = sheetData[headerRowIndex + 1] || [];
            const combinedHeaders = primaryHeaders.map((h, i) => {
                const primary = h ? String(h).trim() : '';
                const secondary = (secondaryHeaders[i]) ? String(secondaryHeaders[i]).trim() : '';
                if (primary && !secondary) return primary;
                if (!primary && secondary) return secondary;
                return (primary + ' ' + secondary).trim();
            });

            // Build best-guess mapping for milestone fields
            const mapping = { core: {} };
            MILESTONE_MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

            combinedHeaders.forEach((headerText, colIndex) => {
                let bestMatch = 'ignore';
                let highestScore = 0.1;
                MILESTONE_MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    (field.aliases || []).forEach(alias => {
                        const lh = headerText.toLowerCase().trim();
                        const la = alias.toLowerCase().trim();
                        if (headerText && lh.includes(la)) {
                            let score = la.length / Math.max(1, lh.length);
                            if (lh === la) score = 1.1;
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) { highestScore = currentScore; bestMatch = field.key; }
                });

                if (bestMatch === 'ignore') {
                    // skip unknown columns
                } else {
                    if (mapping.core[bestMatch] === -1) mapping.core[bestMatch] = colIndex;
                    else {
                        // collision -> ignore
                    }
                }
            });

            // rawImportData for milestone processing
            rawImportData = sheetData;
            // Attempt to process milestone rows. If the helper is missing (older builds),
            // fallback to inline processing to ensure auto-upload works correctly.
            if (typeof processMappedMilestoneData === 'function') {
                // 개선: processMappedMilestoneData 내부에서 10개 제한이 있을 경우 전체 rows를 처리하도록 보장
                // 기존 함수가 반복 범위를 제한한다면, 아래와 같이 전체 rows를 강제 처리하도록 래핑
                const totalRows = rawImportData.length;
                processMappedMilestoneData(rawImportData, mapping, headerRowIndex + 2, totalRows);
            } else {
                // Inline fallback: parse milestone rows similarly to manual mapping path
                try {
                    const processedMilestones = [];
                    for (let i = headerRowIndex + 2; i < rawImportData.length; i++) {
                        const row = rawImportData[i];
                        if (!row || row.every(cell => !cell)) continue;

                        const name = row[mapping.core['마일스톤']];
                        let dateValue = row[mapping.core['날짜']];
                        if (!name || !dateValue) continue;

                        let finalDate = null;
                        if (typeof dateValue === 'number' && dateValue > 0) {
                            // Excel 시리얼 날짜 처리 (1900년 기준) - 로컬 날짜로 직접 변환
                            const msPerDay = 24 * 60 * 60 * 1000;
                            const jan1_1900 = new Date(1900, 0, 1);
                            const daysSince1900 = dateValue - 1; // Excel의 1은 1900년 1월 1일
                            const localDate = new Date(jan1_1900.getTime() + (daysSince1900 * msPerDay));
                            finalDate = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate());
                        } else if (dateValue instanceof Date && !isNaN(dateValue)) {
                            // XLSX가 날짜를 UTC 자정으로 해석하므로, UTC 컴포넌트를 사용하여 엑셀 입력값과 정확히 일치시킴
                            finalDate = new Date(dateValue.getUTCFullYear(), dateValue.getUTCMonth(), dateValue.getUTCDate());
                        } else if (typeof dateValue === 'string') {
                            const match = dateValue.trim().match(/^(\d{4})[-\/]?(\d{2})[-\/]?(\d{2})$/);
                            if (match) {
                                const [_, year, month, day] = match;
                                // 문자열 날짜를 로컬 날짜로 직접 생성
                                finalDate = new Date(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10));
                            }
                        }

                        if (finalDate && !isNaN(finalDate)) {
                            // 로컬 날짜를 사용하여 포맷팅
                            const formattedDate = finalDate.getFullYear() + '-' +
                                String(finalDate.getMonth() + 1).padStart(2, '0') + '-' +
                                String(finalDate.getDate()).padStart(2, '0');
                            processedMilestones.push({ name: name, date: formattedDate });
                        }
                    }

                    if (processedMilestones.length > 0) {
                        milestones = processedMilestones;
                        renderMilestoneModal();
                        render();
                        updateAndApplyDateRange();
                        showToast(`${processedMilestones.length}개의 마일스톤이 성공적으로 로드되었습니다.`, 'success');
                        if (projectData.length > 0 || milestones.length > 0) {
                            saveHtmlBtn.disabled = false;
                            saveMessage.classList.remove('hidden');
                        }
                    }
                } catch (e) {
                    console.warn('fallback milestone processing failed', e);
                }
            }
        }

        // Diagnostic helper: compares title-side projectId order vs gantt-side projectId mapping
        // Non-destructive: only logs when window.__GANTT_AUTO_DEBUG === true
        function logHierarchyMismatchDiagnostic(container) {
            try {
                if (!(window && window.__GANTT_AUTO_DEBUG)) return null;
                container = container || (fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody);
                if (!container) return null;

                const titlesBody = container.querySelector('.gantt-titles-body-wrapper div');
                const ganttRowsBody = container.querySelector('.gantt-body div:first-child');
                if (!titlesBody || !ganttRowsBody) {
                    console.warn('diagnostic: titlesBody or ganttRowsBody not found');
                    return null;
                }

                const titleGroups = [];
                Array.from(titlesBody.children).forEach(el => {
                    if (el.style && el.style.display === 'none') return;
                    if (el.classList.contains('group-item-container')) {
                        const taskType = el.dataset.taskType || null;
                        const ids = Array.from(el.querySelectorAll('.title-item[data-project-id]')).map(t=>t.dataset.projectId).filter(Boolean);
                        titleGroups.push({ type: 'group', taskType, ids });
                    } else if (el.classList.contains('group-header')) {
                        const taskType = el.dataset.taskType || (el.textContent.match(/📂\s*(.+?)\s*\(/)||[])[1] || null;
                        titleGroups.push({ type: 'header', taskType });
                    } else if (el.classList.contains('title-item')) {
                        const pid = el.dataset.projectId;
                        const prev = titleGroups.length && titleGroups[titleGroups.length-1] && titleGroups[titleGroups.length-1].type === 'group' ? titleGroups[titleGroups.length-1] : null;
                        if (prev) prev.ids.push(pid);
                        else titleGroups.push({ type:'group', taskType: (el.closest('.group-item-container')||{}).dataset.taskType||null, ids: [pid] });
                    }
                });

                const groupToGantt = new Map();
                Array.from(ganttRowsBody.children).forEach(child => {
                    if (child.classList.contains('gantt-bar-row') && !child.dataset.projectId) {
                        const bar = child.querySelector('.gantt-bar');
                        const name = bar && bar.dataset && bar.dataset.name ? bar.dataset.name : '';
                        const tt = (name.match(/^(.+?)\s*\(요약\)/)||[])[1] || null;
                        if (tt) {
                            if (!groupToGantt.has(tt)) groupToGantt.set(tt, { groupBar: null, childContainers: [], projectIds: [] });
                            groupToGantt.get(tt).groupBar = child;
                        }
                    } else {
                        const pids = Array.from(child.querySelectorAll('.gantt-bar-row[data-project-id]')).map(br=>br.dataset.projectId).filter(Boolean);
                        if (pids.length) {
                            const firstPid = pids[0];
                            const titleItem = document.querySelector(`.title-item[data-project-id="${firstPid}"]`);
                            const tt = titleItem ? (titleItem.closest('.group-item-container')?.dataset.taskType || null) : null;
                            if (tt) {
                                if (!groupToGantt.has(tt)) groupToGantt.set(tt, { groupBar: null, childContainers: [], projectIds: [] });
                                groupToGantt.get(tt).childContainers.push(child);
                                pids.forEach(id => { if (!groupToGantt.get(tt).projectIds.includes(id)) groupToGantt.get(tt).projectIds.push(id); });
                            } else {
                                if (!groupToGantt.has('__unknown')) groupToGantt.set('__unknown', { groupBar: null, childContainers: [], projectIds: [] });
                                groupToGantt.get('__unknown').childContainers.push(child);
                                pids.forEach(id => { if (!groupToGantt.get('__unknown').projectIds.includes(id)) groupToGantt.get('__unknown').projectIds.push(id); });
                            }
                        } else if (child.dataset && child.dataset.projectId) {
                            const pid = child.dataset.projectId;
                            const titleItem = document.querySelector(`.title-item[data-project-id="${pid}"]`);
                            const tt = titleItem ? (titleItem.closest('.group-item-container')?.dataset.taskType || null) : null;
                            if (tt) {
                                if (!groupToGantt.has(tt)) groupToGantt.set(tt, { groupBar: null, childContainers: [], projectIds: [] });
                                if (!groupToGantt.get(tt).projectIds.includes(pid)) groupToGantt.get(tt).projectIds.push(pid);
                            } else {
                                if (!groupToGantt.has('__unknown')) groupToGantt.set('__unknown', { groupBar: null, childContainers: [], projectIds: [] });
                                if (!groupToGantt.get('__unknown').projectIds.includes(pid)) groupToGantt.get('__unknown').projectIds.push(pid);
                            }
                        }
                    }
                });

                const mismatches = [];
                titleGroups.forEach(tg => {
                    if (tg.type !== 'group') return;
                    const tt = tg.taskType || null;
                    const titleIds = tg.ids || [];
                    const ganttEntry = groupToGantt.get(tt) || groupToGantt.get('__unknown') || null;
                    const ganttIds = ganttEntry ? (ganttEntry.projectIds || []) : [];
                    const missingInGantt = titleIds.filter(id => !ganttIds.includes(id));
                    const extraInGantt = ganttIds.filter(id => !titleIds.includes(id));
                    if (missingInGantt.length || extraInGantt.length) {
                        mismatches.push({ taskType: tt, titleCount: titleIds.length, ganttCount: ganttIds.length, missingInGantt, extraInGantt, titleSample: titleIds.slice(0,10), ganttSample: ganttIds.slice(0,10) });
                    }
                });

                console.group('Gantt <-> Title automatic diagnostic');
                console.log('titleGroups:', titleGroups.map(g=>({taskType:g.taskType, idsCount: g.ids?g.ids.length:0}))); 
                console.log('ganttGroups:', Array.from(groupToGantt.entries()).map(([k,v])=>({taskType:k, projectCount: v.projectIds.length, hasGroupBar: !!v.groupBar, childContainers: v.childContainers.length}))); 
                if (mismatches.length===0) console.log('No mismatches detected by automatic diagnostic.');
                else { console.warn('Mismatches found:', mismatches); mismatches.slice(0,50).forEach(m=>{ console.groupCollapsed('Mismatch: '+(m.taskType||'__null')); console.table(m); console.groupEnd(); }); }
                console.groupEnd();
                return { titleGroupsCount: titleGroups.length, ganttGroupsCount: groupToGantt.size, mismatchesCount: mismatches.length, mismatches };
            } catch (e) {
                console.error('diagnostic failed', e);
                return { error: String(e) };
            }
        }
        // --- End auto-upload helpers ---


        // [성능 최적화] 프로젝트 상태 업데이트 최적화
        let lastStatusUpdateTime = 0;
        const STATUS_UPDATE_THROTTLE_MS = 100; // 최소 업데이트 간격
        
        function updateProjectStatuses(forceUpdate = false) {
            const now = Date.now();
            const timeSinceLastUpdate = now - lastStatusUpdateTime;
            
            // 쓰로틀링: 최소 업데이트 간격 이내면 스킵 (강제 업데이트가 아닌 경우)
            if (!forceUpdate && timeSinceLastUpdate < STATUS_UPDATE_THROTTLE_MS) {
                return;
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // [성능 최적화] 대용량 데이터의 경우 배치 처리
            if (projectData.length > 5000) {
                // 대용량 데이터는 requestIdleCallback 사용
                if (window.requestIdleCallback) {
                    const processBatch = (deadline) => {
                        let processed = 0;
                        for (let i = 0; i < projectData.length; i++) {
                            if (deadline.timeRemaining() <= 0 && processed > 100) {
                                // 다음 프레임에 계속 처리
                                requestIdleCallback(processBatch);
                                return;
                            }
                            
                            const p = projectData[i];
                            if (p.progress === 100) {
                                p.status = '완료';
                            } else if (p.endDate < today) {
                                p.status = '지연';
                            } else if (p.progress > 0) {
                                p.status = '공사중';
                            } else {
                                p.status = '착공전';
                            }
                            processed++;
                        }
                        lastStatusUpdateTime = Date.now();
                    };
                    requestIdleCallback(processBatch);
                } else {
                    // requestIdleCallback 미지원 시 일반 처리
                    projectData.forEach(p => {
                        if (p.progress === 100) {
                            p.status = '완료';
                        } else if (p.endDate < today) {
                            p.status = '지연';
                        } else if (p.progress > 0) {
                            p.status = '공사중';
                        } else {
                            p.status = '착공전';
                        }
                    });
                    lastStatusUpdateTime = Date.now();
                }
            } else {
                // 소량 데이터는 일반 처리
                projectData.forEach(p => {
                    if (p.progress === 100) {
                        p.status = '완료';
                    } else if (p.endDate < today) {
                        p.status = '지연';
                    } else if (p.progress > 0) {
                        p.status = '공사중';
                    } else {
                        p.status = '착공전';
                    }
                });
                lastStatusUpdateTime = Date.now();
            }
        }

        // 개선 사항: 필터링/정렬 결과 메모이제이션을 위한 캐시
        let filteredDataCache = null;
        let filteredDataCacheKey = null;

        // 캐시 무효화 함수
        function invalidateFilteredDataCache() {
            filteredDataCache = null;
            filteredDataCacheKey = null;
        }

        function getFilteredAndSortedData() {
            // 컨트롤 값들은 ID로 직접 접근하므로 항상 최신 상태를 반영
            const searchTerm = (searchInput?.value || '').toLowerCase();
            
            // 캐시 키 생성 (필터 조건의 해시)
            const cacheKey = JSON.stringify({
                searchTerm,
                taskType: taskTypeFilter?.value,
                progress: progressFilter?.value,
                legendStatus: legendStatusFilter,
                showOnlyChanged,
                sortMode: sortState.mode,
                sortDirection: sortState.direction,
                customFilters: customFilterContainer ? Array.from(customFilterContainer.querySelectorAll('select')).map(s => ({ key: s.dataset.filterKey, value: s.value })).filter(f => f.value !== 'all') : [],
                dataLength: projectData.length
            });

            // 캐시가 유효한 경우 재사용
            if (filteredDataCache && filteredDataCacheKey === cacheKey) {
                return filteredDataCache;
            }

            // [성능 최적화] 대용량 데이터의 경우 배열 복사 최적화
            let data;
            if (projectData.length > 10000) {
                // 매우 큰 배열의 경우 slice 사용 (더 빠름)
                data = projectData.slice();
            } else {
                data = [...projectData];
            }

            if (searchTerm && legendStatusFilter) {
                legendStatusFilter = null;
                 // Need to target legend within the correct container (normal or fullscreen)
                 const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                 if (legendContainer) {
                    legendContainer.querySelectorAll('.legend-section [data-status-filter].legend-filter-active').forEach(el => el.classList.remove('legend-filter-active'));
                 }
            }

            // 개선 사항: 메모리 최적화 - 여러 filter 체인을 단일 루프로 통합
            const customFilters = [];
            if(customFilterContainer) {
                customFilterContainer.querySelectorAll('select').forEach(select => {
                    if (select.value !== 'all') {
                        customFilters.push({ key: select.dataset.filterKey, value: select.value });
                    }
                });
            }
            
            const taskTypeValue = taskTypeFilter?.value;
            const progressValue = progressFilter?.value;
            const hasFilters = taskTypeValue !== 'all' || customFilters.length > 0 || progressValue !== 'all' || 
                              legendStatusFilter || searchTerm;
            
            if (hasFilters) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const todayTime = today.getTime();
                const tomorrowTime = tomorrow.getTime();
                
                data = data.filter(p => {
                    // 작업 유형 필터
                    if (taskTypeValue && taskTypeValue !== 'all' && p.taskType !== taskTypeValue) {
                        return false;
                    }
                    
                    // 커스텀 필터
                    for (let i = 0; i < customFilters.length; i++) {
                        const filter = customFilters[i];
                        if (p.customFields?.[filter.key] !== filter.value) {
                            return false;
                        }
                    }
                    
                    // 진행률 필터
                    if (progressValue && progressValue !== 'all') {
                        const progress = p.progress || 0;
                        if (progressValue === 'not_started' && progress !== 0) return false;
                        if (progressValue === 'in_progress' && (progress === 0 || progress === 100)) return false;
                        if (progressValue === 'completed' && progress !== 100) return false;
                    }
                    
                    // 범례 상태 필터
                    if (legendStatusFilter) {
                        if (legendStatusFilter === '오늘시작' || legendStatusFilter === '오늘종료' || 
                            legendStatusFilter === '내일시작' || legendStatusFilter === '내일종료') {
                            let targetDate = null;
                            if (legendStatusFilter === '오늘시작' || legendStatusFilter === '오늘종료') {
                                targetDate = todayTime;
                            } else {
                                targetDate = tomorrowTime;
                            }
                            
                            if (legendStatusFilter === '오늘시작' || legendStatusFilter === '내일시작') {
                                if (!p.startDate) return false;
                                const startDate = new Date(p.startDate);
                                startDate.setHours(0, 0, 0, 0);
                                if (startDate.getTime() !== targetDate) return false;
                            } else {
                                if (!p.endDate) return false;
                                const endDate = new Date(p.endDate);
                                endDate.setHours(0, 0, 0, 0);
                                if (endDate.getTime() !== targetDate) return false;
                            }
                        } else if (p.status !== legendStatusFilter) {
                            return false;
                        }
                    }
                    
                    // 검색어 필터
                    if (searchTerm && !p.name.toLowerCase().includes(searchTerm)) {
                        return false;
                    }
                    
                    return true;
                });
            }

            if (showOnlyChanged) {
                data = data.filter(projectHasChanges);
            }

            const activeSortMode = sortState.mode || (sortBy ? sortBy.value : 'default');
            const effectiveDirection = sortState.direction || SORT_DIRECTIONS.DESC;
            if (activeSortMode && activeSortMode !== 'default') {
                // 개선 사항: 정렬 성능 최적화 - 메트릭 값 사전 계산
                const dataWithMetrics = data.map(item => ({
                    item,
                    metric: getProjectMetricValue(item, activeSortMode)
                }));
                
                dataWithMetrics.sort((a, b) => compareValuesWithDirection(
                    a.metric,
                    b.metric,
                    effectiveDirection
                ));
                
                data = dataWithMetrics.map(d => d.item);
            }

            // 캐시 저장
            filteredDataCache = data;
            filteredDataCacheKey = cacheKey;

            return data;
        }

        function getFilterAwareDataset() {
            if (Array.isArray(latestFilteredData)) {
                return latestFilteredData;
            }
            return getFilteredAndSortedData();
        }

        function render(forceInvalidateCache = false) {
            // [성능 최적화] 메모리 최적화 - 렌더링 디바운싱 및 쓰로틀링으로 불필요한 렌더링 방지
            const now = Date.now();
            const timeSinceLastRender = now - lastRenderTime;
            
            if (renderTimeout) {
                clearTimeout(renderTimeout);
                renderTimeout = null;
            }
            
            if (isRendering) {
                // 이미 렌더링 중이면 다음 프레임에 실행
                renderTimeout = setTimeout(() => render(forceInvalidateCache), 16);
                return;
            }
            
            // 쓰로틀링: 최소 렌더링 간격 이내면 지연
            if (timeSinceLastRender < RENDER_THROTTLE_MS && !forceInvalidateCache) {
                renderTimeout = setTimeout(() => render(forceInvalidateCache), RENDER_THROTTLE_MS - timeSinceLastRender);
                return;
            }
            
            // 캐시 강제 무효화 (필터 변경 시)
            if (forceInvalidateCache) {
                invalidateFilteredDataCache();
            }
            
            isRendering = true;
            const skipAutoScroll = !!(pendingScrollRestore && pendingScrollRestore.skipAutoScroll);
            
            // requestAnimationFrame을 사용하여 브라우저 렌더링 최적화
            requestAnimationFrame(() => {
                try {
                    lastRenderTime = Date.now();
                    updateControlReferences(); // Ensure references are always correct
                    syncSortStateWithSelect({ preserveDirection: true });
                    // 개선 사항: 렌더링 시 원본 날짜가 없는 프로젝트만 기록 (사용자가 날짜를 수정한 경우를 보존하기 위해)
                    // 단, 페이지 로드 직후 첫 렌더링이 아닌 경우에만 ensureOriginalDatesForProjects 사용
                    // 페이지 로드 직후 첫 렌더링은 resetOriginalDatesForProjects로 처리됨
                    ensureOriginalDatesForProjects(projectData);
                    updateProjectStatuses();
                    hideFloatingTooltip();
                    // 개선 사항: 필터링/정렬 결과 캐시 활용
                    const filteredData = getFilteredAndSortedData();
                    latestFilteredData = filteredData;

                    // 서머리 컨테이너 강제 초기화 (변경 이력 닫기 후 렌더링 보장)
                    const overviewGroupSummaries = document.getElementById('overview-group-summaries');
                    const settlementGroupSummaries = document.getElementById('settlement-group-summaries');
                    if (overviewGroupSummaries) overviewGroupSummaries.innerHTML = '';
                    if (settlementGroupSummaries) settlementGroupSummaries.innerHTML = '';

                    updateSummary(filteredData); // Summary updates are always based on main page elements
                    renderGanttChart(filteredData);
                    
                    // [성능 최적화] 의존성 화살표 렌더링 (렌더링 완료 후 - 여러 단계로 확인) - 온오프라인 모두 지원
                    // [핵심 수정] 필터링된 데이터가 아닌 원본 데이터 사용 (모든 프로젝트의 의존성을 렌더링하기 위해)
                    const renderDependencies = () => {
                        const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                        const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                        if (container) {
                            const ganttBody = container.querySelector('.gantt-body');
                            if (ganttBody) {
                                // [핵심 수정] 필터링된 데이터가 아닌 원본 데이터 사용
                                let dataToRender = null;
                                if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) {
                                    dataToRender = window.projectData;
                                    console.log('[dep-render] Using window.projectData for rendering, count:', dataToRender.length);
                                } else if (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) {
                                    dataToRender = projectData;
                                    console.log('[dep-render] Using projectData for rendering, count:', dataToRender.length);
                                } else {
                                    console.warn('[dep-render] No valid data source found');
                                    return;
                                }
                                
                                if (dataToRender && Array.isArray(dataToRender)) {
                                    if (typeof window.renderDependencyArrows === 'function') {
                                        window.renderDependencyArrows(ganttBody, dataToRender);
                                    } else if (typeof renderDependencyArrows === 'function') {
                                        renderDependencyArrows(ganttBody, dataToRender);
                                }
                            }
                        }
                        }
                    };
                    
                    // 첫 번째 시도: 즉시 (동기 렌더링인 경우)
                    setTimeout(renderDependencies, 50);
                    
                    // 두 번째 시도: DOM 업데이트 완료 후
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            setTimeout(renderDependencies, 100);
                        });
                    });
                    
                    // 세 번째 시도: 레이아웃 업데이트 완료 후
                    setTimeout(renderDependencies, 300);
                    
                    updateShortcutActiveStates();
                    
                    // 개선 사항: 메뉴 버튼 텍스트 업데이트 (참조 업데이트 직후)
                    if (toggleHierarchyOrderBtn) {
                        const isBottomMode = hierarchyOrder === 'bottom';
                        const allToggleButtons = Array.from(document.querySelectorAll('#toggleHierarchyOrderBtn, [id*="toggleHierarchyOrderBtn"]'));
                        allToggleButtons.forEach(btn => {
                            try {
                                btn.textContent = isBottomMode ? '계층순서 (하→상)' : '계층순서 (상→하)';
                                if (isBottomMode) {
                                    btn.style.backgroundColor = '#dbeafe';
                                    btn.style.border = '2px solid #3b82f6';
                                    btn.style.fontWeight = 'bold';
                                    btn.style.color = '#1e40af';
                                } else {
                                    btn.style.backgroundColor = '#fef3c7';
                                    btn.style.border = '2px solid #f59e0b';
                                    btn.style.fontWeight = 'bold';
                                    btn.style.color = '#92400e';
                                }
                            } catch (e) { /* ignore per-button style failures */ }
                        });
                    }
                    
                    // 개선 사항: 계층순서 유지 - 렌더링 후 계층순서 적용
                    const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                    if (container) {
                        // DOM이 완전히 생성된 후 계층순서 적용
                        // 두 번의 requestAnimationFrame을 사용하여 DOM이 완전히 렌더링된 후 적용
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                applyHierarchyOrder(container);
                                // 개선 사항: 계층순서 (하→상) 모드일 때 모든 상위 계층 그룹 헤더 숨김 처리
                                if (hierarchyOrder === 'bottom') {
                                    const allGroupHeaders = container.querySelectorAll('.group-header');
                                    allGroupHeaders.forEach(header => {
                                        header.style.display = 'none';
                                    });
                                } else {
                                    const allGroupHeaders = container.querySelectorAll('.group-header');
                                    allGroupHeaders.forEach(header => {
                                        header.style.display = '';
                                    });
                                }
                                
                                // 개선 사항: 메뉴 버튼 텍스트 업데이트 (렌더링 후에도 상태 유지)
                                if (toggleHierarchyOrderBtn) {
                                    const isBottomMode = hierarchyOrder === 'bottom';
                                    const allToggleButtons = Array.from(document.querySelectorAll('#toggleHierarchyOrderBtn, [id*="toggleHierarchyOrderBtn"]'));
                                    allToggleButtons.forEach(btn => {
                                        try {
                                            btn.textContent = isBottomMode ? '계층순서 (하→상)' : '계층순서 (상→하)';
                                            if (isBottomMode) {
                                                btn.style.backgroundColor = '#dbeafe';
                                                btn.style.border = '2px solid #3b82f6';
                                                btn.style.fontWeight = 'bold';
                                                btn.style.color = '#1e40af';
                                            } else {
                                                btn.style.backgroundColor = '#fef3c7';
                                                btn.style.border = '2px solid #f59e0b';
                                                btn.style.fontWeight = 'bold';
                                                btn.style.color = '#92400e';
                                            }
                                        } catch (e) { /* ignore per-button style failures */ }
                                    });
                                }
                                restoreScrollState();
                            });
                        });
                    }
                    
                    // 개선사항 2: 바로가기 동기화
                    syncShortcutsFromOriginal();
                    if (!skipAutoScroll) {
                        setTimeout(scrollToToday, 100);
                    }
                } finally {
                    isRendering = false;
                }
            });
        }

        function updateSummary(data) {
             // Summary elements are always on the main page, not in fullscreen
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            // 개선 사항: 메모리 최적화 - 단일 루프로 통합하여 여러 번의 filter 호출 제거
            let notStartedCount = 0;
            let inProgressCount = 0;
            let completedCount = 0;
            let delayedCount = 0;
            let totalPo = 0;
            let weightedProgressSum = 0;
            let todayStartCount = 0;
            let todayEndCount = 0;
            let tomorrowStartCount = 0;
            let tomorrowEndCount = 0;
            
            const todayTime = today.getTime();
            const tomorrowTime = tomorrow.getTime();
            
            // 단일 루프로 모든 통계 계산
            for (let i = 0; i < data.length; i++) {
                const p = data[i];
                const progress = p.progress || 0;
                const status = p.status;
                
                // 상태별 카운트
                if (progress === 100) {
                    completedCount++;
                } else if (status === '지연') {
                    delayedCount++;
                } else if (progress === 0) {
                    notStartedCount++;
                } else {
                    inProgressCount++;
                }
                
                // 금액 및 진행률 계산
                const poAmount = p.poAmount || 0;
                weightedProgressSum += progress * poAmount;
                totalPo += poAmount;
                
                // 날짜 기반 카운트
                if (p.startDate) {
                    const startDate = new Date(p.startDate);
                    startDate.setHours(0, 0, 0, 0);
                    const startTime = startDate.getTime();
                    if (startTime === todayTime) todayStartCount++;
                    if (startTime === tomorrowTime) tomorrowStartCount++;
                }
                
                if (p.endDate) {
                    const endDate = new Date(p.endDate);
                    endDate.setHours(0, 0, 0, 0);
                    const endTime = endDate.getTime();
                    if (endTime === todayTime) todayEndCount++;
                    if (endTime === tomorrowTime) tomorrowEndCount++;
                }
            }

            const totalCount = data.length;
            const overallProgressRate = totalPo > 0 ? Math.round(weightedProgressSum / totalPo) : 0;
            
            // DOM 업데이트 최소화 - 한 번에 업데이트
            const totalProjectsEl = document.getElementById('totalProjects');
            const inProgressProjectsEl = document.getElementById('inProgressProjects');
            const beforeStartProjectsEl = document.getElementById('beforeStartProjects');
            const completedProjectsEl = document.getElementById('completedProjects');
            const delayedProjectsEl = document.getElementById('delayedProjects');
            const overallProgressEl = document.getElementById('overallProgress');
            const overallProgressBarEl = document.getElementById('overallProgressBar');
            
            if (totalProjectsEl) totalProjectsEl.textContent = totalCount + '건';
            if (inProgressProjectsEl) inProgressProjectsEl.textContent = inProgressCount + '건';
            if (beforeStartProjectsEl) beforeStartProjectsEl.textContent = notStartedCount + '건';
            if (completedProjectsEl) completedProjectsEl.textContent = completedCount + '건';
            if (delayedProjectsEl) delayedProjectsEl.textContent = delayedCount + '건';
            if (overallProgressEl) overallProgressEl.textContent = `${overallProgressRate}%`;
            if (overallProgressBarEl) overallProgressBarEl.style.width = `${overallProgressRate}%`;

			 // Update legend counts (find legend elements in the correct container)
             const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if (legendContainer) {
				 const legendAll = legendContainer.querySelector('#legendAll');
                 const legendNs = legendContainer.querySelector('#legendNotStarted');
                 const legendIp = legendContainer.querySelector('#legendInProgress');
                 const legendC = legendContainer.querySelector('#legendCompleted');
                 const legendD = legendContainer.querySelector('#legendDelayed');
                 const legendGp = legendContainer.querySelector('#legendGroupProgress');
                 const legendTodayStart = legendContainer.querySelector('#legendTodayStart');
                 const legendTodayEnd = legendContainer.querySelector('#legendTodayEnd');
                 const legendTomorrowStart = legendContainer.querySelector('#legendTomorrowStart');
                 const legendTomorrowEnd = legendContainer.querySelector('#legendTomorrowEnd');
				 
				 if(legendAll) legendAll.textContent = `(${totalCount}건)`;
                 if(legendNs) legendNs.textContent = `(${notStartedCount}건)`;
                 if(legendIp) legendIp.textContent = `(${inProgressCount}건)`;
                 if(legendC) legendC.textContent = `(${completedCount}건)`;
                 if(legendD) legendD.textContent = `(${delayedCount}건)`;
                 if(legendGp) legendGp.textContent = `(${overallProgressRate}%)`;
                 if(legendTodayStart) legendTodayStart.textContent = `(${todayStartCount}건)`;
                 if(legendTodayEnd) legendTodayEnd.textContent = `(${todayEndCount}건)`;
                 if(legendTomorrowStart) legendTomorrowStart.textContent = `(${tomorrowStartCount}건)`;
                 if(legendTomorrowEnd) legendTomorrowEnd.textContent = `(${tomorrowEndCount}건)`;
             }


            // Render standard PO summary by task type for the currently filtered data
            renderPoSummary(data);
            renderPoRangeSummary(data); // 개선 사항 1: 금액대별 현황 렌더링 함수 호출
            renderSettlementEfficiency(data); // 개선 사항 1: 정산 효율 분석 렌더링 함수 호출

            // Render dynamic group summaries based on currently visible (filtered) data
            // This ensures the counts shown in '시공사별 총괄' and similar sections
            // reflect the active filters (e.g., 고객사) rather than the full dataset.
            renderGroupSummaries(data);

            // Update the subtle filter label to show which '고객사' (if any) is currently applied
            try {
                const summaryFilterLabel = document.getElementById('summaryFilterLabel');
                if (summaryFilterLabel && customFilterContainer) {
                    let filterText = '전체';
                    let customerValue = '전체';
                    let constructorValue = '전체';
                    
                    // 먼저 고객사와 시공사 필터의 현재 값을 찾음
                    customFilterContainer.querySelectorAll('select').forEach(sel => {
                        const key = sel.dataset.filterKey;
                        const displayName = (customFieldDisplayNames[key] || '').toString();
                        if (displayName.includes('고객사')) {
                            if (sel.value && sel.value !== 'all') {
                                customerValue = sel.value;
                            }
                        } else if (displayName.includes('시공사') || displayName.includes('constructor')) {
                            if (sel.value && sel.value !== 'all') {
                                constructorValue = sel.value;
                            }
                        }
                    });

                    // 필터 텍스트 구성: 고객사만 선택, 시공사만 선택, 둘 다 선택 경우 처리
                    if (customerValue !== '전체') {
                        filterText = constructorValue !== '전체' ? 
                            `${customerValue}>${constructorValue}` : 
                            `${customerValue}>전체`;
                    } else if (constructorValue !== '전체') {
                        filterText = `전체>${constructorValue}`;
                    }
                    
                    summaryFilterLabel.textContent = `필터: ${filterText}`;
                }
            } catch (e) {
                // Fail silently to avoid breaking UI if something unexpected occurs
                console.warn('summary filter label update error', e);
            }
        }

        function renderPoSummary(data) {
            const poSummaryContainer = document.getElementById('poSummary'); // Always on main page
            if (!poSummaryContainer) return;
            poSummaryContainer.innerHTML = '';

            let totalPoAmount = 0;
            const summaryData = data.reduce((acc, p) => {
                if (!acc[p.taskType]) acc[p.taskType] = { amount: 0, count: 0 };
                if (p.poAmount && !isNaN(p.poAmount)) {
                    const amount = p.poAmount;
                    acc[p.taskType].amount += amount;
                    totalPoAmount += amount;
                }
                acc[p.taskType].count++;
                return acc;
            }, {});

            if (Object.keys(summaryData).length === 0 || Object.values(summaryData).every(v => v.amount === 0 && v.count === 0)) {
                poSummaryContainer.innerHTML = '<p class="text-gray-500 col-span-full">표시할 정산 데이터가 없습니다.</p>';
            } else {
                 Object.keys(summaryData).sort().forEach(taskType => {
                    const groupData = summaryData[taskType];
                    if (groupData.count > 0) {
                        const card = document.createElement('div');
                        card.className = "summary-card bg-slate-100 border-l-4 border-slate-500 p-2 rounded-lg shadow-sm";
                        card.dataset.filterType = 'taskType';
                        card.dataset.filterValue = taskType;
                        card.innerHTML = `
                            <div class="font-medium text-slate-700 text-sm pointer-events-none">${taskType} (${groupData.count}건)</div>
                            <div class="text-xl font-bold text-gray-800 pointer-events-none">${formatCurrency(groupData.amount)}</div>
                        `;
                        poSummaryContainer.appendChild(card);
                    }
                });
            }
        }

        // 개선 사항 1: 금액대별 프로젝트 현황 렌더링 함수
        function renderPoRangeSummary(data) {
            const container = document.getElementById('poRangeSummary');
            if (!container) return;

            const ranges = {
                'over_100m': { label: '1억 이상', min: 100000000, max: Infinity, projects: [] },
                '50m_to_100m': { label: '5천만-1억', min: 50000000, max: 100000000, projects: [] },
                '10m_to_50m': { label: '1천만-5천만', min: 10000000, max: 50000000, projects: [] },
                'under_10m': { label: '1천만 미만', min: 0, max: 10000000, projects: [] }
            };

            data.forEach(p => {
                const amount = p.poAmount || 0;
                if (amount >= ranges.over_100m.min) ranges.over_100m.projects.push(p);
                else if (amount >= ranges['50m_to_100m'].min) ranges['50m_to_100m'].projects.push(p);
                else if (amount >= ranges['10m_to_50m'].min) ranges['10m_to_50m'].projects.push(p);
                else ranges.under_10m.projects.push(p);
            });

            let html = `<div class="border-t pt-4 mt-4"><h3 class="text-lg font-semibold mb-2">💰 금액대별 프로젝트 현황</h3><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">`;
            let hasData = false;

            Object.entries(ranges).forEach(([key, range]) => {
                if (range.projects.length > 0) {
                    hasData = true;
                    const totalAmount = range.projects.reduce((sum, p) => sum + (p.poAmount || 0), 0);
                    const totalProgress = range.projects.reduce((sum, p) => sum + (p.progress || 0), 0);
                    const avgProgress = range.projects.length > 0 ? Math.round(totalProgress / range.projects.length) : 0;

                    html += `
                        <div class="summary-card bg-white border-l-4 border-teal-500 p-3 rounded-lg shadow-sm" 
                             data-filter-type="po-range" 
                             data-filter-value="${key}">
                            <div class="font-bold text-teal-800">${range.label}</div>
                            <div class="text-xl font-bold text-gray-800">${formatCurrency(totalAmount)}</div>
                            <div class="text-sm text-gray-500 mt-1">
                                <span>${range.projects.length}건</span>
                                <span class="mx-1">•</span>
                                <span>평균 ${avgProgress}%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                                <div class="bg-teal-600 h-2 rounded-full" style="width: ${avgProgress}%" title="평균 공정률: ${avgProgress}%"></div>
                            </div>
                        </div>
                    `;
                }
            });

            if (!hasData) {
                html += `<p class="text-gray-500 col-span-full">분석할 데이터가 없습니다.</p>`;
            }

            html += `</div></div>`;
            container.innerHTML = html;

            // Add event listeners to new cards
            container.querySelectorAll('[data-filter-type="po-range"]').forEach(card => {
                card.addEventListener('click', (e) => {
                    const rangeKey = e.currentTarget.dataset.filterValue;
                    const rangeData = ranges[rangeKey];
                    if (rangeData && rangeData.projects.length > 0) {
                        showDataDetailModal(`${rangeData.label} 프로젝트 목록`, rangeData.projects);
                    }
                });
            });
        }

        // 개선 사항 1: 정산 효율 분석 렌더링 함수
        function renderSettlementEfficiency(data) {
            const container = document.getElementById('settlementEfficiencyAnalysis');
            if (!container) return;

            const projectsWithEfficiency = data
                .map(p => {
                    const startDate = p.startDate instanceof Date ? p.startDate : new Date(p.startDate);
                    const endDate = p.endDate instanceof Date ? p.endDate : new Date(p.endDate);
                    
                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime()) || !p.poAmount || p.poAmount <= 0) {
                        return null;
                    }

                    let duration = (endDate - startDate) / (1000 * 60 * 60 * 24) + 1;
                    if (duration <= 0) duration = 1;

                    const efficiency = p.poAmount / duration;
                    return { ...p, duration: Math.round(duration), efficiency };
                })
                .filter(p => p !== null)
                .sort((a, b) => b.efficiency - a.efficiency);

            const top5 = projectsWithEfficiency.slice(0, 5);
            const bottom5 = projectsWithEfficiency.slice(-5).reverse();

            const renderList = (projects, title, icon, colorClass) => {
                let listHtml = `<h4 class="font-semibold ${colorClass} mb-2">${icon} ${title}</h4>`;
                if (projects.length === 0) {
                    listHtml += `<div class="p-3 text-sm text-gray-500 bg-gray-50 rounded-md">해당 데이터가 없습니다.</div>`;
                } else {
                    listHtml += `<ul class="space-y-2">`;
                    projects.forEach(p => {
                        listHtml += `
                            <li class="p-2 bg-gray-50 rounded-md border border-gray-200">
                                <div class="font-semibold text-gray-800 truncate" title="${p.name}">${p.name}</div>
                                <div class="text-sm flex justify-between items-center">
                                    <span class="font-bold ${colorClass}">${formatCurrency(Math.round(p.efficiency))}/일</span>
                                    <span class="text-gray-500">${formatCurrency(p.poAmount)} / ${p.duration}일</span>
                                </div>
                            </li>
                        `;
                    });
                    listHtml += `</ul>`;
                }
                return `<div>${listHtml}</div>`;
            };

            let html = `
                <div class="border-t pt-4 mt-4">
                    <h3 class="text-lg font-semibold mb-3">⏱️ 정산 효율 분석 (일일 정산액 기준)</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        ${renderList(top5, 'Top 5 효율적인 프로젝트', '🚀', 'text-green-700')}
                        ${renderList(bottom5, 'Top 5 개선 필요한 프로젝트', '🐢', 'text-orange-700')}
                    </div>
                </div>
            `;

            if (projectsWithEfficiency.length === 0) {
                container.innerHTML = ''; // 데이터 없으면 섹션 자체를 숨김
            } else {
                container.innerHTML = html;
            }
        }


        // Modified renderGroupSummaries function
        function renderGroupSummaries(fullData) {
             // These are always on the main page
            const overviewContainer = document.getElementById('overview-group-summaries');
            const settlementHeaderContainer = document.getElementById('settlement-header-summaries');
            const settlementGroupContainer = document.getElementById('settlement-group-summaries');
             if (!overviewContainer || !settlementHeaderContainer || !settlementGroupContainer) return;

            const workingData = Array.isArray(fullData) ? fullData : getFilterAwareDataset();
            if (!Array.isArray(workingData)) return;

            overviewContainer.innerHTML = '';
            settlementHeaderContainer.innerHTML = '';
            settlementGroupContainer.innerHTML = ''; // Clear previous content
            resetAnalysisHeaderUsage();

            const customFieldKeys = new Set();
            workingData.forEach(p => {
                if (p.customFields) {
                    Object.keys(p.customFields).forEach(key => customFieldKeys.add(key));
                }
            });

            const GROUPING_KEYWORDS = ['고객사', '시공사', '업체', '담당자', 'client', 'constructor', 'company', '비용계정', 'costaccount', 'expenseaccount']
                .map(keyword => keyword.toLowerCase().replace(/[\s_\-]/g, ''));
            const normalizeGroupingValue = (value = '') => value.toString().toLowerCase().replace(/[\s_\-]/g, '');
            const matchesGroupingKeyword = (candidate = '') => {
                const normalized = normalizeGroupingValue(candidate);
                return GROUPING_KEYWORDS.some(keyword => normalized.includes(keyword));
            };
            const customFieldKeyArray = Array.from(customFieldKeys);
            const groupingFields = customFieldKeyArray.filter(key => {
                const displayName = customFieldDisplayNames[key] || key;
                return matchesGroupingKeyword(key) || matchesGroupingKeyword(displayName);
            }).sort();
            const groupingFieldsSet = new Set(groupingFields);
            analysisHeaderPreferences.forEach(prefKey => {
                if (prefKey && customFieldKeys.has(prefKey)) {
                    groupingFieldsSet.add(prefKey);
                }
            });
            const finalGroupingFields = Array.from(groupingFieldsSet);

            let finalSettlementHeaderHTML = '';
            // Prevent duplicate settlement sections (e.g., duplicate '시공사별 정산') by display name
            const renderedSettlementNames = new Set();

            // [추가됨] customFieldDisplayNames가 비어있을 경우를 대비하여,
            // 현재 fullData에서 키를 추출하여 표시 이름을 임시로라도 생성 (재귀 저장 문제 해결)
            if (Object.keys(customFieldDisplayNames).length === 0) {
                groupingFields.forEach(field => {
                    // 필드 키 자체를 표시 이름으로 사용 (예: "customer" -> "customer")
                    // 만약 키에 "고객사", "시공사" 등이 포함되어 있다면 그것을 활용
                    // 한글 키워드 매핑 시도
                    if (field.includes('customer') || field.includes('고객사')) {
                        customFieldDisplayNames[field] = '고객사';
                    } else if (field.includes('constructor') || field.includes('시공사')) {
                         customFieldDisplayNames[field] = '시공사';
                    } else {
                        customFieldDisplayNames[field] = field;
                    }
                });
            }

            finalGroupingFields.forEach(field => {
                // --- 1. Data Aggregation (Same as before) ---
                const groupedData = workingData.reduce((acc, p) => {
                    const groupValue = p.customFields?.[field] || '미지정';
                    if (!acc[groupValue]) {
                        acc[groupValue] = { poAmount: 0, count: 0, weightedProgress: 0, projects: [] };
                    }
                    const po = p.poAmount || 0;
                    const progress = p.progress || 0;

                    acc[groupValue].poAmount += po;
                    acc[groupValue].count++;
                    acc[groupValue].weightedProgress += po * progress;
                    acc[groupValue].projects.push(p);

                    return acc;
                }, {});
                const sortedGroupValues = Object.keys(groupedData).sort();

                // --- 2. Render Overview Section (Same as before) ---
                const displayFieldName = customFieldDisplayNames[field] || field;
                registerAnalysisHeaderUsage(field, displayFieldName, 'overview');
                const overviewKey = `overview_${field}`;
                const overviewSectionId = `overview_section_${overviewKey}`;
                const overviewSection = document.createElement('div');
                overviewSection.className = 'overview-accordion-item';
                overviewSection.id = overviewSectionId;
                overviewSection.dataset.accordionKey = overviewKey;

                let isOverviewOpen = true;
                try {
                    if (savedSettings && Array.isArray(savedSettings.overviewOpenFields)) {
                        isOverviewOpen = savedSettings.overviewOpenFields.includes(`${displayFieldName}별 총괄`);
                    }
                } catch (e) {
                    isOverviewOpen = true;
                }
                overviewSection.classList.add(isOverviewOpen ? 'expanded' : 'collapsed');

                const overviewHeader = document.createElement('div');
                overviewHeader.className = 'overview-accordion-header';
                overviewHeader.dataset.accordionKey = overviewKey;
                overviewHeader.setAttribute('role', 'button');
                overviewHeader.setAttribute('tabindex', '0');
                overviewHeader.setAttribute('aria-expanded', isOverviewOpen ? 'true' : 'false');
                overviewHeader.innerHTML = `
                    <div class="flex items-center gap-2 flex-wrap">
                        <h3 class="text-lg font-semibold">■ ${displayFieldName}별 총괄</h3>
                        ${buildAccordionHintHTML(overviewKey)}
                        ${buildAccordionStatePillHTML(overviewKey, '#' + overviewSectionId, isOverviewOpen)}
                    </div>
                    <svg class="overview-accordion-icon w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                `;

                const overviewContent = document.createElement('div');
                overviewContent.className = 'overview-accordion-content';
                overviewContent.style.display = isOverviewOpen ? '' : 'none';

                const overviewGrid = document.createElement('div');
                overviewGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4';

                sortedGroupValues.forEach(groupValue => {
                    const group = groupedData[groupValue];
                    const groupProgress = group.poAmount > 0 ? Math.round(group.weightedProgress / group.poAmount) : 0;
                    const weightedValue = group.weightedProgress / 100; // 가중치 적용값
                    const card = document.createElement('div');
                    card.className = 'summary-card bg-white border-l-4 border-gray-300 p-3 rounded-lg shadow-sm';
                    card.dataset.filterType = 'custom-group';
                    card.dataset.filterField = field;
                    card.dataset.filterValue = groupValue;
                    card.innerHTML = `
                        <div class="font-bold text-gray-700">${groupValue} (${group.count}건)</div>
                        <div class="text-xl font-bold text-gray-800">${formatCurrency(group.poAmount)}</div>
                        <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                            <div class="bg-gray-500 h-2 rounded-full" style="width: ${groupProgress}%" title="공정률: ${groupProgress}%"></div>
                        </div>
                        <div class="text-sm text-gray-500 mt-1 text-right">가중치: ${weightedValue.toLocaleString('ko-KR')} (${groupProgress}%)</div>
                    `;
                    overviewGrid.appendChild(card);
                });

                overviewContent.appendChild(overviewGrid);
                overviewSection.appendChild(overviewHeader);
                overviewSection.appendChild(overviewContent);
                overviewContainer.appendChild(overviewSection);
                setCustomAccordionState(overviewKey, isOverviewOpen, overviewHeader);

                const toggleOverviewAccordion = () => {
                    const currentlyOpen = overviewSection.classList.contains('expanded');
                    if (currentlyOpen) {
                        overviewSection.classList.remove('expanded');
                        overviewSection.classList.add('collapsed');
                        overviewContent.style.display = 'none';
                    } else {
                        overviewSection.classList.add('expanded');
                        overviewSection.classList.remove('collapsed');
                        overviewContent.style.display = '';
                    }
                    const nowOpen = overviewSection.classList.contains('expanded');
                    overviewHeader.setAttribute('aria-expanded', nowOpen ? 'true' : 'false');
                    setCustomAccordionState(overviewKey, nowOpen, overviewHeader);
                    dismissAccordionHint(overviewKey);
                };

                overviewHeader.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    toggleOverviewAccordion();
                });
                overviewHeader.addEventListener('keydown', handleAccordionHeaderKeydown);

                // --- 3. Render Settlement Section ---
                // For '고객사' we render a flat list (no accordion / no sub-groups) to satisfy the
                // requirement of removing accordion and group UI for 고객사별 정산.
                
                // [수정됨] 필드 이름에 '고객사'가 포함되어 있는지 확인 (대소문자 구분 없이 검사)
                // displayFieldName이나 field 키 자체에 '고객사' 또는 'customer'가 포함되면 고객사 로직 적용
                const isCustomerField = (customFieldDisplayNames[field] || field || '').toLowerCase().includes('고객사') || 
                                        (field || '').toLowerCase().includes('customer');

                if (isCustomerField) {
                    // Mark this display name as rendered to avoid duplicates later
                    if (!renderedSettlementNames.has(displayFieldName)) {
                        renderedSettlementNames.add(displayFieldName);
                    }
                    registerAnalysisHeaderUsage(field, displayFieldName, 'settlement');
                    finalSettlementHeaderHTML = sortedGroupValues.map(groupValue => {
                        const group = groupedData[groupValue];
                        const formattedUnit = formatAmountWithUnit(group.poAmount);
                        return `<span class="font-semibold">${groupValue}:</span> 총 ${formatCurrency(group.poAmount)} ${formattedUnit} / ${group.count}건`;
                    }).join(' <span class="text-black font-light mx-3">🔛</span> ');

                    // Create a simple accordion container (cards) for 고객사 섹션
                    const customerAccordionKey = `settlement_customer_${field}`;
                    const customerAccordionId = `main_settlement_${customerAccordionKey}`;
                    const customerAccordion = document.createElement('div');
                    customerAccordion.className = 'main-settlement-accordion-item mb-4 border border-gray-200 rounded-lg';
                    customerAccordion.id = customerAccordionId;
                    customerAccordion.dataset.accordionKey = customerAccordionKey;

                    const customerHeader = document.createElement('div');
                    customerHeader.className = 'main-settlement-header p-3 cursor-pointer flex items-center justify-between bg-gray-50 hover:bg-gray-100';
                    customerHeader.dataset.accordionKey = customerAccordionKey;
                    customerHeader.setAttribute('role', 'button');
                    customerHeader.setAttribute('tabindex', '0');

                    let isCustomerOpen = true;
                    try {
                        if (savedSettings && Array.isArray(savedSettings.settlementOpenFields)) {
                            isCustomerOpen = savedSettings.settlementOpenFields.includes(displayFieldName);
                        }
                    } catch (e) {
                        isCustomerOpen = true;
                    }
                    customerAccordion.classList.add(isCustomerOpen ? 'expanded' : 'collapsed');

                    customerHeader.innerHTML = `
                        <div class="flex items-center gap-2 flex-wrap">
                            <h3 class="text-lg font-semibold">■ ${displayFieldName}별 정산</h3>
                            ${buildAccordionHintHTML(customerAccordionKey)}
                            ${buildAccordionStatePillHTML(customerAccordionKey, '#' + customerAccordionId, isCustomerOpen)}
                        </div>
                        <svg class="main-settlement-icon w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    `;
                    customerHeader.setAttribute('aria-expanded', isCustomerOpen ? 'true' : 'false');

                    const customerContent = document.createElement('div');
                    customerContent.className = 'main-settlement-content p-4';
                    customerContent.style.display = isCustomerOpen ? 'block' : 'none';

                    const grid = document.createElement('div');
                    grid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';

                    // 먼저 '솔루션' 카드를 생성하고 배치한 다음, 나머지 카드들을 처리합니다
                    const createCustomerCard = (groupValue, group) => {
                        const groupProgress = group.poAmount > 0 ? Math.round(group.weightedProgress / group.poAmount) : 0;
                        const card = document.createElement('div');
                        card.className = 'summary-card bg-white border-l-4 border-gray-300 p-3 rounded-lg shadow-sm';
                        card.dataset.filterType = 'custom-group';
                        card.dataset.filterField = field;
                        card.dataset.filterValue = groupValue;
                        card.innerHTML = `
                            <div class="flex justify-between items-start">
                                <div>
                                    <div class="font-semibold text-gray-800">${groupValue}</div>
                                    <div class="text-sm text-gray-500">${group.count}건 • ${formatCurrency(group.poAmount)}</div>
                                </div>
                                <div class="text-right">
                                    <div class="text-lg font-bold text-gray-800">${formatCurrency(group.poAmount)}</div>
                                    <div class="text-sm text-gray-500">${groupProgress}%</div>
                                </div>
                            </div>
                        `;

                        // Keep same click behavior as original cards
                        card.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const fakeEvent = { target: card };
                            handleCardClick(fakeEvent);
                        });
                        return card;
                    };

                    // 우선순위 카드(고객사A / 고객사 A)를 최상단에 배치하고, 나머지는 기존 순서 유지
                    const preferredKeys = ['고객사A', '고객사 A'];
                    const order = [];
                    const added = new Set();
                    preferredKeys.forEach(key => {
                        if (sortedGroupValues.includes(key)) {
                            order.push(key);
                            added.add(key);
                        }
                    });
                    sortedGroupValues.forEach(v => { if (!added.has(v)) order.push(v); });

                    order.forEach(groupValue => {
                        const group = groupedData[groupValue];
                        const card = createCustomerCard(groupValue, group);
                        grid.appendChild(card);
                    });

                    customerContent.appendChild(grid);
                    customerAccordion.appendChild(customerHeader);
                    customerAccordion.appendChild(customerContent);
                    settlementGroupContainer.prepend(customerAccordion);
                    setCustomAccordionState(customerAccordionKey, isCustomerOpen, customerHeader);

                    const toggleCustomerAccordion = () => {
                        const isCollapsed = customerAccordion.classList.contains('collapsed');
                        if (isCollapsed) {
                            customerAccordion.classList.remove('collapsed');
                            customerAccordion.classList.add('expanded');
                            customerContent.style.display = 'block';
                        } else {
                            customerAccordion.classList.remove('expanded');
                            customerAccordion.classList.add('collapsed');
                            customerContent.style.display = 'none';
                        }
                        const nowOpen = customerAccordion.classList.contains('expanded');
                        customerHeader.setAttribute('aria-expanded', nowOpen ? 'true' : 'false');
                        setCustomAccordionState(customerAccordionKey, nowOpen, customerHeader);
                        dismissAccordionHint(customerAccordionKey);
                        setTimeout(() => {
                            updateSettlementScrollBehavior();
                            try {
                                const containerRef = fullscreenModal.classList.contains('hidden') 
                                    ? document.getElementById('ganttViewContent') 
                                    : fullscreenModalBody;
                                recomputeTodayMarkerHeight(containerRef);
                            } catch (e) {
                                // ignore
                            }
                        }, 120);
                    };

                    customerHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleCustomerAccordion();
                    });
                    customerHeader.addEventListener('keydown', handleAccordionHeaderKeydown);
                } else {
                    // Skip rendering if a settlement section for the same display name already exists
                    if (renderedSettlementNames.has(displayFieldName)) {
                        return; // continue to next field
                    }
                    renderedSettlementNames.add(displayFieldName);
                    registerAnalysisHeaderUsage(field, displayFieldName, 'settlement');
                    // Original accordion-based rendering preserved for non-고객사 fields
                    // Create the main container for this field's sub-accordions
                    const fieldAccordionContainer = document.createElement('div');
                    fieldAccordionContainer.className = 'border-t pt-4 mt-4'; // Add styling as needed

                    // Create main settlement section accordion
                    const mainSettlementAccordion = document.createElement('div');
                    mainSettlementAccordion.className = 'main-settlement-accordion-item mb-4 border border-gray-200 rounded-lg';
                    const mainAccordionKey = `settlement_main_${field}`;
                    const mainAccordionTargetId = `main_settlement_${mainAccordionKey}`;
                    mainSettlementAccordion.id = mainAccordionTargetId;
                    mainSettlementAccordion.dataset.accordionKey = mainAccordionKey;
                    
                    // Main settlement section header
                    const mainSettlementHeader = document.createElement('div');
                    mainSettlementHeader.className = 'main-settlement-header p-3 cursor-pointer flex items-center justify-between bg-gray-50 hover:bg-gray-100';
                    mainSettlementHeader.dataset.accordionKey = mainAccordionKey;
                    mainSettlementHeader.setAttribute('role', 'button');
                    mainSettlementHeader.setAttribute('tabindex', '0');
                    
                    // Main settlement section content
                    const mainSettlementContent = document.createElement('div');
                    mainSettlementContent.className = 'main-settlement-content p-4';
                    
                    // 개선사항 1: 기본 동작은 접힘이지만, 저장된 설정이 있으면 그 상태를 복원합니다.
                    let isSettlementOpen = false;
                    try {
                        if (savedSettings && Array.isArray(savedSettings.settlementOpenFields)) {
                            isSettlementOpen = savedSettings.settlementOpenFields.includes(displayFieldName);
                        }
                    } catch (e) {
                        isSettlementOpen = false;
                    }

                    if (isSettlementOpen) {
                        mainSettlementAccordion.classList.add('expanded');
                        mainSettlementContent.style.display = 'block';
                    } else {
                        mainSettlementAccordion.classList.add('collapsed');
                        mainSettlementContent.style.display = 'none';
                    }

                    mainSettlementHeader.innerHTML = `
                        <div class="flex items-center gap-2 flex-wrap">
                            <h3 class="text-lg font-semibold">■ ${displayFieldName}별 정산</h3>
                            ${buildAccordionHintHTML(mainAccordionKey)}
                            ${buildAccordionStatePillHTML(mainAccordionKey, `#${mainAccordionTargetId}`, isSettlementOpen)}
                        </div>
                        <svg class="main-settlement-icon w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    `;
                    mainSettlementHeader.setAttribute('aria-expanded', isSettlementOpen ? 'true' : 'false');
                    
                    mainSettlementAccordion.appendChild(mainSettlementHeader);
                    mainSettlementAccordion.appendChild(mainSettlementContent);
                    setCustomAccordionState(mainAccordionKey, isSettlementOpen, mainSettlementHeader);
                    
                    // Add click handler for main settlement accordion
                    mainSettlementHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isCollapsed = mainSettlementAccordion.classList.contains('collapsed');
                        if (isCollapsed) {
                            mainSettlementAccordion.classList.remove('collapsed');
                            mainSettlementAccordion.classList.add('expanded');
                            mainSettlementContent.style.display = 'block';
                        } else {
                            mainSettlementAccordion.classList.remove('expanded');
                            mainSettlementAccordion.classList.add('collapsed');
                            mainSettlementContent.style.display = 'none';
                        }
                        const nowOpen = mainSettlementAccordion.classList.contains('expanded');
                        setCustomAccordionState(mainAccordionKey, nowOpen);
                        mainSettlementHeader.setAttribute('aria-expanded', nowOpen ? 'true' : 'false');
                        dismissAccordionHint(mainAccordionKey);
                        
                        // Update scroll behavior after accordion toggle
                        setTimeout(() => {
                            updateSettlementScrollBehavior();
                            // Recompute today marker height after layout change (allow DOM to settle)
                            try {
                                const containerRef = fullscreenModal.classList.contains('hidden') 
                                    ? document.getElementById('ganttViewContent') 
                                    : fullscreenModalBody;
                                recomputeTodayMarkerHeight(containerRef);
                            } catch (e) {
                                // fail silently if environment not ready
                            }
                        }, 120);
                    });
                    mainSettlementHeader.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter' || event.key === ' ') {
                            event.preventDefault();
                            mainSettlementHeader.click();
                        }
                    });
                    
                    fieldAccordionContainer.appendChild(mainSettlementAccordion);

                    // Create individual sub-accordions for each group value inside main settlement content
                    sortedGroupValues.forEach((groupValue, groupIndex) => {
                        const group = groupedData[groupValue];

                        // Sub-Accordion Item Wrapper
                        const subAccordionItem = document.createElement('div');
                        subAccordionItem.className = 'sub-accordion-item mb-2 border-b last:border-b-0'; // Initially closed
                        const sanitizedGroupValue = sanitizeKey(groupValue) || 'group';
                        const subAccordionKey = `settlement_sub_${field}_${sanitizedGroupValue}_${groupIndex}`;
                        const subAccordionTargetId = `sub_settlement_${field}_${sanitizedGroupValue}_${groupIndex}`;
                        subAccordionItem.id = subAccordionTargetId;
                        subAccordionItem.dataset.accordionKey = subAccordionKey;

                        // Sub-Accordion Header
                        const subAccordionHeader = document.createElement('div');
                        subAccordionHeader.className = 'sub-accordion-header py-2'; // Added padding
                        subAccordionHeader.dataset.accordionKey = subAccordionKey;
                        subAccordionHeader.setAttribute('role', 'button');
                        subAccordionHeader.setAttribute('tabindex', '0');
                        subAccordionHeader.setAttribute('aria-expanded', 'false');
                        subAccordionHeader.innerHTML = `
                            <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between w-full gap-2">
                                <div class="flex items-center gap-2 flex-wrap">
                                    <h4 class="font-semibold text-md hover:text-indigo-600" data-filter-type="custom-group" data-filter-field="${field}" data-filter-value="${groupValue}">
                                        ${groupValue}
                                        <span class="text-sm font-normal text-gray-500 ml-2">(${group.count}건 / ${formatCurrency(group.poAmount)})</span>
                                    </h4>
                                    ${buildAccordionHintHTML(subAccordionKey)}
                                </div>
                                <div class="flex items-center gap-2">
                                    ${buildAccordionStatePillHTML(subAccordionKey, `#${subAccordionTargetId}`, false)}
                                    <svg class="sub-accordion-icon w-5 h-5 flex-shrink-0 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                                </div>
                            </div>
                        `;
                        subAccordionItem.appendChild(subAccordionHeader);

                        // Sub-Accordion Content
                        const subAccordionContent = document.createElement('div');
                        subAccordionContent.className = 'sub-accordion-content'; // Content starts hidden

                        const contentGrid = document.createElement('div');
                         // Added pl-4 for indentation
                        contentGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 pb-2 pl-4';

                        const taskTypeSummary = group.projects.reduce((acc, p) => {
                             if (!acc[p.taskType]) {
                                acc[p.taskType] = { amount: 0, count: 0 };
                            }
                            acc[p.taskType].amount += p.poAmount || 0;
                            acc[p.taskType].count++;
                            return acc;
                        }, {});

                        // Sort task types and add numbering
                        Object.keys(taskTypeSummary).sort().forEach((taskType, index) => {
                            const taskData = taskTypeSummary[taskType];
                            contentGrid.innerHTML += `
                            <div class="summary-card bg-slate-50 border-l-4 border-slate-400 p-2 rounded-lg shadow-sm"
                                 data-filter-type="custom-group-task"
                                 data-filter-field="${field}"
                                 data-filter-value="${groupValue}"
                                 data-filter-task-type="${taskType}">
                                 <div class="flex items-baseline">
                                    <span class="text-xs font-mono mr-1.5">${index + 1}.</span> <!-- Numbering -->
                                    <div class="flex-1">
                                        <div class="font-medium text-slate-700 text-sm pointer-events-none">${taskType} (${taskData.count}건)</div>
                                        <div class="text-lg font-bold text-gray-800 pointer-events-none">${formatCurrency(taskData.amount)}</div>
                                    </div>
                                 </div>
                            </div>`;
                        });


                        subAccordionContent.appendChild(contentGrid);
                        subAccordionItem.appendChild(subAccordionContent);
                        setCustomAccordionState(subAccordionKey, false, subAccordionHeader);

                        // Add the complete sub-accordion item to the main settlement content
                        mainSettlementContent.appendChild(subAccordionItem);
                    });

                    // Append or prepend the container based on display name: '시공사' 섹션은 최상단으로 이동
                    if ((customFieldDisplayNames[field] || field).includes('시공사')) {
                        settlementGroupContainer.prepend(fieldAccordionContainer);
                    } else {
                        settlementGroupContainer.appendChild(fieldAccordionContainer);
                    }
                }
            });

            settlementHeaderContainer.innerHTML = finalSettlementHeaderHTML;

            // Add event listeners after rendering
            setupSettlementAccordions();
            
            // Setup settlement section wheel scrolling
            setupSettlementWheelScrolling();
            
            // Setup resize observer for dynamic content changes
            setupSettlementResizeObserver();
            
            // Update scroll behavior after content changes
            updateSettlementScrollBehavior();

            // Reorder priority sections directly under the 정산 header
            reorderSettlementPriority();

            initializeAccordionHints();
            updateAccordionStatePills();
            refreshMappingAnalysisMeta();
        }


        // Function to setup sub-accordion listeners
        function setupSettlementAccordions() {
            const settlementGroupContainer = document.getElementById('settlement-group-summaries');
             if (!settlementGroupContainer) return;
            settlementGroupContainer.querySelectorAll('.sub-accordion-header').forEach(header => {
                 // Remove existing listener to prevent duplicates if called multiple times
                header.removeEventListener('click', toggleSubAccordion);
                header.addEventListener('click', toggleSubAccordion);
                header.removeEventListener('keydown', handleAccordionHeaderKeydown);
                header.addEventListener('keydown', handleAccordionHeaderKeydown);
                header.setAttribute('role', 'button');
                header.setAttribute('tabindex', '0');
            });
        }

        function setupSettlementWheelScrolling() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            // Remove existing listeners to prevent duplicates
            settlementContent.removeEventListener('wheel', handleSettlementWheel);
            settlementContent.addEventListener('wheel', handleSettlementWheel, { passive: false });
        }
        
        function handleSettlementWheel(e) {
            const settlementContent = e.currentTarget;
            
            // Check if content is scrollable
            const isScrollable = settlementContent.scrollHeight > settlementContent.clientHeight;
            
            if (isScrollable && e.deltaY !== 0) {
                // Prevent default browser scrolling
                e.preventDefault();
                e.stopPropagation();
                
                // Smooth scrolling with custom delta
                const scrollAmount = e.deltaY * 0.5; // Reduce scroll speed for better control
                settlementContent.scrollTop += scrollAmount;
            }
        }
        
        function updateSettlementScrollBehavior() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            // Force re-evaluation of scroll behavior
            setTimeout(() => {
                const needsScroll = settlementContent.scrollHeight > settlementContent.clientHeight;
                
                if (needsScroll) {
                    settlementContent.style.overflowY = 'auto';
                    settlementContent.style.maxHeight = '70vh';
                } else {
                    settlementContent.style.overflowY = 'visible';
                    settlementContent.style.maxHeight = 'none';
                }
            }, 100);
        }
        
        // Setup resize observer for settlement content
        function setupSettlementResizeObserver() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(() => {
                    updateSettlementScrollBehavior();
                });
                resizeObserver.observe(settlementContent);
            }
        }

        // Move '고객사A' 카드와 '시공사별 정산' 섹션을 정산 제목 바로 아래로 배치
        function reorderSettlementPriority() {
            try {
                const settlementContent = document.querySelector('.settlement-scrollable');
                if (!settlementContent) return;

                // Ensure priority container exists at top of settlement content
                let priority = document.getElementById('settlementPriorityContainer');
                if (!priority) {
                    priority = document.createElement('div');
                    priority.id = 'settlementPriorityContainer';
                    priority.className = 'space-y-4';
                    settlementContent.insertBefore(priority, settlementContent.firstChild);
                }

                // Move group summaries above poSummary
                const groupContainer = document.getElementById('settlement-group-summaries');
                const poSummary = document.getElementById('poSummary');
                if (groupContainer && poSummary && groupContainer.nextSibling !== poSummary) {
                    try {
                        // If groupContainer currently contains contractor sections we still keep them as children;
                        // we only reposition the container before poSummary.
                        settlementContent.insertBefore(groupContainer, poSummary);
                    } catch (e) {}
                }

                // 1) Find 고객사A card (supports both '고객사A' and '고객사 A')
                const candidateCards = Array.from(document.querySelectorAll('#settlement-group-summaries [data-filter-type="custom-group"]'));
                const customerACard = candidateCards.find(el => {
                    const v = el.dataset.filterValue || '';
                    return v === '고객사A' || v === '고객사 A';
                });
                if (customerACard) {
                    // Wrap the single card to keep spacing consistent
                    let customerWrapper = document.getElementById('priorityCustomerAWrapper');
                    if (!customerWrapper) {
                        customerWrapper = document.createElement('div');
                        customerWrapper.id = 'priorityCustomerAWrapper';
                        customerWrapper.className = '';
                        priority.appendChild(customerWrapper);
                    } else {
                        // empty and re-append to keep order
                        customerWrapper.innerHTML = '';
                        priority.appendChild(customerWrapper);
                    }
                    customerWrapper.appendChild(customerACard);
                }

                // 2) Find all '시공사별 정산' section containers across the settlement area, keep only the first per title,
                //    and place the first one AFTER '#settlement-group-summaries'
                const contractorHeaders = Array.from(document.querySelectorAll('.main-settlement-accordion-item .main-settlement-header h3'))
                    .filter(h3 => ((h3.textContent || '').replace(/^■\s*/, '')).includes('시공사'));
                if (contractorHeaders.length > 0) {
                    // Map headers to their top-level container nodes and deduplicate by header text
                    const seenByTitle = new Set();
                    const containersByTitle = [];
                    contractorHeaders.forEach(h3 => {
                        const title = (h3.textContent || '').replace(/^■\s*/, '').trim();
                        if (seenByTitle.has(title)) {
                            // remove duplicate containers for the same title
                            const fieldContainer = h3.closest('.main-settlement-accordion-item');
                            const container = fieldContainer && fieldContainer.parentElement && fieldContainer.parentElement.closest('.border-t.pt-4.mt-4')
                                ? fieldContainer.parentElement.closest('.border-t.pt-4.mt-4')
                                : (fieldContainer && fieldContainer.parentElement);
                            if (container && container.parentElement) {
                                try { container.parentElement.removeChild(container); } catch (e) {}
                            }
                        } else {
                            seenByTitle.add(title);
                            const fieldContainer = h3.closest('.main-settlement-accordion-item');
                            const container = fieldContainer && fieldContainer.parentElement && fieldContainer.parentElement.closest('.border-t.pt-4.mt-4')
                                ? fieldContainer.parentElement.closest('.border-t.pt-4.mt-4')
                                : (fieldContainer && fieldContainer.parentElement);
                            if (container) containersByTitle.push(container);
                        }
                    });

                    const keep = containersByTitle[0];
                    if (keep) {
                        const groupContainer = document.getElementById('settlement-group-summaries');
                        if (groupContainer && settlementContent) {
                            try { if (keep.parentElement !== settlementContent) { keep.parentElement && keep.parentElement.removeChild(keep); } } catch (e) {}
                            settlementContent.insertBefore(keep, groupContainer.nextSibling);
                        }
                    }
                }
            } catch (e) {
                console.warn('reorderSettlementPriority error', e);
            }
        }

        function handleAccordionHeaderKeydown(event) {
            if (event.defaultPrevented) return;
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                event.currentTarget.click();
            }
        }

        function toggleSubAccordion(e) {
             // Prevent card click event when clicking the header itself
            if (!e.target.closest('[data-filter-type="custom-group"]')) {
                 const subAccordionItem = e.currentTarget.closest('.sub-accordion-item');
                 if (!subAccordionItem) return;
                 subAccordionItem.classList.toggle('open');
                 const accordionKey = subAccordionItem.dataset.accordionKey;
                 const header = e.currentTarget;
                 const isOpen = subAccordionItem.classList.contains('open');
                 if (header) {
                    header.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
                 }
                 if (accordionKey) {
                    setCustomAccordionState(accordionKey, isOpen);
                    dismissAccordionHint(accordionKey);
                 }
                 
                 // Update scroll behavior after sub-accordion toggle and recompute today marker
                 setTimeout(() => {
                     updateSettlementScrollBehavior();
                     try {
                         const containerRef = fullscreenModal.classList.contains('hidden') 
                             ? document.getElementById('ganttViewContent') 
                             : fullscreenModalBody;
                         recomputeTodayMarkerHeight(containerRef);
                     } catch (e) {
                         // ignore errors silently
                     }
                 }, 120);
            }
        }


        function handleCardClick(e) {
            const card = e.target.closest('[data-filter-type]');
             // Prevent modal opening if clicking within a sub-accordion header (let the toggle handle it)
            if (!card || e.target.closest('.sub-accordion-header')) return;

            const filterType = card.dataset.filterType;
            const filterValue = card.dataset.filterValue;
            let title = '';
            let dataForModal = [];

            // Always operate on the latest filter-aware snapshot so summary cards
            // and 상세 목록 share the exact same dataset (manual/automatic filters alike).
            const baseData = getFilterAwareDataset();

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (filterType === 'status') {
                const statusText = filterValue === 'all' ? '전체 작업' : filterValue;
                title = `${statusText} 목록`;
                switch (filterValue) {
                    case 'all':
                        dataForModal = baseData;
                        break;
                    case '공사중':
                        dataForModal = baseData.filter(p => p.progress > 0 && p.progress < 100 && p.endDate >= today);
                        break;
                    case '착공전':
                        dataForModal = baseData.filter(p => (p.progress || 0) === 0 && p.endDate >= today);
                        break;
                    case '완료':
                        dataForModal = baseData.filter(p => p.progress === 100);
                        break;
                    case '지연':
                        dataForModal = baseData.filter(p => p.progress < 100 && p.endDate < today);
                        break;
                    default:
                        dataForModal = [];
                }
                if (dataForModal.length > 0) {
                    showDataDetailModal(title, dataForModal);
                }
            } else if (filterType === 'taskType') {
                title = `'${filterValue}' 상세 공정 현황`;
                dataForModal = baseData.filter(p => p.taskType === filterValue);
                 if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${filterValue}' 공정율`);
                }
            } else if (filterType === 'progress') {
                title = '총괄 상세 현황';
                dataForModal = baseData;
                if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, '총괄 공정율');
                }
            } else if (filterType === 'custom-group') {
                const field = card.dataset.filterField;
                const value = card.dataset.filterValue;
                title = `'${value}' (${field}) 상세 공정 현황`;
                dataForModal = baseData.filter(p => p.customFields?.[field] === value);
                 if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${value}' 공정율`);
                }
            // Improvement: Handle click on sub-cards in settlement group section
            } else if (filterType === 'custom-group-task') {
                const field = card.dataset.filterField;
                const value = card.dataset.filterValue;
                const taskType = card.dataset.filterTaskType;
                title = `'${value}' (${field}) - '${taskType}' 상세`;
                dataForModal = baseData.filter(p => p.customFields?.[field] === value && p.taskType === taskType);
                if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${taskType}' 공정율`);
                }
            }


             if (dataForModal.length > 0 && !e.target.closest('.sub-accordion-header')) {
                if (['status'].includes(filterType)) { // Only show simple list for status clicks
                     showDataDetailModal(title, dataForModal);
                 } else {
                     showProgressDetailModal(title, dataForModal, title.replace(' 상세 공정 현황', ' 공정율')); // Generate label
                 }
            } else if (dataForModal.length === 0 && !e.target.closest('.sub-accordion-header')) {
                 showToast('표시할 데이터가 없습니다.', 'info');
            }
        }

        function showProgressDetailModal(title, data, summaryLabel = '총괄 공정율') {
            // 모달 초기화
            const overlay = dataDetailModal;
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            
            const content = overlay.querySelector('.modal-content');
            // 모달 기본 크기 및 위치 설정
            content.style.width = '80%';
            content.style.maxWidth = '1200px';
            content.style.height = '80vh';
            content.style.maxHeight = '800px';
            content.style.position = 'relative';
            content.style.top = '0';
            content.style.left = '0';
            content.style.transform = 'none';
            content.style.margin = 'auto';
            
            dataDetailTitle.textContent = title;
            // Toolbar with export button and count
            const toolbarHTML = `<div class="flex justify-between items-center mb-3">
                    <div class="text-sm text-gray-600">총 <strong>${data.length}</strong>건</div>
                    <div><button class="table-export-btn px-3 py-1 bg-indigo-600 text-white rounded text-sm">엑셀 다운로드</button></div>
                </div>`;

            let tableHTML = `${toolbarHTML}<table class="w-full text-sm text-left text-gray-500">
                <thead class="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0">
                    <tr>
                        <th scope="col" class="px-4 py-3">No.</th>
                        <th scope="col" class="px-4 py-3">프로젝트 명</th>
                        <th scope="col" class="px-4 py-3 text-right">정산 (A)</th>
                        <th scope="col" class="px-4 py-3 text-right">진행 (B)</th>
                        <th scope="col" class="px-4 py-3 text-right">가중치 적용값 (A*B)</th>
                    </tr>
                </thead>
                <tbody>`;

            let totalPo = 0;
            let weightedProgressSum = 0;

            data.forEach((item, index) => {
                const po = item.poAmount || 0;
                const progress = item.progress || 0;
                const weightedValue = po * progress;
                totalPo += po;
                weightedProgressSum += weightedValue;
                // IMPROVEMENT: Apply accounting format
                tableHTML += `
                    <tr class="border-b hover:bg-gray-50">
                        <td class="px-4 py-2 font-medium text-gray-900">${index + 1}</td>
                        <td class="px-4 py-2">${item.name}</td>
                        <td class="px-4 py-2 text-right">${formatCurrency(po)}</td>
                        <td class="px-4 py-2 text-right">${progress}%</td>
                        <td class="px-4 py-2 text-right">${(weightedValue/100).toLocaleString('ko-KR')}</td>
                    </tr>`;
            });

            const overallProgressRate = totalPo > 0 ? (weightedProgressSum / totalPo).toFixed(2) : 0;

            tableHTML += `</tbody>
                <tfoot class="text-sm font-semibold text-gray-800 bg-gray-100">
                    <tr>
                        <td colspan="2" class="px-4 py-3 text-center">합계</td>
                        <td class="px-4 py-3 text-right">${formatCurrency(totalPo)}</td>
                        <td class="px-4 py-3 text-right">-</td>
                        <td class="px-4 py-3 text-right">${(weightedProgressSum/100).toLocaleString('ko-KR')}</td>
                    </tr>
                    <tr>
                        <td colspan="4" class="px-4 py-3 text-center text-base">${summaryLabel} (가중치 합계 / 정산 합계)</td>
                        <td class="px-4 py-3 text-right text-base font-bold text-blue-600">${overallProgressRate}%</td>
                    </tr>
                </tfoot>
            </table>`;

            dataDetailTableContainer.innerHTML = tableHTML;

            // Make table sortable and attach export
            const tbl = dataDetailTableContainer.querySelector('table');
            if (tbl) makeTableSortable(tbl);
            const btn = dataDetailTableContainer.querySelector('.table-export-btn');
            if (btn) btn.addEventListener('click', () => exportTableToXLSX(tbl, `${title.replace(/[^0-9a-zA-Z가-힣\s_-]/g,'') || 'export'}.xlsx`));

            // 모달 표시 및 스타일 설정
            dataDetailModal.classList.remove('hidden');
            dataDetailModal.style.display = 'flex';
            dataDetailModal.style.justifyContent = 'center';
            dataDetailModal.style.alignItems = 'center';
            
            // 모달 컨텐츠 크기와 위치 재조정
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                requestAnimationFrame(() => {
                    modalContent.style.position = 'relative';
                    modalContent.style.width = '80%';
                    modalContent.style.maxWidth = '1200px';
                    modalContent.style.height = '80vh';
                    modalContent.style.maxHeight = '800px';
                    modalContent.style.margin = 'auto';
                    modalContent.style.transform = 'none';
                    modalContent.style.top = '0';
                    modalContent.style.left = '0';
                    
                    // 스크롤바 위치 초기화
                    if (dataDetailTableContainer) {
                        dataDetailTableContainer.scrollTop = 0;
                    }
                });
            }
        }

        function showDataDetailModal(title, data) {
            dataDetailTitle.textContent = title;
            const toolbarHTML = `<div class="flex justify-between items-center mb-3">
                    <div class="text-sm text-gray-600">총 <strong>${data.length}</strong>건</div>
                    <div><button class="table-export-btn px-3 py-1 bg-indigo-600 text-white rounded text-sm">엑셀 다운로드</button></div>
                </div>`;

            let tableHTML = `${toolbarHTML}<table class="w-full text-sm text-left text-gray-500">
                <thead class="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0">
                    <tr>
                        <th scope="col" class="px-4 py-3">No.</th>
                        <th scope="col" class="px-4 py-3">프로젝트 명</th>
                        <th scope="col" class="px-4 py-3">상태</th>
                        <th scope="col" class="px-4 py-3">시작일</th>
                        <th scope="col" class="px-4 py-3">종료일</th>
                        <th scope="col" class="px-4 py-3 text-right">정산</th>
                    </tr>
                </thead>
                <tbody>`;

            data.forEach((item, index) => {
                // IMPROVEMENT: Apply accounting format
                tableHTML += `
                    <tr class="border-b hover:bg-gray-50">
                        <td class="px-4 py-2 font-medium text-gray-900">${index + 1}</td>
                        <td class="px-4 py-2">${item.name}</td>
                        <td class="px-4 py-2">${item.status}</td>
                        <td class="px-4 py-2">${formatDate(item.startDate)}</td>
                        <td class="px-4 py-2">${formatDate(item.endDate)}</td>
                        <td class="px-4 py-2 text-right">${formatCurrency(item.poAmount)}</td>
                    </tr>`;
            });

            tableHTML += `</tbody></table>`;
            dataDetailTableContainer.innerHTML = tableHTML;

            // Make table sortable and attach export
            const tbl = dataDetailTableContainer.querySelector('table');
            if (tbl) makeTableSortable(tbl);
            const btn = dataDetailTableContainer.querySelector('.table-export-btn');
            if (btn) btn.addEventListener('click', () => exportTableToXLSX(tbl, `${title.replace(/[^0-9a-zA-Z가-힣\s_-]/g,'') || 'export'}.xlsx`));

            // 모달 표시 및 스타일 설정
            dataDetailModal.classList.remove('hidden');
            dataDetailModal.style.display = 'flex';
            dataDetailModal.style.justifyContent = 'center';
            dataDetailModal.style.alignItems = 'center';
            
            // 모달 컨텐츠 크기와 위치 재조정
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                requestAnimationFrame(() => {
                    modalContent.style.position = 'relative';
                    modalContent.style.width = '80%';
                    modalContent.style.maxWidth = '1200px';
                    modalContent.style.height = '80vh';
                    modalContent.style.maxHeight = '800px';
                    modalContent.style.margin = 'auto';
                    modalContent.style.transform = 'none';
                    modalContent.style.top = '0';
                    modalContent.style.left = '0';
                    
                    // 스크롤바 위치 초기화
                    if (dataDetailTableContainer) {
                        dataDetailTableContainer.scrollTop = 0;
                    }
                });
            }
        }

        /**
         * 프로젝트의 현재 상태를 자동으로 계산합니다.
         * @param {number} progress - 프로젝트의 진행률 (0-100)
         * @param {Date} endDate - 프로젝트의 종료일
         * @returns {string} - 계산된 상태 ('착공전'|'공사중'|'완료'|'지연')
         */
        function calculateStatus(progress, endDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            if (progress === 100) return '완료';
            if (endDate < today) return '지연';
            if (progress === 0) return '착공전';
            return '공사중';
        }

        function dateDiffInDays(a, b) {
            const _MS_PER_DAY = 1000 * 60 * 60 * 24;
            const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
            const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());
            return Math.floor((utc2 - utc1) / _MS_PER_DAY);
        }

        function scrollToToday() {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if (!container) return; // Add check
            const todayMarker = container.querySelector('.gantt-today-marker-container');
            if (todayMarker) {
                const todayPosition = todayMarker.offsetLeft;
                const timelineContainer = container.querySelector('.gantt-timeline-body-wrapper');
                if(timelineContainer) {
                    const scrollTarget = todayPosition - (timelineContainer.clientWidth / 2);
                    timelineContainer.scrollTo({ left: scrollTarget, behavior: 'smooth' });
                }
            }
        }

        function handleResizeMousedown(e) {
            if (!e.target.classList.contains('resizer')) return;
            const titlesPane = e.target.closest('.gantt-titles');
            if (!titlesPane) return;

            e.preventDefault();

            const startX = e.clientX;
            const startWidth = titlesPane.offsetWidth;

            const doDrag = (moveEvent) => {
                const newWidth = startWidth + (moveEvent.clientX - startX);
                if (newWidth > 250 && newWidth < 900) {
                    titlesPane.style.width = `${newWidth}px`;
                }
            };

            const stopDrag = () => {
                document.documentElement.removeEventListener('mousemove', doDrag);
                document.documentElement.removeEventListener('mouseup', stopDrag);
            };

            document.documentElement.addEventListener('mousemove', doDrag);
            document.documentElement.addEventListener('mouseup', stopDrag);
        }

        function handleColResizeMousedown(e) {
            const resizer = e.target;
            const titlesPane = resizer.closest('.gantt-titles');
            if (!titlesPane) return;

            e.preventDefault();

            const leftColName = resizer.dataset.colLeft;
            const rightColName = resizer.dataset.colRight;

            // convert camelCase or underscored names to kebab-case CSS variable names
            const toKebab = (s) => String(s).replace(/([a-z0-9])([A-Z])/g, '$1-$2').replace(/_/g, '-').toLowerCase();
            const leftColVar = `--${toKebab(leftColName)}-col-width`;
            const rightColVar = `--${toKebab(rightColName)}-col-width`;

            const startX = e.clientX;
            const startLeftWidth = parseFloat(getComputedStyle(titlesPane).getPropertyValue(leftColVar));
            const startRightWidth = parseFloat(getComputedStyle(titlesPane).getPropertyValue(rightColVar));
            const minWidth = 60;

            const doDrag = (moveEvent) => {
                const diffX = moveEvent.clientX - startX;
                let newLeftWidth = startLeftWidth + diffX;
                let newRightWidth = startRightWidth - diffX;

                if (newLeftWidth < minWidth) {
                    newLeftWidth = minWidth;
                    newRightWidth = startLeftWidth + startRightWidth - minWidth;
                }
                if (newRightWidth < minWidth) {
                    newRightWidth = minWidth;
                    newLeftWidth = startLeftWidth + startRightWidth - minWidth;
                }

                titlesPane.style.setProperty(leftColVar, `${newLeftWidth}px`);
                titlesPane.style.setProperty(rightColVar, `${newRightWidth}px`);
            };

            const stopDrag = () => {
                document.documentElement.removeEventListener('mousemove', doDrag);
                document.documentElement.removeEventListener('mouseup', stopDrag);
            };

            document.documentElement.addEventListener('mousemove', doDrag);
            document.documentElement.addEventListener('mouseup', stopDrag);
        }

        function handleColumnToggle(toggleBtn) {
            const colName = toggleBtn.dataset.col;
            if (colName && typeof columnVisibility[colName] !== 'undefined') {
                columnVisibility[colName] = !columnVisibility[colName];
                toggleBtn.textContent = columnVisibility[colName] ? '[-]' : '[+]';
                const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                 if (!container) return; // Add check
                const elementsToToggle = container.querySelectorAll(`.${colName}`);
                elementsToToggle.forEach(el => {
                    el.style.display = columnVisibility[colName] ? '' : 'none';
                    if (colName === 'project-dates' && columnVisibility[colName]) {
                         el.style.display = 'flex';
                    }
                });
            }
        }

        // 두 번째 버전의 handleDateEditClick 제거됨 - 통합 모달 시스템 사용

        // 개선 사항: 진행률 업데이트 후 해당 프로젝트의 DOM 요소를 직접 업데이트하는 함수
        function updateProgressInDOM(projectId, newProgress) {
            // ID 타입 통일 (문자열로 변환)
            const projectIdStr = String(projectId);
            
            // 모든 가능한 컨테이너에서 찾기
            const containers = [];
            const ganttViewContent = document.getElementById('ganttViewContent');
            if (ganttViewContent) containers.push(ganttViewContent);
            if (fullscreenModalBody) containers.push(fullscreenModalBody);
            
            containers.forEach(container => {
                // 진행률 텍스트 업데이트 (모든 매칭 요소)
                const progressEditors = container.querySelectorAll(`.progress-editor[data-project-id="${projectIdStr}"]`);
                progressEditors.forEach(progressEditor => {
                    progressEditor.textContent = `${newProgress}%`;
                });

                // 진행률 바 업데이트 (모든 매칭 요소)
                const titleItems = container.querySelectorAll(`.title-item[data-project-id="${projectIdStr}"]`);
                titleItems.forEach(titleItem => {
                    const progressSummary = titleItem.querySelector('.project-progress-summary');
                    if (progressSummary) {
                        const progressBar = progressSummary.querySelector('div > div');
                        if (progressBar) {
                            progressBar.style.width = `${newProgress}%`;
                            progressBar.style.background = getProgressGradient(newProgress);
                        }
                        progressSummary.setAttribute('title', `${newProgress}%`);
                        progressSummary.setAttribute('aria-label', `진행률 ${newProgress}%`);
                    }
                });

                // 간트 차트의 진행률 바 업데이트 (모든 매칭 요소)
                const barRows = container.querySelectorAll(`.gantt-bar-row[data-project-id="${projectIdStr}"]`);
                barRows.forEach(barRow => {
                    const progressFill = barRow.querySelector('.gantt-bar-progress');
                    if (progressFill) {
                        const bar = barRow.querySelector('.gantt-bar');
                        if (bar) {
                            const barWidth = parseFloat(bar.style.width) || 0;
                            progressFill.style.width = `${barWidth * (newProgress / 100)}px`;
                        }
                    }
                    const tooltip = barRow.querySelector('.tooltip');
                    if (tooltip) {
                        tooltip.innerHTML = tooltip.innerHTML.replace(/<strong>진행:<\/strong> \d+%/, `<strong>진행:</strong> ${newProgress}%`);
                    }
                });
            });
        }

        // 두 번째 버전의 handleProgressEditClick 제거됨 - 통합 모달 시스템 사용

        function handleLegendClick(legendItem) {
            const status = legendItem.dataset.statusFilter;
            const isActive = legendItem.classList.contains('legend-filter-active');

             // Target legend within the correct container
             const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if(legendContainer) {
                 legendContainer.querySelectorAll('.legend-section [data-status-filter].legend-filter-active').forEach(el => el.classList.remove('legend-filter-active'));
             }

            // 새로운 날짜 기반 범례 처리
            const dateBasedFilters = ['오늘시작', '오늘종료', '내일시작', '내일종료'];
            let targetDate = null;
            let shouldScroll = false;

            if (dateBasedFilters.includes(status)) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);

                if (status === '오늘시작' || status === '오늘종료') {
                    targetDate = new Date(today);
                } else if (status === '내일시작' || status === '내일종료') {
                    targetDate = new Date(tomorrow);
                }
                shouldScroll = true;
                legendStatusFilter = status;
                legendItem.classList.add('legend-filter-active');
            } else if (status === '전체') {
                legendStatusFilter = null;
                // No active highlight for '전체'
            } else if (isActive) {
                legendStatusFilter = null;
            } else {
                legendStatusFilter = status;
                legendItem.classList.add('legend-filter-active');
            }

            if (searchInput) searchInput.value = '';

            render();

            // 날짜로 스크롤
            if (shouldScroll && targetDate) {
                setTimeout(() => {
                    scrollToDate(targetDate);
                }, 100);
            }
        }

        function scrollToDate(targetDate) {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (!container) return;

            const timelineContainer = container.querySelector('.gantt-timeline-body-wrapper');
            if (!timelineContainer) return;

            // 날짜를 픽셀 위치로 변환
            const dateOffset = dateDiffInDays(viewMinDate, targetDate);
            const targetPosition = dateOffset * DAY_WIDTH;

            // 중앙으로 스크롤
            const scrollTarget = Math.max(0, targetPosition - (timelineContainer.clientWidth / 2));
            timelineContainer.scrollTo({ left: scrollTarget, behavior: 'smooth' });
        }

        function renderGanttChart(data) {
             const isInFullscreen = !fullscreenModal.classList.contains('hidden');
             const container = isInFullscreen ? fullscreenModalBody : document.getElementById('ganttViewContent');
             if (!container) return; // Exit if container not found
             const currentGanttContainer = container.querySelector('#ganttChart'); // Find chart within the current container
             if (!currentGanttContainer) return; // Exit if chart area not found


            currentGanttContainer.innerHTML = '';

            if (!viewMinDate || !viewMaxDate) {
                currentGanttContainer.innerHTML = `<p class="text-center text-gray-500 p-8">데이터가 없습니다. 우측 하단 메뉴를 통해 데이터를 업로드하세요.</p>`;
                return;
            }

            const ganttEl = document.createElement('div');
            ganttEl.className = 'gantt-chart-container';

            const titlesPane = document.createElement('div');
            titlesPane.className = 'gantt-titles';

            if (savedSettings) {
                if (savedSettings.titlesPaneWidth) {
                    titlesPane.style.width = savedSettings.titlesPaneWidth;
                }
                if (savedSettings.columnWidths) {
                    titlesPane.style.setProperty('--po-col-width', savedSettings.columnWidths.po);
                    titlesPane.style.setProperty('--dates-col-width', savedSettings.columnWidths.dates);
                    titlesPane.style.setProperty('--progress-col-width', savedSettings.columnWidths.progress);
                    // Restore the newly added progress summary column width if available
                    if (typeof savedSettings.columnWidths.progressSummary !== 'undefined' && savedSettings.columnWidths.progressSummary !== null) {
                        titlesPane.style.setProperty('--progress-summary-col-width', savedSettings.columnWidths.progressSummary);
                    }
                }
            }

            const headerEl = document.createElement('div');
            headerEl.className = 'header flex items-center';
            headerEl.innerHTML = `
                <div class="flex items-center flex-grow pr-2">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-name">${columnVisibility['project-name'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">명칭</span>
                </div>

                <div class="header-col justify-start items-center" style="width: var(--po-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-po">${columnVisibility['project-po'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">정산</span>
                </div>
                <div class="col-resizer" data-col-left="po" data-col-right="dates"></div>
                <div class="header-col justify-start items-center" style="width: var(--dates-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-dates">${columnVisibility['project-dates'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">기간</span>
                </div>
                <div class="col-resizer" data-col-left="dates" data-col-right="progress"></div>
                <div class="header-col justify-start items-center" style="width: var(--progress-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-progress">${columnVisibility['project-progress'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">진행</span>
                </div>
                <div class="col-resizer" data-col-left="progress" data-col-right="progressSummary"></div>
                <div class="header-col justify-start items-center" style="width: var(--progress-summary-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-progress-summary">${columnVisibility['project-progress-summary'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">진행률</span>
                </div>
            `;
            titlesPane.appendChild(headerEl);

            const resizer = document.createElement('div');
            resizer.className = 'resizer';
            titlesPane.appendChild(resizer);

            const titlesBodyWrapper = document.createElement('div');
            titlesBodyWrapper.className = 'gantt-titles-body-wrapper';
            
            // [핵심 수정] 의존성 선을 그리기 위한 SVG 추가
            const dependencySvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            dependencySvg.className = 'task-list-dependency-svg';
            dependencySvg.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; overflow: visible;';
            titlesBodyWrapper.appendChild(dependencySvg);


            const timelineWrapper = document.createElement('div');
            timelineWrapper.className = 'gantt-timeline-wrapper';

            const timelineHeaderWrapper = document.createElement('div');
            timelineHeaderWrapper.className = 'gantt-timeline-header-wrapper';

            const timelineBodyWrapper = document.createElement('div');
            timelineBodyWrapper.className = 'gantt-timeline-body-wrapper';

            const timelineHeader = document.createElement('div');
            timelineHeader.className = 'gantt-timeline-header';
            const yearMonthHeader = document.createElement('div');
            yearMonthHeader.className = 'gantt-year-month-header';
            const dayHeader = document.createElement('div');
            dayHeader.className = 'gantt-day-header';
            const weekdayHeader = document.createElement('div');
            weekdayHeader.className = 'gantt-weekday-header';

            const totalDays = dateDiffInDays(viewMinDate, viewMaxDate);
            const timelineWidth = (totalDays + 1) * DAY_WIDTH;

            let currentMonth = -1, monthDayCount = 0, monthEl;
            const weekdays = ['일', '월', '화', '수', '목', '금', '토'];
            
            // 개선 사항: 메모리 최적화 - DocumentFragment를 사용하여 DOM 조작 최소화
            const dayFragment = document.createDocumentFragment();
            const weekdayFragment = document.createDocumentFragment();

            for (let i = 0; i <= totalDays; i++) {
                const date = new Date(viewMinDate);
                date.setDate(date.getDate() + i);
                const dayOfWeek = date.getDay();
                const isWeekendOrHoliday = dayOfWeek === 0 || dayOfWeek === 6 || isHoliday(date);

                if (date.getMonth() !== currentMonth) {
                    if (monthEl) monthEl.style.width = `${monthDayCount * DAY_WIDTH}px`;
                    currentMonth = date.getMonth();
                    monthDayCount = 0;
                    monthEl = document.createElement('div');
                    monthEl.className = 'gantt-month';
                    monthEl.textContent = `${date.getFullYear()}년 ${currentMonth + 1}월`;
                    yearMonthHeader.appendChild(monthEl);
                }
                monthDayCount++;

                const dayEl = document.createElement('div');
                dayEl.className = 'gantt-day';
                dayEl.style.width = `${DAY_WIDTH}px`;
                dayEl.textContent = date.getDate();
                if(isWeekendOrHoliday) {
                    dayEl.classList.add('bg-red-50', 'text-red-500', 'font-bold');
                } else if (dayOfWeek === 6) {
                    dayEl.classList.add('bg-gray-100');
                }
                dayFragment.appendChild(dayEl);

                const weekdayEl = document.createElement('div');
                weekdayEl.className = 'gantt-weekday';
                weekdayEl.style.width = `${DAY_WIDTH}px`;
                weekdayEl.textContent = weekdays[dayOfWeek];
                if (isWeekendOrHoliday) {
                    weekdayEl.classList.add('text-red-500', 'font-bold');
                }
                weekdayFragment.appendChild(weekdayEl);
            }
            if (monthEl) monthEl.style.width = `${monthDayCount * DAY_WIDTH}px`;
            
            // DocumentFragment를 한 번에 추가하여 DOM 재계산 최소화
            dayHeader.appendChild(dayFragment);
            weekdayHeader.appendChild(weekdayFragment);

            timelineHeader.appendChild(yearMonthHeader);
            timelineHeader.appendChild(dayHeader);
            timelineHeader.appendChild(weekdayHeader);
            timelineHeader.style.width = `${timelineWidth}px`;

            const ganttBody = document.createElement('div');
            ganttBody.className = 'gantt-body';
            ganttBody.style.width = `${timelineWidth}px`;

            const gridAndMarkerContainer = document.createElement('div');
            gridAndMarkerContainer.style.position = 'absolute';
            gridAndMarkerContainer.style.top = '0';
            gridAndMarkerContainer.style.left = '0';
            gridAndMarkerContainer.style.width = '100%';
            gridAndMarkerContainer.style.height = '100%';
            gridAndMarkerContainer.style.zIndex = '1';

            // 개선 사항: 메모리 최적화 - DocumentFragment를 사용하여 DOM 조작 최소화
            const gridFragment = document.createDocumentFragment();
            for (let i = 0; i <= totalDays; i++) {
                const line = document.createElement('div');
                line.className = 'gantt-grid-line';
                line.style.left = `${i * DAY_WIDTH}px`;
                gridFragment.appendChild(line);
            }
            gridAndMarkerContainer.appendChild(gridFragment);
            ganttBody.appendChild(gridAndMarkerContainer);

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (today >= viewMinDate && today <= viewMaxDate) {
                const todayOffsetDays = dateDiffInDays(viewMinDate, today);
                const todayLeftPosition = `${todayOffsetDays * DAY_WIDTH + (DAY_WIDTH/2)}px`;

                // 헤더의 "오늘" 마커 생성
                const headerMarkerContainer = document.createElement('div');
                headerMarkerContainer.className = 'gantt-today-marker-container';
                headerMarkerContainer.style.left = todayLeftPosition;
                headerMarkerContainer.style.height = '32px';
                headerMarkerContainer.style.bottom = 'auto';
                headerMarkerContainer.style.pointerEvents = 'none'; // 마우스 이벤트 방지

                const headerMarkerLine = document.createElement('div');
                headerMarkerLine.className = 'gantt-today-marker';

                const markerLabel = document.createElement('div');
                markerLabel.className = 'gantt-today-label';
                markerLabel.textContent = '오늘';

                headerMarkerContainer.appendChild(headerMarkerLine);
                headerMarkerContainer.appendChild(markerLabel);
                timelineHeaderWrapper.appendChild(headerMarkerContainer);

                // 본문의 "오늘" 마커 생성
                const bodyMarkerContainer = document.createElement('div');
                bodyMarkerContainer.className = 'gantt-today-marker-container';
                bodyMarkerContainer.style.left = todayLeftPosition;
                bodyMarkerContainer.style.zIndex = '3';
                bodyMarkerContainer.style.pointerEvents = 'none'; // 마우스 이벤트 방지
                bodyMarkerContainer.style.position = 'absolute';
                bodyMarkerContainer.style.top = '0';
                bodyMarkerContainer.style.bottom = '0'; // 전체 높이 설정

                const bodyMarkerLine = document.createElement('div');
                bodyMarkerLine.className = 'gantt-today-marker';
                bodyMarkerLine.style.height = '100%'; // 컨테이너 전체 높이 사용
                
                bodyMarkerContainer.appendChild(bodyMarkerLine);
                ganttBody.appendChild(bodyMarkerContainer);
            }

            const titlesBody = document.createElement('div');
            const ganttRowsBody = document.createElement('div');

            const milestoneTrack = document.createElement('div');
            milestoneTrack.className = 'milestone-track';
            ganttBody.appendChild(milestoneTrack);

            const milestoneTitleRow = document.createElement('div');
            milestoneTitleRow.className = 'milestone-title-row';
            milestoneTitleRow.innerHTML = `<span>⏱ 마일스톤</span>`;
            titlesBody.appendChild(milestoneTitleRow);

            milestones.forEach(m => {
                const mDate = parseLocalDateString(m.date);
                if (mDate && viewMinDate && viewMaxDate && mDate >= viewMinDate && mDate <= viewMaxDate) {
                    const offset = dateDiffInDays(viewMinDate, mDate);
                    const marker = document.createElement('div');
                    marker.className = 'milestone-marker';
                    marker.style.left = `${offset * DAY_WIDTH + (DAY_WIDTH / 2)}px`;
                    // 마일스톤 표시를 YYYY-MM-DD 형식으로만 표시

                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.innerHTML = `<strong>${m.name}</strong><br>${formatDateYMD(mDate)}`;
                    marker.setAttribute('title', `${m.name} (${formatDateYMD(mDate)})`);
                    marker.appendChild(tooltip);

                    milestoneTrack.appendChild(marker);
                }
            });

            ganttBody.appendChild(ganttRowsBody);

            const groupedData = {};
            const taskTypeOrder = [];
            data.forEach(project => {
                if (!groupedData[project.taskType]) {
                    groupedData[project.taskType] = [];
                    taskTypeOrder.push(project.taskType);
                }
                groupedData[project.taskType].push(project);
            });

            const sortMode = sortState.mode || (sortBy ? sortBy.value : 'default');
            const sortDirection = (sortMode && sortMode !== 'default') ? (sortState.direction || SORT_DIRECTIONS.DESC) : SORT_DIRECTIONS.DESC;
            const renderFlatList = hierarchyOrder === 'bottom';

            const compareMetrics = (valueA, valueB) => {
                if (!sortMode || sortMode === 'default') return 0;
                return compareValuesWithDirection(valueA, valueB, sortDirection);
            };

            const getProjectDuration = (project) => {
                if (project?.startDate instanceof Date && project?.endDate instanceof Date && !isNaN(project.startDate) && !isNaN(project.endDate)) {
                    return dateDiffInDays(project.startDate, project.endDate) + 1;
                }
                return 0;
            };

            const getProjectMetricByMode = (project, mode) => getProjectMetricValue(project, mode);

            if (sortMode && sortMode !== 'default' && !renderFlatList) {
                Object.keys(groupedData).forEach(taskType => {
                    groupedData[taskType].sort((p1, p2) => compareMetrics(
                        getProjectMetricByMode(p1, sortMode),
                        getProjectMetricByMode(p2, sortMode)
                    ));
                });
            }

            const groupStats = {};
            Object.keys(groupedData).forEach(taskType => {
                const projects = groupedData[taskType];
                let minStart = null, maxEnd = null, totalDuration = 0, totalPo = 0, weightedProgressSum = 0;
                projects.forEach(p => {
                    if (p.startDate && !isNaN(p.startDate)) {
                        if (minStart === null || p.startDate < minStart) minStart = p.startDate;
                    }
                    if (p.endDate && !isNaN(p.endDate)) {
                        if (maxEnd === null || p.endDate > maxEnd) maxEnd = p.endDate;
                    }
                    const dur = getProjectDuration(p);
                    totalDuration += dur;
                    const po = p.poAmount || 0;
                    totalPo += po;
                    weightedProgressSum += (p.progress || 0) * po;
                });
                const groupProgress = totalPo > 0 ? Math.round(weightedProgressSum / totalPo) : 0;
                groupStats[taskType] = { minStart, maxEnd, totalDuration, totalPo, groupProgress };
            });

            const getGroupSortMetric = (taskType) => {
                const stats = groupStats[taskType] || {};
                switch (sortMode) {
                    case 'startDate':
                        return stats.minStart ? +stats.minStart : null;
                    case 'endDate':
                        return stats.maxEnd ? +stats.maxEnd : null;
                    case 'duration':
                        return stats.totalDuration || 0;
                    case 'progress':
                        return stats.groupProgress || 0;
                    default:
                        return null;
                }
            };

            const getChildSortMetric = (taskType) => {
                const projects = groupedData[taskType];
                if (!projects || projects.length === 0) return null;
                return getProjectMetricByMode(projects[0], sortMode);
            };

            const searchTerm = (searchInput?.value || '');

            const createProjectRowElements = (project) => {
                let displayName = project.name;
                if (searchTerm) {
                    const regex = new RegExp(searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
                    displayName = displayName.replace(regex, match => `<span class="search-highlight">${match}</span>`);
                }

                const completedClass = project.progress === 100 ? 'text-gray-400 line-through' : '';

                const titleItem = document.createElement('div');
                titleItem.className = 'title-item';
                titleItem.__projectRef = project;
                const projectIndex = projectData.indexOf(project);
                const stableProjectId = ensureProjectHasStableId(
                    project,
                    projectIndex !== -1 ? `idx:${projectIndex}` : '',
                    project?.name || ''
                );
                if (stableProjectId) {
                    titleItem.dataset.projectId = stableProjectId;
                } else {
                    delete titleItem.dataset.projectId;
                }
                if (projectIndex !== -1) {
                    titleItem.dataset.projectIndex = String(projectIndex);
                }

                const startCurrentYmd = getNormalizedProjectDateString(project, 'startDate');
                const endCurrentYmd = getNormalizedProjectDateString(project, 'endDate');
                const originalStart = getOriginalDateValue(project, 'startDate') || '';
                const originalEnd = getOriginalDateValue(project, 'endDate') || '';
                const originalProgress = getOriginalProgress(project);
                const currentProgress = typeof project.progress === 'number' ? project.progress : (project.progress || 0);
                const isProgressCompleted = Number(project.progress) === 100;
                // [핵심 수정] '변경' 라벨 표시 로직 강화 - 빈 문자열도 비교 대상에 포함
                const startChanged = originalStart !== undefined && originalStart !== null && startCurrentYmd !== undefined && startCurrentYmd !== null && 
                                     String(originalStart).trim() !== '' && String(startCurrentYmd).trim() !== '' && 
                                     String(originalStart).trim() !== String(startCurrentYmd).trim();
                const endChanged = originalEnd !== undefined && originalEnd !== null && endCurrentYmd !== undefined && endCurrentYmd !== null && 
                                   String(originalEnd).trim() !== '' && String(endCurrentYmd).trim() !== '' && 
                                   String(originalEnd).trim() !== String(endCurrentYmd).trim();
                const progressChanged = (typeof originalProgress === 'number' && typeof currentProgress === 'number' && originalProgress !== currentProgress) ||
                                       (originalProgress !== undefined && originalProgress !== null && currentProgress !== undefined && currentProgress !== null && 
                                        String(originalProgress).trim() !== '' && String(currentProgress).trim() !== '' && 
                                        Number(originalProgress) !== Number(currentProgress));
                const startSpanClass = `date-editor start-date${startChanged ? ' date-changed' : ''}${isProgressCompleted ? ' date-completed' : ''}`;
                const endSpanClass = `date-editor end-date${endChanged ? ' date-changed' : ''}${isProgressCompleted ? ' date-completed' : ''}`;
                const progressSpanClass = `progress-editor${progressChanged ? ' date-changed' : ''}`;
                const hasDateChange = startChanged || endChanged || progressChanged;
                const startTitle = startCurrentYmd
                    ? (startChanged ? `현재: ${startCurrentYmd} | 원본: ${originalStart}` : `현재: ${startCurrentYmd}`)
                    : (originalStart ? `원본: ${originalStart}` : '날짜 없음');
                const endTitle = endCurrentYmd
                    ? (endChanged ? `현재: ${endCurrentYmd} | 원본: ${originalEnd}` : `현재: ${endCurrentYmd}`)
                    : (originalEnd ? `원본: ${originalEnd}` : '날짜 없음');

                // 의존성 정보 가져오기
                const hasDependency = project.dependsOn && project.dependsOn.length > 0;
                const dependencyBtnClass = hasDependency ? 'dependency-setting-btn has-dependency' : 'dependency-setting-btn';
                const dependencyBtnTitle = hasDependency ? `의존성: ${project.dependsOn.map(dep => {
                    const depProject = projectData.find(p => String(p.id) === String(dep.projectId));
                    return depProject ? depProject.name : '알 수 없음';
                }).join(', ')}` : '의존성 설정';
                
                // [핵심 수정] 현재 프로젝트가 다른 프로젝트의 의존성인지 확인 (연결 표시용)
                const isDependencyOf = projectData.filter(p => 
                    p.dependsOn && Array.isArray(p.dependsOn) && 
                    p.dependsOn.some(dep => String(dep.projectId) === String(project.id))
                );
                
                // [핵심 수정] 의존성 표시 기호 생성 (프로젝트명 라벨 제거, 직각 선으로 연결)
                let dependencySymbolsHTML = '';
                if (hasDependency && project.dependsOn.length > 0) {
                    const colorMap = {
                        'start-to-start': '#2563eb',
                        'end-to-start':   '#10b981',
                        'end-to-end':     '#f59e0b',
                        'start-to-end':   '#ef4444'
                    };
                    
                    const typeMap = {
                        'start-to-start': 'SS',
                        'end-to-start': 'FS',
                        'end-to-end': 'FF',
                        'start-to-end': 'SF'
                    };
                    
                    project.dependsOn.forEach((dep, index) => {
                        const depProject = projectData.find(p => String(p.id) === String(dep.projectId));
                        const depName = depProject ? depProject.name : '알 수 없음';
                        const depColor = colorMap[dep.type] || '#9ca3af';
                        const depType = typeMap[dep.type] || dep.type;
                        
                        // [핵심 수정] 클릭 가능한 의존성 표시 기호 (직각 선으로 연결)
                        dependencySymbolsHTML += `
                            <span class="dependency-symbol dependency-symbol-clickable" style="color: ${depColor}; margin-left: 4px; cursor: pointer;" data-depends-on-id="${dep.projectId}" data-dep-type="${dep.type}" data-project-id="${stableProjectId}" data-dep-index="${index}" title="클릭하여 '${escapeAttribute(depName)}'로 이동 (${depType})">
                                <span class="dependency-start-circle" style="color: ${depColor};">○</span>
                                <span class="dependency-line" style="color: ${depColor};">-----</span>
                                <span class="dependency-end-circle" style="color: ${depColor};">●</span>
                            </span>
                        `;
                    });
                }
                
                // [핵심 수정] 연결 표시 추가 (현재 프로젝트가 다른 프로젝트의 의존성인 경우)
                if (isDependencyOf.length > 0) {
                    const incomingDepsNames = isDependencyOf.map(p => p.name).join(', ');
                    dependencySymbolsHTML += `
                        <span class="dependency-symbol dependency-symbol-incoming" 
                              style="color: #9ca3af; margin-left: 4px; font-size: 11px;" 
                              title="이 작업에 의존하는 작업: ${escapeAttribute(incomingDepsNames)}">
                            ← 의존됨 (${isDependencyOf.length})
                        </span>
                    `;
                }
                
                titleItem.innerHTML = `
                    <span class="project-name ${completedClass}" style="display: ${columnVisibility['project-name'] ? '' : 'none'}" title="${escapeAttribute(project.name)}">
                        ${displayName}
                        <button type="button" class="${dependencyBtnClass}" data-project-id="${stableProjectId}" title="${escapeAttribute(dependencyBtnTitle)}" style="pointer-events: auto; cursor: pointer; background: ${hasDependency ? '#eff6ff' : '#ffffff'}; border: 1px solid ${hasDependency ? '#60a5fa' : '#d1d5db'};">
                            <span style="color: transparent; text-shadow: 0 0 0 ${hasDependency ? '#3b82f6' : '#d1d5db'};">
                                ${hasDependency ? '⛓️' : '🔗'}
                            </span>
                        </button>
                        ${dependencySymbolsHTML}
                    </span>
                    <div class="flex items-center flex-shrink-0">
                        <span class="project-po ${completedClass}" style="width: var(--po-col-width); display: ${columnVisibility['project-po'] ? '' : 'none'}">${formatCurrency(project.poAmount)}</span>
                        <div class="project-dates ${completedClass}" style="width: var(--dates-col-width); margin: 0; display: ${columnVisibility['project-dates'] ? 'flex' : 'none'}">
                            <span class="${startSpanClass}" data-project-id="${stableProjectId}" ${projectIndex !== -1 ? `data-project-index="${projectIndex}"` : ''} data-date-type="startDate" data-original-date="${escapeAttribute(originalStart)}" data-current-date="${escapeAttribute(startCurrentYmd)}" title="${escapeAttribute(startTitle)}">${formatDate(project.startDate)}</span>
                            <span>~</span>
                            <span class="${endSpanClass}" data-project-id="${stableProjectId}" ${projectIndex !== -1 ? `data-project-index="${projectIndex}"` : ''} data-date-type="endDate" data-original-date="${escapeAttribute(originalEnd)}" data-current-date="${escapeAttribute(endCurrentYmd)}" title="${escapeAttribute(endTitle)}">${formatDate(project.endDate)}</span>
                        </div>
                        <span class="project-progress" style="width: var(--progress-col-width); display: ${columnVisibility['project-progress'] ? '' : 'none'}">
                           <span class="${progressSpanClass}" data-project-id="${stableProjectId}" data-original-progress="${originalProgress !== '' ? originalProgress : ''}" data-current-progress="${currentProgress}" title="${progressChanged ? `현재: ${currentProgress}% | 원본: ${originalProgress}%` : `현재: ${currentProgress}%`}">${project.progress || 0}%</span>
                        </span>
                        <div class="project-progress-summary" style="width: var(--progress-summary-col-width); display: ${columnVisibility['project-progress-summary'] ? '' : 'none'}; padding-left:8px;" title="${project.progress || 0}%" aria-label="진행률 ${project.progress || 0}%">
                            <div style="background:#f1f5f9;border-radius:6px;height:8px;overflow:hidden;position:relative;">
                                <div style="background:${getProgressGradient(project.progress || 0)};height:8px;width:${project.progress || 0}%;transition:width:0.3s;box-shadow:0 1px 3px rgba(0,0,0,0.06);"></div>
                            </div>
                        </div>
                    </div>
                `;

                // 의존성 설정 버튼이 항상 동작하도록 직접 리스너 등록 (동적 생성 요소 대응)
                const dependencyBtn = titleItem.querySelector('.dependency-setting-btn');
                if (dependencyBtn && !dependencyBtn.hasAttribute('data-listener-attached')) {
                    dependencyBtn.__projectRef = project;
                    if (projectIndex !== -1 && !dependencyBtn.hasAttribute('data-project-index')) {
                        dependencyBtn.setAttribute('data-project-index', String(projectIndex));
                    }
                    dependencyBtn.setAttribute('data-listener-attached', 'true');
                    dependencyBtn.addEventListener('click', (event) => {
                        handleDependencyButtonActivation(event, dependencyBtn);
                    }, true); // capture 단계에서 처리하여 다른 리스너보다 우선 실행
                }
                
                // [핵심 수정] 의존성 표시 기호 클릭 이벤트 핸들러 추가
                const dependencySymbols = titleItem.querySelectorAll('.dependency-symbol-clickable');
                dependencySymbols.forEach(symbol => {
                    if (!symbol.hasAttribute('data-click-listener-attached')) {
                        symbol.setAttribute('data-click-listener-attached', 'true');
                        symbol.addEventListener('click', (e) => {
                            // [핵심 수정] date-editor나 progress-editor 클릭을 방해하지 않도록 확인
                            const dateEditor = e.target.closest('.date-editor');
                            const progressEditor = e.target.closest('.progress-editor');
                            if (dateEditor || progressEditor) {
                                // date-editor나 progress-editor 클릭이면 이벤트 전파 허용
                                return;
                            }
                            e.stopPropagation();
                            
                            const dependsOnId = symbol.dataset.dependsOnId;
                            if (!dependsOnId) return;
                            
                            // 연결된 프로젝트의 title-item 찾기
                            const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                            const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                            if (!container) return;
                            
                            const titlesBodyWrapper = container.querySelector('.gantt-titles-body-wrapper');
                            if (!titlesBodyWrapper) return;
                            
                            const titlesBody = titlesBodyWrapper.querySelector('.gantt-titles-body');
                            if (!titlesBody) return;
                            
                            // [핵심 수정] 모든 title-item 검색 (그룹 내부 포함) 및 그룹 자동 펼치기
                            const findTitleItem = async (dependsOnId, titlesBody) => {
                                // 먼저 모든 title-item 검색 (보이는 것만)
                                const allTitleItems = titlesBody.querySelectorAll('.title-item');
                                for (const item of allTitleItems) {
                                    if (item.dataset.projectId === dependsOnId) {
                                        // 요소가 보이는지 확인
                                        const rect = item.getBoundingClientRect();
                                        if (rect.width > 0 && rect.height > 0) {
                                            return item;
                                        }
                                    }
                                }
                                
                                // 찾지 못한 경우, 그룹 내부 검색
                                const groupContainers = titlesBody.querySelectorAll('.group-item-container');
                                for (const groupContainer of groupContainers) {
                                    const taskType = groupContainer.dataset.taskType;
                                    if (!taskType) continue;
                                    
                                    // 접혀있는 그룹이면 펼치기
                                    if (groupContainer.classList.contains('hidden')) {
                                        const groupHeader = titlesBody.querySelector(`.group-header[data-task-type="${taskType}"]`);
                                        if (groupHeader) {
                                            // 그룹 헤더 클릭 이벤트 트리거
                                            groupHeader.click();
                                            // DOM 업데이트 대기
                                            await new Promise(resolve => setTimeout(resolve, 200));
                                        }
                                    }
                                    
                                    // 그룹 내부 검색
                                    const items = groupContainer.querySelectorAll('.title-item');
                                    for (const item of items) {
                                        if (item.dataset.projectId === dependsOnId) {
                                            return item;
                                        }
                                    }
                                }
                                
                                return null;
                            };
                            
                            // [핵심 수정] 스크롤 컨테이너 확인 및 직접 스크롤 위치 계산
                            const scrollToTarget = (targetItem, scrollContainer, timelineBodyWrapper) => {
                                // 타겟 요소의 위치 계산
                                const targetRect = targetItem.getBoundingClientRect();
                                const containerRect = scrollContainer.getBoundingClientRect();
                                const currentScrollTop = scrollContainer.scrollTop || 0;
                                
                                // 타겟 요소의 상대 위치 계산
                                const targetTop = targetRect.top - containerRect.top + currentScrollTop;
                                const containerHeight = scrollContainer.clientHeight;
                                const targetHeight = targetRect.height;
                                
                                // 중앙으로 스크롤
                                const scrollTarget = targetTop - (containerHeight / 2) + (targetHeight / 2);
                                const finalScrollTop = Math.max(0, scrollTarget);
                                
                                // 스크롤 이동
                                scrollContainer.scrollTo({
                                    top: finalScrollTop,
                                    behavior: 'smooth'
                                });
                                
                                // 타임라인 영역도 동기화 (스크롤 동기화 로직과 호환)
                                if (timelineBodyWrapper) {
                                    timelineBodyWrapper.scrollTo({
                                        top: finalScrollTop,
                                        behavior: 'smooth'
                                    });
                                }
                            };
                            
                            // [핵심 수정] 비동기 함수로 변경하여 그룹 펼치기 후 검색
                            (async () => {
                                const targetTitleItem = await findTitleItem(dependsOnId, titlesBody);
                                
                                if (!targetTitleItem) {
                                    if (typeof showToast === 'function') {
                                        showToast('연결된 작업을 찾을 수 없습니다.', 'warning');
                                    }
                                    return;
                                }
                                
                                // [핵심 수정] scrollIntoView 사용 (가장 확실한 방법)
                                // 스크롤 동기화 로직이 자동으로 처리하도록 함
                                targetTitleItem.scrollIntoView({ 
                                    behavior: 'smooth', 
                                    block: 'center',
                                    inline: 'nearest'
                                });
                                
                                // [핵심 수정] scrollIntoView 후 스크롤 동기화 보장
                                // 약간의 지연 후 스크롤 동기화 확인 및 조정
                                setTimeout(() => {
                                    const timelineBodyWrapper = container.querySelector('.gantt-timeline-body-wrapper');
                                    if (timelineBodyWrapper && titlesBodyWrapper) {
                                        // 스크롤 동기화 (타임라인 영역도 함께 스크롤)
                                        const titlesScrollTop = titlesBodyWrapper.scrollTop || 0;
                                        if (timelineBodyWrapper.scrollTop !== titlesScrollTop) {
                                            timelineBodyWrapper.scrollTop = titlesScrollTop;
                                        }
                                    }
                                }, 200);
                                
                                // 하이라이트 효과
                                targetTitleItem.style.transition = 'background-color 0.3s ease';
                                targetTitleItem.style.backgroundColor = 'rgba(59, 130, 246, 0.15)';
                                setTimeout(() => {
                                    targetTitleItem.style.backgroundColor = '';
                                    setTimeout(() => {
                                        targetTitleItem.style.transition = '';
                                    }, 300);
                                }, 2000);
                                
                                // 클릭한 의존성 표시 기호 하이라이트
                                symbol.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                                symbol.style.transform = 'scale(1.3)';
                                symbol.style.opacity = '0.8';
                                setTimeout(() => {
                                    symbol.style.transform = '';
                                    symbol.style.opacity = '';
                                    setTimeout(() => {
                                        symbol.style.transition = '';
                                    }, 200);
                                }, 400);
                                
                                // 연결된 의존성 선 하이라이트
                                const svg = titlesBodyWrapper.querySelector('.task-list-dependency-svg');
                                if (svg) {
                                    const path = svg.querySelector(`path[data-from="${dependsOnId}"][data-to="${stableProjectId}"], path[data-from="${stableProjectId}"][data-to="${dependsOnId}"]`);
                                    if (path) {
                                        path.style.transition = 'stroke-width 0.2s ease, opacity 0.2s ease';
                                        path.style.strokeWidth = '3';
                                        path.style.opacity = '1';
                                        setTimeout(() => {
                                            path.style.strokeWidth = '1.5';
                                            path.style.opacity = '';
                                            setTimeout(() => {
                                                path.style.transition = '';
                                            }, 200);
                                        }, 1000);
                                    }
                                }
                            })();
                            
                            // 하이라이트 효과
                            targetTitleItem.style.transition = 'background-color 0.3s ease';
                            targetTitleItem.style.backgroundColor = 'rgba(59, 130, 246, 0.15)';
                            setTimeout(() => {
                                targetTitleItem.style.backgroundColor = '';
                                setTimeout(() => {
                                    targetTitleItem.style.transition = '';
                                }, 300);
                            }, 2000);
                            
                            // 클릭한 의존성 표시 기호 하이라이트
                            symbol.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                            symbol.style.transform = 'scale(1.3)';
                            symbol.style.opacity = '0.8';
                            setTimeout(() => {
                                symbol.style.transform = '';
                                symbol.style.opacity = '';
                                setTimeout(() => {
                                    symbol.style.transition = '';
                                }, 200);
                            }, 400);
                            
                            // 연결된 의존성 선 하이라이트
                            const svg = titlesBodyWrapper.querySelector('.task-list-dependency-svg');
                            if (svg) {
                                const path = svg.querySelector(`path[data-from="${dependsOnId}"][data-to="${stableProjectId}"], path[data-from="${stableProjectId}"][data-to="${dependsOnId}"]`);
                                if (path) {
                                    path.style.transition = 'stroke-width 0.2s ease, opacity 0.2s ease';
                                    path.style.strokeWidth = '3';
                                    path.style.opacity = '1';
                                    setTimeout(() => {
                                        path.style.strokeWidth = '1.5';
                                        path.style.opacity = '';
                                        setTimeout(() => {
                                            path.style.transition = '';
                                        }, 200);
                                    }, 1000);
                                }
                            }
                        });
                    }
                });

                const barRow = document.createElement('div');
                barRow.className = 'gantt-bar-row';
                if (stableProjectId) {
                    barRow.dataset.projectId = stableProjectId;
                } else {
                    delete barRow.dataset.projectId;
                }

                const duration = dateDiffInDays(project.startDate, project.endDate) + 1;
                const offset = dateDiffInDays(viewMinDate, project.startDate);

                const barWidth = Math.max(1, duration) * DAY_WIDTH - 4;
                const barLeft = offset * DAY_WIDTH;

                const bar = document.createElement('div');
                const barColorClass = statusColors[project.status] || statusColors['default'];
                bar.className = `gantt-bar ${barColorClass}`;
                bar.style.left = `${barLeft}px`;
                bar.dataset.name = project.name;
                bar.dataset.status = project.status;
                bar.style.width = `${barWidth}px`;

                if (project.endDate < today && project.status !== '완료') {
                    bar.style.opacity = '0.7';
                }

                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';

                let customFieldsHTML = '';
                if (project.customFields) {
                    for(const key in project.customFields){
                        if(project.customFields[key]) {
                            customFieldsHTML += `<strong>${key}:</strong> ${project.customFields[key]}<br>`;
                        }
                    }
                }

                tooltip.innerHTML = `<strong>${project.name}</strong><br>
                                   <strong>진행:</strong> ${project.progress || 0}%<br>
                                   <strong>기간:</strong> ${project.startDate.toLocaleDateString()} ~ ${project.endDate.toLocaleDateString()} (${duration}일)<br>
                                   <strong>상태:</strong> ${project.status}<br>
                                   <strong>비용:</strong> ${formatCurrency(project.poAmount || 0)}<br>
                                   ${customFieldsHTML}`;
                bar.appendChild(tooltip);

                const barLabel = document.createElement('div');
                barLabel.className = 'gantt-bar-label';
                barLabel.textContent = `${project.name} [${project.status}]`;
                bar.appendChild(barLabel);

                barRow.appendChild(bar);

                if ((project.progress || 0) > 0) {
                    const progressFill = document.createElement('div');
                    progressFill.className = 'gantt-bar-progress';
                    progressFill.style.left = `${barLeft}px`;
                    progressFill.style.width = `${barWidth * (project.progress / 100)}px`;
                    barRow.appendChild(progressFill);
                }

                return { titleItem, barRow };
            };

            const typesToExpand = new Set();
            if (searchTerm || legendStatusFilter) {
                data.forEach(p => {
                    if (p.taskType) typesToExpand.add(p.taskType);
                });
            }
            
            // 개선 사항: 계층 순서가 'bottom'일 때는 모든 그룹을 자동으로 펼침
            if (hierarchyOrder === 'bottom') {
                data.forEach(p => {
                    if (p.taskType) {
                        typesToExpand.add(p.taskType);
                        openTaskGroups.add(p.taskType);
                    }
                });
            }

            if (renderFlatList) {
                // 개선 사항: 대용량 데이터 렌더링 최적화 - 청크 단위 비동기 렌더링
                const flatTitlesFragment = document.createDocumentFragment();
                const flatBarsFragment = document.createDocumentFragment();
                const chunkSize = data.length > 500 ? 50 : 100; // 대용량 데이터는 더 작은 청크로
                
                if (data.length > 500) {
                    // 대용량 데이터는 비동기 청크 렌더링
                    let chunkStart = 0;
                    const renderChunk = () => {
                        const chunkEnd = Math.min(chunkStart + chunkSize, data.length);
                        for (let i = chunkStart; i < chunkEnd; i++) {
                            const { titleItem, barRow } = createProjectRowElements(data[i]);
                            flatTitlesFragment.appendChild(titleItem);
                            flatBarsFragment.appendChild(barRow);
                        }
                        chunkStart = chunkEnd;
                        
                        if (chunkStart < data.length) {
                            // 다음 청크를 다음 프레임에 렌더링
                            requestAnimationFrame(renderChunk);
                        } else {
                            // 모든 청크 렌더링 완료
                            titlesBody.appendChild(flatTitlesFragment);
                            ganttRowsBody.appendChild(flatBarsFragment);
                        }
                    };
                    renderChunk();
                } else {
                    // 소량 데이터는 동기 렌더링
                    for (let chunkStart = 0; chunkStart < data.length; chunkStart += chunkSize) {
                        const chunkEnd = Math.min(chunkStart + chunkSize, data.length);
                        for (let i = chunkStart; i < chunkEnd; i++) {
                            const { titleItem, barRow } = createProjectRowElements(data[i]);
                            flatTitlesFragment.appendChild(titleItem);
                            flatBarsFragment.appendChild(barRow);
                        }
                    }
                    titlesBody.appendChild(flatTitlesFragment);
                    ganttRowsBody.appendChild(flatBarsFragment);
                }
            }
            if (!renderFlatList) {
                const groupInitialOpenMap = {};
                Object.keys(groupedData).forEach(taskType => {
                    const shouldForceExpand = hierarchyOrder === 'bottom';
                    groupInitialOpenMap[taskType] = shouldForceExpand
                        ? true
                        : ((searchTerm || legendStatusFilter) ? typesToExpand.has(taskType) : openTaskGroups.has(taskType));
                });

                const sortedTaskTypes = Object.keys(groupedData).sort((a, b) => {
                    if (sortMode === 'default') {
                        return a.localeCompare(b, undefined, { sensitivity: 'base' });
                    }

                    const valueA = groupInitialOpenMap[a] ? getChildSortMetric(a) : getGroupSortMetric(a);
                    const valueB = groupInitialOpenMap[b] ? getChildSortMetric(b) : getGroupSortMetric(b);
                    const comparison = compareMetrics(valueA, valueB);
                    if (comparison !== 0) return comparison;
                    return a.localeCompare(b, undefined, { sensitivity: 'base' });
                });

                sortedTaskTypes.forEach(taskType => {
                    const projects = groupedData[taskType];
                    if (projects.length === 0) return;

                    let groupTotalPo = 0;
                    let groupWeightedProgressSum = 0;
                    projects.forEach(p => {
                        groupWeightedProgressSum += (p.progress || 0) * (p.poAmount || 0);
                        groupTotalPo += (p.poAmount || 0);
                    });
                    const groupProgress = groupTotalPo > 0 ? Math.round(groupWeightedProgressSum / groupTotalPo) : 0;

                    const groupPoSum = projects.reduce((sum, p) => sum + (p.poAmount || 0), 0);
                    const formattedGroupPoSum = formatCurrency(groupPoSum);
                    const groupMinDate = new Date(Math.min(...projects.map(p => p.startDate.getTime())));
                    const groupMaxDate = new Date(Math.max(...projects.map(p => p.endDate.getTime())));

                    const isInitiallyOpen = !!groupInitialOpenMap[taskType];

                    const allProjectsInGroupCompleted = projects.every(p => p.progress === 100);
                    const groupCompletedClass = allProjectsInGroupCompleted ? 'text-gray-400 line-through' : '';

                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'group-header';
                    groupHeader.style.display = 'flex';
                    groupHeader.style.justifyContent = 'space-between';
                    groupHeader.style.alignItems = 'center';
                    groupHeader.dataset.taskType = taskType;
                    groupHeader.innerHTML = `
                        <div class="flex-grow whitespace-nowrap overflow-hidden text-ellipsis pr-2 ${groupCompletedClass}">
                            <span class="group-toggle">${isInitiallyOpen ? '[-]' : '[+]'}</span> 📂 ${taskType} (${projects.length}건 / ${formattedGroupPoSum})
                        </div>
                         <div class="flex items-center flex-shrink-0">
                            <div class="project-po justify-end" style="width: var(--po-col-width); display: ${columnVisibility['project-po'] ? '' : 'none'}"></div>
                            <div class="project-dates group-dates-summary justify-center ${groupCompletedClass}" style="width: var(--dates-col-width); margin: 0; display: ${columnVisibility['project-dates'] ? 'flex' : 'none'};">
                                <span class="font-semibold">${formatDate(groupMinDate)}</span>
                                <span class="mx-1">~</span>
                                <span class="font-semibold">${formatDate(groupMaxDate)}</span>
                            </div>
                            <div class="project-progress font-bold text-right pr-2.5 ${groupCompletedClass}" style="width: var(--progress-col-width); display: ${columnVisibility['project-progress'] ? '' : 'none'}">${groupProgress}%</div>
                            <div class="project-progress-summary pr-2" style="width: var(--progress-summary-col-width); display: ${columnVisibility['project-progress-summary'] ? '' : 'none'};" title="${groupProgress}%" aria-label="그룹 진행률 ${groupProgress}%">
                                <div style="background:#f1f5f9;border-radius:6px;height:10px;overflow:hidden;position:relative;">
                                    <div style="background:${getProgressGradient(groupProgress)};height:10px;width:${groupProgress}%;transition:width:0.3s;box-shadow:0 1px 4px rgba(0,0,0,0.06);"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    const groupBarRow = document.createElement('div');
                    groupBarRow.className = 'gantt-bar-row';
                    ganttRowsBody.appendChild(groupBarRow);

                    const groupDuration = dateDiffInDays(groupMinDate, groupMaxDate) + 1;
                    const groupOffset = dateDiffInDays(viewMinDate, groupMinDate);
                    const groupBar = document.createElement('div');
                    const groupColor = getGroupProgressColor(groupProgress);
                    groupBar.className = 'gantt-bar';
                    if(isInitiallyOpen) groupBar.classList.add('hidden');
                    groupBar.style.backgroundColor = groupColor;
                    groupBar.style.height = '10px';
                    groupBar.style.top = '11px';
                    groupBar.style.left = `${groupOffset * DAY_WIDTH}px`;
                    groupBar.style.width = `${Math.max(1, groupDuration) * DAY_WIDTH - 2}px`;
                    groupBar.style.borderRadius = '2px';
                    groupBar.style.opacity = '1';
                    groupBar.dataset.name = `${taskType} (요약)`;

                    const groupStatuses = new Set(projects.map(p => p.status));
                    let groupStatus = '착공전';
                    if (groupStatuses.has('지연')) {
                        groupStatus = '지연';
                    } else if (groupStatuses.has('공사중')) {
                        groupStatus = '공사중';
                    } else if (projects.every(p => p.status === '완료')) {
                        groupStatus = '완료';
                    } else if (groupStatuses.has('착공전')) {
                        groupStatus = '착공전';
                    }
                    groupBar.dataset.status = groupStatus;

                    const groupTooltip = document.createElement('div');
                    groupTooltip.className = 'tooltip';
                    groupTooltip.innerHTML = `<strong>${taskType} (요약)</strong><br><strong>기간:</strong> ${groupMinDate.toLocaleDateString()} ~ ${groupMaxDate.toLocaleDateString()} (${groupDuration}일)<br><strong>총 ${projects.length}개 프로젝트</strong><br><strong>총 비용:</strong> ${formatCurrency(groupPoSum)}`;
                    groupBar.appendChild(groupTooltip);
                    groupBarRow.appendChild(groupBar);

                    const groupBarLabel = document.createElement('div');
                    groupBarLabel.className = 'gantt-bar-label';
                    groupBarLabel.textContent = `${taskType} (요약) [${groupStatus}]`;
                    groupBar.appendChild(groupBarLabel);

                    if (groupProgress > 0) {
                        const groupProgressFill = document.createElement('div');
                        groupProgressFill.className = 'gantt-bar-progress';
                        if (isInitiallyOpen) groupProgressFill.classList.add('hidden');
                        groupProgressFill.style.left = `${groupOffset * DAY_WIDTH}px`;
                        const groupBarWidth = Math.max(1, groupDuration) * DAY_WIDTH - 2;
                        groupProgressFill.style.width = `${groupBarWidth * (groupProgress / 100)}px`;
                        groupProgressFill.style.top = '11px';
                        groupProgressFill.style.zIndex = '8';
                        groupProgressFill.style.height = '10px';
                        groupBarRow.appendChild(groupProgressFill);
                    }

                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'group-item-container';
                    groupContainer.dataset.taskType = taskType;
                    if(!isInitiallyOpen) groupContainer.classList.add('hidden');
                    
                    const childBarRowsContainer = document.createElement('div');
                     if(!isInitiallyOpen) childBarRowsContainer.classList.add('hidden');
                    ganttRowsBody.appendChild(childBarRowsContainer);

                    titlesBody.appendChild(groupHeader);
                    titlesBody.appendChild(groupContainer);

                    const titlesFragment = document.createDocumentFragment();
                    const barsFragment = document.createDocumentFragment();
                    const chunkSize = 100;
                    
                    for (let chunkStart = 0; chunkStart < projects.length; chunkStart += chunkSize) {
                        const chunkEnd = Math.min(chunkStart + chunkSize, projects.length);
                        const chunk = projects.slice(chunkStart, chunkEnd);
                        
                        chunk.forEach(p => {
                            const { titleItem, barRow } = createProjectRowElements(p);
                            titlesFragment.appendChild(titleItem);
                            barsFragment.appendChild(barRow);
                        });
                    }

                    groupContainer.appendChild(titlesFragment);
                    childBarRowsContainer.appendChild(barsFragment);

                    groupHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isNowCollapsed = groupContainer.classList.toggle('hidden');
                        childBarRowsContainer.classList.toggle('hidden', isNowCollapsed);
                        groupBar.classList.toggle('hidden', !isNowCollapsed);

                        const progressFill = groupBarRow.querySelector('.gantt-bar-progress');
                        if(progressFill) {
                            progressFill.classList.toggle('hidden', !isNowCollapsed);
                        }

                        if (isNowCollapsed) {
                            groupHeader.querySelector('.group-toggle').textContent = '[+]';
                            openTaskGroups.delete(taskType);
                        } else {
                            groupHeader.querySelector('.group-toggle').textContent = '[-]';
                            openTaskGroups.add(taskType);
                            
                            // [핵심 수정] 그룹 펼치기 후 렌더링 보장 (render() 호출하지 않음)
                            // render() 호출 시 DOM이 재생성되어 이벤트 핸들러가 사라질 수 있음
                            // 대신 의존성 렌더링만 업데이트
                            setTimeout(() => {
                                // 의존성 렌더링 보장
                                const containerRef = fullscreenModal.classList.contains('hidden') 
                                    ? document.getElementById('ganttViewContent') 
                                    : fullscreenModalBody;
                                if (containerRef) {
                                    const ganttBody = containerRef.querySelector('.gantt-body');
                                    if (ganttBody) {
                                        const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                                            window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                                        if (dataToRender && Array.isArray(dataToRender)) {
                                            if (typeof window.renderDependencyArrows === 'function') {
                                                window.renderDependencyArrows(ganttBody, dataToRender);
                                            } else if (typeof renderDependencyArrows === 'function') {
                                                renderDependencyArrows(ganttBody, dataToRender);
                                            }
                                        }
                                    }
                                }
                            }, 150);
                        }
                        setTimeout(() => {
                            updateLayoutSync();
                            const containerRef = fullscreenModal.classList.contains('hidden') 
                                ? document.getElementById('ganttViewContent') 
                                : fullscreenModalBody;
                            if (containerRef) {
                                applyHierarchyOrder(containerRef);
                            }
                            try {
                                recomputeTodayMarkerHeight(containerRef);
                            } catch (e) {
                                // ignore
                            }
                        }, 300);
                    });
                });
            }

            titlesBodyWrapper.appendChild(titlesBody);
            titlesPane.appendChild(titlesBodyWrapper);

            timelineWrapper.appendChild(timelineHeaderWrapper);
            timelineWrapper.appendChild(timelineBodyWrapper);

            timelineHeaderWrapper.appendChild(timelineHeader);
            timelineBodyWrapper.appendChild(ganttBody);

            ganttEl.appendChild(titlesPane);
            ganttEl.appendChild(timelineWrapper);

            currentGanttContainer.appendChild(ganttEl);

            setTimeout(() => {
                updateLayoutSync();
                
                // [핵심 수정] 작업 목록 영역 의존성 직각 선 렌더링
                const renderTaskListDependencyLines = () => {
                    try {
                        const svg = titlesBodyWrapper.querySelector('.task-list-dependency-svg');
                        if (!svg) return;
                        
                        // 기존 선 제거
                        svg.innerHTML = '';
                        
                        // 원본 데이터 사용 (모든 프로젝트의 의존성을 렌더링하기 위해)
                        const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                            window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                        
                        if (!dataToRender || dataToRender.length === 0) return;
                        
                        // 각 title-item의 위치 수집
                        const titlePositions = new Map();
                        const titleItems = titlesBody.querySelectorAll('.title-item');
                        
                        titleItems.forEach(titleItem => {
                            const projectId = titleItem.dataset.projectId;
                            if (!projectId) return;
                            
                            const rect = titleItem.getBoundingClientRect();
                            const parentRect = titlesBodyWrapper.getBoundingClientRect();
                            const top = rect.top - parentRect.top + titlesBody.scrollTop;
                            const height = rect.height;
                            const centerY = top + height / 2;
                            const right = rect.right - parentRect.left;
                            
                            titlePositions.set(String(projectId), {
                                top: top,
                                centerY: centerY,
                                right: right,
                                height: height
                            });
                        });
                        
                        if (titlePositions.size === 0) return;
                        
                        // SVG defs에 마커 정의 추가
                        const svgNS = 'http://www.w3.org/2000/svg';
                        const defs = document.createElementNS(svgNS, 'defs');
                        svg.appendChild(defs);
                        
                        const colorMap = {
                            'start-to-start': '#2563eb',
                            'end-to-start':   '#10b981',
                            'end-to-end':     '#f59e0b',
                            'start-to-end':   '#ef4444'
                        };
                        
                        // 화살표 마커 생성
                        Object.keys(colorMap).forEach(type => {
                            const marker = document.createElementNS(svgNS, 'marker');
                            marker.setAttribute('id', `task-list-arrow-${type}`);
                            marker.setAttribute('viewBox', '0 0 10 10');
                            marker.setAttribute('refX', '9');
                            marker.setAttribute('refY', '5');
                            marker.setAttribute('markerWidth', '6');
                            marker.setAttribute('markerHeight', '6');
                            marker.setAttribute('orient', 'auto');
                            const path = document.createElementNS(svgNS, 'path');
                            path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                            path.setAttribute('fill', colorMap[type]);
                            marker.appendChild(path);
                            defs.appendChild(marker);
                        });
                        
                        // 의존성 선 그리기
                        dataToRender.forEach(project => {
                            if (!project.dependsOn || !Array.isArray(project.dependsOn) || project.dependsOn.length === 0) {
                                return;
                            }
                            
                            const projectPos = titlePositions.get(String(project.id));
                            if (!projectPos) return;
                            
                            project.dependsOn.forEach(dep => {
                                const depPos = titlePositions.get(String(dep.projectId));
                                if (!depPos) return;
                                
                                const edgeColor = colorMap[dep.type] || '#9ca3af';
                                
                                // 직각 선 경로 계산 (의존성 프로젝트 → 현재 프로젝트)
                                // 작업 목록 영역에서는 오른쪽 끝에서 오른쪽 끝으로 연결
                                const startX = depPos.right;
                                const startY = depPos.centerY;
                                const endX = projectPos.right;
                                const endY = projectPos.centerY;
                                
                                // 직각 경로: 수평선 → 수직선 → 수평선
                                const midX = (startX + endX) / 2;
                                const path = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
                                
                                const pathEl = document.createElementNS(svgNS, 'path');
                                pathEl.setAttribute('d', path);
                                pathEl.setAttribute('stroke', edgeColor);
                                pathEl.setAttribute('stroke-width', '1.5');
                                pathEl.setAttribute('fill', 'none');
                                pathEl.setAttribute('marker-end', `url(#task-list-arrow-${dep.type})`);
                                pathEl.setAttribute('data-from', String(dep.projectId));
                                pathEl.setAttribute('data-to', String(project.id));
                                pathEl.setAttribute('data-type', dep.type);
                                
                                // 툴팁을 위한 title 추가
                                const depProject = dataToRender.find(p => String(p.id) === String(dep.projectId));
                                const depName = depProject ? depProject.name : '알 수 없음';
                                const typeMap = {
                                    'start-to-start': 'SS',
                                    'end-to-start': 'FS',
                                    'end-to-end': 'FF',
                                    'start-to-end': 'SF'
                                };
                                const depType = typeMap[dep.type] || dep.type;
                                pathEl.setAttribute('title', `${depName} (${depType}) → ${project.name}`);
                                pathEl.setAttribute('id', `task-list-dep-path-${dep.projectId}-${project.id}`);
                                
                                svg.appendChild(pathEl);
                                
                                // [핵심 수정] Flow circle 애니메이션 추가 (막대 그래프 영역과 동일한 스타일)
                                const flowCircle = document.createElementNS(svgNS, 'circle');
                                const flowR = Math.max(2, Math.min(projectPos.height * 0.12, 3));
                                flowCircle.setAttribute('r', String(flowR));
                                flowCircle.setAttribute('fill', edgeColor);
                                flowCircle.setAttribute('opacity', '0.8');
                                flowCircle.setAttribute('id', `task-list-flow-${dep.projectId}-${project.id}`);
                                
                                // 애니메이션 정의 (SVG animateMotion 사용)
                                const animateMotion = document.createElementNS(svgNS, 'animateMotion');
                                animateMotion.setAttribute('dur', '2s');
                                animateMotion.setAttribute('repeatCount', 'indefinite');
                                animateMotion.setAttribute('path', path);
                                flowCircle.appendChild(animateMotion);
                                
                                svg.appendChild(flowCircle);
                            });
                        });
                    } catch (e) {
                        console.warn('[task-list-dep] Error rendering dependency lines:', e);
                    }
                };
                
                // 첫 번째 시도: 레이아웃 업데이트 후
                setTimeout(renderTaskListDependencyLines, 100);
                
                // 두 번째 시도: DOM 업데이트 완료 후
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        setTimeout(renderTaskListDependencyLines, 200);
                    });
                });
                
                // 세 번째 시도: 추가 지연
                setTimeout(renderTaskListDependencyLines, 400);
                
                // [성능 최적화] 의존성 화살표 렌더링 (레이아웃 업데이트 후) - 온오프라인 모두 지원
                if (typeof renderDependencyArrows === 'function') {
                renderDependencyArrows(ganttBody, data);
                } else if (typeof window.renderDependencyArrows === 'function') {
                    window.renderDependencyArrows(ganttBody, data);
                }
            }, 0);
            
            // [성능 최적화] 추가 보장: DOM 업데이트 완료 후 의존성 렌더링 재시도
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        const finalGanttBody = currentGanttContainer.querySelector('.gantt-body');
                        if (finalGanttBody && data && Array.isArray(data)) {
                            if (typeof renderDependencyArrows === 'function') {
                                renderDependencyArrows(finalGanttBody, data);
                            } else if (typeof window.renderDependencyArrows === 'function') {
                                window.renderDependencyArrows(finalGanttBody, data);
                            }
                        }
                    }, 100);
                });
            });

            const finalTitlesBodyWrapper = ganttEl.querySelector('.gantt-titles-body-wrapper');
            const finalTimelineHeaderWrapper = ganttEl.querySelector('.gantt-timeline-header-wrapper');
            const finalTimelineBodyWrapper = ganttEl.querySelector('.gantt-timeline-body-wrapper');

             if (finalTimelineBodyWrapper && finalTitlesBodyWrapper && finalTimelineHeaderWrapper) {
                // 개선사항 2: 스크롤 동기화 및 열 구분선 정렬 검증
                let scrollTimeout;
                finalTimelineBodyWrapper.addEventListener('scroll', () => {
                    hideFloatingTooltip();
                    // 수직/수평 스크롤 동기화
                    finalTitlesBodyWrapper.scrollTop = finalTimelineBodyWrapper.scrollTop;
                    finalTimelineHeaderWrapper.scrollLeft = finalTimelineBodyWrapper.scrollLeft;
                    
                    // [핵심 수정] 스크롤 시 작업 목록 영역 의존성 선 위치 업데이트
                    const updateTaskListDependencyLinesOnScroll = () => {
                        try {
                            const svg = finalTitlesBodyWrapper.querySelector('.task-list-dependency-svg');
                            if (!svg) return;
                            
                            const titlesBody = finalTitlesBodyWrapper.querySelector('.gantt-titles-body');
                            if (!titlesBody) return;
                            
                            // 원본 데이터 사용
                            const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                                window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                            
                            if (!dataToRender || dataToRender.length === 0) return;
                            
                            // 각 title-item의 위치 수집
                            const titlePositions = new Map();
                            const titleItems = titlesBody.querySelectorAll('.title-item');
                            
                            titleItems.forEach(titleItem => {
                                const projectId = titleItem.dataset.projectId;
                                if (!projectId) return;
                                
                                const rect = titleItem.getBoundingClientRect();
                                const parentRect = finalTitlesBodyWrapper.getBoundingClientRect();
                                const top = rect.top - parentRect.top + titlesBody.scrollTop;
                                const height = rect.height;
                                const centerY = top + height / 2;
                                const right = rect.right - parentRect.left;
                                
                                titlePositions.set(String(projectId), {
                                    top: top,
                                    centerY: centerY,
                                    right: right,
                                    height: height
                                });
                            });
                            
                            if (titlePositions.size === 0) return;
                            
                            // 기존 선의 경로만 업데이트 (마커는 유지)
                            const paths = svg.querySelectorAll('path');
                            paths.forEach(pathEl => {
                                const fromId = pathEl.getAttribute('data-from');
                                const toId = pathEl.getAttribute('data-to');
                                
                                const fromPos = titlePositions.get(fromId);
                                const toPos = titlePositions.get(toId);
                                
                                if (fromPos && toPos) {
                                    const startX = fromPos.right;
                                    const startY = fromPos.centerY;
                                    const endX = toPos.right;
                                    const endY = toPos.centerY;
                                    const midX = (startX + endX) / 2;
                                    const path = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
                                    pathEl.setAttribute('d', path);
                                }
                            });
                        } catch (e) {
                            console.warn('[task-list-dep-scroll] Error updating dependency lines on scroll:', e);
                        }
                    };
                    
                    // 스크롤 시 의존성 선 위치 업데이트 (디바운스)
                    clearTimeout(finalTitlesBodyWrapper.dependencyLineUpdateTimeout);
                    finalTitlesBodyWrapper.dependencyLineUpdateTimeout = setTimeout(updateTaskListDependencyLinesOnScroll, 50);
                    
                    // 스크롤 중에는 마커 투명도를 낮춤
                    const markers = document.querySelectorAll('.gantt-today-marker-container');
                     markers.forEach(marker => {
                         const line = marker.querySelector('.gantt-today-marker');
                         if (line) line.style.opacity = '0.5';
                         // 라벨의 투명도는 변경하지 않습니다.
                     });
                    
                    // 스크롤 완료 후 마커 재계산 및 투명도 복원
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const containerRef = fullscreenModal.classList.contains('hidden') 
                            ? document.getElementById('ganttViewContent') 
                            : fullscreenModalBody;
                        recomputeTodayMarkerHeight(containerRef);
                        
                        // 열 구분선 정렬 상태 검증 (디바운스 적용)
                        if (!finalTimelineBodyWrapper.alignmentTimeout) {
                            finalTimelineBodyWrapper.alignmentTimeout = setTimeout(() => {
                                verifyTimelineAlignment();
                                finalTimelineBodyWrapper.alignmentTimeout = null;
                            }, 100);
                        }
                    }, 150); // 스크롤 완료 후 지연 시간
                });                 // Modify the wheel event listener for the timeline body
                finalTimelineBodyWrapper.addEventListener('wheel', (e) => {
                    // Prevent default only if scrolling horizontally or if the default scroll wouldn't do anything
                    if (e.deltaX !== 0 || (e.deltaY !== 0 && (timelineBodyWrapper.scrollHeight <= timelineBodyWrapper.clientHeight))) {
                       e.preventDefault();
                    }
                    // Always allow vertical scroll propagation if possible
                    finalTimelineBodyWrapper.scrollTop += e.deltaY;
                    finalTimelineBodyWrapper.scrollLeft += e.deltaX; // Allow horizontal scroll with wheel if applicable
                }, { passive: false });


                const scrollbarWidth = finalTimelineBodyWrapper.offsetWidth - finalTimelineBodyWrapper.clientWidth;
                finalTimelineHeaderWrapper.style.paddingRight = `${scrollbarWidth}px`;
            }

            ganttEl.querySelectorAll('.title-item').forEach(titleItem => {
                const projectId = titleItem.dataset.projectId;
                if (!projectId) return;

                const barRow = ganttEl.querySelector(`.gantt-bar-row[data-project-id="${projectId}"]`);
                if (!barRow) return;
                const highlight = () => { titleItem.classList.add('row-hover'); barRow.classList.add('row-hover'); };
                const unhighlight = () => { titleItem.classList.remove('row-hover'); barRow.classList.remove('row-hover'); };
                titleItem.addEventListener('mouseenter', highlight);
                titleItem.addEventListener('mouseleave', unhighlight);
                barRow.addEventListener('mouseenter', highlight);
                barRow.addEventListener('mouseleave', unhighlight);
            });

            // 의존성 설정 버튼 클릭 이벤트 위임 (동적으로 생성된 버튼에도 작동) - document 레벨로 이동
            // 기존 이벤트 리스너 제거 후 새로 추가 (중복 방지)
            /*
            const existingHandler = ganttEl._dependencyClickHandler;
            if (existingHandler) {
                ganttEl.removeEventListener('click', existingHandler);
            }
            const dependencyClickHandler = (e) => {
                // 버튼 자체를 클릭했거나 버튼 내부 요소를 클릭한 경우
                const dependencyBtn = e.target.closest('.dependency-setting-btn');
                if (dependencyBtn) {
                    e.stopPropagation();
                    e.preventDefault();
                    e.stopImmediatePropagation(); // 다른 이벤트 리스너의 실행 방지
                    const projectId = dependencyBtn.dataset.projectId || dependencyBtn.closest('.title-item')?.dataset.projectId;
                    if (projectId) {
                        try {
                            if (typeof openDependencyModal === 'function') {
                                openDependencyModal(projectId);
                            } else if (typeof window.openDependencyModal === 'function') {
                                window.openDependencyModal(projectId);
                            } else {
                                console.error('openDependencyModal 함수를 찾을 수 없습니다.');
                                if (typeof showToast === 'function') {
                                    showToast('의존성 설정 기능을 사용할 수 없습니다.', 'error');
                                }
                            }
                        } catch (error) {
                            console.error('의존성 모달 열기 오류:', error);
                            if (typeof showToast === 'function') {
                                showToast('의존성 설정 중 오류가 발생했습니다.', 'error');
                            }
                        }
                    }
                    return false; // 추가적인 이벤트 전파 방지
                }
            };
            ganttEl._dependencyClickHandler = dependencyClickHandler;
            ganttEl.addEventListener('click', dependencyClickHandler, true); // capture phase에서 실행
            */

            // 개선 사항 1: 마우스 위치에 따라 라벨 위치를 동적으로 조정합니다.
            ganttEl.addEventListener('mousemove', (e) => {
                const bar = e.target.closest('.gantt-bar');
                if (!bar) return;

                const label = bar.querySelector('.gantt-bar-label');
                if (!label) return;

                // 바의 경계 상자를 기준으로 마우스의 X 좌표를 계산합니다.
                const barRect = bar.getBoundingClientRect();
                let labelLeft = e.clientX - barRect.left;

                // 라벨이 바의 경계를 벗어나지 않도록 위치를 제한합니다.
                const labelWidth = label.offsetWidth;
                const barWidth = bar.offsetWidth;

                // 라벨이 바의 오른쪽 끝을 넘어가지 않도록 조정합니다.
                if (labelLeft + labelWidth > barWidth) {
                    labelLeft = barWidth - labelWidth;
                }
                label.style.left = `${Math.max(0, labelLeft)}px`;
            });

            // Create Header Toggle Button
            // Check if button already exists to avoid duplicates on re-render
            if (!document.querySelector('.header-toggle-btn-container')) {
                const headerToggleContainer = document.createElement('div');
                headerToggleContainer.className = 'header-toggle-btn-container';
                
                const headerToggleBtn = document.createElement('div');
                headerToggleBtn.className = 'header-toggle-btn';
                headerToggleBtn.title = '헤더 접기/펴기';
                
                headerToggleBtn.addEventListener('click', () => {
                    const ganttContainer = document.querySelector('.gantt-chart-container');
                    if (ganttContainer) {
                        ganttContainer.classList.toggle('header-collapsed');
                        headerToggleBtn.classList.toggle('active');
                    }
                });
                
                headerToggleContainer.appendChild(headerToggleBtn);
                
                // Find the correct container to append to
                const ganttContainer = document.querySelector('.gantt-chart-container');
                if (ganttContainer) {
                    ganttContainer.appendChild(headerToggleContainer);
                    // Make sure container position is relative for absolute positioning of toggle
                    if (getComputedStyle(ganttContainer).position === 'static') {
                        ganttContainer.style.position = 'relative';
                    }
                }
            }
            // 개선된 툴팁 클릭 이벤트 핸들러
            ganttEl.addEventListener('click', (e) => {
                const bar = e.target.closest('.gantt-bar');
                if (!bar) {
                    hideFloatingTooltip();
                    return;
                }

                const tooltip = bar.querySelector('.tooltip');
                if (!tooltip) {
                    hideFloatingTooltip();
                    return;
                }

                if (activeTooltipBar === bar && floatingTooltip?.classList.contains('visible')) {
                    hideFloatingTooltip();
                    return;
                }

                hideFloatingTooltip();
                showFloatingTooltip(bar, tooltip, {
                    pointerX: e.clientX,
                    pointerY: e.clientY,
                });
            });

            const handleBarHoverTooltip = (event) => {
                const bar = event.target.closest('.gantt-bar');
                if (!bar) {
                    hideHoverTooltip();
                    return;
                }

                const tooltip = bar.querySelector('.tooltip');
                if (!tooltip || !hoverTooltip) {
                    hideHoverTooltip();
                    return;
                }

                const simpleText = bar.dataset.name || bar.getAttribute('aria-label') || tooltip.textContent || '';
                if (!simpleText.trim()) {
                    hideHoverTooltip();
                    return;
                }

                hoverTooltip.textContent = simpleText.trim();
                const container = getActiveTimelineContainer();
                const containerRect = container ? container.getBoundingClientRect() : { top: 0 };
                const top = Math.max(4, containerRect.top + 4);
                const tooltipRect = hoverTooltip.getBoundingClientRect();
                let left = event.clientX - tooltipRect.width / 2;
                const margin = 8;
                const maxLeft = window.innerWidth - tooltipRect.width - margin;
                left = Math.max(margin, Math.min(left, maxLeft));
                hoverTooltip.style.top = `${top}px`;
                hoverTooltip.style.left = `${left}px`;
                hoverTooltip.classList.add('visible');
            };

            ganttEl.addEventListener('mousemove', handleBarHoverTooltip);
            ganttEl.addEventListener('mouseleave', () => {
                hideHoverTooltip();
            });

             // Add legend click listeners specifically for the current view
             const currentLegendContainer = container.querySelector('#legendSection');
             if (currentLegendContainer) {
                 currentLegendContainer.querySelectorAll('[data-status-filter]').forEach(item => {
                     item.removeEventListener('click', handleLegendClickEvent); // Remove previous listener
                     item.addEventListener('click', handleLegendClickEvent); // Add new one
                 });
             }
             
             // 개선 사항: 계층순서 유지 - renderGanttChart 함수 끝에서 계층순서 적용

        // 작업 의존성 관리 함수들
        let currentDependencyProjectId = null;
        let selectedDependencyType = 'end-to-start';

        function openDependencyModal(projectId) {
            console.log('🔗 openDependencyModal 호출됨, projectId:', projectId);
            
            // projectData를 여러 방법으로 찾기 (스코프 문제 해결)
            const dataSource = (typeof projectData !== 'undefined' ? projectData : 
                               (typeof window.projectData !== 'undefined' ? window.projectData : null));
            
            console.log('🔗 dataSource 찾기 결과:', {
                hasProjectData: typeof projectData !== 'undefined',
                hasWindowProjectData: typeof window.projectData !== 'undefined',
                dataSourceType: dataSource ? (Array.isArray(dataSource) ? 'array' : typeof dataSource) : 'null',
                dataSourceLength: dataSource && Array.isArray(dataSource) ? dataSource.length : 0
            });
            
            if (!dataSource || !Array.isArray(dataSource) || dataSource.length === 0) {
                console.error('🔗 projectData를 찾을 수 없습니다.');
                if (typeof showToast === 'function') {
                    showToast('프로젝트 데이터를 찾을 수 없습니다. 페이지를 새로고침해 주세요.', 'error');
                } else {
                    alert('프로젝트 데이터를 찾을 수 없습니다. 페이지를 새로고침해 주세요.');
                }
                return;
            }
            
            currentDependencyProjectId = projectId;
            const project = dataSource.find(p => String(p.id) === String(projectId));
            console.log('🔗 프로젝트 찾기 결과:', { projectId, found: !!project, projectName: project?.name });
            
            // [성능 최적화] 초기 의존성 상태 저장 (취소 시 비교용)
            if (project) {
                initialDependencyState = project.dependsOn ? JSON.stringify(project.dependsOn) : '';
                console.log('[dep-modal] Initial dependency state saved:', initialDependencyState);
            }
            
            if (!project) {
                console.error('🔗 프로젝트를 찾을 수 없습니다. projectId:', projectId);
                if (typeof showToast === 'function') {
                    showToast('작업을 찾을 수 없습니다.', 'error');
                } else {
                    alert('작업을 찾을 수 없습니다.');
                }
                return;
            }

            const modal = document.getElementById('dependencyModal');
            console.log('🔗 모달 요소 찾기 결과:', { modal: !!modal, modalId: modal?.id });
            
            if (!modal) {
                console.error('🔗 dependencyModal을 찾을 수 없습니다.');
                if (typeof showToast === 'function') {
                    showToast('의존성 설정 모달을 찾을 수 없습니다.', 'error');
                } else {
                    alert('의존성 설정 모달을 찾을 수 없습니다.');
                }
                return;
            }
            
            // 모달이 body의 직접 자식이 아니면 body로 이동 (다른 컨테이너에 가려지는 것 방지)
            if (modal.parentElement !== document.body) {
                console.log('🔗 모달을 body로 이동:', modal.parentElement?.tagName);
                document.body.appendChild(modal);
            }
            
            const currentProjectEl = document.getElementById('dependencyCurrentProject');
            const selectEl = document.getElementById('dependencyProjectSelect');
            
            if (!currentProjectEl || !selectEl) {
                console.error('의존성 모달 요소를 찾을 수 없습니다.');
                return;
            }

            currentProjectEl.textContent = project.name || '알 수 없음';

            // 의존 작업 선택 목록 채우기
            selectEl.innerHTML = '';
            dataSource.forEach(p => {
                if (String(p.id) !== String(projectId)) {
                    const option = document.createElement('option');
                    option.value = p.id;
                    option.textContent = p.name || '알 수 없음';
                    selectEl.appendChild(option);
                }
            });

            // [성능 최적화] 기존 의존성 설정 불러오기
            // 여러 의존성이 있을 경우 첫 번째 의존성의 타입을 기본값으로 설정
            if (project.dependsOn && project.dependsOn.length > 0) {
                // [성능 최적화] 디버깅: 로드된 의존성 확인
                console.log('[dep-modal] Loading dependencies for project', projectId, ':', JSON.stringify(project.dependsOn));
                console.log('[dep-modal] Dependencies count:', project.dependsOn.length);
                
                project.dependsOn.forEach((dep, idx) => {
                    const option = selectEl.querySelector(`option[value="${dep.projectId}"]`);
                    if (option) {
                        option.selected = true;
                        // [성능 최적화] 각 의존성의 타입을 option의 data 속성에 저장
                    if (dep.type) {
                            option.setAttribute('data-dep-type', dep.type);
                        }
                        console.log(`[dep-modal] Loaded dependency ${idx}:`, dep.projectId, 'type:', dep.type || 'undefined');
                    } else {
                        console.warn(`[dep-modal] Option not found for dependency:`, dep.projectId);
                    }
                    // 첫 번째 의존성의 타입을 기본값으로 설정
                    if (dep.type && !selectedDependencyType) {
                        selectedDependencyType = dep.type;
                    }
                });
            } else {
                selectedDependencyType = 'end-to-start';
                console.log('[dep-modal] No existing dependencies for project', projectId);
            }

            // 의존성 유형 선택 상태 업데이트
            document.querySelectorAll('.dependency-type-option').forEach(opt => {
                opt.classList.remove('selected');
                const radio = opt.querySelector('.dependency-type-radio');
                if (radio) {
                    radio.checked = false;
                }
                if (opt.dataset.type === selectedDependencyType) {
                    opt.classList.add('selected');
                    if (radio) {
                        radio.checked = true;
                    }
                }
            });
            
            // 검색 기능 초기화
            initializeDependencySearch();
            
            // 도움말 토글 기능 초기화
            initializeDependencyTypeHelp();
            
            // 의존성 유형 옵션 클릭 이벤트 리스너 추가 (onclick 대신)
            document.querySelectorAll('.dependency-type-option').forEach(opt => {
                opt.removeEventListener('click', handleDependencyTypeClick);
                opt.addEventListener('click', handleDependencyTypeClick);
                
                // 라디오 버튼 클릭 이벤트도 추가
                const radio = opt.querySelector('.dependency-type-radio');
                if (radio) {
                    radio.removeEventListener('click', function(e) {
                        e.stopPropagation();
                        const type = opt.getAttribute('data-type');
                        if (type) {
                            selectDependencyType(type);
                        }
                    });
                    radio.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const type = opt.getAttribute('data-type');
                        if (type) {
                            selectDependencyType(type);
                        }
                    });
                }
            });
            
            // 취소/저장/해제 버튼 이벤트 리스너 추가 (onclick 대신)
            const cancelBtn = modal.querySelector('.dependency-modal-btn-secondary');
            const saveBtn = modal.querySelector('.dependency-modal-btn-primary');
            const clearBtn = modal.querySelector('.dependency-modal-btn-danger');
            if (cancelBtn) {
                cancelBtn.removeEventListener('click', closeDependencyModal);
                cancelBtn.addEventListener('click', closeDependencyModal);
            }
            if (saveBtn) {
                saveBtn.removeEventListener('click', saveDependency);
                saveBtn.addEventListener('click', saveDependency);
            }
            if (clearBtn) {
                clearBtn.removeEventListener('click', clearDependency);
                clearBtn.addEventListener('click', clearDependency);
            }
            
            // X 버튼 이벤트 리스너 추가
            const closeBtn = modal.querySelector('.dependency-modal-close');
            if (closeBtn) {
                closeBtn.removeEventListener('click', closeDependencyModal);
                closeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeDependencyModal();
                });
            }

            console.log('🔗 모달 표시 시도, hidden 클래스 제거 전:', modal.classList.contains('hidden'));
            modal.classList.remove('hidden');
            
            // 모달이 확실히 보이도록 스타일 명시적으로 설정
            modal.style.display = 'flex';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            modal.style.pointerEvents = 'auto';
            modal.style.zIndex = '9999';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.right = '0';
            modal.style.bottom = '0';
            modal.style.background = 'rgba(0, 0, 0, 0.5)';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            
            // 모달 컨텐츠 스타일도 명시적으로 설정
            const modalContent = modal.querySelector('.dependency-modal-content');
            if (modalContent) {
                modalContent.style.background = 'white';
                modalContent.style.borderRadius = '8px';
                modalContent.style.padding = '20px';
                modalContent.style.maxWidth = '500px';
                modalContent.style.width = '90%';
                modalContent.style.maxHeight = '80vh';
                modalContent.style.overflowY = 'auto';
                modalContent.style.boxShadow = '0 10px 25px rgba(0,0,0,0.2)';
                modalContent.style.position = 'relative';
                modalContent.style.zIndex = '10000';
                modalContent.style.margin = 'auto';
            }
            
            // select 박스 스타일도 명시적으로 설정 (이미 위에서 선언됨)
            if (selectEl) {
                selectEl.style.width = '100%';
                selectEl.style.padding = '8px 12px';
                selectEl.style.border = '1px solid #d1d5db';
                selectEl.style.borderRadius = '6px';
                selectEl.style.fontSize = '14px';
                selectEl.style.background = 'white';
                selectEl.style.minHeight = '120px';
                selectEl.style.boxSizing = 'border-box';
            }
            
            console.log('🔗 모달 표시 완료, hidden 클래스 제거 후:', modal.classList.contains('hidden'));
            console.log('🔗 모달 스타일 display:', window.getComputedStyle(modal).display);
            console.log('🔗 모달 스타일 visibility:', window.getComputedStyle(modal).visibility);
            console.log('🔗 모달 스타일 opacity:', window.getComputedStyle(modal).opacity);
            console.log('🔗 모달 스타일 zIndex:', window.getComputedStyle(modal).zIndex);
            console.log('🔗 모달 부모 요소:', modal.parentElement?.tagName, modal.parentElement?.id);
        }
        
        // 함수 정의 직후 즉시 전역에 노출 (renderGanttChart 실행 전에도 접근 가능하도록)
        window.openDependencyModal = openDependencyModal;

        function closeDependencyModal() {
            // [성능 최적화] 취소 시 변경 이력 생성
            if (currentDependencyProjectId && initialDependencyState !== null) {
                const dataSource = (typeof projectData !== 'undefined' ? projectData : 
                                   (typeof window.projectData !== 'undefined' ? window.projectData : null));
                
                if (dataSource && Array.isArray(dataSource)) {
                    const project = dataSource.find(p => String(p.id) === String(currentDependencyProjectId));
                    if (project) {
                        const currentDependency = project.dependsOn ? JSON.stringify(project.dependsOn) : '';
                        
                        // 초기 상태와 현재 상태가 다르면 변경 이력 생성 (취소된 변경)
                        if (initialDependencyState !== currentDependency) {
                            console.log('[dep-modal] Cancelled changes detected. Creating revision entry.');
                            console.log('[dep-modal] Before:', initialDependencyState);
                            console.log('[dep-modal] After:', currentDependency);
                            createRevisionEntry(currentDependencyProjectId, 'dependency-cancelled', initialDependencyState || '없음', currentDependency || '없음');
                        }
                    }
                }
            }
            
            // 초기 상태 초기화
            initialDependencyState = null;
            
            const modal = document.getElementById('dependencyModal');
            if (!modal) return;
            
            // 모달 숨기기
            modal.classList.add('hidden');
            modal.style.display = 'none';
            modal.style.visibility = 'hidden';
            modal.style.opacity = '0';
            modal.style.pointerEvents = 'none';
            
            currentDependencyProjectId = null;
        }
        
        // 함수 정의 직후 즉시 전역에 노출
        window.closeDependencyModal = closeDependencyModal;

        // ESC 키로 의존성 모달 닫기
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const dependencyModal = document.getElementById('dependencyModal');
                if (dependencyModal && !dependencyModal.classList.contains('hidden')) {
                    closeDependencyModal();
                }
            }
        });

        function selectDependencyType(type) {
            selectedDependencyType = type;
            document.querySelectorAll('.dependency-type-option').forEach(opt => {
                opt.classList.remove('selected');
                const radio = opt.querySelector('.dependency-type-radio');
                if (radio) {
                    radio.checked = false;
                }
                if (opt.dataset.type === type) {
                    opt.classList.add('selected');
                    if (radio) {
                        radio.checked = true;
                    }
                }
            });
        }
        
        // 함수 정의 직후 즉시 전역에 노출
        window.selectDependencyType = selectDependencyType;
        
        // 의존성 유형 옵션 클릭 핸들러
        function handleDependencyTypeClick(e) {
            e.preventDefault();
            e.stopPropagation();
            const option = e.currentTarget;
            const type = option.getAttribute('data-type');
            if (type) {
                selectDependencyType(type);
            }
        }
        
        // 검색 기능 초기화
        function initializeDependencySearch() {
            const searchToggle = document.getElementById('dependencySearchToggle');
            const searchContainer = document.getElementById('dependencySearchContainer');
            const searchInput = document.getElementById('dependencySearchInput');
            const selectEl = document.getElementById('dependencyProjectSelect');
            
            if (!searchToggle || !searchContainer || !searchInput || !selectEl) return;
            
            // 검색 토글 버튼 클릭 이벤트
            searchToggle.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const isVisible = searchContainer.style.display !== 'none';
                searchContainer.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) {
                    searchInput.focus();
                }
            });
            
            // 검색 입력 이벤트
            let searchTimeout;
            searchInput.addEventListener('input', function(e) {
                clearTimeout(searchTimeout);
                const searchTerm = e.target.value.toLowerCase().trim();
                
                searchTimeout = setTimeout(() => {
                    const options = selectEl.querySelectorAll('option');
                    options.forEach(option => {
                        const text = option.textContent.toLowerCase();
                        if (searchTerm === '' || text.includes(searchTerm)) {
                            option.style.display = '';
                        } else {
                            option.style.display = 'none';
                        }
                    });
                }, 100);
            });
            
            // 검색 초기화 (모달 열 때)
            searchInput.value = '';
            searchContainer.style.display = 'none';
            const options = selectEl.querySelectorAll('option');
            options.forEach(option => {
                option.style.display = '';
            });
        }
        
        // 의존성 유형 도움말 초기화
        function initializeDependencyTypeHelp() {
            const helpToggle = document.getElementById('dependencyTypeHelpToggle');
            const helpContainer = document.getElementById('dependencyTypeHelpContainer');
            
            if (!helpToggle || !helpContainer) return;
            
            // 도움말 토글 버튼 클릭 이벤트
            helpToggle.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const isVisible = helpContainer.style.display !== 'none';
                helpContainer.style.display = isVisible ? 'none' : 'block';
            });
            
            // 도움말 초기화 (모달 열 때)
            helpContainer.style.display = 'none';
        }

        function saveDependency() {
            if (!currentDependencyProjectId) return;

            // projectData를 여러 방법으로 찾기 (스코프 문제 해결)
            const dataSource = (typeof projectData !== 'undefined' ? projectData : 
                               (typeof window.projectData !== 'undefined' ? window.projectData : null));
            
            if (!dataSource || !Array.isArray(dataSource) || dataSource.length === 0) {
                console.error('projectData를 찾을 수 없습니다.');
                if (typeof showToast === 'function') {
                    showToast('프로젝트 데이터를 찾을 수 없습니다. 페이지를 새로고침해 주세요.', 'error');
                } else {
                    alert('프로젝트 데이터를 찾을 수 없습니다. 페이지를 새로고침해 주세요.');
                }
                return;
            }

            const project = dataSource.find(p => String(p.id) === String(currentDependencyProjectId));
            if (!project) {
                if (typeof showToast === 'function') {
                    showToast('작업을 찾을 수 없습니다.', 'error');
                } else {
                    alert('작업을 찾을 수 없습니다.');
                }
                return;
            }

            const selectEl = document.getElementById('dependencyProjectSelect');
            const selectedOptions = Array.from(selectEl.selectedOptions);

            // 순환 의존성 검사
            const selectedIds = selectedOptions.map(opt => opt.value);
            if (hasCircularDependency(currentDependencyProjectId, selectedIds)) {
                showToast('순환 의존성이 감지되었습니다. 의존성을 다시 확인해주세요.', 'error');
                return;
            }

            // 변경 전 의존성 저장 (변경 이력용)
            const beforeDependency = project.dependsOn ? JSON.stringify(project.dependsOn) : '';

            // [성능 최적화] 디버깅: 저장 전 상태 확인
            console.log('[dep-save] Before save - existing dependencies:', beforeDependency);
            console.log('[dep-save] Selected options count:', selectedOptions.length);
            selectedOptions.forEach((opt, idx) => {
                console.log(`[dep-save] Selected option ${idx}:`, opt.value, 'type:', opt.getAttribute('data-dep-type') || selectedDependencyType);
            });

            // [성능 최적화] 의존성 저장 - 각 의존성의 타입을 개별적으로 저장
            // 선택된 옵션에 있는 의존성만 저장 (사용자가 선택 해제한 의존성은 제거됨)
            const newDependsOn = selectedOptions.map(opt => {
                // [성능 최적화] 기존 의존성 타입이 있으면 유지, 없으면 선택된 타입 사용
                const existingType = opt.getAttribute('data-dep-type');
                const depType = existingType || selectedDependencyType;
                return {
                projectId: opt.value,
                    type: depType
                };
            });
            
            // [성능 최적화] 중복 제거 (같은 projectId가 여러 개 있는 경우)
            const uniqueDependsOn = [];
            const seenProjectIds = new Set();
            newDependsOn.forEach(dep => {
                const depId = String(dep.projectId);
                if (!seenProjectIds.has(depId)) {
                    seenProjectIds.add(depId);
                    uniqueDependsOn.push(dep);
                }
            });
            
            // [핵심 수정] 배열 깊은 복사하여 할당 (참조 공유 방지)
            project.dependsOn = JSON.parse(JSON.stringify(uniqueDependsOn));

            // [핵심 수정] 모든 데이터 소스 동기화 보장 (배열 깊은 복사)
            // 1. window.projectData 동기화
            if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData)) {
                const windowProject = window.projectData.find(p => String(p.id) === String(currentDependencyProjectId));
                if (windowProject) {
                    // [핵심 수정] 배열 참조를 끊고 새 배열로 교체
                    windowProject.dependsOn = JSON.parse(JSON.stringify(uniqueDependsOn));
                    console.log('[dep-save] ✅ Synchronized window.projectData for project', currentDependencyProjectId);
                } else {
                    console.warn('[dep-save] ⚠️  Project not found in window.projectData:', currentDependencyProjectId);
                }
            }
            
            // 2. projectData 동기화 (별도로 관리되는 경우)
            if (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData !== dataSource) {
                const projectDataProject = projectData.find(p => String(p.id) === String(currentDependencyProjectId));
                if (projectDataProject) {
                    // [핵심 수정] 배열 참조를 끊고 새 배열로 교체
                    projectDataProject.dependsOn = JSON.parse(JSON.stringify(uniqueDependsOn));
                    console.log('[dep-save] ✅ Synchronized projectData for project', currentDependencyProjectId);
                } else {
                    console.warn('[dep-save] ⚠️  Project not found in projectData:', currentDependencyProjectId);
                }
            }

            // [핵심 수정] 저장 직후 데이터 검증
            const verifySavedData = () => {
                const sources = [
                    { name: 'dataSource', data: dataSource },
                    { name: 'window.projectData', data: typeof window.projectData !== 'undefined' ? window.projectData : null },
                    { name: 'projectData', data: typeof projectData !== 'undefined' ? projectData : null }
                ];
                
                sources.forEach(source => {
                    if (!source.data || !Array.isArray(source.data)) return;
                    const savedProject = source.data.find(p => String(p.id) === String(currentDependencyProjectId));
                    if (savedProject) {
                        const savedDeps = savedProject.dependsOn || [];
                        const expectedDeps = uniqueDependsOn;
                        if (JSON.stringify(savedDeps) !== JSON.stringify(expectedDeps)) {
                            console.error(`[dep-save] ❌ Data mismatch in ${source.name}!`);
                            console.error(`[dep-save]   Expected:`, JSON.stringify(expectedDeps));
                            console.error(`[dep-save]   Actual:`, JSON.stringify(savedDeps));
                        } else {
                            console.log(`[dep-save] ✅ Data verified in ${source.name}:`, savedDeps.length, 'dependencies');
                        }
                    }
                });
            };
            
            verifySavedData();

            // [성능 최적화] 디버깅: 저장된 의존성 확인
            console.log('[dep-save] After save - saved dependencies:', JSON.stringify(project.dependsOn));
            console.log('[dep-save] Saved dependencies count:', project.dependsOn.length);
            const dataSourceProject = dataSource.find(p => String(p.id) === String(currentDependencyProjectId));
            console.log('[dep-save] DataSource project dependencies:', JSON.stringify(dataSourceProject?.dependsOn || []));

            // 변경 후 의존성 저장 (변경 이력용)
            const afterDependency = JSON.stringify(project.dependsOn);

            // 의존성에 따라 날짜 자동 계산
            updateProjectDatesByDependency(project);

            // 변경 이력 생성
            if (beforeDependency !== afterDependency) {
                createRevisionEntry(currentDependencyProjectId, 'dependency', beforeDependency || '없음', afterDependency || '없음');
            }

            closeDependencyModal();
            invalidateFilteredDataCache();
            
            // [성능 최적화] 의존성 화살표 렌더링 보장 (여러 단계로 재시도)
            const renderDependencies = (useStoredDataSource = false) => {
                try {
                    const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                    const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                    if (!container) {
                        console.warn('[dep-save] Container not found');
                        return false;
                    }
                    
                    const ganttBody = container.querySelector('.gantt-body');
                    if (!ganttBody) {
                        console.warn('[dep-save] Gantt body not found');
                        return false;
                    }
                    
                    // [핵심 수정] 저장 직후에는 저장한 dataSource를 우선 사용
                    let dataToRender = null;
                    
                    // 우선순위: 저장한 dataSource > window.projectData > projectData
                    if (dataSource && Array.isArray(dataSource) && dataSource.length > 0) {
                        // [핵심 수정] 저장한 프로젝트의 의존성이 최신인지 확인
                        const savedProject = dataSource.find(p => String(p.id) === String(currentDependencyProjectId));
                        if (savedProject && JSON.stringify(savedProject.dependsOn) === JSON.stringify(uniqueDependsOn)) {
                            dataToRender = dataSource;
                            console.log('[dep-save] ✅ Using saved dataSource (verified) for rendering, count:', dataToRender.length);
                        } else {
                            console.warn('[dep-save] ⚠️  dataSource not verified, trying window.projectData');
                            if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) {
                                dataToRender = window.projectData;
                                console.log('[dep-save] Using window.projectData for rendering, count:', dataToRender.length);
                            }
                        }
                    } else if (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) {
                        dataToRender = window.projectData;
                        console.log('[dep-save] Using window.projectData for rendering, count:', dataToRender.length);
                    } else if (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) {
                        dataToRender = projectData;
                        console.log('[dep-save] Using projectData for rendering, count:', dataToRender.length);
                    } else {
                        // [핵심 수정] 데이터 소스가 준비되지 않은 상태에서 재시도하는 것은 정상적인 상황이므로 디버그 레벨로 변경
                        if (console.debug) {
                            console.debug('[dep-save] No valid data source found yet - this is normal during retry attempts');
                        }
                        return false;
                    }
                    
                    // [핵심 수정] 렌더링 전 최종 데이터 검증
                    if (!dataToRender || !Array.isArray(dataToRender)) {
                        // [핵심 수정] 데이터가 준비되지 않은 상태에서 재시도하는 것은 정상적인 상황이므로 디버그 레벨로 변경
                        if (console.debug) {
                            console.debug('[dep-save] dataToRender is not ready yet - this is normal during retry attempts');
                        }
                        return false;
                    }
                    
                    const renderProject = dataToRender.find(p => String(p.id) === String(currentDependencyProjectId));
                    if (renderProject) {
                        const renderDeps = renderProject.dependsOn || [];
                        if (JSON.stringify(renderDeps) !== JSON.stringify(uniqueDependsOn)) {
                            console.error('[dep-save] ❌ CRITICAL: Data mismatch before rendering!');
                            console.error('[dep-save]   Expected:', JSON.stringify(uniqueDependsOn));
                            console.error('[dep-save]   Actual:', JSON.stringify(renderDeps));
                            // 데이터 불일치 시 dataSource로 강제 교체
                            if (dataSource && Array.isArray(dataSource) && dataSource.length > 0) {
                                dataToRender = dataSource;
                                console.log('[dep-save] 🔄 Forced to use dataSource due to mismatch');
                            } else {
                                return false;
                            }
                        } else {
                            console.log('[dep-save] ✅ Data verified before rendering:', renderDeps.length, 'dependencies');
                        }
                    } else {
                        console.warn('[dep-save] ⚠️  Project not found in dataToRender:', currentDependencyProjectId);
                    }
                    
                    // [핵심 수정] 막대 행 준비 상태 확인
                    let foundCount = 0;
                    dataToRender.forEach(project => {
                        const row = ganttBody.querySelector(`.gantt-bar-row[data-project-id="${project.id}"]`);
                        if (row) {
                            const bar = row.querySelector('.gantt-bar');
                            if (bar) {
                                foundCount++;
                            }
                        }
                    });
                    
                    // [핵심 수정] 조건 완화 - 하나라도 찾으면 렌더링
                    if (foundCount === 0) {
                        console.warn(`[dep-save] No bar rows found: 0/${dataToRender.length} found`);
                        return false; // 재시도는 호출 측에서 처리
                    }
                    
                    console.log(`[dep-save] Bar rows ready: ${foundCount}/${dataToRender.length} found - proceeding with rendering`);
                    
                    // [핵심 수정] 최종 데이터 검증 - 모든 프로젝트의 의존성 확인
                    console.log('[dep-save] 📊 Final data verification:');
                    let totalDepsInData = 0;
                    dataToRender.forEach(p => {
                        if (p.dependsOn && Array.isArray(p.dependsOn) && p.dependsOn.length > 0) {
                            totalDepsInData += p.dependsOn.length;
                        }
                    });
                    console.log('[dep-save]   - Total dependencies in dataToRender:', totalDepsInData);
                    
                    const projectToRender = dataToRender.find(p => String(p.id) === String(currentDependencyProjectId));
                    if (projectToRender) {
                        console.log('[dep-save]   - Current project dependencies:', JSON.stringify(projectToRender.dependsOn));
                        console.log('[dep-save]   - Current project dependencies count:', projectToRender.dependsOn ? projectToRender.dependsOn.length : 0);
                        console.log('[dep-save]   - Expected dependencies:', JSON.stringify(uniqueDependsOn));
                        console.log('[dep-save]   - Expected count:', uniqueDependsOn.length);
                        
                        // [핵심 수정] 저장된 의존성과 렌더링할 의존성 비교
                        const renderDeps = projectToRender.dependsOn || [];
                        if (JSON.stringify(renderDeps) !== JSON.stringify(uniqueDependsOn)) {
                            console.error('[dep-save] ❌ CRITICAL: Final data mismatch!');
                            console.error('[dep-save]   Expected:', JSON.stringify(uniqueDependsOn));
                            console.error('[dep-save]   Actual:', JSON.stringify(renderDeps));
                        } else {
                            console.log('[dep-save] ✅ Final data match confirmed');
                        }
                    } else {
                        console.error('[dep-save] ❌ Project not found in dataToRender:', currentDependencyProjectId);
                    }
                    
                    // [성능 최적화] 모든 의존성 렌더링 보장
                    console.log('[dep-save] ✅ Calling renderDependencyArrows...');
                    if (typeof window.renderDependencyArrows === 'function') {
                        window.renderDependencyArrows(ganttBody, dataToRender);
                        
                        // 렌더링 완료 확인
                        setTimeout(() => {
                            const renderedSvg = ganttBody.querySelector('.gantt-dependency-svg');
                            if (renderedSvg) {
                                const renderedPaths = renderedSvg.querySelectorAll('path[data-from]');
                                console.log('[dep-save] ✅ SVG found in DOM');
                                console.log('[dep-save]   - Paths found:', renderedPaths.length);
                                console.log('[dep-save]   - For project:', currentDependencyProjectId);
                                return true;
                            } else {
                                console.error('[dep-save] ❌ SVG NOT FOUND IN DOM');
                                return false;
                }
            }, 100);
                        return true; // 함수 호출은 성공
                    } else if (typeof renderDependencyArrows === 'function') {
                        console.log('[dep-save] Using local renderDependencyArrows function');
                        renderDependencyArrows(ganttBody, dataToRender);
                        return true;
                    } else {
                        console.error('[dep-save] ❌ renderDependencyArrows function not found!');
                        console.error('[dep-save] window.renderDependencyArrows:', typeof window.renderDependencyArrows);
                        console.error('[dep-save] renderDependencyArrows:', typeof renderDependencyArrows);
                        return false;
                    }
                } catch (e) {
                    console.error('[dep-save] Error rendering dependencies:', e);
                    return false;
                }
            };
            
            // [성능 최적화] render() 호출 후 의존성 렌더링 보장
            render();
            
            // [핵심 수정] 작업 목록 영역 의존성 직각 선 업데이트 함수
            const updateTaskListDependencyLines = () => {
                try {
                    const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                    const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : document.getElementById('ganttViewContent');
                    if (!container) return;
                    
                    const titlesBodyWrapper = container.querySelector('.gantt-titles-body-wrapper');
                    if (!titlesBodyWrapper) return;
                    
                    const svg = titlesBodyWrapper.querySelector('.task-list-dependency-svg');
                    if (!svg) return;
                    
                    const titlesBody = titlesBodyWrapper.querySelector('.gantt-titles-body');
                    if (!titlesBody) return;
                    
                    // 기존 선 제거
                    svg.innerHTML = '';
                    
                    // 원본 데이터 사용
                    const dataToRender = (typeof window.projectData !== 'undefined' && Array.isArray(window.projectData) && window.projectData.length > 0) ?
                                        window.projectData : (typeof projectData !== 'undefined' && Array.isArray(projectData) && projectData.length > 0) ? projectData : [];
                    
                    if (!dataToRender || dataToRender.length === 0) return;
                    
                    // 각 title-item의 위치 수집
                    const titlePositions = new Map();
                    const titleItems = titlesBody.querySelectorAll('.title-item');
                    
                    titleItems.forEach(titleItem => {
                        const projectId = titleItem.dataset.projectId;
                        if (!projectId) return;
                        
                        const rect = titleItem.getBoundingClientRect();
                        const parentRect = titlesBodyWrapper.getBoundingClientRect();
                        const top = rect.top - parentRect.top + titlesBody.scrollTop;
                        const height = rect.height;
                        const centerY = top + height / 2;
                        const right = rect.right - parentRect.left;
                        
                        titlePositions.set(String(projectId), {
                            top: top,
                            centerY: centerY,
                            right: right,
                            height: height
                        });
                    });
                    
                    if (titlePositions.size === 0) return;
                    
                    // SVG defs에 마커 정의 추가
                    const svgNS = 'http://www.w3.org/2000/svg';
                    const defs = document.createElementNS(svgNS, 'defs');
                    svg.appendChild(defs);
                    
                    const colorMap = {
                        'start-to-start': '#2563eb',
                        'end-to-start':   '#10b981',
                        'end-to-end':     '#f59e0b',
                        'start-to-end':   '#ef4444'
                    };
                    
                    // 화살표 마커 생성
                    Object.keys(colorMap).forEach(type => {
                        const marker = document.createElementNS(svgNS, 'marker');
                        marker.setAttribute('id', `task-list-arrow-${type}`);
                        marker.setAttribute('viewBox', '0 0 10 10');
                        marker.setAttribute('refX', '9');
                        marker.setAttribute('refY', '5');
                        marker.setAttribute('markerWidth', '6');
                        marker.setAttribute('markerHeight', '6');
                        marker.setAttribute('orient', 'auto');
                        const path = document.createElementNS(svgNS, 'path');
                        path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                        path.setAttribute('fill', colorMap[type]);
                        marker.appendChild(path);
                        defs.appendChild(marker);
                    });
                    
                    // 의존성 선 그리기
                    dataToRender.forEach(project => {
                        if (!project.dependsOn || !Array.isArray(project.dependsOn) || project.dependsOn.length === 0) {
                            return;
                        }
                        
                        const projectPos = titlePositions.get(String(project.id));
                        if (!projectPos) return;
                        
                        project.dependsOn.forEach(dep => {
                            const depPos = titlePositions.get(String(dep.projectId));
                            if (!depPos) return;
                            
                            const edgeColor = colorMap[dep.type] || '#9ca3af';
                            
                            // 직각 선 경로 계산
                            const startX = depPos.right;
                            const startY = depPos.centerY;
                            const endX = projectPos.right;
                            const endY = projectPos.centerY;
                            
                            // 직각 경로: 수평선 → 수직선 → 수평선
                            const midX = (startX + endX) / 2;
                            const path = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
                            
                            const pathEl = document.createElementNS(svgNS, 'path');
                            pathEl.setAttribute('d', path);
                            pathEl.setAttribute('stroke', edgeColor);
                            pathEl.setAttribute('stroke-width', '1.5');
                            pathEl.setAttribute('fill', 'none');
                            pathEl.setAttribute('marker-end', `url(#task-list-arrow-${dep.type})`);
                            pathEl.setAttribute('data-from', String(dep.projectId));
                            pathEl.setAttribute('data-to', String(project.id));
                            pathEl.setAttribute('data-type', dep.type);
                            
                            // 툴팁을 위한 title 추가
                            const depProject = dataToRender.find(p => String(p.id) === String(dep.projectId));
                            const depName = depProject ? depProject.name : '알 수 없음';
                            const typeMap = {
                                'start-to-start': 'SS',
                                'end-to-start': 'FS',
                                'end-to-end': 'FF',
                                'start-to-end': 'SF'
                            };
                            const depType = typeMap[dep.type] || dep.type;
                            pathEl.setAttribute('title', `${depName} (${depType}) → ${project.name}`);
                            
                            svg.appendChild(pathEl);
                        });
                    });
                } catch (e) {
                    console.warn('[task-list-dep-save] Error updating dependency lines:', e);
                }
            };
            
            // 첫 번째 시도: DOM 업데이트 완료 후 (원본 데이터 사용)
            setTimeout(() => {
                let renderSuccess = renderDependencies();
                
                // [핵심 수정] 작업 목록 영역 의존성 선 업데이트
                updateTaskListDependencyLines();
                if (!renderSuccess) {
                    // 두 번째 시도: requestAnimationFrame을 사용하여 DOM 업데이트 완료 보장
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            setTimeout(() => {
                                renderSuccess = renderDependencies();
                                if (!renderSuccess) {
                                    // 세 번째 시도: 레이아웃 업데이트 완료 후
                                    setTimeout(() => {
                                        renderSuccess = renderDependencies();
                                        if (!renderSuccess) {
                                            // 네 번째 시도: 최종 재시도
                                            setTimeout(() => {
                                                renderSuccess = renderDependencies();
                                                if (!renderSuccess) {
                                                    // 다섯 번째 시도: 최종 최종 재시도
                                                    setTimeout(() => {
                                                        renderDependencies();
                                                    }, 500);
                        }
                                            }, 300);
                                        }
                                    }, 200);
                }
                            }, 150);
                        });
                    });
                }
            }, 150);
            
            showToast('의존성이 저장되었습니다.', 'success');
        }
        
        // 의존성 해제 함수
        function clearDependency() {
            if (!currentDependencyProjectId) return;

            // projectData를 여러 방법으로 찾기 (스코프 문제 해결)
            const dataSource = (typeof projectData !== 'undefined' ? projectData : 
                               (typeof window.projectData !== 'undefined' ? window.projectData : null));
            
            if (!dataSource || !Array.isArray(dataSource) || dataSource.length === 0) {
                console.error('projectData를 찾을 수 없습니다.');
                if (typeof showToast === 'function') {
                    showToast('프로젝트 데이터를 찾을 수 없습니다. 페이지를 새로고침해 주세요.', 'error');
                } else {
                    alert('프로젝트 데이터를 찾을 수 없습니다. 페이지를 새로고침해 주세요.');
                }
                return;
            }

            const project = dataSource.find(p => String(p.id) === String(currentDependencyProjectId));
            if (!project) {
                if (typeof showToast === 'function') {
                    showToast('작업을 찾을 수 없습니다.', 'error');
                } else {
                    alert('작업을 찾을 수 없습니다.');
                }
                return;
            }

            // 변경 전 의존성 저장 (변경 이력용)
            const beforeDependency = project.dependsOn ? JSON.stringify(project.dependsOn) : '';

            // 의존성 해제 - 빈 배열로 설정
            project.dependsOn = [];

            // 변경 후 의존성 저장 (변경 이력용)
            const afterDependency = JSON.stringify(project.dependsOn);

            // 의존성에 따라 날짜 자동 계산
            updateProjectDatesByDependency(project);

            // 변경 이력 생성
            if (beforeDependency !== afterDependency) {
                createRevisionEntry(currentDependencyProjectId, 'dependency', beforeDependency || '없음', afterDependency || '없음');
            }

            closeDependencyModal();
            invalidateFilteredDataCache();
            render();
            
            // 의존성 화살표 렌더링 보장 (렌더링 완료 후)
            setTimeout(() => {
                const isInFullscreen = !fullscreenModal.classList.contains('hidden');
                const container = isInFullscreen ? fullscreenModalBody : document.getElementById('ganttViewContent');
                if (container) {
                    const ganttBody = container.querySelector('.gantt-body');
                    if (ganttBody) {
                        // 필터링된 데이터 가져오기
                        const filteredData = getFilteredAndSortedData ? getFilteredAndSortedData() : 
                                           (latestFilteredData || dataSource);
                        if (filteredData && Array.isArray(filteredData)) {
                            renderDependencyArrows(ganttBody, filteredData);
                        }
                    }
                }
            }, 100);
            
            showToast('의존성이 해제되었습니다.', 'success');
        }
        
        // 함수 정의 직후 즉시 전역에 노출
        window.saveDependency = saveDependency;
        window.clearDependency = clearDependency;

        function hasCircularDependency(projectId, dependencyIds) {
            // projectData를 여러 방법으로 찾기 (스코프 문제 해결)
            const dataSource = (typeof projectData !== 'undefined' ? projectData : 
                               (typeof window.projectData !== 'undefined' ? window.projectData : null));
            
            if (!dataSource || !Array.isArray(dataSource)) {
                return false;
            }
            
            // 간단한 순환 의존성 검사 (직접적인 순환만 체크)
            for (const depId of dependencyIds) {
                const depProject = dataSource.find(p => String(p.id) === String(depId));
                if (depProject && depProject.dependsOn) {
                    for (const dep of depProject.dependsOn) {
                        if (String(dep.projectId) === String(projectId)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function updateProjectDatesByDependency(project) {
            if (!project.dependsOn || project.dependsOn.length === 0) return;

            // projectData를 여러 방법으로 찾기 (스코프 문제 해결)
            const dataSource = (typeof projectData !== 'undefined' ? projectData : 
                               (typeof window.projectData !== 'undefined' ? window.projectData : null));
            
            if (!dataSource || !Array.isArray(dataSource)) {
                return;
            }

            let minStartDate = null;
            let minEndDate = null;

            project.dependsOn.forEach(dep => {
                const depProject = dataSource.find(p => String(p.id) === String(dep.projectId));
                if (!depProject || !depProject.startDate || !depProject.endDate) return;

                const depStart = new Date(depProject.startDate);
                const depEnd = new Date(depProject.endDate);

                switch (dep.type) {
                    case 'start-to-start':
                        if (!minStartDate || depStart < minStartDate) {
                            minStartDate = depStart;
                        }
                        break;
                    case 'end-to-start':
                        if (!minStartDate || depEnd < minStartDate) {
                            minStartDate = depEnd;
                        }
                        break;
                    case 'end-to-end':
                        if (!minEndDate || depEnd < minEndDate) {
                            minEndDate = depEnd;
                        }
                        break;
                    case 'start-to-end':
                        if (!minEndDate || depStart < minEndDate) {
                            minEndDate = depStart;
                        }
                        break;
                }
            });

            // 날짜 업데이트
            if (minStartDate && (!project.startDate || minStartDate > project.startDate)) {
                project.startDate = new Date(minStartDate);
                project.startDateStr = formatDateYMD(project.startDate);
            }
            if (minEndDate && (!project.endDate || minEndDate > project.endDate)) {
                project.endDate = new Date(minEndDate);
                project.endDateStr = formatDateYMD(project.endDate);
            }

            // 종료일이 시작일보다 앞서면 조정
            if (project.startDate && project.endDate && project.endDate < project.startDate) {
                project.endDate = new Date(project.startDate);
                project.endDateStr = formatDateYMD(project.endDate);
            }
        }

        function renderDependencyArrows(ganttBody, data) {
            // 기존 화살표 제거
            const existingSvg = ganttBody.querySelector('.gantt-dependency-svg');
            if (existingSvg) existingSvg.remove();

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '8';
            svg.setAttribute('class', 'gantt-dependency-svg');

            // 화살표 마커 정의는 각 막대 높이에 따라 동적으로 생성
            // 기본 화살표 마커는 나중에 각 의존성에 맞게 조정됨

            // 모든 막대 행의 위치 정보를 먼저 수집
            const barPositions = new Map();
            
            data.forEach(project => {
                const projectBarRow = ganttBody.querySelector(`.gantt-bar-row[data-project-id="${project.id}"]`);
                if (!projectBarRow) return;

                const projectBar = projectBarRow.querySelector('.gantt-bar');
                if (!projectBar) return;

                // 막대의 실제 위치 계산 (style.left 사용 - 절대 위치)
                const projectBarLeft = parseFloat(projectBar.style.left) || 0;
                const projectBarWidth = parseFloat(projectBar.style.width) || 0;
                const projectBarRight = projectBarLeft + projectBarWidth;
                
                // 막대의 Y 위치 계산 (getBoundingClientRect를 사용하여 정확한 위치 계산)
                const barRect = projectBar.getBoundingClientRect();
                const ganttBodyRect = ganttBody.getBoundingClientRect();
                const projectBarTop = barRect.top - ganttBodyRect.top + ganttBody.scrollTop;
                
                // 막대의 실제 높이 확인
                const barHeight = barRect.height || 20; // 기본값 20px
                const projectBarCenterY = projectBarTop + (barHeight / 2);

                barPositions.set(project.id, {
                    top: projectBarTop,
                    left: projectBarLeft,
                    width: projectBarWidth,
                    right: projectBarRight,
                    centerY: projectBarCenterY,
                    height: barHeight
                });
            });

            data.forEach(project => {
                if (!project.dependsOn || project.dependsOn.length === 0) return;

                const projectPos = barPositions.get(project.id);
                if (!projectPos) return;

                project.dependsOn.forEach(dep => {
                    const depPos = barPositions.get(dep.projectId);
                    if (!depPos) return;

                    let startX, startY, endX, endY;
                    
                    // [개선] 원형 마커 크기를 막대 높이보다 작게 설정 - 현재 크기에서 20% 더 크게
                    const minBarHeight = Math.min(projectPos.height, depPos.height);
                    // 시작점 빈 원형 마커 크기 (막대 높이보다 작게)
                    const baseStartCircleRadius = Math.max(1.2, Math.min(minBarHeight * 0.18, 2.5));
                    // 끝점 채워진 원형 마커 크기 (막대 높이보다 작게)
                    const baseEndCircleRadius = Math.max(1.2, Math.min(minBarHeight * 0.18, 2.5));
                    // 물 흐름 원형 크기 (더 작게)
                    const baseFlowCircleRadius = Math.max(1, Math.min(minBarHeight * 0.12, 2));
                    // [개선] 현재 크기에서 20% 더 크게: 1.2 * 1.2 = 1.44배 적용
                    const sizeScale = 1.44;
                    const startCircleRadius = baseStartCircleRadius * sizeScale;
                    const endCircleRadius = baseEndCircleRadius * sizeScale;
                    const flowCircleRadius = baseFlowCircleRadius * sizeScale;

                    // 의존성 유형에 따라 시작점/끝점 결정 (단일 직선)
                    switch (dep.type) {
                        case 'start-to-start': // SS: 시작 → 시작 (좌측 → 좌측)
                            startX = depPos.left;
                            startY = depPos.centerY;
                            endX = projectPos.left;
                            endY = projectPos.centerY;
                            break;
                            
                        case 'end-to-start': // FS: 종료 → 시작 (우측 → 좌측) - 가장 일반적
                            startX = depPos.right;
                            startY = depPos.centerY;
                            endX = projectPos.left;
                            endY = projectPos.centerY;
                            break;
                            
                        case 'end-to-end': // FF: 종료 → 종료 (우측 → 우측)
                            startX = depPos.right;
                            startY = depPos.centerY;
                            endX = projectPos.right;
                            endY = projectPos.centerY;
                            break;
                            
                        case 'start-to-end': // SF: 시작 → 종료 (좌측 → 우측)
                            startX = depPos.left;
                            startY = depPos.centerY;
                            endX = projectPos.right;
                            endY = projectPos.centerY;
                            break;
                            
                        default:
                            return;
                    }

                    const defs = svg.querySelector('defs') || svg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'defs'));

                    // 색상 매핑 (의존성 유형별)
                    const colorMap = {
                        'start-to-start': '#2563eb',
                        'end-to-start':   '#10b981',
                        'end-to-end':     '#f59e0b',
                        'start-to-end':   '#ef4444'
                    };
                    const edgeColor = colorMap[dep.type] || '#9ca3af';

                    // 시작점 빈 원형 마커 생성 (○)
                    const startMarkerId = `start-circle-${dep.projectId}-${project.id}`;
                    const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    startMarker.setAttribute('id', startMarkerId);
                    const startMarkerSize = startCircleRadius * 2 + 2;
                    startMarker.setAttribute('viewBox', `0 0 ${startMarkerSize} ${startMarkerSize}`);
                    startMarker.setAttribute('refX', startCircleRadius + 1);
                    startMarker.setAttribute('refY', startCircleRadius + 1);
                    startMarker.setAttribute('markerWidth', startMarkerSize);
                    startMarker.setAttribute('markerHeight', startMarkerSize);
                    startMarker.setAttribute('orient', 'auto');
                    startMarker.setAttribute('markerUnits', 'userSpaceOnUse');
                    
                    const startCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    startCircle.setAttribute('cx', startCircleRadius + 1);
                    startCircle.setAttribute('cy', startCircleRadius + 1);
                    startCircle.setAttribute('r', startCircleRadius);
                    startCircle.setAttribute('fill', 'none'); // 빈 원형
                    startCircle.setAttribute('stroke', edgeColor);
                    startCircle.setAttribute('stroke-width', '0.6');
                    startCircle.setAttribute('opacity', '0.95');
                    
                    startMarker.appendChild(startCircle);
                    defs.appendChild(startMarker);

                    // 끝점 채워진 원형 마커 생성 (●)
                    const endMarkerId = `end-circle-${dep.projectId}-${project.id}`;
                    const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    endMarker.setAttribute('id', endMarkerId);
                    const endMarkerSize = endCircleRadius * 2 + 2;
                    endMarker.setAttribute('viewBox', `0 0 ${endMarkerSize} ${endMarkerSize}`);
                    endMarker.setAttribute('refX', endCircleRadius + 1);
                    endMarker.setAttribute('refY', endCircleRadius + 1);
                    endMarker.setAttribute('markerWidth', endMarkerSize);
                    endMarker.setAttribute('markerHeight', endMarkerSize);
                    endMarker.setAttribute('orient', 'auto');
                    endMarker.setAttribute('markerUnits', 'userSpaceOnUse');
                    
                    const endCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    endCircle.setAttribute('cx', endCircleRadius + 1);
                    endCircle.setAttribute('cy', endCircleRadius + 1);
                    endCircle.setAttribute('r', endCircleRadius);
                    endCircle.setAttribute('fill', edgeColor); // 채워진 원형
                    endCircle.setAttribute('stroke', 'none');
                    endCircle.setAttribute('opacity', '0.95');
                    
                    endMarker.appendChild(endCircle);
                    defs.appendChild(endMarker);

                    // Path 생성 (단일 직선)
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const d = `M ${startX} ${startY} L ${endX} ${endY}`;
                    
                    path.setAttribute('d', d);
                    path.setAttribute('id', `dependency-path-${dep.projectId}-${project.id}`);
                    path.setAttribute('class', `gantt-dependency-arrow dependency-${dep.type}`);
                    path.setAttribute('data-from', dep.projectId);
                    path.setAttribute('data-to', project.id);
                    path.setAttribute('marker-start', `url(#${startMarkerId})`); // 시작점 빈 원형 마커 적용
                    path.setAttribute('marker-end', `url(#${endMarkerId})`); // 끝점 채워진 원형 마커 적용
                    // 명시적으로 색상/스타일 지정 (JS 레벨에서 적용하여 인라인 우선 적용)
                    path.setAttribute('stroke', edgeColor);
                    path.setAttribute('stroke-width', '0.8');
                    path.setAttribute('stroke-dasharray', '6 4');
                    path.setAttribute('stroke-linecap', 'round');
                    
                    svg.appendChild(path);

                    // [개선] 물 흐름 효과: 선을 따라 이동하는 작은 원형들 - 개수 20% 증가, 속도 10% 빠르게
                    const flowCircleCount = 4; // 현재 3개에서 20% 증가: 3 * 1.2 = 3.6 -> 4개
                    for (let i = 0; i < flowCircleCount; i++) {
                        const flowCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        flowCircle.setAttribute('class', 'dependency-flow-circle');
                        flowCircle.setAttribute('r', flowCircleRadius);
                        flowCircle.setAttribute('fill', edgeColor);
                        flowCircle.setAttribute('opacity', '0.95');
                        
                        // animateMotion을 사용하여 path를 따라 이동
                        const animateMotion = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
                        animateMotion.setAttribute('dur', '2.25s'); // 현재 2.5s에서 10% 빠르게: 2.5 * 0.9 = 2.25s
                        animateMotion.setAttribute('repeatCount', 'indefinite');
                        animateMotion.setAttribute('begin', `${i * 0.5}s`); // 원의 개수 증가에 맞춰 간격 조정
                        
                        const mpath = document.createElementNS('http://www.w3.org/2000/svg', 'mpath');
                        // 호환성: xlink:href 네임스페이스와 modern href 모두 설정
                        try {
                            mpath.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#dependency-path-${dep.projectId}-${project.id}`);
                        } catch(e) {}
                        mpath.setAttribute('href', `#dependency-path-${dep.projectId}-${project.id}`);
                        animateMotion.appendChild(mpath);
                        flowCircle.appendChild(animateMotion);
                        
                        svg.appendChild(flowCircle);
                    }
                });
            });

            if (svg.children.length > 0) {
                ganttBody.appendChild(svg);
            }
        }

        // 전역 함수로 노출
        window.openDependencyModal = openDependencyModal;
        window.closeDependencyModal = closeDependencyModal;
        window.selectDependencyType = selectDependencyType;
        window.saveDependency = saveDependency;
        window.clearDependency = clearDependency;
        window.clearDependency = clearDependency;
             // DOM이 완전히 생성된 후 계층순서를 적용하여 정렬, 필터, 접기/펼치기 등 작업 시에도 유지
             setTimeout(() => {
                 applyHierarchyOrder(container);
             }, 0);
        }

         // Separate event handler function for legend clicks
         function handleLegendClickEvent(e) {
             handleLegendClick(e.currentTarget);
         }


        function updateLayoutSync() {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (!container) return;

            const titlesBodyWrapper = container.querySelector('.gantt-titles-body-wrapper');
            const titlesBody = titlesBodyWrapper ? titlesBodyWrapper.querySelector('div') : null; // The actual scrolling div
            const timelineBodyWrapper = container.querySelector('.gantt-timeline-body-wrapper');
            const bodyTodayMarker = container.querySelector('.gantt-body > .gantt-today-marker-container');
            const ganttBody = container.querySelector('.gantt-body');

            if (!titlesBody || !timelineBodyWrapper || !ganttBody) return;

            // **개선 사항 1: '오늘' 점선 높이 동적 제한**
            if (bodyTodayMarker) {
                recomputeTodayMarkerHeight(container);
            }

            // Sync scrollbar spacer
            const oldSpacer = titlesBody.querySelector('.scrollbar-spacer');
            if (oldSpacer) oldSpacer.remove();

            const scrollbarHeight = timelineBodyWrapper.offsetHeight - timelineBodyWrapper.clientHeight;
            if (scrollbarHeight > 0) {
                const spacer = document.createElement('div');
                spacer.className = 'scrollbar-spacer';
                spacer.style.height = `${scrollbarHeight}px`;
                titlesBody.appendChild(spacer);
            }
            
            // 개선 사항: 계층 순서 적용 (렌더링 후 최종 순서 조정)
            applyHierarchyOrder(container);
        }

        // 현재 보이는 마지막 행의 정중앙까지만 '오늘' 점선 표시
        // 개선사항 2&3: 타임라인 정렬 검증 및 처리 함수
        function verifyTimelineAlignment() {
            const timelineHeader = document.querySelector('.gantt-timeline-header');
            const ganttBody = document.querySelector('.gantt-body');
            if (!timelineHeader || !ganttBody) return;

            const headerGridLines = Array.from(timelineHeader.querySelectorAll('.gantt-day')).map(day => {
                const rect = day.getBoundingClientRect();
                return Math.round(rect.left);
            });
            
            const bodyGridLines = Array.from(ganttBody.querySelectorAll('.gantt-grid-line')).map(line => {
                const rect = line.getBoundingClientRect();
                return Math.round(rect.left);
            });

            const threshold = 1; // 1픽셀 이내의 오차는 허용
            const isAligned = headerGridLines.every((headerPos, index) => {
                const bodyPos = bodyGridLines[index];
                return Math.abs(headerPos - bodyPos) <= threshold;
            });

            if (!isAligned) {
                showTimelineAlignmentWarning();
            }
        }

        function showTimelineAlignmentWarning() {
            const zoomBtn = document.getElementById('zoomBtn');
            if (!zoomBtn) return;

            const warningClass = 'bg-yellow-200';
            if (!zoomBtn.classList.contains(warningClass)) {
                zoomBtn.classList.add(warningClass);
                showToast('날짜 설정을 초기화하여 열 구분선을 정렬해주세요.', 'warning');
                
                // **개선 사항 1 수정: 자동으로 날짜 설정 모달 표시 제거 - 사용자가 '날짜 설정' 버튼을 클릭할 때만 모달이 열리도록 변경**
                // 모달은 사용자가 직접 '날짜 설정' 버튼을 클릭할 때만 열리도록 함
            }
        }

        function recomputeTodayMarkerHeight(container) {
            const wrapper = container.querySelector('.gantt-timeline-body-wrapper');
            const ganttBody = container.querySelector('.gantt-body');
            const marker = container.querySelector('.gantt-body > .gantt-today-marker-container');
            if (!wrapper || !ganttBody || !marker) return;
        
            const markerLine = marker.querySelector('.gantt-today-marker');
        
            // 모든 작업 항목(펼쳐진 것과 접힌 것 모두)을 가져옴
            const allItems = Array.from(ganttBody.querySelectorAll('.gantt-bar-row'));
            const visibleItems = allItems.filter(item => {
                // 행이 보이려면, 해당 요소와 그 모든 부모 요소들이 'hidden' 클래스를 가지고 있지 않아야 합니다.
                let el = item;
                while(el && el !== ganttBody) {
                    if (el.classList.contains('hidden')) return false;
                    el = el.parentElement;
                }
                return true;
            });
            
            // 계층 구조를 고려하여 마지막 표시 항목을 찾음
            const lastVisibleItem = visibleItems[visibleItems.length - 1];
        
            if (lastVisibleItem) {
                const ganttBodyRect = ganttBody.getBoundingClientRect();
                const lastItemRect = lastVisibleItem.getBoundingClientRect();
                
                // 마지막으로 보이는 항목의 중간 지점까지의 높이를 계산합니다.
                const heightToMiddle = (lastItemRect.top - ganttBodyRect.top) + (lastItemRect.height / 2);
                marker.style.height = `${heightToMiddle}px`;
            }

            // 스크롤 시 마커의 가시성 확인
            const todayOffset = parseInt(marker.style.left);
            const scrollLeft = wrapper.scrollLeft;
            const clientWidth = wrapper.clientWidth;
        
            // 가시 영역에 있는지 확인하고 투명도 조정
            if (todayOffset >= scrollLeft && todayOffset <= scrollLeft + clientWidth) {
                marker.style.opacity = '1';
                if (markerLine) markerLine.style.opacity = '1';
            } else {
                // 화면 밖에 있을 때는 약간 투명하게 처리
                if (markerLine) markerLine.style.opacity = '0.5';
            }
        }

        // Make a table sortable by clicking on headers. Adds small ▲/▼ indicators.
        function makeTableSortable(table) {
            if (!table) return;
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            if (!thead || !tbody) return;

            const ths = Array.from(thead.querySelectorAll('th'));
            ths.forEach((th, colIndex) => {
                // add sort indicator
                let indicator = th.querySelector('.sort-indicator');
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'sort-indicator ml-2 text-xs';
                    indicator.style.cursor = 'pointer';
                    th.appendChild(indicator);
                }

                th.style.userSelect = 'none';
                th.addEventListener('click', () => {
                    const currentDir = th.dataset.sortDir || 'none';
                    const newDir = currentDir === 'asc' ? 'desc' : 'asc';
                    // reset all
                    ths.forEach(t => { t.dataset.sortDir = ''; const si = t.querySelector('.sort-indicator'); if (si) si.textContent = ''; });
                    th.dataset.sortDir = newDir;
                    indicator.textContent = newDir === 'asc' ? '▲' : '▼';

                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const cellValues = rows.map(r => {
                        const cell = r.children[colIndex];
                        return cell ? cell.textContent.trim() : '';
                    });

                    // detect numeric or date
                    const isNumeric = cellValues.every(v => v === '' || /^[-+]?\d{1,3}(?:[,\d]{0,}|\d*)(?:\.\d+)?(?:%|원)?$/.test(v.replace(/\s/g,'')));
                    const isDate = cellValues.every(v => parseLocalDateString(v) instanceof Date && !isNaN(parseLocalDateString(v)?.getTime()));

                    rows.sort((a, b) => {
                        const va = a.children[colIndex] ? a.children[colIndex].textContent.trim() : '';
                        const vb = b.children[colIndex] ? b.children[colIndex].textContent.trim() : '';
                        let resa = va, resb = vb;
                        if (isNumeric) {
                            const numA = parseFloat(va.replace(/[,%원\s]/g, '')) || 0;
                            const numB = parseFloat(vb.replace(/[,%원\s]/g, '')) || 0;
                            resa = numA; resb = numB;
                        } else if (isDate) {
                            const da = parseLocalDateString(va); const db = parseLocalDateString(vb);
                            resa = da ? +da : 0; resb = db ? +db : 0;
                        } else {
                            resa = va.toLowerCase(); resb = vb.toLowerCase();
                        }

                        if (resa < resb) return newDir === 'asc' ? -1 : 1;
                        if (resa > resb) return newDir === 'asc' ? 1 : -1;
                        return 0;
                    });

                    // Re-attach rows in sorted order
                    rows.forEach(r => tbody.appendChild(r));
                });
            });
        }

        function exportTableToXLSX(tableElement, filename = 'export.xlsx') {
            if (!tableElement) return;
            try {
                // Use direct table->sheet conversion
                const ws = XLSX.utils.table_to_sheet(tableElement);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
                XLSX.writeFile(wb, filename);
            } catch (e) {
                console.error('exportTableToXLSX error', e);
                showToast('테이블을 엑셀로 내보내는 중 오류가 발생했습니다.', 'error');
            }
        }


        function makeResizable(modalContentElement) {
            const resizers = modalContentElement.querySelectorAll('.resizer-handle');
            let original_width = 0, original_height = 0, original_x = 0, original_y = 0, original_mouse_x = 0, original_mouse_y = 0;

            resizers.forEach(resizer => {
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const rect = modalContentElement.getBoundingClientRect();
                    original_width = rect.width;
                    original_height = rect.height;
                    original_x = rect.left;
                    original_y = rect.top;
                    original_mouse_x = e.pageX;
                    original_mouse_y = e.pageY;
                    const direction = resizer.dataset.direction;

                    const overlay = modalContentElement.parentElement;
                    if (overlay.style.justifyContent !== 'flex-start') {
                        overlay.style.justifyContent = 'flex-start';
                        overlay.style.alignItems = 'flex-start';
                        modalContentElement.style.left = `${rect.left}px`;
                        modalContentElement.style.top = `${rect.top}px`;
                        modalContentElement.style.margin = '0';
                    }

                    function resize(e) {
                        if (direction.includes('e')) {
                            const width = original_width + (e.pageX - original_mouse_x);
                            if (width >= 500) modalContentElement.style.width = width + 'px';
                        }
                        if (direction.includes('s')) {
                             const height = original_height + (e.pageY - original_mouse_y);
                             if (height >= 400) modalContentElement.style.height = height + 'px';
                        }
                         if (direction.includes('w')) {
                            const width = original_width - (e.pageX - original_mouse_x);
                            if (width >= 500) {
                                modalContentElement.style.width = width + 'px';
                                modalContentElement.style.left = original_x + (e.pageX - original_mouse_x) + 'px';
                            }
                        }
                        if (direction.includes('n')) {
                            const height = original_height - (e.pageY - original_mouse_y);
                            if (height > 300) {
                                modalContentElement.style.height = height + 'px';
                                modalContentElement.style.top = original_y + (e.pageY - original_mouse_y) + 'px';
                            }
                        }
                    }

                    function stopResize() {
                        window.removeEventListener('mousemove', resize);
                        window.removeEventListener('mouseup', stopResize);
                    }
                    window.addEventListener('mousemove', resize);
                    window.addEventListener('mouseup', stopResize);
                });
            });
        }

        function makeDraggable(modalContent, handle) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

            handle.style.cursor = 'move';
            handle.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;

                const overlay = modalContent.parentElement;
                if (overlay.style.justifyContent !== 'flex-start') {
                    const rect = modalContent.getBoundingClientRect();
                    overlay.style.justifyContent = 'flex-start';
                    overlay.style.alignItems = 'flex-start';
                    modalContent.style.left = `${rect.left}px`;
                    modalContent.style.top = `${rect.top}px`;
                    modalContent.style.margin = '0';
                }

                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                modalContent.style.top = (modalContent.offsetTop - pos2) + "px";
                modalContent.style.left = (modalContent.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        makeResizable(fullscreenModalContent);
        makeResizable(dataDetailModal.querySelector('.modal-content'));
        if (zoomModalContent) {
            makeResizable(zoomModalContent);
        }

        const dataDetailModalContent = dataDetailModal.querySelector('.modal-content');
        makeDraggable(dataDetailModalContent, dataDetailModalContent.querySelector('.resizable-modal-header'));
        makeDraggable(fullscreenModalContent, fullscreenModalContent.querySelector('.resizable-modal-header'));
        if (zoomModalContent) {
            makeDraggable(zoomModalContent, zoomModalContent.querySelector('.resizable-modal-header'));
        }

        // Make milestone modal resizable & draggable
        const milestoneModalContent = milestoneModal.querySelector('.modal-content');
        if (milestoneModalContent) {
            makeResizable(milestoneModalContent);
            const milestoneHeader = milestoneModalContent.querySelector('.resizable-modal-header');
            if (milestoneHeader) makeDraggable(milestoneModalContent, milestoneHeader);
        }

        function downloadTemplate(format) {
            const templateData = [
                {
                    'No': '1', 'ID': 'A-001', '작업 유형': '공통', '고객사': '고객사 A', '명칭': '프로젝트 예시 1', '발주 유형': '일반', '상태': '착공전', '시작일': '2025-01-01', '종료일': '2025-01-31', '정산': '50000000', '진행률': '0'
                },
                {
                    'No': '2', 'ID': 'B-002', '작업 유형': '건축', '고객사': '고객사 B', '명칭': '프로젝트 예시 2', '발주 유형': '긴급', '상태': '공사중', '시작일': '2025-02-15', '종료일': '2025-03-20', '정산': '120000000', '진행률': '50'
                }
            ];
            const wsData = [
                ["[데이터 양식 설명]"],
                ["No", "ID", "작업 유형", "고객사", "명칭", "발주 유형", "상태", "시작일", "종료일", "정산", "진행률"],
                ["(숫자)", "(문자, 고유값)", "(문자)", "(문자, 필수)", "(문자, 필수)", "(일반/긴급)", "(착공전/공사중/완료/지연)", "(YYYY-MM-DD, 필수)", "(YYYY-MM-DD, 필수)", "(숫자, 콤마 제외)", "(0-100)"],
                ["", "", "", "", "", "", "※ 상태 자동 계산:", "", "", "", ""],
                ["", "", "", "", "", "", "- 착공전: 진행률 0% 이고 종료일이 오늘 이후", "", "", "", ""],
                ["", "", "", "", "", "", "- 공사중: 진행률 1~99% 이고 종료일이 오늘 이후", "", "", "", ""],
                ["", "", "", "", "", "", "- 완료: 진행률 100%", "", "", "", ""],
                ["", "", "", "", "", "", "- 지연: 진행률 100% 미만이고 종료일이 오늘 이전", "", "", "", ""],
                ["", "", "", "", "💡 저장 시:", "", "", "", "", "", ""],
                ["", "", "", "", "- 모든 데이터와 설정이 저장됨", "", "", "", "", "", ""],
                ["", "", "", "", "- 나중에 이어서 작업 가능", "", "", "", "", "", ""],
            ];
            wsData[1].push('진행률');
            wsData[2].push('(숫자 또는 %)');
            const sheet = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.sheet_add_json(sheet, templateData, { origin: "A4", skipHeader: true });

            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, sheet, "Project Data");

            // Add milestone sample sheet for XLSX
            const milestoneSample = [
                ['No', '마일스톤', '날짜'],
                [1, '프로젝트 킥오프', '2025-01-15']
            ];
            const msSheet = XLSX.utils.aoa_to_sheet(milestoneSample);

            if (format === 'xlsx') {
                XLSX.utils.book_append_sheet(workbook, msSheet, '마일스톤');
                const fileName = `gantt_template.${format}`;
                XLSX.writeFile(workbook, fileName);
                showToast(`"${fileName}" 양식 파일 다운로드를 시작합니다.`, 'info');
            } else if (format === 'csv') {
                // For CSV, generate two separate CSV files: projects template and milestone template
                const projectsCsv = XLSX.utils.sheet_to_csv(sheet);
                const milestoneCsv = XLSX.utils.sheet_to_csv(msSheet);

                // helper to download plain text as file
                const downloadText = (content, name) => {
                    // Prepend UTF-8 BOM to help Excel on Windows recognize UTF-8 encoding
                    const bomPrefixed = '\uFEFF' + content;
                    const blob = new Blob([bomPrefixed], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };

                const dateSuffix = new Date().toISOString().slice(0,10);
                downloadText(projectsCsv, `gantt_template_projects_${dateSuffix}.csv`);
                // small delay to ensure browser processing of consecutive downloads
                setTimeout(() => {
                    downloadText(milestoneCsv, `gantt_template_milestones_${dateSuffix}.csv`);
                }, 150);
                showToast('CSV 양식 파일(프로젝트, 마일스톤) 다운로드를 시작합니다.', 'info');
            } else {
                const fileName = `gantt_template.${format}`;
                XLSX.writeFile(workbook, fileName);
                showToast(`"${fileName}" 양식 파일 다운로드를 시작합니다.`, 'info');
            }
        }

        /**
         * [IMPROVED FUNCTION] 현재 대시보드 상태를 새로운 독립 실행형 HTML 파일로 저장합니다.
         * 이 함수는 모든 저장 관련 문제를 해결하기 위한 핵심 수정 사항입니다.
         * @returns {void}
         */
        function saveAsStandaloneHTML() {
            // [개선 사항 1] 저장 전 데이터 무결성 검증
            if (projectData.length === 0 && milestones.length === 0) {
                showToast("저장할 데이터가 없습니다.", 'warning');
                return;
            }

            // [개선 사항 2] 필수 데이터 필드 검증
            const invalidProjects = projectData.filter(p => {
                return !p.name || !p.startDate || !p.endDate || 
                       typeof p.progress === 'undefined' || p.progress === null ||
                       !p.id || !p.taskType;
            });

            if (invalidProjects.length > 0) {
                const message = `데이터 정합성 문제 발견: ${invalidProjects.length}개 항목에 필수 필드가 누락되었습니다.`;
                showToast(message, 'error');
                console.error('Invalid projects:', invalidProjects);
                return;
            }

            // [개선 사항 3] 날짜 데이터 검증
            const dateErrors = projectData.filter(p => {
                const start = p.startDate instanceof Date ? p.startDate : new Date(p.startDate);
                const end = p.endDate instanceof Date ? p.endDate : new Date(p.endDate);
                return isNaN(start.getTime()) || isNaN(end.getTime()) || start > end;
            });

            if (dateErrors.length > 0) {
                const message = `날짜 데이터 오류: ${dateErrors.length}개 항목에 잘못된 날짜가 있습니다.`;
                showToast(message, 'error');
                console.error('Date errors:', dateErrors);
                return;
            }

            // [FIX] DOM 조작 전에 데이터를 직렬화하여 깨끗한 상태를 보장합니다.
            // 날짜는 안정적인 직렬화를 위해 ISO 문자열로 변환됩니다.
            const toYMD = (d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            const dataToEmbed = projectData.map(p => {
                // [FIX] 날짜가 유효한지 확인 후 변환합니다. 반드시 로컬 기준 YYYY-MM-DD 형식으로 저장합니다.
                const startDateStr = (p.startDate instanceof Date && !isNaN(p.startDate)) ? toYMD(p.startDate) : (p.startDateStr || '');
                const endDateStr = (p.endDate instanceof Date && !isNaN(p.endDate)) ? toYMD(p.endDate) : (p.endDateStr || '');
                return {
                    ...p,
                    startDate: startDateStr,
                    endDate: endDateStr,
                };
            });

            const customFiltersState = {};
            document.querySelectorAll('#controlsPanel #customFilterContainer select').forEach(sel => {
                // 'customer-filter'의 경우 항상 '고객사'로 저장 (초기값 유지)
                if (sel.id === 'customer-filter' && sel.querySelector('option[value="고객사"]')) {
                    customFiltersState[sel.dataset.filterKey] = '고객사';
                } else {
                    customFiltersState[sel.dataset.filterKey] = sel.value;
                }
            });
            
            // 바로가기 설정 저장
            const pinnedShortcutsArray = Array.from(pinnedShortcuts);

            const currentTitlesPane = document.querySelector('.gantt-titles');
            const settlementOpenFields = Array.from(document.querySelectorAll('.main-settlement-accordion-item')).map(el => {
                const hdr = el.querySelector('.main-settlement-header h3');
                // Remove the visual bullet prefix '■ ' if present to get the field name
                const text = hdr ? hdr.textContent.replace(/^■\s*/, '').trim() : null;
                // [수정됨] expanded 클래스가 있으면 펼쳐진 상태임.
                // 저장 시점의 DOM 상태를 그대로 저장해야 하므로,
                // .expanded 클래스가 있는 항목의 텍스트를 저장함.
                return el.classList.contains('expanded') && text ? text : null;
            }).filter(Boolean);

            // [추가됨] 총괄 아코디언 상태 저장 (overviewOpenFields)
            const overviewOpenFields = Array.from(document.querySelectorAll('.overview-accordion-item')).map(el => {
                 const hdr = el.querySelector('.overview-accordion-header h3');
                 const text = hdr ? hdr.textContent.replace(/^■\s*/, '').trim() : null;
                 return el.classList.contains('expanded') && text ? text : null;
            }).filter(Boolean);

            // [개선 사항 2] 저장 시 모든 UI 상태와 설정을 포함하도록 개선
            const settings = { 
                openTaskGroups: Array.from(openTaskGroups),
                columnVisibility: columnVisibility,
                filters: {
                    progress: progressFilter ? progressFilter.value : 'all',
                    taskType: taskTypeFilter ? taskTypeFilter.value : 'all',
                    sort: sortBy ? sortBy.value : 'default',
                    sortDirection: sortState.direction || SORT_DIRECTIONS.DESC,
                    showOnlyChanged: showOnlyChanged,
                    search: searchInput ? searchInput.value : '',
                    customFilters: customFiltersState,
                },
                legendStatusFilter: legendStatusFilter,
                titlesPaneWidth: currentTitlesPane ? currentTitlesPane.style.width : null,
                columnWidths: currentTitlesPane ? {
                    po: getComputedStyle(currentTitlesPane).getPropertyValue('--po-col-width'),
                    dates: getComputedStyle(currentTitlesPane).getPropertyValue('--dates-col-width'),
                    progress: getComputedStyle(currentTitlesPane).getPropertyValue('--progress-col-width'),
                    progressSummary: getComputedStyle(currentTitlesPane).getPropertyValue('--progress-summary-col-width')
                } : null,
                viewMinDate: viewMinDate ? toYMD(viewMinDate) : null,
                viewMaxDate: viewMaxDate ? toYMD(viewMaxDate) : null,
                pinnedShortcuts: Array.from(pinnedShortcuts),
                controlsPanelOpen: !controlsPanel.classList.contains('translate-x-full'),
                controlSections: Array.from(document.querySelectorAll('#controlsPanel .control-section-header')).map(header => ({
                    id: header.id || header.querySelector('h3').textContent.trim(),
                    isOpen: header.classList.contains('open')
                })),
                timelineScrollLeft: document.querySelector('.gantt-timeline-body-wrapper')?.scrollLeft || 0,
                timelineScrollTop: document.querySelector('.gantt-timeline-body-wrapper')?.scrollTop || 0
                , // 정산 아코디언 상태 저장
                hierarchyOrder: hierarchyOrder, // 개선 사항: 계층 순서 저장
                // **개선 사항 2**: 현재 열려있는 툴팁 정보 저장
                activeTooltip: (() => {
                    if (!floatingTooltip || !floatingTooltip.classList.contains('visible') || !activeTooltipBar) return null;
                    return {
                        projectId: activeTooltipBar.closest('.gantt-bar-row')?.dataset.projectId || null,
                        content: floatingTooltip.innerHTML
                    };
                })(),

                settlementOpenFields: settlementOpenFields,
                // [추가됨] 총괄 아코디언 상태 저장
                overviewOpenFields: overviewOpenFields,
                autoUploadUrl: (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL,
                autoUploadEnabled: !!(autoUploadEnabled && autoUploadEnabled.checked),
                // [개선 사항 3] 커스텀 필드 표시 이름 저장 (재귀 저장 시 라벨 유실 방지)
                customFieldDisplayNames: customFieldDisplayNames,
                analysisHeaderPreferences: Array.from(analysisHeaderPreferences),
                analysisHeaderPreferenceLabels: analysisHeaderPreferenceLabels
            };

            // Milestone modal state (position/size and open state)
            try {
                const mmOverlay = document.getElementById('milestoneModal');
                const mmContent = mmOverlay ? mmOverlay.querySelector('.modal-content') : null;
                settings.milestoneModalOpen = mmOverlay ? !mmOverlay.classList.contains('hidden') : false;
                if (mmContent) {
                    // Capture inline style values if present (left/top/width/height)
                    settings.milestoneModalStyle = {
                        left: mmContent.style.left || null,
                        top: mmContent.style.top || null,
                        width: mmContent.style.width || null,
                        height: mmContent.style.height || null,
                        overlayJustify: mmOverlay ? mmOverlay.style.justifyContent || null : null,
                        overlayAlign: mmOverlay ? mmOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.milestoneModalStyle = null;
                }
            } catch (e) {
                console.warn('milestone modal state capture failed', e);
            }

            // Data Detail modal state
            try {
                const ddOverlay = document.getElementById('dataDetailModal');
                const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                settings.dataDetailModalOpen = ddOverlay ? !ddOverlay.classList.contains('hidden') : false;
                if (ddContent) {
                    settings.dataDetailModalStyle = {
                        left: ddContent.style.left || null,
                        top: ddContent.style.top || null,
                        width: ddContent.style.width || null,
                        height: ddContent.style.height || null,
                        overlayJustify: ddOverlay ? ddOverlay.style.justifyContent || null : null,
                        overlayAlign: ddOverlay ? ddOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.dataDetailModalStyle = null;
                }
            } catch (e) {
                console.warn('data detail modal state capture failed', e);
            }

            // Data Detail modal state
            try {
                const ddOverlay = document.getElementById('dataDetailModal');
                const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                settings.dataDetailModalOpen = ddOverlay ? !ddOverlay.classList.contains('hidden') : false;
                if (ddContent) {
                    settings.dataDetailModalStyle = {
                        left: ddContent.style.left || null,
                        top: ddContent.style.top || null,
                        width: ddContent.style.width || null,
                        height: ddContent.style.height || null,
                        overlayJustify: ddOverlay ? ddOverlay.style.justifyContent || null : null,
                        overlayAlign: ddOverlay ? ddOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.dataDetailModalStyle = null;
                }
            } catch (e) {
                console.warn('data detail modal state capture failed', e);
            }

            // 강력한 메서드를 사용하여 최종 HTML 문자열을 생성합니다.
            const htmlContent = generateStandaloneHTML(dataToEmbed, milestones, settings);

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gantt_dashboard_${new Date().toISOString().slice(0,10)}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast("HTML 파일이 성공적으로 저장되었습니다.", 'success');
        }

        /**
         * [NEW & IMPROVED] 저장을 위한 최종 HTML 콘텐츠 문자열을 생성합니다.
         * 이 함수는 다중 저장 문제 해결의 핵심입니다. 
         * 재귀적 저장(저장된 파일을 열어서 다시 저장) 시에도 데이터 스크립트와 플레이스홀더를 
         * 올바르게 유지하여 파일이 손상되지 않도록 합니다.
         */
        function generateStandaloneHTML(data, milestonesToEmbed, settings) {
            let html = document.documentElement.outerHTML;

            // JSON 데이터를 안전하게 스크립트에 주입하기 위한 헬퍼
            // script 태그가 문자열 내에 포함될 경우를 대비해 이스케이프 처리 (HTML 파서 혼동 방지)
            const safeJson = (obj) => JSON.stringify(obj, null, 2).replace(/<\x2Fscript>/g, '<\\/script>');

            // 헬퍼 함수: 스크립트와 플레이스홀더를 스마트하게 교체
            const replaceOrInsert = (htmlStr, varName, placeholder, dataObj, extraScript = '') => {
                // HTML 파서가 종료 태그로 오인하지 않도록 \x3C(<) 사용
                const scriptContent = `<script>window.${varName} = ${safeJson(dataObj)};\x3C/script>`;
                const fullContent = `${scriptContent}\n    ${extraScript}${extraScript ? '\n    ' : ''}<!-- ${placeholder} -->`;
                
                // Case 1: [기존 스크립트 + 플레이스홀더]가 모두 있는 경우 (이상적인 상태)
                // HTML 파서 회피를 위해 정규식 생성 시에도 태그 분리
                const placeholderRegex = new RegExp(`(<script>window\\.${varName}[\\s\\S]*?\\x3C\\/script>\\s*)?<!-- ${placeholder} -->`, 'i');
                
                if (placeholderRegex.test(htmlStr)) {
                    return htmlStr.replace(placeholderRegex, fullContent);
                }
                
                // Case 2: 플레이스홀더는 없고 [기존 스크립트]만 있는 경우 (이전 저장에서 플레이스홀더 유실됨)
                const scriptRegex = new RegExp(`<script>window\\.${varName}[\\s\\S]*?\\x3C\\/script>`, 'i');
                if (scriptRegex.test(htmlStr)) {
                    return htmlStr.replace(scriptRegex, fullContent);
                }

                // Case 3: 둘 다 없는 경우
                console.warn(`Injection point for ${varName} not found.`);
                return htmlStr;
            };

            // 1. 데이터 주입
            html = replaceOrInsert(html, 'embeddedData', 'EMBEDDED_DATA_PLACEHOLDER', data);

            // 2. 마일스톤 주입
            html = replaceOrInsert(html, 'embeddedMilestones', 'EMBEDDED_MILESTONES_PLACEHOLDER', milestonesToEmbed);

            // 3. 설정 주입 (isStandalone 마커 포함)
            html = replaceOrInsert(html, 'embeddedSettings', 'EMBEDDED_SETTINGS_PLACEHOLDER', settings, '<script>window.isStandalone = true;\x3C/script>');

            // 4. Doctype 확인
            if (!html.trim().toLowerCase().startsWith('<!doctype html>')) {
                return `<!DOCTYPE html>\n` + html;
            }
            return html;
        }

        function renderMilestoneModal() {
            milestoneList.innerHTML = '';
            
            // 저장된 모달 상태 복원
            const modalContent = milestoneModal.querySelector('.modal-content');
            if (modalContent) {
                if (savedSettings && savedSettings.milestoneModalStyle) {
                    const s = savedSettings.milestoneModalStyle;
                    if (s.width) modalContent.style.width = s.width;
                    if (s.height) modalContent.style.height = s.height;
                    if (s.left) modalContent.style.left = s.left;
                    if (s.top) modalContent.style.top = s.top;
                    if (s.overlayJustify) milestoneModal.style.justifyContent = s.overlayJustify;
                    if (s.overlayAlign) milestoneModal.style.alignItems = s.overlayAlign;
                } else {
                    // 저장된 설정이 없을 때는 화면 중앙에 배치
                    milestoneModal.style.justifyContent = 'center';
                    milestoneModal.style.alignItems = 'center';
                    modalContent.style.position = 'relative';
                    modalContent.style.left = '0';
                    modalContent.style.top = '0';
                    modalContent.style.margin = 'auto';
                    modalContent.style.transform = 'none';
                }
            }

            if (milestones.length === 0) {
                milestoneList.innerHTML = `<p class="text-center text-gray-500">등록된 마일스톤이 없습니다.</p>`;
            } else {
                // [수정됨] 세로 스크롤바 자동 생성 및 스타일 조정
                milestoneList.style.overflowY = 'auto';
                milestoneList.style.maxHeight = '400px'; // 적절한 최대 높이 설정

                milestones.sort((a,b) => new Date(a.date) - new Date(b.date)).forEach((m, index) => {
                    const item = document.createElement('div');
                    // 개선 사항 2: 교차 색상 적용 (홀수/짝수) - [수정됨] 연한 회색 및 글자 굵기 변경
                    const isEven = index % 2 === 0;
                    item.className = 'milestone-nav-item flex items-center justify-between p-2 border-b hover:bg-gray-100 cursor-pointer';
                    
                    // 배경색: 짝수는 흰색(#ffffff), 홀수는 아주 연한 회색(#f8fafc) -> 더 연하게 조정 필요하면 #fafafa 등
                    // 요청사항: "교차 색상의 회색을 연한 회색으로 변경" -> 기존 #e2e8f0(slate-200)보다 연한 #f1f5f9(slate-100) 또는 #f8fafc(slate-50) 사용
                    // 여기서는 짝수: 흰색, 홀수: #f1f5f9 (slate-100) 정도로 설정하여 구분감은 주되 눈이 편하게 함
                    item.style.backgroundColor = isEven ? '#ffffff' : '#f1f5f9';
                    
                    item.dataset.date = m.date;
                    
                    // [수정됨] 글자 굵기 교차 적용 (가독성 확보)
                    const fontWeightClass = isEven ? 'font-medium' : 'font-bold'; // 또는 400/600 등
                    // 짝수: 보통(medium/500), 홀수: 굵게(bold/700) - 혹은 반대로. 
                    // 요청사항: "항목의 글자 굵기 교차 굵기"
                    
                    item.innerHTML = `
                        <div class="${fontWeightClass}">
                            <span>${m.name}</span>
                            <span class="text-sm text-gray-500 ml-2 font-normal">${m.date}</span>
                        </div>
                        <button data-index="${index}" class="delete-milestone-btn text-red-500 hover:text-red-700 font-normal">삭제</button>
                    `; // z-index 추가
                    milestoneList.appendChild(item);
                });
            }
        }

        function handleAddMilestone(e) {
            e.preventDefault();
            const dateInput = document.getElementById('milestoneDate');
            const nameInput = document.getElementById('milestoneName');

            if (dateInput.value && nameInput.value) {
                // 입력된 날짜를 파싱
                const inputDate = new Date(dateInput.value + 'T00:00:00');
                
                // YYYY-MM-DD 형식으로 변환
                const adjustedDate = 
                    inputDate.getFullYear() + '-' +
                    String(inputDate.getMonth() + 1).padStart(2, '0') + '-' +
                    String(inputDate.getDate()).padStart(2, '0');

                milestones.push({ date: adjustedDate, name: nameInput.value });
                updateAndApplyDateRange();
                renderMilestoneModal();
                render();
                showToast('마일스톤이 추가되었습니다.', 'success');
                
                // 개선사항: 폼 리셋 시에도 상태 보존을 위해 값 저장
                const savedDateValue = dateInput.value;
                const savedNameValue = nameInput.value;
                addMilestoneForm.reset();
                
                // 개선사항: 저장된 값으로 복원 (사용자 편의성)
                if (savedDateValue) dateInput.value = savedDateValue;
                if (savedNameValue) nameInput.value = savedNameValue;
                
                if(projectData.length > 0 || milestones.length > 0){
                    saveHtmlBtn.disabled = false;
                    saveMessage.classList.remove('hidden');
                }
            }
        }

        // 개선 사항 1: 마일스톤 삭제 핸들러
        function handleMilestoneDelete(e) {
            e.stopPropagation(); // 이벤트 버블링 방지
            const deleteBtn = e.target.closest('.delete-milestone-btn');
            const index = parseInt(deleteBtn.dataset.index, 10);
            milestones.splice(index, 1);
            updateAndApplyDateRange();
            renderMilestoneModal();
            render();
            showToast('마일스톤이 삭제되었습니다.', 'info');
            if(projectData.length === 0 && milestones.length === 0){
                saveHtmlBtn.disabled = true;
                saveMessage.classList.add('hidden');
            }
        }

        // 개선 사항 1: 마일스톤 이동 핸들러
        function handleMilestoneNavigate(e) {
            const item = e.target.closest('.milestone-nav-item');
            const dateStr = item.dataset.date;
            if (!dateStr || !viewMinDate) return;

            const targetDate = parseLocalDateString(dateStr);
            if (!targetDate || isNaN(targetDate)) return;

            const offsetDays = dateDiffInDays(viewMinDate, targetDate);
            const scrollPosition = (offsetDays * DAY_WIDTH) - (DAY_WIDTH * 5); // 약간의 여백을 둠

            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            const timelineContainer = container.querySelector('.gantt-timeline-body-wrapper');

            if (timelineContainer) {
                timelineContainer.scrollTo({ left: scrollPosition, behavior: 'smooth' });
            }

        }

        function initDefaultPinnedShortcuts() {
            // 기본 바로가기 순서 설정 (개선 사항: '검색'을 바로가기에 추가)
            const defaultPinnedControls = [
                'showChangesBtn',        // 변경
                'expandAllBtn',          // 펼치기
                'collapseAllBtn',        // 접기
                'fullscreenBtn',         // 전체 화면
                'milestoneBtn',          // 마일스톤
                'toggleHierarchyOrderBtn', // 계층순서
                'customer-filter',       // 고객사
                'contractor-filter',     // 시공사
                'cost-account-filter',   // 비용계정
                'taskTypeFilter',        // 유형
                'sortBy',                // 정렬
                'progressFilter',        // 진척률
                'searchInput',           // 검색 (추가됨)
                'zoomBtn'                // 날짜 설정
            ];
            
            // 기존 핀 초기화
            pinnedShortcuts.clear();
            
            // 새로운 핀 설정
            defaultPinnedControls.forEach(id => {
                pinnedShortcuts.add(id);
            });
            
            // 계층순서 버튼을 항상 '오늘' 옆에 배치
            ensureShortcutOrderRules();

            // 바로가기 메뉴 업데이트
            if (typeof updateShortcuts === 'function') {
                updateShortcuts();
            }
        }

        function initializeDashboard() {
            // 로컬에 저장된 대시보드 설정(자동 업로드 등)이 있으면 불러와 초기값으로 병합
            try {
                if (!window.embeddedSettings) {
                    const local = loadDashboardSettings();
                    if (local) {
                        savedSettings = Object.assign({}, savedSettings || {}, local);
                    }
                }
            } catch (e) {
                console.warn('Failed to merge local dashboard settings', e);
            }
            // 초기화 시 임시 보관소(sessionStorage)에 저장된 업데이트 표시 데이터를 제거합니다.
            try {
                sessionStorage.removeItem('__gantt_updated_projects');
            } catch (e) {}
            try {
                document.querySelectorAll('.progress-updated').forEach(el => el.classList.remove('progress-updated'));
            } catch (e) {}

            if (window.isStandalone) {
                dataPanel.classList.add('hidden');

                const shouldBeOpen = window.embeddedSettings && window.embeddedSettings.controlsPanelOpen === true;
                if (!shouldBeOpen) {
                    controlsPanel.classList.add('translate-x-full');
                    controlsPanelOverlay.classList.add('hidden');
                    // network-status의 z-index를 원래대로 복원
                    const networkStatus = document.getElementById('network-status');
                    if (networkStatus) {
                        networkStatus.classList.remove('panel-open');
                    }
                } else {
                    // network-status의 z-index를 낮춰서 X 닫기 버튼이 클릭 가능하도록
                    const networkStatus = document.getElementById('network-status');
                    if (networkStatus) {
                        networkStatus.classList.add('panel-open');
                    }
                }
            }

            const controlsPanelEl = document.getElementById('controlsPanel');
            if (controlsPanelEl && !controlsPanelEl.hasAttribute('data-pin-listener-attached')) {
                controlsPanelEl.addEventListener('click', function(e) {
                    const pinBtn = e.target.closest('.pin-shortcut-btn');
                    if (!pinBtn) return;
                    
                    e.stopPropagation();
                    const controlId = pinBtn.dataset.controlId;
                    if (!controlId) return;

                    if (pinnedShortcuts.has(controlId)) {
                        pinnedShortcuts.delete(controlId);
                    } else {
                        pinnedShortcuts.add(controlId);
                    }

                    ensureShortcutOrderRules();
                    
                    updateShortcuts();
                    
                    showToast(pinnedShortcuts.has(controlId) ? 
                        '바로가기가 추가되었습니다.' : 
                        '바로가기가 제거되었습니다.', 
                        'info'
                    );
                });
                
                controlsPanelEl.setAttribute('data-pin-listener-attached', 'true');
            }

            updateControlReferences();


             const initialLegendSection = document.getElementById('legendSection');
             if (initialLegendSection) {
                 initialLegendSection.querySelectorAll('[data-status-filter]').forEach(item => {
                     item.addEventListener('click', handleLegendClickEvent);
                 });
             }


            if (window.embeddedData) {
                try {
                    // 개선 사항: 임베디드 데이터 로드 시 원본 날짜 레지스트리 초기화 (하드코딩 방지)
                    originalDateRegistry.clear();
                    
                    // [개선 사항 1] 데이터 파싱 시 엄격한 유효성 검사 적용
                    const parsedData = window.embeddedData.map(p => {
                        // 필수 필드 검증
                        if (!p.name || !p.id || !p.taskType) {
                            console.warn('Missing required fields:', p);
                            return null;
                        }

                        // 날짜 파싱 및 검증
                        const startDate = p.startDate ? parseLocalDateString(p.startDate) : null;
                        const endDate = p.endDate ? parseLocalDateString(p.endDate) : null;
                        
                        if (!startDate || !endDate || isNaN(startDate) || isNaN(endDate) || startDate > endDate) {
                            console.warn('Invalid dates:', p);
                            return null;
                        }

                        // 진행률 정규화
                        let progress = p.progress;
                        if (typeof progress === 'string') {
                            // 퍼센트 기호 제거 및 숫자로 변환
                            progress = parseInt(progress.replace('%', ''), 10);
                        }
                        if (isNaN(progress) || progress < 0 || progress > 100) {
                            console.warn('Invalid progress value, defaulting to 0:', p);
                            progress = 0;
                        }

                        // 정산액 정규화
                        let poAmount = p.poAmount;
                        if (typeof poAmount === 'string') {
                            // 콤마 제거 및 숫자로 변환
                            poAmount = parseInt(poAmount.replace(/,/g, ''), 10);
                        }
                        if (isNaN(poAmount)) {
                            console.warn('Invalid poAmount value, defaulting to 0:', p);
                            poAmount = 0;
                        }

                        // 개선 사항: 날짜 문자열을 올바르게 설정하여 원본 날짜 비교가 정확하게 작동하도록 함
                        const startDateStrFormatted = startDate ? formatDateYMD(startDate) : (p.startDate || '');
                        const endDateStrFormatted = endDate ? formatDateYMD(endDate) : (p.endDate || '');
                        
                        return {
                            ...p,
                            startDate,
                            endDate,
                            startDateStr: startDateStrFormatted,
                            endDateStr: endDateStrFormatted,
                            progress,
                            poAmount,
                            // 상태 자동 계산
                            status: calculateStatus(progress, endDate)
                        };
                    });

                    // 유효한 데이터만 필터링
                    projectData = parsedData.filter(p => p !== null);
                    normalizeAllProjectDates(projectData);
                    
                    // 캐시 무효화
                    invalidateFilteredDataCache();

                    // 개선 사항: 임베디드 데이터 로드 후 모든 프로젝트의 원본 날짜를 현재 날짜로 강제 재설정 (하드코딩 방지)
                    // 모든 프로젝트에 대해 원본 날짜를 현재 날짜로 설정
                    // 먼저 레지스트리를 완전히 초기화
                    originalDateRegistry.clear();
                    // 그 다음 모든 프로젝트의 원본 날짜를 현재 날짜로 설정
                    rebaselineOriginalDates(true, false);

                    // [개선 사항 2] 데이터 로드 결과 보고
                    const invalidCount = parsedData.length - projectData.length;
                    if (invalidCount > 0) {
                        showToast(`${invalidCount}개의 항목이 유효성 검사를 통과하지 못해 제외되었습니다.`, 'warning');
                    }
                } catch (error) {
                    console.error('Error parsing embedded data:', error);
                    showToast('데이터 로드 중 오류가 발생했습니다.', 'error');
                    projectData = [];
                    // 캐시 무효화
                    invalidateFilteredDataCache();
                }

                // Normalize custom field keys in loaded embedded data: sanitize keys and populate display name map
                projectData.forEach(p => {
                    if (p.customFields) {
                        const newCustom = {};
                        Object.keys(p.customFields).forEach(origKey => {
                            const safe = sanitizeKey(origKey);
                            if (safe) {
                                newCustom[safe] = p.customFields[origKey];
                                customFieldDisplayNames[safe] = customFieldDisplayNames[safe] || origKey;
                            }
                        });
                        p.customFields = newCustom;
                    }
                });
            }

            if (window.embeddedMilestones) {
                milestones = window.embeddedMilestones;
            }

            updateAndApplyDateRange();
            
            // 개선 사항: 데이터 로드 완료 후 모든 프로젝트의 원본 날짜를 현재 날짜로 강제 재설정 (하드코딩 방지)
            // 페이지 로드 시 한 번만 실행하여 모든 프로젝트의 원본 날짜를 현재 날짜로 설정
            if (projectData && projectData.length > 0) {
                // 먼저 레지스트리를 완전히 초기화
                originalDateRegistry.clear();
                // 그 다음 모든 프로젝트의 원본 날짜를 현재 날짜로 설정
                rebaselineOriginalDates(true, false);
            }

            if (window.embeddedSettings) {
                savedSettings = window.embeddedSettings;
                openTaskGroups = new Set(savedSettings.openTaskGroups || []);
                columnVisibility = savedSettings.columnVisibility || columnVisibility;
                pinnedShortcuts = new Set(savedSettings.pinnedShortcuts || []);
                if (Array.isArray(savedSettings.analysisHeaderPreferences)) {
                    analysisHeaderPreferences = new Set(savedSettings.analysisHeaderPreferences.filter(Boolean));
                }
                if (savedSettings.analysisHeaderPreferenceLabels) {
                    analysisHeaderPreferenceLabels = { ...savedSettings.analysisHeaderPreferenceLabels };
                }
                persistAnalysisHeaderPrefs();
                
                // [개선 사항 3] 저장된 커스텀 필드 표시 이름 복원 (재귀 저장 시 라벨 복구)
                if (savedSettings.customFieldDisplayNames) {
                    customFieldDisplayNames = { ...savedSettings.customFieldDisplayNames };
                }

                ensureShortcutOrderRules();
                // Ensure pinnable controls and header shortcuts are rendered and synchronized
                // even if the controls panel is closed when loading the standalone file.
                try {
                    // This will add pin buttons to control wrappers and render shortcut items
                    if (typeof setupPinnableControls === 'function') setupPinnableControls();
                    if (typeof updateShortcuts === 'function') updateShortcuts();
                    // Sync values from original controls into shortcut clones if needed
                    if (typeof syncShortcutsFromOriginal === 'function') syncShortcutsFromOriginal();
                } catch (e) {
                    console.warn('Shortcut initialization failed during restore:', e);
                }
                
                if(savedSettings.filters) {
                    if(progressFilter) progressFilter.value = savedSettings.filters.progress;
                    if(taskTypeFilter) taskTypeFilter.value = savedSettings.filters.taskType;
                    if(sortBy) sortBy.value = savedSettings.filters.sort;
                    if (typeof savedSettings.filters.sortDirection !== 'undefined') {
                        sortState.direction = savedSettings.filters.sortDirection === SORT_DIRECTIONS.ASC ? SORT_DIRECTIONS.ASC : SORT_DIRECTIONS.DESC;
                    } else {
                        sortState.direction = SORT_DIRECTIONS.DESC;
                    }
                    sortState.mode = sortBy ? sortBy.value : 'default';
                    updateSortDirectionIndicators();
                    if (typeof savedSettings.filters.showOnlyChanged === 'boolean') {
                        showOnlyChanged = savedSettings.filters.showOnlyChanged;
                    } else {
                        showOnlyChanged = false;
                    }
                    updateShowChangesButtonState();
                    if(searchInput && savedSettings.filters.search) {
                        searchInput.value = savedSettings.filters.search;
                    }
                    if (savedSettings.filters.customFilters) {
                        // populateFilters 이후에 적용될 것입니다.
                    }
                }

                // Restore legend status filter selection
                if (typeof savedSettings.legendStatusFilter !== 'undefined') {
                    legendStatusFilter = savedSettings.legendStatusFilter || null;
                    const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                    if (legendContainer) {
                        legendContainer.querySelectorAll('.legend-section [data-status-filter].legend-filter-active').forEach(el => el.classList.remove('legend-filter-active'));
                        if (legendStatusFilter) {
                            const toActivate = legendContainer.querySelector(`.legend-section [data-status-filter="${legendStatusFilter}"]`);
                            if (toActivate) toActivate.classList.add('legend-filter-active');
                        }
                    }
                }

                if (savedSettings.viewMinDate && savedSettings.viewMaxDate) {
                    const parseLocalDateStringForSettings = (s) => {
                        try {
                            const parts = String(s).split('-');
                            if (parts.length >= 3) return new Date(parseInt(parts[0],10), parseInt(parts[1],10)-1, parseInt(parts[2],10));
                        } catch (e) {}
                        return new Date(s);
                    };
                    viewMinDate = parseLocalDateStringForSettings(savedSettings.viewMinDate);
                    viewMaxDate = parseLocalDateStringForSettings(savedSettings.viewMaxDate);
                }

                // 개선 사항: 계층 순서 복원
                if (savedSettings.hierarchyOrder) {
                    hierarchyOrder = savedSettings.hierarchyOrder;
                    // 버튼 텍스트 및 스타일 업데이트 (현재 상태를 시각적으로 명확히 표시)
                    // 개선 사항: 현재 상태에 맞게 메뉴 이름 자동 변경
                    if (toggleHierarchyOrderBtn) {
                        const isBottomMode = hierarchyOrder === 'bottom';
                        toggleHierarchyOrderBtn.textContent = isBottomMode ? '계층순서 (하→상)' : '계층순서 (상→하)';
                        
                        // 현재 상태를 시각적으로 표시하기 위한 스타일 적용
                        if (isBottomMode) {
                            toggleHierarchyOrderBtn.style.backgroundColor = '#dbeafe'; // 하늘색 배경
                            toggleHierarchyOrderBtn.style.border = '2px solid #3b82f6'; // 파란색 테두리
                            toggleHierarchyOrderBtn.style.fontWeight = 'bold';
                            toggleHierarchyOrderBtn.style.color = '#1e40af';
                        } else {
                            toggleHierarchyOrderBtn.style.backgroundColor = '#fef3c7'; // 노란색 배경
                            toggleHierarchyOrderBtn.style.border = '2px solid #f59e0b'; // 주황색 테두리
                            toggleHierarchyOrderBtn.style.fontWeight = 'bold';
                            toggleHierarchyOrderBtn.style.color = '#92400e';
                        }
                    }
                    
                    // 바로가기 메뉴의 활성화 상태 업데이트 (깜빡임 및 테두리 표시)
                    if (typeof updateShortcutActiveStates === 'function') {
                        updateShortcutActiveStates();
                    }
                }

                // 컨트롤 패널 상태 복원
                const shouldBeOpen = savedSettings.controlsPanelOpen === true;
                const networkStatus = document.getElementById('network-status');
                if (shouldBeOpen) {
                    controlsPanel.classList.remove('translate-x-full');
                    controlsPanelOverlay.classList.remove('hidden');
                    // network-status의 z-index를 낮춰서 X 닫기 버튼이 클릭 가능하도록
                    if (networkStatus) {
                        networkStatus.classList.add('panel-open');
                    }
                } else {
                    controlsPanel.classList.add('translate-x-full');
                    controlsPanelOverlay.classList.add('hidden');
                    // network-status의 z-index를 원래대로 복원
                    if (networkStatus) {
                        networkStatus.classList.remove('panel-open');
                    }
                }
                
                // 컨트롤 섹션 상태 복원
                if (savedSettings.controlSections) {
                    savedSettings.controlSections.forEach(section => {
                        const header = document.querySelector(`#controlsPanel .control-section-header[id="${section.id}"]`) || 
                                     Array.from(document.querySelectorAll('#controlsPanel .control-section-header'))
                                          .find(h => h.querySelector('h3').textContent.trim() === section.id);
                        if (header) {
                            if (section.isOpen) {
                                header.classList.add('open');
                                const content = header.nextElementSibling;
                                if (content && content.classList.contains('control-section-content')) {
                                    content.style.maxHeight = '1000px';
                                    content.style.paddingTop = '0.5rem';
                                    content.style.paddingBottom = '0.5rem';
                                }
                            } else {
                                header.classList.remove('open');
                                const content = header.nextElementSibling;
                                if (content && content.classList.contains('control-section-content')) {
                                    content.style.maxHeight = '0';
                                    content.style.paddingTop = '0';
                                    content.style.paddingBottom = '0';
                                }
                            }
                        }
                    });
                }

                setTimeout(() => {
                    const timelineWrapper = document.querySelector('.gantt-timeline-body-wrapper');
                    if (timelineWrapper) {
                        timelineWrapper.scrollLeft = savedSettings.timelineScrollLeft || 0;
                        timelineWrapper.scrollTop = savedSettings.timelineScrollTop || 0;
                    }

                }, 100);

                // Restore milestone modal position/size and open state if present
                try {
                    const mmOverlay = document.getElementById('milestoneModal');
                    const mmContent = mmOverlay ? mmOverlay.querySelector('.modal-content') : null;
                    if (savedSettings.milestoneModalStyle && mmContent) {
                        const s = savedSettings.milestoneModalStyle;
                        if (s.width) mmContent.style.width = s.width;
                        if (s.height) mmContent.style.height = s.height;
                        if (s.left) mmContent.style.left = s.left;
                        if (s.top) mmContent.style.top = s.top;
                        if (s.overlayJustify && mmOverlay) mmOverlay.style.justifyContent = s.overlayJustify;
                        if (s.overlayAlign && mmOverlay) mmOverlay.style.alignItems = s.overlayAlign;
                    }
                    if (typeof savedSettings.milestoneModalOpen !== 'undefined' && mmOverlay) {
                        if (savedSettings.milestoneModalOpen) mmOverlay.classList.remove('hidden');
                        else mmOverlay.classList.add('hidden');
                    }
                } catch (e) {
                    console.warn('milestone modal restore failed', e);
                }

                // Restore data detail modal position/size and open state if present
                try {
                    const ddOverlay = document.getElementById('dataDetailModal');
                    const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                    if (savedSettings.dataDetailModalStyle && ddContent) {
                        const s = savedSettings.dataDetailModalStyle;
                        if (s.width) ddContent.style.width = s.width;
                        if (s.height) ddContent.style.height = s.height;
                        if (s.left) ddContent.style.left = s.left;
                        if (s.top) ddContent.style.top = s.top;
                        if (s.overlayJustify && ddOverlay) ddOverlay.style.justifyContent = s.overlayJustify;
                        if (s.overlayAlign && ddOverlay) ddOverlay.style.alignItems = s.overlayAlign;
                    }
                    if (typeof savedSettings.dataDetailModalOpen !== 'undefined' && ddOverlay) {
                        if (savedSettings.dataDetailModalOpen) ddOverlay.classList.remove('hidden');
                        else ddOverlay.classList.add('hidden');
                    }
                } catch (e) {
                    console.warn('data detail modal restore failed', e);
                }
            }

            // 복원: 자동 업로드 URL 및 활성화 상태
            try {
                if (savedSettings && savedSettings.autoUploadUrl) {
                    if (autoUploadUrlInput) autoUploadUrlInput.value = savedSettings.autoUploadUrl;
                } else {
                    if (autoUploadUrlInput) autoUploadUrlInput.value = DEFAULT_AUTO_UPLOAD_URL;
                }

                // 기본값: 페이지 로드 시 자동 불러오기 ON
                if (savedSettings && typeof savedSettings.autoUploadEnabled !== 'undefined') {
                    if (autoUploadEnabled) autoUploadEnabled.checked = !!savedSettings.autoUploadEnabled;
                } else {
                    if (autoUploadEnabled) autoUploadEnabled.checked = true; // 초기 기본값을 켬
                }
            } catch (e) {
                console.warn('auto upload restore error', e);
            }

            // 페이지 초기 로드 시 자동 업로드 시도 (온라인이면)
            setTimeout(() => {
                try {
                    // [FIX] 독립 실행형 파일이 아닐 때만 자동 업로드를 시도합니다.
                    if (window.isStandalone) return;
                    
                    // [개선] GitHub에서 배포된 코드를 웹에서 열면 자동으로 모든 데이터가 자동 업로딩되도록 개선
                    // GitHub 환경 감지 (github.io 또는 github.com에서 열릴 때)
                    const isGitHubEnvironment = window.location.hostname.includes('github.io') || window.location.hostname.includes('github.com');
                    
                    // GitHub 환경이거나 자동 업로드가 활성화된 경우 자동 업로드 실행
                    const shouldAutoUpload = isGitHubEnvironment || (autoUploadEnabled && autoUploadEnabled.checked);
                    
                    if (shouldAutoUpload) {
                        // GitHub 환경에서는 CSV를 먼저 시도하고, 실패하면 엑셀을 시도
                        if (isGitHubEnvironment) {
                            // CSV URL 설정 (기본값 또는 사용자 입력값)
                            const projectUrl = (csvProjectUrlInput && csvProjectUrlInput.value) ? csvProjectUrlInput.value.trim() : DEFAULT_CSV_PROJECT_URL;
                            const milestoneUrl = (csvMilestoneUrlInput && csvMilestoneUrlInput.value) ? csvMilestoneUrlInput.value.trim() : DEFAULT_CSV_MILESTONE_URL;
                            
                            // CSV 파일 먼저 시도
                            fetchAndImportCsvUrls(projectUrl, milestoneUrl).catch(csvErr => {
                                console.warn('CSV auto upload failed, trying Excel:', csvErr);
                                // CSV 실패 시 엑셀 파일 시도
                                const excelUrl = (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL;
                                if (excelUrl) {
                                    fetchAndImportFromUrl(excelUrl).catch(excelErr => {
                                        console.warn('Excel auto upload also failed', excelErr);
                                        showToast('CSV 및 Excel 자동 업로딩에 실패했습니다. (오프라인 또는 파일 없음)', 'warning');
                                    });
                                } else {
                                    showToast('CSV 자동 업로딩에 실패했습니다. (오프라인 또는 파일 없음)', 'warning');
                                }
                            });
                        } else {
                            // 일반 환경에서는 사용자 설정에 따라 처리
                            const uploadType = (autoUploadTypeCsv && autoUploadTypeCsv.checked) ? 'csv' : 'excel';
                            if (uploadType === 'csv') {
                                const projectUrl = (csvProjectUrlInput && csvProjectUrlInput.value) ? csvProjectUrlInput.value.trim() : '';
                                const milestoneUrl = (csvMilestoneUrlInput && csvMilestoneUrlInput.value) ? csvMilestoneUrlInput.value.trim() : '';
                                if (projectUrl || milestoneUrl) {
                                    fetchAndImportCsvUrls(projectUrl, milestoneUrl).catch(err => {
                                        console.warn('CSV auto upload failed', err);
                                        showToast('CSV 자동 업로딩에 실패했습니다. (오프라인 또는 파일 없음)', 'warning');
                                    });
                                }
                            } else {
                                const url = (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL;
                                if (url) {
                                    fetchAndImportFromUrl(url).catch(err => {
                                        console.warn('auto upload failed', err);
                                        showToast('자동 업로딩에 실패했습니다. (오프라인 또는 파일 없음)', 'warning');
                                    });
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn('auto upload init error', e);
                }
            }, 600);

            // 복원: CSV URL 설정
            try {
                if (savedSettings && savedSettings.csvProjectUrl) {
                    if (csvProjectUrlInput) csvProjectUrlInput.value = savedSettings.csvProjectUrl;
                } else if (csvProjectUrlInput) {
                    csvProjectUrlInput.value = DEFAULT_CSV_PROJECT_URL;
                }
                if (savedSettings && savedSettings.csvMilestoneUrl) {
                    if (csvMilestoneUrlInput) csvMilestoneUrlInput.value = savedSettings.csvMilestoneUrl;
                } else if (csvMilestoneUrlInput) {
                    csvMilestoneUrlInput.value = DEFAULT_CSV_MILESTONE_URL;
                }
                if (savedSettings && savedSettings.autoUploadType === 'csv') {
                    if (autoUploadTypeCsv) autoUploadTypeCsv.checked = true;
                    if (excelUrlSection) excelUrlSection.classList.add('hidden');
                    if (csvUrlSection) csvUrlSection.classList.remove('hidden');
                } else {
                    if (autoUploadTypeExcel) autoUploadTypeExcel.checked = true;
                    if (excelUrlSection) excelUrlSection.classList.remove('hidden');
                    if (csvUrlSection) csvUrlSection.classList.add('hidden');
                }
            } catch (e) {
                console.warn('CSV URL restore error', e);
            }

            // 버튼 리스너: 지금 불러오기
            if (autoUploadNowBtn) {
                autoUploadNowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const uploadType = (autoUploadTypeCsv && autoUploadTypeCsv.checked) ? 'csv' : 'excel';
                    if (uploadType === 'csv') {
                        const projectUrl = (csvProjectUrlInput && csvProjectUrlInput.value) ? csvProjectUrlInput.value.trim() : '';
                        const milestoneUrl = (csvMilestoneUrlInput && csvMilestoneUrlInput.value) ? csvMilestoneUrlInput.value.trim() : '';
                        if (!projectUrl && !milestoneUrl) {
                            showToast('CSV URL을 입력해주세요.', 'warning');
                            return;
                        }
                        fetchAndImportCsvUrls(projectUrl, milestoneUrl).catch(err => {
                            console.error('CSV upload failed', err);
                            showToast('CSV 업로딩에 실패했습니다.', 'error');
                        });
                    } else {
                        const url = (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL;
                        if (!url) {
                            showToast('자동 업로딩 URL을 입력하세요.', 'warning');
                            return;
                        }
                        fetchAndImportFromUrl(url).catch(err => {
                            console.warn('manual auto upload failed', err);
                            showToast('파일을 불러오지 못했습니다.', 'error');
                        });
                    }
                });
            }
            if (projectData.length > 0 || milestones.length > 0) {
                 saveHtmlBtn.disabled = false;
                 exportToExcelBtn.disabled = false;
                 exportToCsvBtn.disabled = false;
                 saveMessage.classList.remove('hidden');
            }

            function exportData(format = 'xlsx') {
                if (projectData.length === 0) {
                    showToast('내보낼 데이터가 없습니다.', 'warning');
                    return;
                }
                const workbook = XLSX.utils.book_new();

                // 기본 데이터 시트 준비
                const mainData = projectData.map((item, index) => {
                    // 의존성 정보를 읽기 쉬운 형식으로 변환
                    let dependencyStr = '';
                    if (item.dependsOn && Array.isArray(item.dependsOn) && item.dependsOn.length > 0) {
                        dependencyStr = item.dependsOn.map(dep => {
                            const depProject = projectData.find(p => String(p.id) === String(dep.projectId));
                            const depName = depProject ? depProject.name : dep.projectId;
                            const typeMap = {
                                'start-to-start': 'SS',
                                'end-to-start': 'FS',
                                'end-to-end': 'FF',
                                'start-to-end': 'SF'
                            };
                            const typeLabel = typeMap[dep.type] || dep.type;
                            return `${depName}(${typeLabel})`;
                        }).join('; ');
                    } else {
                        dependencyStr = '없음';
                    }
                    
                    return {
                        'No': index + 1,
                        'ID': item.id || '',
                        '작업 유형': item.taskType || '',
                        '명칭': item.name || '',
                        '상태': item.status || '',
                        '시작일': item.startDateStr || '',
                        '종료일': item.endDateStr || '',
                        '진행률': item.progress || 0,
                        '정산': item.poAmount || 0,
                        '의존성': dependencyStr,
                        ...Object.entries(item.customFields || {}).reduce((acc, [key, value]) => {
                            acc[customFieldDisplayNames[key] || key] = value;
                            return acc;
                        }, {})
                    };
                });

                // 메인 데이터 시트 추가
                const mainSheet = XLSX.utils.json_to_sheet(mainData);
                XLSX.utils.book_append_sheet(workbook, mainSheet, '작업 목록');

                // 마일스톤 데이터 시트 추가 (마일스톤이 있는 경우)
                let milestoneSheet = null;
                if (milestones.length > 0) {
                    const milestoneData = milestones.map((item, index) => ({
                        'No': index + 1,
                        '마일스톤': item.name,
                        '날짜': item.date
                    }));
                    milestoneSheet = XLSX.utils.json_to_sheet(milestoneData);
                    XLSX.utils.book_append_sheet(workbook, milestoneSheet, '마일스톤');
                }

                // 통계 데이터 시트 추가
                const statsData = [];
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                // 전체 통계
                const notStartedCount = projectData.filter(p => (p.progress || 0) === 0 && p.status !== '지연').length;
                const inProgressCount = projectData.filter(p => p.progress > 0 && p.progress < 100 && p.status !== '지연').length;
                const completedCount = projectData.filter(p => p.progress === 100).length;
                const delayedCount = projectData.filter(p => p.status === '지연').length;

                let totalPo = 0;
                let weightedProgressSum = 0;
                projectData.forEach(p => {
                    weightedProgressSum += (p.progress || 0) * (p.poAmount || 0);
                    totalPo += (p.poAmount || 0);
                });

                const overallProgressRate = totalPo > 0 ? Math.round(weightedProgressSum / totalPo * 100) / 100 : 0;

                statsData.push(
                    ['전체 통계', ''],
                    ['총 건수', projectData.length],
                    ['착공전', notStartedCount],
                    ['진행중', inProgressCount],
                    ['완료', completedCount],
                    ['지연', delayedCount],
                    ['총 정산액', totalPo],
                    ['전체 진행률', overallProgressRate + '%'],
                    ['', ''],
                    ['작업 유형별 통계', '']
                );

                // 작업 유형별 통계
                const taskTypeStats = projectData.reduce((acc, p) => {
                    const type = p.taskType || '미분류';
                    if (!acc[type]) {
                        acc[type] = { count: 0, amount: 0, progress: 0, weightedProgress: 0 };
                    }
                    acc[type].count++;
                    acc[type].amount += p.poAmount || 0;
                    acc[type].weightedProgress += (p.progress || 0) * (p.poAmount || 0);
                    return acc;
                }, {});

                Object.entries(taskTypeStats).sort((a, b) => a[0].localeCompare(b[0])).forEach(([type, stats]) => {
                    const progressRate = stats.amount > 0 ? Math.round(stats.weightedProgress / stats.amount * 100) / 100 : 0;
                    statsData.push(
                        [type, ''],
                        ['건수', stats.count],
                        ['정산액', stats.amount],
                        ['진행률', progressRate + '%'],
                        ['', '']
                    );
                });

                const statsSheet = XLSX.utils.aoa_to_sheet(statsData);
                XLSX.utils.book_append_sheet(workbook, statsSheet, '통계');

                // [개선] 업데이트된 항목들의 전/후 데이터 시트 추가 (일관된 전/후 컬럼)
                try {
                    const updatedProjectIds = window.__getUpdatedProjects ? window.__getUpdatedProjects() : [];
                    if (Array.isArray(updatedProjectIds) && updatedProjectIds.length > 0) {
                        const updateHistoryData = [];
                        updateHistoryData.push(['업데이트 항목 상세 이력']);
                        updateHistoryData.push(['']);
                        updateHistoryData.push([
                            '프로젝트 ID', '명칭',
                            '변경전 시작일', '변경후 시작일',
                            '변경전 종료일', '변경후 종료일',
                            '변경전 진행률(%)', '변경후 진행률(%)',
                            '변경 시간'
                        ]);

                        const fmtDateForProject = (p, type) => {
                            if (!p) return '';
                            if (p[type] instanceof Date && !isNaN(p[type])) return formatDateYMD(p[type]);
                            return p[`${type}Str`] || '';
                        };

                        const includeOverall = updatedProjectIds.includes('overall');
                        if (includeOverall) {
                            const totalPo = projectData.reduce((s, p) => s + (p.poAmount || 0), 0);
                            const origWeighted = projectData.reduce((s, p) => {
                                const op = getOriginalProgress(p);
                                return s + ((Number(op) || 0) * (p.poAmount || 0));
                            }, 0);
                            const currentWeighted = projectData.reduce((s, p) => s + ((p.progress || 0) * (p.poAmount || 0)), 0);
                            const origOverall = totalPo > 0 ? Math.round(origWeighted / totalPo * 100) / 100 : 0;
                            const currOverall = totalPo > 0 ? Math.round(currentWeighted / totalPo * 100) / 100 : 0;
                            updateHistoryData.push(['overall', '전체 진행률', '', '', '', '', origOverall + '%', currOverall + '%', new Date().toLocaleString('ko-KR')]);
                        }

                        updatedProjectIds.forEach(pid => {
                            if (pid === 'overall') return;
                            const project = projectData.find(p => p.id === pid);
                            if (!project) return;

                            const registryKey = getProjectRegistryKey(project, pid, project.name);
                            const originalDates = registryKey ? (originalDateRegistry.get(registryKey) || { start: '', end: '' }) : { start: '', end: '' };
                            const originalStart = originalDates.start || '';
                            const originalEnd = originalDates.end || '';
                            const currentStart = fmtDateForProject(project, 'startDate');
                            const currentEnd = fmtDateForProject(project, 'endDate');

                            const originalProg = getOriginalProgress(project);
                            const currentProg = (typeof project.progress === 'number') ? project.progress : (project.progress || 0);

                            const changed = (originalStart !== currentStart) || (originalEnd !== currentEnd) || (Number(originalProg) !== Number(currentProg));
                            if (changed) {
                                updateHistoryData.push([
                                    pid,
                                    project.name || '',
                                    originalStart || '', currentStart || '',
                                    originalEnd || '', currentEnd || '',
                                    (originalProg === '' ? '' : String(originalProg) + '%'), String(currentProg) + '%',
                                    new Date().toLocaleString('ko-KR')
                                ]);
                            }
                        });

                        if (updateHistoryData.length > 3) {
                            const updateHistorySheet = XLSX.utils.aoa_to_sheet(updateHistoryData);
                            XLSX.utils.book_append_sheet(workbook, updateHistorySheet, '업데이트 이력');
                        }
                    }
                } catch (e) {
                    console.warn('update history sheet creation failed', e);
                }

                // 파일 저장: XLSX는 기존 방식 유지, CSV는 프로젝트/마일스톤을 각각 CSV로 다운로드
                if (format === 'xlsx') {
                    const fileName = `gantt_data_${new Date().toISOString().slice(0,10)}.${format}`;
                    XLSX.writeFile(workbook, fileName);
                    showToast(`데이터를 ${format.toUpperCase()} 파일로 저장했습니다.`, 'success');
                } else if (format === 'csv') {
                    // Create CSV content for main sheet and milestone sheet (if present)
                    const projectsCsv = XLSX.utils.sheet_to_csv(mainSheet);
                    const downloadText = (content, name) => {
                        // Prepend UTF-8 BOM so Excel (Windows) opens CSV with correct encoding
                        const bomPrefixed = '\uFEFF' + content;
                        const blob = new Blob([bomPrefixed], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = name;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    };

                    const dateSuffix = new Date().toISOString().slice(0,10);
                    downloadText(projectsCsv, `gantt_data_projects_${dateSuffix}.csv`);

                    if (milestoneSheet) {
                        setTimeout(() => {
                            const milestoneCsv = XLSX.utils.sheet_to_csv(milestoneSheet);
                            downloadText(milestoneCsv, `gantt_data_milestones_${dateSuffix}.csv`);
                        }, 150);
                    }

                    showToast('프로젝트 및 마일스톤 CSV 파일을 다운로드했습니다.', 'success');
                } else {
                    const fileName = `gantt_data_${new Date().toISOString().slice(0,10)}.${format}`;
                    XLSX.writeFile(workbook, fileName);
                    showToast(`데이터를 ${format.toUpperCase()} 파일로 저장했습니다.`, 'success');
                }
            }

            // 내보내기 버튼 이벤트 리스너
            exportToExcelBtn.addEventListener('click', () => exportData('xlsx'));
            exportToCsvBtn.addEventListener('click', () => exportData('csv'));

            populateFilters();
             if (savedSettings && savedSettings.filters && savedSettings.filters.customFilters && customFilterContainer) {
                 customFilterContainer.querySelectorAll('select').forEach(sel => {
                    // [FIX] '고객사'/'시공사' 필터는 고정 ID를 가지므로 ID로 직접 값을 설정합니다.
                    if (sel.id === 'customer-filter') {
                        // '고객사' 필터는 항상 '고객사'로 초기 설정
                        if (sel.querySelector('option[value="고객사"]')) {
                            sel.value = '고객사';
                        } else {
                            sel.value = savedSettings.filters.customFilters[sel.dataset.filterKey] || 'all';
                        }
                        return;
                    } else if (sel.id === 'contractor-filter') {
                        sel.value = savedSettings.filters.customFilters[sel.dataset.filterKey] || 'all';
                        return;
                    }
                     const key = sel.dataset.filterKey;
                     if(savedSettings.filters.customFilters[key] !== undefined) {
                         sel.value = savedSettings.filters.customFilters[key] || 'all';
                     }
                 });
             }
             
             // savedSettings 복원 후 헤더 필터도 '고객사'로 동기화
             const headerCustomFilter = document.getElementById('header-customer-filter-shortcut');
             const mainCustomerFilter = customFilterContainer?.querySelector('#customer-filter');
             if (headerCustomFilter && mainCustomerFilter) {
                 headerCustomFilter.innerHTML = mainCustomerFilter.innerHTML;
                 if (headerCustomFilter.querySelector('option[value="고객사"]')) {
                     headerCustomFilter.value = '고객사';
                     mainCustomerFilter.value = '고객사';
                 } else {
                     headerCustomFilter.value = mainCustomerFilter.value;
                 }
             }
             const headerCostFilter = document.getElementById('header-cost-account-filter-shortcut');
             const mainCostFilter = customFilterContainer?.querySelector('#cost-account-filter');
             if (headerCostFilter) {
                 if (mainCostFilter) {
                     headerCostFilter.innerHTML = mainCostFilter.innerHTML;
                     headerCostFilter.value = mainCostFilter.value;
                     headerCostFilter.disabled = false;
                 } else {
                     headerCostFilter.innerHTML = '<option value="all">비용계정</option>';
                     headerCostFilter.value = 'all';
                     headerCostFilter.disabled = true;
                 }
             }

            // 개선 사항: 렌더링 직전에 모든 프로젝트의 원본 날짜를 현재 날짜로 강제 재설정 (하드코딩 방지)
            // 페이지 로드 시 최종 확인하여 모든 프로젝트의 원본 날짜를 현재 날짜로 설정
            if (projectData && projectData.length > 0) {
                // 먼저 레지스트리를 완전히 초기화
                originalDateRegistry.clear();
                // 그 다음 모든 프로젝트의 원본 날짜를 현재 날짜로 설정
                rebaselineOriginalDates(true, false);
                
                // Initialize revision history if not already initialized
                if (revisionHistory.length === 0) {
                    createInitialRevision();
                }
            }

            // Revision history UI will be updated when the panel is opened via the FAB button

            render();
            if(window.embeddedData) {
                showToast('저장된 데이터를 불러왔습니다.', 'info');
                renderMilestoneModal();
            }

            // [FIX] 저장된 파일 로드 시 바로가기 메뉴를 올바르게 복원합니다.
            if (savedSettings) {
                setTimeout(() => {
                    updateControlReferences();
                    updateShortcuts();
                }, 100);
            }
            
            setupSettlementAccordions();
            setupControlSectionToggles(document.getElementById('controlsSection'));
        }

        document.addEventListener('DOMContentLoaded', initializeDashboard);
        // Ensure Overview panel gets an adaptive max-height so its content can scroll
        function adjustOverviewMaxHeight() {
            try {
                const panel = document.getElementById('accordion-panel-overview');
                if (!panel) return;
                // Keep original grid layout intact; only limit height and enable vertical scroll
                const rect = panel.getBoundingClientRect();
                // Reserve small margin at bottom (24px)
                const available = Math.max(120, window.innerHeight - rect.top - 24);
                panel.style.maxHeight = available + 'px';
                panel.style.overflowY = 'auto';
                panel.style.webkitOverflowScrolling = 'touch';
            } catch (e) {
                console.warn('adjustOverviewMaxHeight failed', e);
            }
        }

        // Call after initialization and on resize; also when overview header toggles
        window.addEventListener('resize', adjustOverviewMaxHeight);
        document.addEventListener('DOMContentLoaded', () => setTimeout(adjustOverviewMaxHeight, 120));
        // If the overview header exists, call adjust when it's clicked (toggle)
        (function attachOverviewToggleListener(){
            try {
                const btn = document.querySelector('[aria-controls="accordion-panel-overview"]');
                if (!btn) return;
                btn.addEventListener('click', () => setTimeout(adjustOverviewMaxHeight, 250));
            } catch (e) {}
        })();
    </script>

    <script>
    // [비파괴적 패치] 동적 생성되는 의존성 버튼에 대해 강제 스타일을 적용합니다.
    // 이유: 일부 환경에서 CSS 우선순위 또는 렌더 시점 문제로 의해 스타일이 적용되지 않아,
    //       MutationObserver로 버튼이 생성되는 시점에 인라인 스타일을 강제 설정하여 항상 기대한 시각적 결과를 보장합니다.
    (function(){
        try {
            function applyDepBtnStyle(btn){
                if(!btn || !(btn instanceof HTMLElement)) return;
                // 적용하려는 시각 규칙들: 다른 아이콘과 일관된 크기/정렬 유지
                btn.style.padding = '0.12em';
                btn.style.width = '1.6em';
                btn.style.height = '1.6em';
                btn.style.fontSize = '0.95em';
                btn.style.lineHeight = '1';
                btn.style.fontWeight = '400';
                btn.style.boxSizing = 'border-box';
                btn.style.borderWidth = '1px';
                btn.style.display = 'inline-flex';
                btn.style.alignItems = 'center';
                btn.style.justifyContent = 'center';
                btn.style.borderRadius = '4px';
                // Ensure icon keeps centered
                btn.style.verticalAlign = 'middle';
                // keep pointer-events and cursor from template
                btn.style.cursor = 'pointer';
                // make sure emoji/icon color uses text-shadow rules from CSS
                btn.style.background = btn.style.background || '';
            }

            // Apply immediately to any existing buttons
            document.querySelectorAll('button.dependency-setting-btn, button[class*=\"dependency-setting-btn\"]').forEach(applyDepBtnStyle);

            // Observe DOM additions and apply when buttons are inserted dynamically
            const observer = new MutationObserver(function(mutations){
                for(const m of mutations){
                    for(const n of m.addedNodes){
                        if(n && n.nodeType === 1){
                            const el = /** @type {HTMLElement} */(n);
                            if(el.matches && (el.matches('button.dependency-setting-btn') || el.matches('button[class*=\"dependency-setting-btn\"]'))){
                                applyDepBtnStyle(el);
                            } else {
                                // search within subtree
                                const b = el.querySelector && (el.querySelector('button.dependency-setting-btn') || el.querySelector('button[class*=\"dependency-setting-btn\"]'));
                                if(b) applyDepBtnStyle(b);
                            }
                        }
                    }
                }
            });
            observer.observe(document.body || document.documentElement, { childList: true, subtree: true });
            console.info('[dep-style-fix] 적용됨 - 의존성 버튼 스타일을 강제 적용합니다.');
        } catch (e) {
            console.error('[dep-style-fix] 실패:', e);
        }
    })();
    </script>
    <script>
    (function() {
        function parseNumberFromCurrency(text) {
            if (!text) return 0;
            const digits = String(text).replace(/[^0-9]/g, '');
            return digits ? parseInt(digits, 10) : 0;
        }

        let lastSummarySignature = null;

        function computeCardsAggregate(cards) {
            let totalAmount = 0;
            let totalCount = 0;
            cards.forEach(card => {
                const countEl = card.querySelector('.text-sm.text-gray-500');
                const rightAmountEl = card.querySelector('.text-right .text-lg');
                if (countEl) {
                    const m = (countEl.textContent || '').match(/(\d+)\s*건/);
                    if (m) totalCount += parseInt(m[1], 10);
                }
                if (rightAmountEl) totalAmount += parseNumberFromCurrency(rightAmountEl.textContent);
            });
            return { totalAmount, totalCount };
        }

        function updateCustomerSettlementSummary() {
            try {
                const container = document.getElementById('settlement-group-summaries');
                if (!container) return;

                // Find the first flat grid section (고객사별 정산 카드가 만들어지는 섹션)
                const flatSections = Array.from(container.children).filter(el =>
                    el && el.classList && el.classList.contains('border-t') && el.querySelector('.grid')
                );
                if (flatSections.length === 0) return;

                const section = flatSections[0];
                const grid = section.querySelector('.grid');
                if (!grid) return;

                const cards = Array.from(grid.querySelectorAll('.summary-card[data-filter-type="custom-group"]'));

                const existing = grid.querySelector('#customer-settlement-summary-card');

                if (cards.length < 2) return; // Only show when 2+ cards exist

                const { totalAmount, totalCount } = computeCardsAggregate(cards);

                // Debounce: only update when signature changes (prevents flicker/shake)
                const signature = `${cards.length}|${totalAmount}|${totalCount}`;
                if (lastSummarySignature === signature && existing) return;
                lastSummarySignature = signature;

                // Build or update summary card element
                let summary = existing;
                if (!summary) {
                    summary = document.createElement('div');
                    summary.id = 'customer-settlement-summary-card';
                    summary.className = 'summary-card bg-amber-50 border-l-4 border-amber-500 p-3 rounded-lg shadow-sm cursor-pointer';
                    summary.setAttribute('aria-label', '고객사별 정산 요약');
                    grid.appendChild(summary);
                    // Attach click handler once for modal, using existing modal pipeline
                    summary.addEventListener('click', () => {
                        try {
                            const customerCards = Array.from(grid.querySelectorAll('.summary-card[data-filter-type="custom-group"]'));
                            if (customerCards.length === 0) return;
                            const field = customerCards[0].dataset.filterField; // e.g., 고객사 필드 키
                            const allowedValues = customerCards.map(c => c.dataset.filterValue);
                            const baseData = (typeof getFilteredAndSortedData === 'function') ? getFilteredAndSortedData() : (window.projectData || []);
                            const combined = baseData.filter(p => allowedValues.includes(p?.customFields?.[field]));
                            if (combined.length > 0 && typeof showProgressDetailModal === 'function') {
                                showProgressDetailModal('고객사 합계 상세 공정 현황', combined, '고객사 합계 공정율');
                            }
                        } catch (err) {
                            console.warn('customer summary modal error', err);
                        }
                    });
                }

                summary.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <div class="font-semibold text-amber-800">고객사 합계</div>
                            <div class="text-sm text-amber-700">${totalCount.toLocaleString('ko-KR')}건</div>
                        </div>
                        <div class="text-right">
                            <div class="text-lg font-bold text-amber-900">${totalAmount.toLocaleString('ko-KR')}원</div>
                        </div>
                    </div>
                `;
            } catch (e) {
                console.warn('updateCustomerSettlementSummary error', e);
            }
        }

        function setupCustomerSummaryObserver() {
            const target = document.getElementById('settlement-group-summaries');
            if (!target || !window.MutationObserver) return;
            const observer = new MutationObserver((mutations) => {
                // Only react to child list changes that add/remove cards to reduce noise
                const relevant = mutations.some(m => m.type === 'childList');
                if (!relevant) return;
                clearTimeout(setupCustomerSummaryObserver._t);
                setupCustomerSummaryObserver._t = setTimeout(updateCustomerSettlementSummary, 60);
            });
            observer.observe(target, { childList: true, subtree: true });
            // Initial pass
            setTimeout(updateCustomerSettlementSummary, 0);
        }

        document.addEventListener('DOMContentLoaded', setupCustomerSummaryObserver);
        })();
        </script>

        <!-- Non-invasive accessibility & focus enhancement for group headers and group summary bars -->
        <script>
        (function(){
            // Add minimal focus styles without altering existing CSS blocks
            try {
                const css = `
                    /* Light translucent gray fill for hover/focus to match editor 'cell focus' expectation */
                    .group-header:focus, .group-header.focused { outline: 2px solid rgba(148,163,184,0.35); outline-offset: -2px; background: rgba(148,163,184,0.06); }
                    .gantt-bar-row:focus, .gantt-bar-row.focused { outline: 2px solid rgba(148,163,184,0.35); outline-offset: -2px; background: rgba(148,163,184,0.06); }
                    .gantt-bar:focus, .gantt-bar.focused { box-shadow: 0 0 0 3px rgba(59,130,246,0.12); }
                    .title-item.focused { background: rgba(148,163,184,0.06); }
                `;
                const s = document.createElement('style'); s.setAttribute('data-enhance-focus','true'); s.textContent = css; document.head.appendChild(s);
            } catch (e) { console.warn('focus-enhance: style injection failed', e); }

            function enhanceGanttFocus() {
                try {
                    // 1) Make group headers keyboard-focusable and add keyboard handlers
                    const groupHeaders = Array.from(document.querySelectorAll('.group-header'));
                    groupHeaders.forEach(h => {
                        if (!h.hasAttribute('data-enhanced-focus')) {
                            h.setAttribute('tabindex', '0');
                            h.setAttribute('role', 'row');
                            h.dataset.enhancedFocus = '1';
                            // Reflect expanded/collapsed state for screen readers
                            const isOpen = h.classList.contains('open') || (h.parentElement && h.parentElement.classList.contains('open'));
                            h.setAttribute('aria-expanded', String(!!isOpen));
                            h.addEventListener('keydown', (ev) => {
                                if (ev.key === 'Enter' || ev.key === ' ') {
                                    ev.preventDefault();
                                    // emulate click/toggle without changing DOM order
                                    const clickTarget = h.closest('.group-header') || h;
                                    if (clickTarget && typeof clickTarget.click === 'function') clickTarget.click();
                                }
                            });
                            // Observe class changes to keep aria-expanded in sync
                            if (window.MutationObserver) {
                                const ph = new MutationObserver(() => {
                                    try {
                                        const nowOpen = h.classList.contains('open') || (h.parentElement && h.parentElement.classList.contains('open'));
                                        h.setAttribute('aria-expanded', String(!!nowOpen));
                                    } catch(e){}
                                });
                                ph.observe(h, { attributes: true, attributeFilter: ['class'] });
                            }
                        }
                    });

                    // 2) Make group summary bars and their containing rows focusable
                    const summaryBars = Array.from(document.querySelectorAll('.gantt-bar')).filter(b => {
                        const name = (b.dataset && b.dataset.name) ? b.dataset.name : b.getAttribute('data-name') || '';
                        return name && name.indexOf('(요약)') !== -1; // existing code uses '(요약)' marker
                    });

                    summaryBars.forEach(bar => {
                        try {
                            const row = bar.closest('.gantt-bar-row');
                            if (row && !row.hasAttribute('data-enhanced-focus')) {
                                row.setAttribute('tabindex', '0');
                                row.setAttribute('role', 'row');
                                row.dataset.enhancedFocus = '1';
                                row.addEventListener('keydown', (ev) => {
                                    if (ev.key === 'Enter' || ev.key === ' ') {
                                        ev.preventDefault();
                                        // forward activation to the bar element
                                        if (typeof bar.click === 'function') bar.click();
                                        else bar.dispatchEvent(new MouseEvent('click', {bubbles:true}));
                                    }
                                });
                            }

                            if (!bar.hasAttribute('tabindex')) {
                                bar.setAttribute('tabindex', '0');
                                bar.setAttribute('role', 'button');
                                const label = (bar.dataset && bar.dataset.name) ? bar.dataset.name : (bar.getAttribute('aria-label') || '그룹 요약');
                                bar.setAttribute('aria-label', label);
                                bar.addEventListener('keydown', (ev) => {
                                    if (ev.key === 'Enter' || ev.key === ' ') {
                                        ev.preventDefault();
                                        if (typeof bar.click === 'function') {
                                            bar.click();
                                        } else {
                                            bar.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                                        }
                                    }
                                });
                            }
                        } catch (inner) { console.warn('focus-enhance: summary bar enhance failed', inner); }
                    });

                    // Additional helper/wiring: allow header <-> row focus sync and keyboard navigation
                    function findGroupBarRowLocal(taskType) {
                        if (!taskType) return null;
                        try {
                            const candidateBar = Array.from(document.querySelectorAll('.gantt-bar')).find(b => {
                                const name = (b.dataset && b.dataset.name) ? b.dataset.name : (b.getAttribute('data-name') || '');
                                return name && (name.indexOf(taskType) === 0 || name.indexOf(taskType + ' ') === 0 || name.indexOf('(' + taskType) !== -1);
                            });
                            if (candidateBar) {
                                const r = candidateBar.closest('.gantt-bar-row');
                                if (r) return r;
                            }
                            const titleItems = Array.from(document.querySelectorAll(`.group-item-container[data-task-type="${taskType}"] .title-item`));
                            const projectIds = titleItems.map(t => t.dataset.projectId).filter(Boolean);
                            if (projectIds.length) {
                                const br = Array.from(document.querySelectorAll('.gantt-bar-row[data-project-id]')).find(b => projectIds.includes(b.dataset.projectId));
                                if (br) return br.parentElement || br;
                            }
                            const groupRows = Array.from(document.querySelectorAll('.gantt-bar-row')).filter(r => !r.dataset.projectId);
                            if (groupRows.length) return groupRows[0];
                        } catch(e) { console.warn('findGroupBarRowLocal error', e); }
                        return null;
                    }

                    function applyFocusSyncLocal(h, row) {
                        try {
                            // Prevent multiple attachments
                            if (h.dataset.focusSyncAttached) return;
                            h.dataset.focusSyncAttached = '1';

                            const onFocus = () => { try { h.classList.add('focused'); if (row) row.classList.add('focused'); } catch(e){} };
                            const onBlur = () => { try { if (document.activeElement !== h && document.activeElement !== row) { h.classList.remove('focused'); if (row) row.classList.remove('focused'); } } catch(e){} };
                            h.addEventListener('focus', onFocus);
                            h.addEventListener('blur', onBlur);
                            if (row) {
                                row.addEventListener('focus', () => { try { row.classList.add('focused'); h.classList.add('focused'); } catch(e){} });
                                row.addEventListener('blur', () => { try { if (document.activeElement !== h && document.activeElement !== row) { row.classList.remove('focused'); h.classList.remove('focused'); } } catch(e){} });
                            }

                            // Mouse hover: show focused state while mouse is over either header or row
                            const setHover = (on) => {
                                try {
                                    if (on) { h.classList.add('focused'); if (row) row.classList.add('focused'); }
                                    else {
                                        // only remove hover visual if element is not keyboard-focused
                                        const focusedEl = document.activeElement;
                                        if (focusedEl !== h && focusedEl !== row) {
                                            h.classList.remove('focused'); if (row) row.classList.remove('focused');
                                        }
                                    }
                                } catch(e){}
                            };
                            h.addEventListener('mouseenter', () => setHover(true));
                            h.addEventListener('mouseleave', () => setHover(false));
                            if (row) {
                                row.addEventListener('mouseenter', () => setHover(true));
                                row.addEventListener('mouseleave', () => setHover(false));
                            }

                            h.addEventListener('keydown', (ev) => {
                                if ((ev.key === 'ArrowRight' || ev.key === 'ArrowDown') && row) { ev.preventDefault(); try { row.focus(); } catch(e){} }
                                if ((ev.key === 'ArrowLeft' || ev.key === 'ArrowUp') && row) { ev.preventDefault(); try { h.focus(); } catch(e){} }
                            });
                        } catch(e) { /* non-critical */ }
                    }

                    try {
                        const gh = Array.from(document.querySelectorAll('.group-header'));
                        gh.forEach(h => {
                            try {
                                const taskType = h.dataset.taskType || (h.textContent.match(/📂\s*(.+?)\s*\(/)||[])[1];
                                const r = taskType ? findGroupBarRowLocal(taskType) : document.querySelector('.gantt-bar-row');
                                applyFocusSyncLocal(h, r);
                            } catch(e){}
                        });
                    } catch(e) { /* non-critical */ }
                } catch (e) {
                    console.warn('focus-enhance: enhanceGanttFocus error', e);
                }
            }

            // Run after DOM ready and schedule a couple delayed runs to catch late renders
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => { enhanceGanttFocus(); setTimeout(enhanceGanttFocus, 120); });
            } else {
                enhanceGanttFocus(); setTimeout(enhanceGanttFocus, 120);
            }

            // Observe gantt area for changes and re-apply enhancements non-destructively
            (function attachObserver(){
                const target = document.getElementById('ganttChart') || document.getElementById('ganttChartWrapper') || document;
                if (!window.MutationObserver || !target) return;
                const mo = new MutationObserver((mutations) => {
                    // debounce
                    clearTimeout(enhanceGanttFocus._t);
                    enhanceGanttFocus._t = setTimeout(enhanceGanttFocus, 40);
                });
                try { mo.observe(target, { childList: true, subtree: true, attributes: true }); }
                catch(e){ console.warn('focus-enhance: observer attach failed', e); }
            })();
        })();
        </script>
    <script>
    // Non-destructive scroll-sync enhancement: keep titles and timeline vertically synchronized
    (function(){
        function getScrollableWithin(selector) {
            try {
                const wrapper = document.querySelector(selector);
                if (!wrapper) return null;
                if (wrapper.scrollHeight > wrapper.clientHeight) return wrapper;
                // try first child div
                const child = wrapper.querySelector('div');
                if (child && child.scrollHeight > child.clientHeight) return child;
                return wrapper;
            } catch(e) { return null; }
        }

        function bindSync() {
            // Prefer the actual inner elements used elsewhere in this file
            const titlesElSelectors = ['.gantt-titles-body-wrapper div', '.gantt-titles-body-wrapper', '.gantt-titles'];
            const timelineElSelectors = ['.gantt-body div:first-child', '.gantt-timeline-body-wrapper div', '.gantt-timeline-body-wrapper', '.gantt-body', '#ganttChart'];
            let titlesEl = null;
            let timelineEl = null;

            for (const s of titlesElSelectors) {
                const el = document.querySelector(s);
                if (el) { titlesEl = el; break; }
            }
            for (const s of timelineElSelectors) {
                const el = document.querySelector(s);
                if (el) { timelineEl = el; break; }
            }
            // Fallback to previous heuristic
            if (!titlesEl) titlesEl = getScrollableWithin('.gantt-titles-body-wrapper') || getScrollableWithin('.gantt-titles');
            if (!timelineEl) timelineEl = getScrollableWithin('.gantt-timeline-body-wrapper') || getScrollableWithin('.gantt-body') || getScrollableWithin('#ganttChart') || document.querySelector('#ganttChart');
            if (!titlesEl || !timelineEl) return;

            // avoid duplicate binding
            if (titlesEl.dataset.scrollSync === '1') return;
            titlesEl.dataset.scrollSync = '1';
            timelineEl.dataset.scrollSync = '1';

            let isSyncing = false;

            const syncFromTitles = () => {
                if (isSyncing) return;
                isSyncing = true;
                try { timelineEl.scrollTop = titlesEl.scrollTop; } catch(e){}
                requestAnimationFrame(() => { isSyncing = false; });
            };

            const syncFromTimeline = () => {
                if (isSyncing) return;
                isSyncing = true;
                try { titlesEl.scrollTop = timelineEl.scrollTop; } catch(e){}
                requestAnimationFrame(() => { isSyncing = false; });
            };

            titlesEl.addEventListener('scroll', syncFromTitles, {passive:true});
            timelineEl.addEventListener('scroll', syncFromTimeline, {passive:true});

            // Also sync wheel events in case scroll is prevented; keep passive:false only if needed
            titlesEl.addEventListener('wheel', (ev) => {
                // If titlesEl is itself scrollable, let it scroll naturally and mirror its scrollTop.
                // If it's not scrollable, forward the wheel delta to timeline to scroll it.
                try {
                    const canScroll = titlesEl.scrollHeight > titlesEl.clientHeight;
                    if (canScroll) {
                        requestAnimationFrame(() => { try { timelineEl.scrollTop = titlesEl.scrollTop; } catch(e){} });
                    } else {
                        // forward deltaY to timeline
                        ev.preventDefault();
                        timelineEl.scrollTop += ev.deltaY;
                    }
                } catch(e){}
            }, {passive:false});

            // Also attach to wrapper selectors to increase chance of catching wheel when inner div isn't target
            ['.gantt-titles', '.gantt-titles-body-wrapper'].forEach(sel => {
                const wrap = document.querySelector(sel);
                if (!wrap) return;
                if (wrap.dataset.wheelForwardAttached) return;
                wrap.dataset.wheelForwardAttached = '1';
                wrap.addEventListener('wheel', (ev) => {
                    try {
                        timelineEl.scrollTop += ev.deltaY;
                        ev.preventDefault();
                    } catch(e){}
                }, {passive:false});
            });
        }

        // initial bind and re-bind on DOM changes
        bindSync();
        if (window.MutationObserver) {
            const target = document.getElementById('ganttChart') || document;
            const mo = new MutationObserver(() => {
                // small debounce
                clearTimeout(bindSync._t);
                bindSync._t = setTimeout(bindSync, 80);
            });
            try { mo.observe(target, { childList:true, subtree:true }); } catch(e){}
        }
    })();
    </script>

    <script>
    // Legend collapse/expand toggle handler (non-destructive)
    document.addEventListener('DOMContentLoaded', function () {
        try {
            const legendSection = document.getElementById('legendSection');
            const toggleBtn = document.getElementById('legendToggle');
            if (!legendSection || !toggleBtn) return;
            toggleBtn.addEventListener('click', function (e) {
                e.stopPropagation();
                const collapsed = legendSection.classList.toggle('legend-collapsed');
                toggleBtn.setAttribute('aria-expanded', String(!collapsed));
                toggleBtn.title = collapsed ? '펼치기' : '접기';
            });
        } catch (e) { /* noop */ }
    });
    </script>

    <script>
    function findProjectByIdentifier(projectId, projectIndex) {
        // projectData를 여러 방법으로 찾기 (스코프 문제 해결)
        const dataSource = (typeof projectData !== 'undefined' ? projectData : 
                           (typeof window.projectData !== 'undefined' ? window.projectData : null));
        
        if (!dataSource || !Array.isArray(dataSource)) {
            return null;
        }
        
        if (projectId !== undefined && projectId !== null && String(projectId).trim() !== '') {
            const match = dataSource.find(p => String(p.id) === String(projectId));
            if (match) return match;
        }
        if (projectIndex !== undefined && projectIndex !== null && String(projectIndex).trim() !== '') {
            const numericIndex = Number(projectIndex);
            if (!Number.isNaN(numericIndex) && numericIndex >= 0 && numericIndex < dataSource.length) {
                return dataSource[numericIndex];
            }
        }
        return null;
    }

    // Schedule header-only triangle toggle (non-destructive, mirrors legend colors)
    function handleDependencyButtonActivation(event, explicitButton) {
        try {
            console.log('🔗 의존성 버튼 클릭 감지됨', { event: !!event, explicitButton: !!explicitButton });
            
            if (event) {
                event.stopImmediatePropagation();
                event.preventDefault();
                event.stopPropagation();
            }

            const dependencyBtn = explicitButton
                || (event && event.target
                    ? (event.target.classList.contains('dependency-setting-btn')
                        ? event.target
                        : event.target.closest('.dependency-setting-btn'))
                    : null);
            if (!dependencyBtn) {
                console.warn('🔗 의존성 버튼을 찾을 수 없습니다');
                return false;
            }
            
            console.log('🔗 의존성 버튼 찾음:', dependencyBtn);

            const titleItemEl = dependencyBtn.closest('.title-item');
            const storedProjectRef = dependencyBtn.__projectRef || titleItemEl?.__projectRef || null;
            let projectId = dependencyBtn.getAttribute('data-project-id')
                || titleItemEl?.getAttribute('data-project-id');
            const projectIndexAttr = dependencyBtn.getAttribute('data-project-index')
                || titleItemEl?.getAttribute('data-project-index');

            let targetProject = findProjectByIdentifier(projectId, projectIndexAttr) || storedProjectRef;

            if (!targetProject && titleItemEl) {
                const fallbackName = titleItemEl.querySelector('.project-name')?.textContent?.trim();
                if (fallbackName) {
                    // projectData를 여러 방법으로 찾기 (스코프 문제 해결)
                    const dataSource = (typeof projectData !== 'undefined' ? projectData : 
                                       (typeof window.projectData !== 'undefined' ? window.projectData : null));
                    if (dataSource && Array.isArray(dataSource)) {
                        targetProject = dataSource.find(p => (p.name || '').trim() === fallbackName);
                    }
                }
            }

            if (targetProject) {
                const ensuredId = ensureProjectHasStableId(
                    targetProject,
                    projectIndexAttr ? `idx:${projectIndexAttr}` : '',
                    targetProject?.name || ''
                );
                if (ensuredId) {
                    projectId = ensuredId;
                    dependencyBtn.setAttribute('data-project-id', ensuredId);
                    if (titleItemEl) {
                        titleItemEl.setAttribute('data-project-id', ensuredId);
                    }
                }
                dependencyBtn.__projectRef = targetProject;
                if (titleItemEl) {
                    titleItemEl.__projectRef = targetProject;
                }
                if (projectIndexAttr && !dependencyBtn.getAttribute('data-project-index')) {
                    dependencyBtn.setAttribute('data-project-index', projectIndexAttr);
                }
            }

            if (!projectId) {
                console.error('🔗 projectId를 찾을 수 없습니다');
                if (typeof showToast === 'function') {
                    showToast('작업을 찾을 수 없습니다.', 'error');
                } else {
                    alert('작업을 찾을 수 없습니다.');
                }
                return false;
            }

            console.log('🔗 모달 열기 시도, projectId:', projectId);
            console.log('🔗 window.openDependencyModal:', typeof window.openDependencyModal);
            console.log('🔗 openDependencyModal:', typeof openDependencyModal);

            if (window.openDependencyModal && typeof window.openDependencyModal === 'function') {
                console.log('🔗 window.openDependencyModal 호출');
                try {
                    window.openDependencyModal(projectId);
                    console.log('🔗 모달 열기 성공');
                } catch (err) {
                    console.error('🔗 모달 열기 실패:', err);
                    if (typeof showToast === 'function') {
                        showToast('의존성 설정 모달을 열 수 없습니다: ' + err.message, 'error');
                    } else {
                        alert('의존성 설정 모달을 열 수 없습니다: ' + err.message);
                    }
                }
            } else if (typeof openDependencyModal === 'function') {
                console.log('🔗 openDependencyModal 호출');
                try {
                    openDependencyModal(projectId);
                    console.log('🔗 모달 열기 성공');
                } catch (err) {
                    console.error('🔗 모달 열기 실패:', err);
                    if (typeof showToast === 'function') {
                        showToast('의존성 설정 모달을 열 수 없습니다: ' + err.message, 'error');
                    } else {
                        alert('의존성 설정 모달을 열 수 없습니다: ' + err.message);
                    }
                }
            } else {
                console.error('🔗 openDependencyModal 함수를 찾을 수 없습니다.');
                if (typeof showToast === 'function') {
                    showToast('의존성 설정 기능을 사용할 수 없습니다.', 'error');
                } else {
                    alert('의존성 설정 기능을 사용할 수 없습니다. 페이지를 새로고침해 주세요.');
                }
            }
        } catch (error) {
            console.error('의존성 모달 열기 오류:', error);
            if (typeof showToast === 'function') {
                showToast('의존성 설정 중 오류가 발생했습니다.', 'error');
            } else {
                alert('의존성 설정 중 오류가 발생했습니다.');
            }
        }
        return false;
    }

    document.addEventListener('DOMContentLoaded', function () {
        try {
            const projectView = document.getElementById('projectView');
            const headerToggle = document.getElementById('scheduleHeaderToggle');
            if (!projectView || !headerToggle) return;
            headerToggle.addEventListener('click', function (e) {
                e.stopPropagation();
                const collapsed = projectView.classList.toggle('schedule-header-collapsed');
                headerToggle.setAttribute('aria-expanded', String(!collapsed));
                headerToggle.title = collapsed ? '펼치기' : '접기';
                // 일정 아코디언 토글 시 배타적 표시 업데이트
                updateExclusiveAccordionVisibility();
            });
        } catch (e) { /* noop */ }

        // 의존성 설정 버튼 클릭 이벤트 처리 (강화된 이벤트 위임)
        document.addEventListener('click', function(e) {
            // 의존성 버튼 클릭 감지
            if (e.target && (e.target.classList.contains('dependency-setting-btn') || e.target.closest('.dependency-setting-btn'))) {
                const dependencyBtn = e.target.classList.contains('dependency-setting-btn') ? e.target : e.target.closest('.dependency-setting-btn');
                handleDependencyButtonActivation(e, dependencyBtn);
            }
        }, true); // 캡처링 단계에서 실행하여 다른 리스너보다 먼저 처리

        // 팝업창 드래그 앤 드롭 및 리사이징 기능 초기화
        initializeModalDragAndResize();
    });

    // 팝업창 드래그 앤 드롭 및 리사이징 기능 함수
    function initializeModalDragAndResize() {
        // 데이터 매핑 및 미리보기 메뉴의 모든 팝업창 목록
        const modalIds = ['mappingModal', 'zoomModal', 'errorCorrectionModal', 'dataDetailModal', 'milestoneModal', 'fullscreenModal', 'dependencyModal'];

        modalIds.forEach(modalId => {
            const modal = document.getElementById(modalId);
            if (!modal) return;

            // dependencyModal은 .dependency-modal-content를 사용
            const modalContent = modal.querySelector('.modal-content') || modal.querySelector('.dependency-modal-content');
            if (!modalContent) return;

            // 이미 리사이저 핸들이 있는지 확인하고 없으면 추가
            if (!modalContent.querySelector('.resizer-handle')) {
                const directions = ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'];
                directions.forEach(dir => {
                    const handle = document.createElement('div');
                    handle.className = `resizer-handle ${dir}`;
                    handle.setAttribute('data-direction', dir);
                    modalContent.appendChild(handle);
                });
            }

            // 드래그 기능 추가
            const header = modalContent.querySelector('.resizable-modal-header') 
                || modalContent.querySelector('.dependency-modal-header')
                || modalContent.querySelector('h2')?.parentElement
                || modalContent.querySelector('h3')?.parentElement;
            if (header) {
                header.style.cursor = 'move';
                header.addEventListener('mousedown', function(e) {
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return; // 닫기 버튼 제외

                    e.preventDefault();

                    // 드래그 시작 시점에 모달의 실제 위치 계산
                    const rect = modalContent.getBoundingClientRect();
                    const currentTransform = modalContent.style.transform;

                    // transform이 적용되어 있다면 실제 위치 계산
                    let modalLeft, modalTop;
                    if (currentTransform && currentTransform.includes('translate')) {
                        // transform: translate(-50%, -50%)가 적용된 경우
                        const computedStyle = window.getComputedStyle(modalContent);
                        const transformValue = computedStyle.transform;
                        if (transformValue && transformValue !== 'none') {
                            // transform이 적용된 경우, 실제 렌더링된 위치 사용
                            modalLeft = rect.left;
                            modalTop = rect.top;
                        } else {
                            modalLeft = rect.left;
                            modalTop = rect.top;
                        }
                    } else {
                        modalLeft = rect.left;
                        modalTop = rect.top;
                    }

                    // 마우스 클릭 위치와 모달 위치의 상대적 오프셋 계산
                    const offsetX = e.clientX - modalLeft;
                    const offsetY = e.clientY - modalTop;

                    // 드래그 시작 시점에 모달 크기 고정
                    const modalWidth = modalContent.offsetWidth;
                    const modalHeight = modalContent.offsetHeight;

                    // 드래그 시작 시 transform 제거하고 실제 픽셀 위치 설정
                    modalContent.style.transform = 'none';
                    modalContent.style.left = modalLeft + 'px';
                    modalContent.style.top = modalTop + 'px';
                    modalContent.style.position = 'fixed';
                    // 크기를 명시적으로 설정하여 변경 방지
                    modalContent.style.width = modalWidth + 'px';
                    modalContent.style.height = modalHeight + 'px';

                    function moveModal(e) {
                        const newX = e.clientX - offsetX;
                        const newY = e.clientY - offsetY;

                        // 화면 경계 제한 (고정된 크기 사용)
                        const maxX = window.innerWidth - modalWidth;
                        const maxY = window.innerHeight - modalHeight;

                        modalContent.style.left = Math.max(0, Math.min(newX, maxX)) + 'px';
                        modalContent.style.top = Math.max(0, Math.min(newY, maxY)) + 'px';
                        modalContent.setAttribute('data-dragged', 'true'); // 드래그됨 표시
                    }

                    function stopMoving() {
                        document.removeEventListener('mousemove', moveModal);
                        document.removeEventListener('mouseup', stopMoving);
                    }

                    document.addEventListener('mousemove', moveModal);
                    document.addEventListener('mouseup', stopMoving);
                });
            }

            // 리사이징 기능 추가
            const resizerHandles = modalContent.querySelectorAll('.resizer-handle');
            resizerHandles.forEach(handle => {
                handle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const direction = handle.getAttribute('data-direction');
                    const rect = modalContent.getBoundingClientRect();
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const startWidth = rect.width;
                    const startHeight = rect.height;
                    const startLeft = rect.left;
                    const startTop = rect.top;

                    function resizeModal(e) {
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        let newWidth = startWidth;
                        let newHeight = startHeight;
                        let newLeft = startLeft;
                        let newTop = startTop;

                        // 방향에 따른 크기 조정
                        if (direction.includes('e')) newWidth = startWidth + deltaX;
                        if (direction.includes('s')) newHeight = startHeight + deltaY;
                        if (direction.includes('w')) {
                            newWidth = startWidth - deltaX;
                            newLeft = startLeft + deltaX;
                        }
                        if (direction.includes('n')) {
                            newHeight = startHeight - deltaY;
                            newTop = startTop + deltaY;
                        }

                        // 최소 크기 제한
                        const minWidth = 300;
                        const minHeight = 200;

                        if (newWidth >= minWidth) {
                            modalContent.style.width = newWidth + 'px';
                            if (direction.includes('w')) {
                                modalContent.style.left = newLeft + 'px';
                            }
                        }

                        if (newHeight >= minHeight) {
                            modalContent.style.height = newHeight + 'px';
                            if (direction.includes('n')) {
                                modalContent.style.top = newTop + 'px';
                            }
                        }

                        modalContent.style.position = 'fixed';
                        modalContent.style.transform = 'none';
                        modalContent.setAttribute('data-dragged', 'true'); // 리사이징됨 표시
                    }

                    function stopResizing() {
                        document.removeEventListener('mousemove', resizeModal);
                        document.removeEventListener('mouseup', stopResizing);
                    }

                    document.addEventListener('mousemove', resizeModal);
                    document.addEventListener('mouseup', stopResizing);
                });
            });

            // 모달이 표시될 때 화면 중앙에 적절한 크기로 설정
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'class' && !modal.classList.contains('hidden')) {
                        // 모달이 표시될 때 중앙에 위치 (드래그 전까지)
                        if (!modalContent.hasAttribute('data-dragged')) {
                            modalContent.style.position = 'fixed';
                            modalContent.style.width = ''; // 초기 너비 리셋
                            modalContent.style.height = ''; // 초기 높이 리셋
                            modalContent.style.maxWidth = '90vw'; // 화면 너비의 90%로 제한
                            modalContent.style.maxHeight = '80vh'; // 화면 높이의 80%로 제한

                            // 화면 중앙에 위치
                            const rect = modalContent.getBoundingClientRect();
                            const centerX = (window.innerWidth - rect.width) / 2;
                            const centerY = (window.innerHeight - rect.height) / 2;

                            modalContent.style.left = Math.max(0, centerX) + 'px';
                            modalContent.style.top = Math.max(0, centerY) + 'px';
                            modalContent.style.transform = 'none';
                        }
                    }
                });
            });
            observer.observe(modal, { attributes: true, attributeFilter: ['class'] });
        });
    }
    </script>

    <script>
    /* Enhanced wheel-forwarding: if wheel occurs over a titles area element, find the nearest #ganttChart and its timeline container and forward the delta.
       Non-destructive: idempotent, uses passive:false on the single listener so we can preventDefault when forwarding. */
    (function(){
        try {
            if (window.__wheel_forward_installed) return;
            window.__wheel_forward_installed = true;

            function findNearestChart(el){
                // Try multiple nearby containers: #ganttChart, #ganttChartWrapper, #ganttViewContent
                try {
                    if (!el) return document.getElementById('ganttChart') || document.getElementById('ganttChartWrapper') || document.querySelector('#ganttChart');
                    let chart = null;
                    if (el.closest) {
                        chart = el.closest('#ganttChart') || el.closest('#ganttChartWrapper') || el.closest('#ganttViewContent');
                    }
                    if (chart && chart.id === 'ganttViewContent') {
                        // find inner chart wrapper inside the view content
                        chart = chart.querySelector('#ganttChartWrapper') || chart.querySelector('#ganttChart') || chart;
                    }
                    return chart || document.getElementById('ganttChart') || document.getElementById('ganttChartWrapper') || document.querySelector('#ganttChart');
                } catch (e) {
                    return document.getElementById('ganttChart') || document.getElementById('ganttChartWrapper') || document.querySelector('#ganttChart');
                }
            }

            function findTimelineInChart(chart){
                try {
                    if(!chart) return document.querySelector('.gantt-timeline-body-wrapper, .gantt-body, .gantt-timeline-wrapper');
                    // prefer direct children inside the chart/wrapper
                    return chart.querySelector('.gantt-timeline-body-wrapper') || chart.querySelector('.gantt-body') || chart.querySelector('.gantt-timeline-wrapper') || document.querySelector('.gantt-timeline-body-wrapper') || document.querySelector('.gantt-body');
                } catch (e) {
                    return document.querySelector('.gantt-timeline-body-wrapper, .gantt-body, .gantt-timeline-wrapper');
                }
            }

            function isOverTitles(el){
                if(!el) return false;
                return !!(el.closest && (el.closest('.gantt-titles') || el.closest('.gantt-titles-body-wrapper') || el.closest('.title-item') || el.closest('.project-name') || el.closest('.group-header')));
            }

            window.addEventListener('wheel', function(ev){
                try {
                    const el = document.elementFromPoint(ev.clientX, ev.clientY);
                    if (!el) return;
                    if (!isOverTitles(el)) return; // only handle wheels over the titles area

                    const chart = findNearestChart(el);
                    const timeline = findTimelineInChart(chart);
                    if (!timeline) return;

                    // convert deltaMode to pixels
                    let dy = ev.deltaY;
                    if (ev.deltaMode === 1) dy *= 16;
                    if (ev.deltaMode === 2) dy *= (timeline.clientHeight || 800);

                    // Forward the scroll to timeline and prevent default to avoid odd interactions
                    ev.preventDefault();
                    timeline.scrollTop += dy;
                } catch (e) {
                    // swallow errors — this is a progressive enhancement
                }
            }, {passive: false});

            console.info('[wheel-forward] installed');
        } catch (err) {
            console.error('[wheel-forward] failed to install', err);
        }
    })();
    </script>

    <!-- Non-destructive enhancement: progress update highlighting + '진행' trigger handler -->
    <style>
        /* 눈에 띄는 진척률 업데이트 스타일 (빨간색, 굵게) */
        .progress-updated {
            color: #b91c1c !important; /* red-700 */
            font-weight: 800 !important;
        }
    </style>

    <script>
    (function(){
        // Non-destructive observer and input-triggered highlighter
        const PROG_SELECTOR = '#overallProgress, .title-item .project-progress, .project-progress';

        // Persistence: store project IDs (or 'overall') that are marked as updated
        const UPDATED_STORAGE_KEY = '__gantt_updated_projects';
        // Use sessionStorage for temporary (session-scoped) storage instead of persistent localStorage
        const updatedProjectsSet = new Set(JSON.parse(sessionStorage.getItem(UPDATED_STORAGE_KEY) || '[]'));

        function persistUpdatedSet(){
            try{ sessionStorage.setItem(UPDATED_STORAGE_KEY, JSON.stringify(Array.from(updatedProjectsSet))); }catch(e){}
        }

        function findProjectIdForElement(el){
            if(!el) return null;
            // direct overall progress
            if(el.id === 'overallProgress') return 'overall';
            // look for nearest ancestor with data-project-id
            const pidEl = el.closest && el.closest('[data-project-id]');
            if(pidEl && pidEl.dataset && pidEl.dataset.projectId) return pidEl.dataset.projectId;
            // find a gantt-bar-row ancestor
            const barRow = el.closest && el.closest('.gantt-bar-row[data-project-id]');
            if(barRow && barRow.dataset && barRow.dataset.projectId) return barRow.dataset.projectId;
            return null;
        }

        function applyHighlightByProjectId(pid){
            if(!pid) return;
            if(pid === 'overall'){
                const o = document.getElementById('overallProgress');
                if(o) o.classList.add('progress-updated');
                return;
            }
            // add class to all matching elements
            try{
                const selectors = [
                    `.title-item[data-project-id="${pid}"]`,
                    `.title-item[data-project-id="${pid}"] .project-progress`,
                    `.gantt-bar-row[data-project-id="${pid}"]`,
                    `.gantt-bar-row[data-project-id="${pid}"] .project-progress`,
                    `[data-project-id="${pid}"] .project-progress`,
                    `[data-project-id="${pid}"]`
                ];
                selectors.forEach(sel => {
                    Array.from(document.querySelectorAll(sel)).forEach(el => el.classList.add('progress-updated'));
                });
            }catch(e){}
        }

        function markUpdated(el){
            if(!el) return;
            try{
                // determine project id and persist
                const pid = findProjectIdForElement(el);
                if(pid) {
                    updatedProjectsSet.add(pid);
                    persistUpdatedSet();
                    applyHighlightByProjectId(pid);
                    return;
                }
                // fallback: just add class to element
                el.classList.add('progress-updated');
            }catch(e){ /* swallow */ }
        }

        // Observe character/child changes across document and mark when progress nodes change
        const docObserver = new MutationObserver(mutations => {
            for(const m of mutations){
                let target = m.target;
                if(target && target.nodeType === 3) target = target.parentElement;
                if(!target) continue;
                try{
                    if(target.matches && (target.matches(PROG_SELECTOR) || target.closest && target.closest(PROG_SELECTOR))){
                        const el = target.matches(PROG_SELECTOR) ? target : target.closest(PROG_SELECTOR);
                        if(el) markUpdated(el);
                    }
                }catch(e){ }
            }
        });
        try{ docObserver.observe(document.body, { childList:true, subtree:true, characterData:true }); }catch(e){}

        // Also ensure newly added nodes are observed and easily markable
        function ensureObservingExisting(){
            try{
                document.querySelectorAll(PROG_SELECTOR).forEach(el=>{
                    if(el.__tinyObserver) return;
                    try{
                        const o = new MutationObserver(()=> markUpdated(el));
                        o.observe(el, { childList:true, subtree:true, characterData:true });
                        el.__tinyObserver = o;
                    }catch(e){ }
                });
            }catch(e){}
        }
        setInterval(ensureObservingExisting, 2500);

        // Apply any stored highlights on init and on DOM mutations
        function applyStoredUpdatedHighlights(){
            try{
                const stored = Array.from(updatedProjectsSet);
                stored.forEach(pid => applyHighlightByProjectId(pid));
            }catch(e){}
        }
        applyStoredUpdatedHighlights();

        // Re-apply stored highlights when new nodes matching project ids are added
        const reapplier = new MutationObserver((mutations) => {
            if(updatedProjectsSet.size === 0) return;
            for(const m of mutations){
                // quick path: if addedNodes exist, try reapplying
                if(m.addedNodes && m.addedNodes.length>0){
                    applyStoredUpdatedHighlights();
                    break;
                }
            }
        });
        try{ reapplier.observe(document.body, { childList:true, subtree:true }); }catch(e){}

        // 계층 순서(상->하 또는 하->상) 관리
        let hierarchyOrder = window.hierarchyOrder || 'top'; // 'top' | 'bottom'
        const orderBtn = document.getElementById('toggleHierarchyOrderBtn');
        if(orderBtn){
            const updateLabel = ()=> orderBtn.textContent = '계층순서: ' + (hierarchyOrder === 'top' ? '상->하' : '하->상');
            orderBtn.addEventListener('click', ()=>{
                hierarchyOrder = (hierarchyOrder === 'top' ? 'bottom' : 'top');
                window.hierarchyOrder = hierarchyOrder;
                updateLabel();
            });
            updateLabel();
        }

        // '진행' 입력 핸들러: 입력값이 정확히 '진행'일 때 진척률 요소들을 계층순서에 따라 차례로 하이라이트합니다.
        function handleJinhaengInput(el){
            if(!el) return;
            const val = String((el.value || '')).trim();
            if(val !== '진행') return;
            const nodes = Array.from(document.querySelectorAll('.title-item .project-progress, .project-progress'));
            // include overall progress at the end/beginning depending on preference
            const overall = document.querySelector('#overallProgress');
            if(overall) nodes.unshift(overall);
            if(nodes.length === 0) return;
            const list = hierarchyOrder === 'top' ? nodes : nodes.reverse();
            list.forEach((n, i) => setTimeout(()=> markUpdated(n), i * 120));
        }

        document.addEventListener('input', (e)=>{
            const t = e.target;
            if(!t) return;
            if(t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable){
                handleJinhaengInput(t);
            }
        }, {passive:true});

        document.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter'){
                const active = document.activeElement;
                if(active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)){
                    handleJinhaengInput(active);
                }
            }
        });
        
        // 공개 함수: 편집기/파이프라인이 프로그래밍적으로 진척률 업데이트를 알릴 수 있도록 훅 제공
        window.__markProgressUpdated = function(selector){
            try{
                if(!selector){
                    // mark all known progress nodes
                    document.querySelectorAll(PROG_SELECTOR).forEach(el => markUpdated(el));
                    return;
                }
                const els = document.querySelectorAll(selector);
                if(els && els.length>0){
                    els.forEach(el => markUpdated(el));
                } else {
                    // if selector looks like a project id string, accept it
                    // allow calling with project id directly
                    try{
                        const maybePid = String(selector);
                        if(maybePid.length > 0) {
                            updatedProjectsSet.add(maybePid);
                            persistUpdatedSet();
                            applyHighlightByProjectId(maybePid);
                        }
                    }catch(e){}
                }
            }catch(e){}
        };

        window.__clearProgressUpdated = function(id){
            try{
                if(!id){
                    updatedProjectsSet.clear();
                    persistUpdatedSet();
                    document.querySelectorAll('.progress-updated').forEach(el => el.classList.remove('progress-updated'));
                    return;
                }
                updatedProjectsSet.delete(id);
                persistUpdatedSet();
                // remove classes for elements with that id
                if(id === 'overall'){
                    const o = document.getElementById('overallProgress'); if(o) o.classList.remove('progress-updated');
                } else {
                    Array.from(document.querySelectorAll(`[data-project-id="${id}"]`)).forEach(el => el.classList.remove('progress-updated'));
                    Array.from(document.querySelectorAll(`.title-item[data-project-id="${id}"] .project-progress`)).forEach(el=>el.classList.remove('progress-updated'));
                }
            }catch(e){}
        };

        window.__getUpdatedProjects = function(){
            try{ return Array.from(updatedProjectsSet); }catch(e){ return []; }
        };

        // 노트: 이 스크립트는 원본 DOM의 순서나 내용을 변경하지 않습니다. 오직 CSS 클래스를 추가/제거하여
        //       사용자에게 '업데이트됨' 상태를 명확히 보여주는 비파괴적 개선입니다.
    })();

        // --- Revision History Auto Upload Logic ---
        
        const revisionHistorySettingsBtn = document.getElementById('revisionHistorySettingsBtn');
        const revisionHistorySettingsPanel = document.getElementById('revisionHistorySettingsPanel');
        const revisionHistoryAutoUrlInput = document.getElementById('revisionHistoryAutoUrlInput');
        const revisionHistoryAutoLoadCheckbox = document.getElementById('revisionHistoryAutoLoadCheckbox');
        const revisionHistoryLoadNowBtn = document.getElementById('revisionHistoryLoadNowBtn');
        
        const startupChoiceModal = document.getElementById('startupChoiceModal');
        const startupChoiceAutoBtn = document.getElementById('startupChoiceAutoBtn');
        const startupChoiceManualBtn = document.getElementById('startupChoiceManualBtn');
        const startupChoiceRemember = document.getElementById('startupChoiceRemember');
        const startupChoiceAutoExecute = document.getElementById('startupChoiceAutoExecute');
        const closeStartupChoiceModalBtn = document.getElementById('closeStartupChoiceModalBtn');

        // Toggle Settings Panel
        if (revisionHistorySettingsBtn && revisionHistorySettingsPanel) {
            revisionHistorySettingsBtn.addEventListener('click', () => {
                revisionHistorySettingsPanel.classList.toggle('hidden');
            });
        }

        // Load Settings from LocalStorage
        function loadRevisionHistorySettings() {
            try {
                const saved = localStorage.getItem('revisionHistorySettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    if (revisionHistoryAutoUrlInput) revisionHistoryAutoUrlInput.value = settings.url || DEFAULT_REVISION_HISTORY_URL;
                    if (revisionHistoryAutoLoadCheckbox) revisionHistoryAutoLoadCheckbox.checked = !!settings.autoLoad;
                    // [수정됨] 자동실행 상태 로드
                    if (startupChoiceAutoExecute) startupChoiceAutoExecute.checked = !!settings.autoExecute;
                    return settings;
                }
            } catch (e) {
                console.warn('Failed to load revision history settings', e);
            }
            // Default
            if (revisionHistoryAutoUrlInput) revisionHistoryAutoUrlInput.value = DEFAULT_REVISION_HISTORY_URL;
            return null;
        }

        // Save Settings to LocalStorage
        function saveRevisionHistorySettings() {
            try {
                const settings = {
                    url: revisionHistoryAutoUrlInput ? revisionHistoryAutoUrlInput.value.trim() : DEFAULT_REVISION_HISTORY_URL,
                    autoLoad: revisionHistoryAutoLoadCheckbox ? revisionHistoryAutoLoadCheckbox.checked : false,
                    // [수정됨] 자동실행 옵션 추가
                    autoExecute: startupChoiceAutoExecute ? startupChoiceAutoExecute.checked : false
                };
                localStorage.setItem('revisionHistorySettings', JSON.stringify(settings));
            } catch (e) {
                console.warn('Failed to save revision history settings', e);
            }
        }

        if (revisionHistoryAutoUrlInput) revisionHistoryAutoUrlInput.addEventListener('change', saveRevisionHistorySettings);
        if (revisionHistoryAutoLoadCheckbox) revisionHistoryAutoLoadCheckbox.addEventListener('change', saveRevisionHistorySettings);
        // [수정됨] 자동실행 체크박스 변경 이벤트 리스너 추가 (Startup Modal 내)
        if (startupChoiceAutoExecute) startupChoiceAutoExecute.addEventListener('change', saveRevisionHistorySettings);
        // [수정됨] 기억하기 체크박스 변경 이벤트 리스너 추가
        if (startupChoiceRemember) startupChoiceRemember.addEventListener('change', () => {
             // 기억하기 해제 시 설정 삭제 고려? 아니면 그냥 놔두고 저장 시점에 반영?
             // 여기서는 즉시 저장이 아니라 버튼 클릭 시 저장하므로 리스너 불필요할 수도 있으나,
             // 사용자가 체크박스만 끄고 창을 닫아버리는 경우를 대비해 즉시 저장을 원한다면 추가.
             // 하지만 "X" 버튼이나 "자동/수동" 버튼 클릭 시 저장 로직이 있으므로 여기선 패스.
             // 단, 사용자가 "자동실행"을 끄고 "X"를 눌러 닫을 때 저장이 되어야 함.
             // "X" 버튼 핸들러에서 saveRevisionHistorySettings()를 호출하고 있음.
             // saveRevisionHistorySettings() 내부에서 현재 DOM 상태를 읽어서 저장함.
             // 따라서 DOM 상태가 변경되면 나중에 저장될 때 반영됨.
        });

        // Fetch and Import Logic
        async function fetchAndImportRevisionHistoryFromUrl(url, isStartup = false) {
            if (!url) return;
            
            try {
                if (!isStartup) {
                    showToast('변경 이력 데이터를 불러오는 중...', 'info');
                }
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const arrayBuffer = await response.arrayBuffer();
                
                const file = new File([arrayBuffer], "revision_history.xlsx", { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
                importRevisionHistoryFromExcel(file, isStartup);
                
                // [수정됨] 자동 실행 시에도 성공 메시지 출력 (사용자 요청)
                if (isStartup) {
                    showToast('자동 실행: GitHub 변경 이력 데이터 로드 완료', 'success');
                } else {
                    showToast('변경 이력 데이터 로드 완료', 'success');
                }
            } catch (e) {
                console.error('Revision history auto-upload failed:', e);
                // [수정됨] 자동 실행 시에도 실패 메시지 출력 (사용자 요청)
                if (isStartup) {
                     showToast('자동 실행 실패: 변경 이력 데이터 로드 중 오류 발생 (' + e.message + ')', 'error');
                } else {
                    showToast('변경 이력 데이터 로드 실패: ' + e.message, 'error');
                }
            }
        }

        if (revisionHistoryLoadNowBtn) {
            revisionHistoryLoadNowBtn.addEventListener('click', () => {
                const url = revisionHistoryAutoUrlInput ? revisionHistoryAutoUrlInput.value.trim() : DEFAULT_REVISION_HISTORY_URL;
                fetchAndImportRevisionHistoryFromUrl(url);
            });
        }

        // Startup Logic with Auto-Execute Check
        function initRevisionHistoryStartup() {
            const settings = loadRevisionHistorySettings();
            
            // [개선] GitHub에서 배포된 코드를 웹에서 열면 자동으로 모든 데이터가 자동 업로딩되도록 개선
            // GitHub 환경 감지 (github.io 또는 github.com에서 열릴 때)
            const isGitHubEnvironment = window.location.hostname.includes('github.io') || window.location.hostname.includes('github.com');
            
            // GitHub 환경이거나 자동 실행이 활성화된 경우 자동 업로드 실행
            const shouldAutoExecute = isGitHubEnvironment || (settings && settings.autoExecute);
            
            // 1. Auto-Execute: If enabled, wait for data readiness, then load history
            if (shouldAutoExecute) {
                // Poll for data readiness (simple check if projectData is populated)
                // "Hardcoded code execution" implies data might be in 'data' variable
                // We wait until projectData is likely initialized.
                // Note: projectData is initialized from 'data' variable at start of script.
                // If 'data' is empty initially and loaded later, we need to wait.
                
                const checkDataReady = setInterval(() => {
                    // Check if projectData has items (assuming raw data upload populates it)
                    // OR check if a specific flag indicating data load complete is set?
                    // For now, we assume if projectData.length > 0, raw data is present.
                    // If raw data is hardcoded, it will be > 0 immediately.
                    if (projectData && projectData.length > 0) {
                        clearInterval(checkDataReady);
                        const url = isGitHubEnvironment ? (settings && settings.url ? settings.url : DEFAULT_REVISION_HISTORY_URL) : (settings.url || DEFAULT_REVISION_HISTORY_URL);
                        fetchAndImportRevisionHistoryFromUrl(url, true);
                    }
                }, 500); // Check every 500ms
                
                return; // Skip showing modal
            }
            
            // If settings exist (user explicitly set autoLoad to false), do nothing (Manual)
            // But wait, if AutoExecute is false, we might still want to show modal if not "Remembered"?
            // The previous logic was: if settings exist, don't show modal.
            // If the user wants to show modal again, they need to clear settings or we need a "Show on Startup" flag.
            // Currently "Remember" implies "Don't show modal again".
            
            // [수정됨] 자동실행이 해제되어 있으면 간단한 메시지 출력 (사용자 요청)
            if (settings && !settings.autoExecute) {
                // 기존에 설정이 저장되어 있지만 autoExecute가 false인 경우
                // (사용자가 기억하기 체크했거나, 이전에 설정을 저장함)
                // 데이터 로드 안함 메시지 출력
                // 단, '기억하기' 체크 여부와 상관없이 settings가 있으면 여기로 옴.
                // 만약 사용자가 '수동'을 선택했고 '기억하기'를 체크했다면 settings.autoExecute = false임.
                // 이때 메시지를 띄워달라는 요청으로 해석됨.
                // 하지만 너무 자주 뜨면 귀찮을 수 있으니, 일단 요청대로 구현.
                 setTimeout(() => {
                    // [수정됨] 메시지가 사라지지 않는 문제 해결을 위해 showToast의 지속 시간 명시적 지정
                    showToast('자동 실행 해제됨: GitHub 변경 이력 데이터를 업로드 하지 않았습니다.', 'info', 3000);
                }, 1500); // 약간의 지연 후 표시
            }

            // If user has NOT saved settings (first run or didn't click remember), show modal
            if (!settings) {
                 if (startupChoiceModal) startupChoiceModal.classList.remove('hidden');
            }
        }

        // Startup Choice Modal Handlers
        const startupChoiceUrlInput = document.getElementById('startupChoiceUrlInput');
        if (startupChoiceUrlInput) {
             const settings = loadRevisionHistorySettings();
             startupChoiceUrlInput.value = (settings && settings.url) ? settings.url : DEFAULT_REVISION_HISTORY_URL;
        }

        if (startupChoiceAutoBtn) {
            startupChoiceAutoBtn.addEventListener('click', () => {
                const remember = startupChoiceRemember && startupChoiceRemember.checked;
                const autoExecute = startupChoiceAutoExecute && startupChoiceAutoExecute.checked;
                const url = startupChoiceUrlInput ? startupChoiceUrlInput.value.trim() : DEFAULT_REVISION_HISTORY_URL;
                
                if (remember || autoExecute) {
                    if (revisionHistoryAutoUrlInput) revisionHistoryAutoUrlInput.value = url;
                    // [수정됨] '이 선택을 기억하기'와 '자동실행'을 별도로 저장
                    if (revisionHistoryAutoLoadCheckbox) revisionHistoryAutoLoadCheckbox.checked = !!autoExecute; 
                    // autoLoadCheckBox -> Auto-Load on startup (This maps to Auto-Execute behavior)
                    // However, the user request says "If Auto-Execute option is selected... it auto uploads"
                    // So Auto-Execute implies AutoLoad=true.
                    // "Remember this choice" implies saving the URL preference and maybe modal suppression?
                    
                    saveRevisionHistorySettings();
                }
                
                fetchAndImportRevisionHistoryFromUrl(url);
                if (startupChoiceModal) startupChoiceModal.classList.add('hidden');
            });
        }

        if (startupChoiceManualBtn) {
            startupChoiceManualBtn.addEventListener('click', () => {
                const remember = startupChoiceRemember && startupChoiceRemember.checked;
                
                if (remember) {
                    if (revisionHistoryAutoLoadCheckbox) revisionHistoryAutoLoadCheckbox.checked = false;
                    saveRevisionHistorySettings();
                }
                
                if (startupChoiceModal) startupChoiceModal.classList.add('hidden');
                if (revisionHistoryPanel) revisionHistoryPanel.classList.remove('hidden');
            });
        }

        if (closeStartupChoiceModalBtn) {
            closeStartupChoiceModalBtn.addEventListener('click', () => {
                const remember = startupChoiceRemember && startupChoiceRemember.checked;
                const autoExecute = startupChoiceAutoExecute && startupChoiceAutoExecute.checked;
                // 항상 현재 자동실행 상태를 저장하도록 변경: 사용자가 체크 해제 후 닫기를 눌렀을 때도 상태가 보존되어야 함
                if (revisionHistoryAutoLoadCheckbox) revisionHistoryAutoLoadCheckbox.checked = !!autoExecute;
                saveRevisionHistorySettings();
                
                if (startupChoiceModal) startupChoiceModal.classList.add('hidden');
            });
        }

        // Run startup init
        // [수정됨] setTimeout 제거하여 즉시 실행 (토스트 타이머 충돌 가능성 배제 및 초기화 순서 보장)
        // 단, DOM이 완전히 로드된 후에 실행되어야 하므로 requestAnimationFrame 사용 또는 DOMContentLoaded 이벤트 안이라면 그냥 호출
        // 현재 스크립트는 body 맨 끝에 있으므로 DOM 준비됨.
        initRevisionHistoryStartup();
    </script>
    <script>
    // Non-invasive runtime enhancements:
    // 1) After loading revisions, try to remap dependency IDs to current project IDs (by name fallback)
    // 2) Override renderDependencyArrows at runtime to draw orthogonal right-angled routes and enlarge markers by ~20%
    (function(){
        try {
            // Save originals
            const _origApplyLoadedRevisions = window.applyLoadedRevisions || (typeof applyLoadedRevisions === 'function' ? applyLoadedRevisions : null);
            const _origRenderDependencyArrows = window.renderDependencyArrows || (typeof renderDependencyArrows === 'function' ? renderDependencyArrows : null);

            function remapDependenciesToCurrentProjects() {
                try {
                    if (!window.projectData || !Array.isArray(window.projectData)) return;
                    
                    // [성능 최적화] projectData를 Map으로 변환하여 O(n²) → O(n)으로 개선
                    const projectDataByIdMap = new Map();
                    const projectDataByNameMap = new Map();
                    window.projectData.forEach(p => {
                        if (p && p.id) {
                            projectDataByIdMap.set(String(p.id), p);
                        }
                        if (p && p.name) {
                            projectDataByNameMap.set(String(p.name), p);
                        }
                    });
                    
                    // Build name lookup from revisionHistory snapshots (if available)
                    const nameBySnapshotId = new Map();
                    if (window.revisionHistory && Array.isArray(window.revisionHistory)) {
                        window.revisionHistory.forEach(rev => {
                            if (rev && Array.isArray(rev.snapshot)) {
                                rev.snapshot.forEach(s => {
                                    if (s && s.id && s.name) nameBySnapshotId.set(String(s.id), String(s.name));
                                });
                            }
                        });
                    }

                    // For each project's dependsOn, ensure projectId refers to an existing projectData id.
                    window.projectData.forEach(proj => {
                        if (!proj || !Array.isArray(proj.dependsOn)) return;
                        proj.dependsOn = proj.dependsOn.map(dep => {
                            if (!dep || !dep.projectId) return null;
                            // If id matches current project, keep (Map 사용으로 O(1) 조회)
                            const found = projectDataByIdMap.get(String(dep.projectId));
                            if (found) return { projectId: String(found.id), type: dep.type };

                            // Try to resolve by snapshot name -> find current project by name (Map 사용으로 O(1) 조회)
                            const snapName = nameBySnapshotId.get(String(dep.projectId));
                            if (snapName) {
                                const byName = projectDataByNameMap.get(String(snapName));
                                if (byName) return { projectId: String(byName.id), type: dep.type };
                            }

                            // As a last resort, try to match dep.projectId as a name directly (Map 사용으로 O(1) 조회)
                            const byDirectName = projectDataByNameMap.get(String(dep.projectId));
                            if (byDirectName) return { projectId: String(byDirectName.id), type: dep.type };

                            // Couldn't remap — drop this dependency to avoid broken links
                            return null;
                        }).filter(Boolean);
                    });
                } catch (e) {
                    console.warn('[dep-remap] remapDependenciesToCurrentProjects failed', e);
                }
            }

            // Override applyLoadedRevisions to run remap after original runs
            if (_origApplyLoadedRevisions) {
                window.applyLoadedRevisions = function(){
                    try {
                        _origApplyLoadedRevisions.apply(this, arguments);
                    } catch (e) {
                        console.warn('[dep-enhance] original applyLoadedRevisions error', e);
                    }
                    try {
                        remapDependenciesToCurrentProjects();
                        // Re-render dependency arrows after remap - multiple attempts to ensure rendering
                        const renderDependencyArrows = () => {
                            try {
                                const isInFullscreen = typeof fullscreenModal !== 'undefined' && fullscreenModal && !fullscreenModal.classList.contains('hidden');
                                const container = isInFullscreen ? (typeof fullscreenModalBody !== 'undefined' ? fullscreenModalBody : null) : (document.getElementById('ganttViewContent') || document.body);
                                if (!container) return;
                                const ganttBody = (container && container.querySelector) ? container.querySelector('.gantt-body') : null;
                                if (!ganttBody) return;
                                const filteredData = (typeof getFilteredAndSortedData === 'function') ? getFilteredAndSortedData() : (window.latestFilteredData || window.projectData || []);
                                if (filteredData && Array.isArray(filteredData) && window.renderDependencyArrows) {
                                    window.renderDependencyArrows(ganttBody, filteredData);
                                }
                            } catch (e) { 
                                console.warn('[dep-enhance] rerender failed', e); 
                            }
                        };
                        
                        // First attempt: immediate (in case render is synchronous)
                        renderDependencyArrows();
                        
                        // Second attempt: after render() completes (100ms delay)
                        setTimeout(renderDependencyArrows, 100);
                        
                        // Third attempt: after DOM updates (300ms delay)
                        setTimeout(renderDependencyArrows, 300);
                        
                        // Fourth attempt: after layout sync (500ms delay)
                        setTimeout(renderDependencyArrows, 500);
                        
                        // Fifth attempt: after all animations complete (800ms delay)
                        setTimeout(renderDependencyArrows, 800);
                    } catch (e) { console.warn('[dep-enhance] post-apply remap failed', e); }
                };
            }

            // Override renderDependencyArrows with orthogonal routing and larger markers
            window.renderDependencyArrows = function(ganttBody, data) {
                // [핵심 수정] 함수 진입점 로그
                console.log('[dep-render] ===== FUNCTION CALLED =====');
                console.log('[dep-render] ganttBody:', ganttBody);
                console.log('[dep-render] data:', data);
                console.log('[dep-render] data type:', typeof data);
                console.log('[dep-render] data isArray:', Array.isArray(data));
                console.log('[dep-render] data length:', data ? data.length : 0);
                
                try {
                    // [성능 최적화] 데이터 검증
                    if (!data || !Array.isArray(data) || data.length === 0) {
                        console.error('[dep-render] ❌ NO DATA - Early return');
                        console.error('[dep-render] data:', data);
                        console.error('[dep-render] isArray:', Array.isArray(data));
                        console.error('[dep-render] ===== FUNCTION EXIT (NO DATA) =====');
                        return;
                    }
                    
                    // [핵심 수정] ganttBody 검증 강화
                    if (!ganttBody) {
                        console.error('[dep-render] ❌ NO GANTT BODY - Early return');
                        console.error('[dep-render] ===== FUNCTION EXIT (NO GANTT BODY) =====');
                        return;
                    }
                    
                    console.log('[dep-render] ✅ Data and ganttBody validated');
                    
                    // [성능 최적화] Use original barPositions collection if possible to stay consistent
                    // 기존 SVG 요소 완전 제거
                    const existingSvg = ganttBody.querySelector('.gantt-dependency-svg');
                    if (existingSvg) {
                        existingSvg.remove();
                    }

                    const svgNS = 'http://www.w3.org/2000/svg';
                    const svg = document.createElementNS(svgNS, 'svg');
                    svg.style.position = 'absolute';
                    svg.style.top = '0'; svg.style.left = '0'; svg.style.width = '100%'; svg.style.height = '100%';
                    svg.style.pointerEvents = 'none'; svg.style.zIndex = '5'; // Lower than bars (z-index: 9) to render behind them
                    svg.setAttribute('class', 'gantt-dependency-svg');
                    
                    // Create or get tooltip element for dependency arrows
                    let tooltip = document.getElementById('dependency-arrow-tooltip');
                    if (!tooltip) {
                        tooltip = document.createElement('div');
                        tooltip.id = 'dependency-arrow-tooltip';
                        tooltip.style.cssText = 'position: fixed; background: rgba(31, 41, 55, 0.95); color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; line-height: 1.6; max-width: 350px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none; z-index: 1000; display: none; white-space: normal;';
                        document.body.appendChild(tooltip);
                    }

                    // [핵심 수정] 의존성 데이터 확인 - 먼저 수행 (projectsWithDependencies를 먼저 선언)
                    let totalDependencies = 0;
                    let projectsWithDependencies = [];
                    console.log('[dep-render] 🔍 Analyzing data for dependencies...');
                    console.log('[dep-render]   - Data array length:', data.length);
                    console.log('[dep-render]   - Data sample (first 3):', data.slice(0, 3).map(p => ({
                        id: p.id,
                        name: p.name,
                        hasDependsOn: !!p.dependsOn,
                        dependsOnType: typeof p.dependsOn,
                        dependsOnIsArray: Array.isArray(p.dependsOn),
                        dependsOnLength: p.dependsOn ? (Array.isArray(p.dependsOn) ? p.dependsOn.length : 'not array') : 'null/undefined'
                    })));
                    
                    data.forEach((project, idx) => {
                        if (project.dependsOn && Array.isArray(project.dependsOn) && project.dependsOn.length > 0) {
                            totalDependencies += project.dependsOn.length;
                            projectsWithDependencies.push({
                                id: project.id,
                                name: project.name,
                                dependsOn: project.dependsOn
                            });
                            // [성능 최적화] 각 프로젝트의 의존성 상세 로그
                            console.log(`[dep-render] ✅ Project ${project.id} (${project.name}) has ${project.dependsOn.length} dependencies:`, JSON.stringify(project.dependsOn));
                        } else {
                            // 의존성이 없는 프로젝트도 로그 (처음 몇 개만)
                            if (idx < 5) {
                                console.log(`[dep-render] ⚠️  Project ${project.id} (${project.name}) has NO dependencies (dependsOn: ${project.dependsOn}, type: ${typeof project.dependsOn}, isArray: ${Array.isArray(project.dependsOn)})`);
                            }
                        }
                    });
                    
                    console.log('[dep-render] 📊 Dependency Analysis:');
                    console.log('[dep-render]   - Total projects:', data.length);
                    console.log('[dep-render]   - Projects with dependencies:', projectsWithDependencies.length);
                    console.log('[dep-render]   - Total dependencies:', totalDependencies);
                    if (projectsWithDependencies.length > 0) {
                        console.log('[dep-render]   - Projects with dependencies:', projectsWithDependencies);
                    } else {
                        // [핵심 수정] 의존성이 없는 것은 정상적인 상황이므로 디버그 레벨로 변경
                        // console.debug는 개발자 도구에서 "Verbose" 레벨을 활성화해야 보임
                        if (console.debug) {
                            console.debug('[dep-render] No dependencies found in data - this is normal if no dependencies are set');
                        }
                        return;
                    }
                    
                    // [핵심 수정] 막대 위치 수집 - 실패한 프로젝트 추적
                    const barPositions = new Map();
                    const missingBarRows = [];
                    data.forEach(project => {
                        const row = ganttBody.querySelector(`.gantt-bar-row[data-project-id="${project.id}"]`);
                        if (!row) {
                            missingBarRows.push({ id: project.id, name: project.name, reason: 'row not found' });
                            return;
                        }
                        const bar = row.querySelector('.gantt-bar');
                        if (!bar) {
                            missingBarRows.push({ id: project.id, name: project.name, reason: 'bar not found' });
                            return;
                        }
                        const projectBarLeft = parseFloat(bar.style.left) || 0;
                        const projectBarWidth = parseFloat(bar.style.width) || 0;
                        const projectBarRight = projectBarLeft + projectBarWidth;
                        const barRect = bar.getBoundingClientRect();
                        const ganttRect = ganttBody.getBoundingClientRect();
                        const top = barRect.top - ganttRect.top + ganttBody.scrollTop;
                        const height = barRect.height || 20;
                        const centerY = top + height / 2;
                        barPositions.set(String(project.id), { left: projectBarLeft, right: projectBarRight, centerY, top, height });
                    });
                    
                    // [핵심 수정] 막대 위치 수집 결과 로그 - 강력한 디버깅
                    console.log('[dep-render] 📍 Bar Position Collection Results:');
                    console.log('[dep-render]   - Found:', barPositions.size, '/', data.length);
                    console.log('[dep-render]   - Missing:', missingBarRows.length);
                    if (missingBarRows.length > 0) {
                        if (missingBarRows.length <= 10) {
                            console.warn('[dep-render]   - Missing projects:', missingBarRows);
                        } else {
                            console.warn('[dep-render]   - Missing projects (first 10):', missingBarRows.slice(0, 10));
                            console.warn(`[dep-render]   - ... and ${missingBarRows.length - 10} more projects`);
                        }
                    }
                    
                    // 의존성이 있는 프로젝트 중 막대 위치를 찾은 것 확인
                    const projectsWithDepsAndBars = projectsWithDependencies.filter(p => {
                        return barPositions.has(String(p.id));
                    });
                    console.log('[dep-render]   - Projects with dependencies AND bar positions:', projectsWithDepsAndBars.length, '/', projectsWithDependencies.length);
                    if (projectsWithDepsAndBars.length === 0 && projectsWithDependencies.length > 0) {
                        console.error('[dep-render] ❌ CRITICAL: No bar positions found for projects with dependencies!');
                        console.error('[dep-render] This means dependencies exist but bars are not rendered yet');
                    }

                    const defs = document.createElementNS(svgNS, 'defs');
                    svg.appendChild(defs);

                    const colorMap = {
                        'start-to-start': '#2563eb',
                        'end-to-start':   '#10b981',
                        'end-to-end':     '#f59e0b',
                        'start-to-end':   '#ef4444'
                    };

                    // [핵심 수정] 의존성이 있는 프로젝트만 렌더링 - 강력한 디버깅
                    let renderedCount = 0;
                    let skippedCount = 0;
                    
                    console.log('[dep-render] 🎨 Starting dependency rendering...');
                    projectsWithDependencies.forEach(projectInfo => {
                        const project = data.find(p => String(p.id) === String(projectInfo.id));
                        if (!project) {
                            console.warn(`[dep-render] ⚠️  Project ${projectInfo.id} not found in data array`);
                            skippedCount++;
                            return;
                        }
                        
                        const projectPos = barPositions.get(String(project.id));
                        if (!projectPos) {
                            console.warn(`[dep-render] ⚠️  Skipping project ${project.id} - bar position not found`);
                            skippedCount += project.dependsOn.length;
                            return;
                        }

                        // [성능 최적화] 모든 의존성 순회하며 렌더링
                        project.dependsOn.forEach((dep, depIndex) => {
                            if (!dep || !dep.projectId) {
                                console.warn(`[dep-render] ⚠️  Invalid dependency at index ${depIndex} for project ${project.id}`);
                                skippedCount++;
                                return;
                            }
                            
                            // [성능 최적화] 디버깅: 각 의존성 렌더링 시도 로그
                            console.log(`[dep-render] Rendering dependency ${depIndex + 1}/${project.dependsOn.length} for project ${project.id}:`, dep.projectId, 'type:', dep.type);
                            
                            const depPos = barPositions.get(String(dep.projectId));
                            if (!depPos) {
                                console.warn(`[dep-render] ⚠️  Dependency position not found for project ${dep.projectId} (dependency of project ${project.id})`);
                                skippedCount++;
                                return;
                            }

                            // [개선] compute orthogonal path - SS, FS, FF, SF 개념에 맞게 막대 그래프의 시작/끝에 정확히 연결
                            // SS (start-to-start): 시작 → 시작 (좌측 → 좌측)
                            // FS (end-to-start): 종료 → 시작 (우측 → 좌측)
                            // FF (end-to-end): 종료 → 종료 (우측 → 우측)
                            // SF (start-to-end): 시작 → 종료 (좌측 → 우측)
                            // [핵심 개선] 마커('○', '●')를 막대 그래프의 시작/끝 중앙에 정확히 위치
                            let startX, endX, startY, endY;
                            if (dep.type === 'start-to-start') {
                                // SS: 선행 작업의 좌측 끝 중앙 → 현재 작업의 좌측 끝 중앙
                                startX = depPos.left;
                                startY = depPos.top + depPos.height / 2; // 막대 그래프 시작 끝의 중앙
                                endX = projectPos.left;
                                endY = projectPos.top + projectPos.height / 2; // 막대 그래프 시작 끝의 중앙
                            } else if (dep.type === 'end-to-start') {
                                // FS: 선행 작업의 우측 끝 중앙 → 현재 작업의 좌측 끝 중앙
                                startX = depPos.right;
                                startY = depPos.top + depPos.height / 2; // 막대 그래프 끝의 중앙
                                endX = projectPos.left;
                                endY = projectPos.top + projectPos.height / 2; // 막대 그래프 시작 끝의 중앙
                            } else if (dep.type === 'end-to-end') {
                                // FF: 선행 작업의 우측 끝 중앙 → 현재 작업의 우측 끝 중앙
                                startX = depPos.right;
                                startY = depPos.top + depPos.height / 2; // 막대 그래프 끝의 중앙
                                endX = projectPos.right;
                                endY = projectPos.top + projectPos.height / 2; // 막대 그래프 끝의 중앙
                            } else if (dep.type === 'start-to-end') {
                                // SF: 선행 작업의 좌측 끝 중앙 → 현재 작업의 우측 끝 중앙
                                startX = depPos.left;
                                startY = depPos.top + depPos.height / 2; // 막대 그래프 시작 끝의 중앙
                                endX = projectPos.right;
                                endY = projectPos.top + projectPos.height / 2; // 막대 그래프 끝의 중앙
                            } else {
                                // 기본값 (fallback)
                                startX = depPos.left;
                                startY = depPos.top + depPos.height / 2;
                                endX = projectPos.left;
                                endY = projectPos.top + projectPos.height / 2;
                            }

                            const edgeColor = colorMap[dep.type] || '#9ca3af';

                            // [개선] marker sizes (현재 크기에서 20% 더 크게)
                            const minBarHeight = Math.min(depPos.height, projectPos.height);
                            const baseStartR = Math.max(1.2, Math.min(minBarHeight * 0.18, 2.5));
                            const baseEndR = Math.max(1.2, Math.min(minBarHeight * 0.18, 2.5));
                            const baseFlowR = Math.max(1, Math.min(minBarHeight * 0.12, 2));
                            const scale = 1.44; // 현재 1.2배에서 20% 더 증가: 1.2 * 1.2 = 1.44배
                            const startR = baseStartR * scale;
                            const endR = baseEndR * scale;
                            const flowR = baseFlowR * scale;

                            // create markers
                            const startId = `dep-start-${dep.projectId}-${project.id}`;
                            const endId = `dep-end-${dep.projectId}-${project.id}`;

                            const createMarker = (id, r, fill, stroke) => {
                                const marker = document.createElementNS(svgNS, 'marker');
                                const size = r * 2 + 4;
                                marker.setAttribute('id', id);
                                marker.setAttribute('viewBox', `0 0 ${size} ${size}`);
                                marker.setAttribute('refX', r + 2);
                                marker.setAttribute('refY', r + 2);
                                marker.setAttribute('markerWidth', size);
                                marker.setAttribute('markerHeight', size);
                                marker.setAttribute('orient', 'auto');
                                marker.setAttribute('markerUnits', 'userSpaceOnUse');
                                const c = document.createElementNS(svgNS, 'circle');
                                c.setAttribute('cx', String(r + 2)); c.setAttribute('cy', String(r + 2)); c.setAttribute('r', String(r));
                                if (fill) c.setAttribute('fill', fill); else c.setAttribute('fill', 'none');
                                if (stroke) c.setAttribute('stroke', stroke);
                                c.setAttribute('stroke-width', '0.8');
                                marker.appendChild(c);
                                return marker;
                            };

                            defs.appendChild(createMarker(startId, startR, null, edgeColor));
                            defs.appendChild(createMarker(endId, endR, edgeColor, 'none'));

                            // [성능 최적화] Build orthogonal path with collision avoidance
                            // 세그먼트 길이를 조정하여 막대 그래프와의 충돌을 최소화
                            // [핵심 개선] 마커 위치에서 시작하여 막대 그래프와 충분히 떨어진 거리로 경로 시작
                            const seg = Math.min(Math.max(25, Math.abs(endX - startX) * 0.25), 70); // 세그먼트 길이 증가 (20→25, 60→70, 0.2→0.25) - 막대 그래프와 더 멀리 떨어지도록
                            const dir = endX >= startX ? 1 : -1;
                            // 시작점과 끝점에서 마커 위치를 유지하면서 경로 시작
                            // [핵심 개선] let으로 선언하여 충돌 회피 시 경로 조정 가능
                            let routeStartX = startX + dir * seg; // 시작 마커에서 충분히 떨어진 위치
                            let routeEndX = endX - dir * seg; // 끝 마커에서 충분히 떨어진 위치

                            // [성능 최적화] Helper function to check if a vertical line segment intersects with any bar
                            // 여유 공간(padding)을 추가하여 막대 그래프와 겹치지 않도록 개선
                            const COLLISION_PADDING = 20; // 막대 그래프와의 최소 여유 공간 (px) - 8에서 20으로 증가
                            const ROUTE_MARGIN = COLLISION_PADDING + 10; // 충돌 회피를 위한 추가 여유 공간 - 5에서 10으로 증가
                            const checkVerticalCollision = (x, y1, y2) => {
                                const minY = Math.min(y1, y2);
                                const maxY = Math.max(y1, y2);
                                for (const [barId, barPos] of barPositions.entries()) {
                                    if (barId === String(dep.projectId) || barId === String(project.id)) continue;
                                    // [성능 최적화] 여유 공간을 고려한 경계 계산
                                    const barLeft = barPos.left - COLLISION_PADDING;
                                    const barRight = barPos.right + COLLISION_PADDING;
                                    const barTop = barPos.top - COLLISION_PADDING;
                                    const barBottom = barPos.top + barPos.height + COLLISION_PADDING;
                                    // Check if vertical line at x intersects with this bar (여유 공간 포함)
                                    if (x >= barLeft && x <= barRight) {
                                        // Check if vertical segment overlaps with bar vertically (여유 공간 포함)
                                        if (maxY >= barTop && minY <= barBottom) {
                                            return { collides: true, bar: barPos };
                                        }
                                    }
                                }
                                return { collides: false, bar: null };
                            };

                            // [성능 최적화] Helper function to check if a horizontal line segment intersects with any bar
                            // 여유 공간(padding)을 추가하여 막대 그래프와 겹치지 않도록 개선
                            const checkHorizontalCollision = (y, x1, x2) => {
                                const minX = Math.min(x1, x2);
                                const maxX = Math.max(x1, x2);
                                for (const [barId, barPos] of barPositions.entries()) {
                                    if (barId === String(dep.projectId) || barId === String(project.id)) continue;
                                    // [성능 최적화] 여유 공간을 고려한 경계 계산
                                    const barLeft = barPos.left - COLLISION_PADDING;
                                    const barRight = barPos.right + COLLISION_PADDING;
                                    const barTop = barPos.top - COLLISION_PADDING;
                                    const barBottom = barPos.top + barPos.height + COLLISION_PADDING;
                                    // Check if horizontal line at y intersects with this bar (여유 공간 포함)
                                    if (y >= barTop && y <= barBottom) {
                                        // Check if horizontal segment overlaps with bar horizontally (여유 공간 포함)
                                        if (maxX >= barLeft && minX <= barRight) {
                                            return { collides: true, bar: barPos };
                                        }
                                    }
                                }
                                return { collides: false, bar: null };
                            };

                            // Check if path would intersect with any bar between start and end
                            let routeY = startY; // Default: use centerY
                            const minX = Math.min(routeStartX, routeEndX);
                            const maxX = Math.max(routeStartX, routeEndX);
                            
                            // [성능 최적화] Find all bars that the horizontal path segment would intersect
                            // 여유 공간을 고려하여 더 정확한 충돌 감지
                            const intersectingBars = [];
                            for (const [barId, barPos] of barPositions.entries()) {
                                if (barId === String(dep.projectId) || barId === String(project.id)) continue;
                                // [성능 최적화] 여유 공간을 고려한 경계 계산
                                const barLeft = barPos.left - COLLISION_PADDING;
                                const barRight = barPos.right + COLLISION_PADDING;
                                const barTop = barPos.top - COLLISION_PADDING;
                                const barBottom = barPos.top + barPos.height + COLLISION_PADDING;
                                if (barLeft < maxX && barRight > minX) {
                                    // Bar is in the horizontal range (여유 공간 포함)
                                    // Check if the routeY (startY) would intersect this bar (여유 공간 포함)
                                    if (startY >= barTop && startY <= barBottom) {
                                        intersectingBars.push(barPos);
                                    }
                                }
                            }

                            // Check vertical segments for collisions
                            const startVerticalCollision = checkVerticalCollision(routeStartX, startY, routeY);
                            const endVerticalCollision = checkVerticalCollision(routeEndX, routeY, endY);

                            // If collisions detected, find the best route (above or below all intersecting bars)
                            if (intersectingBars.length > 0 || startVerticalCollision.collides || endVerticalCollision.collides) {
                                // Collect all bars that need to be avoided
                                const allBarsToAvoid = [...intersectingBars];
                                if (startVerticalCollision.collides && !allBarsToAvoid.includes(startVerticalCollision.bar)) {
                                    allBarsToAvoid.push(startVerticalCollision.bar);
                                }
                                if (endVerticalCollision.collides && !allBarsToAvoid.includes(endVerticalCollision.bar)) {
                                    allBarsToAvoid.push(endVerticalCollision.bar);
                                }

                                // Find the highest top and lowest bottom of all bars to avoid
                                let highestTop = Math.min(...allBarsToAvoid.map(b => b.top));
                                let lowestBottom = Math.max(...allBarsToAvoid.map(b => b.top + b.height));
                                
                                // [성능 최적화] Try routing above all bars first (여유 공간 증가)
                                // ROUTE_MARGIN은 이미 상단에서 정의됨
                                let routeAbove = highestTop - ROUTE_MARGIN;
                                // Check if above route is clear of all bars in the range
                                let aboveClear = true;
                                const aboveHorizontalCheck = checkHorizontalCollision(routeAbove, routeStartX, routeEndX);
                                if (aboveHorizontalCheck.collides) {
                                    aboveClear = false;
                                }
                                const aboveStartVerticalCheck = checkVerticalCollision(routeStartX, startY, routeAbove);
                                if (aboveStartVerticalCheck.collides) {
                                    aboveClear = false;
                                }
                                const aboveEndVerticalCheck = checkVerticalCollision(routeEndX, routeAbove, endY);
                                if (aboveEndVerticalCheck.collides) {
                                    aboveClear = false;
                                }
                                
                                if (aboveClear) {
                                    routeY = routeAbove;
                                } else {
                                    // [성능 최적화] Route below all bars (여유 공간 증가)
                                    let routeBelow = lowestBottom + ROUTE_MARGIN;
                                    let belowClear = true;
                                    const belowHorizontalCheck = checkHorizontalCollision(routeBelow, routeStartX, routeEndX);
                                    if (belowHorizontalCheck.collides) {
                                        belowClear = false;
                                    }
                                    const belowStartVerticalCheck = checkVerticalCollision(routeStartX, startY, routeBelow);
                                    if (belowStartVerticalCheck.collides) {
                                        belowClear = false;
                                    }
                                    const belowEndVerticalCheck = checkVerticalCollision(routeEndX, routeBelow, endY);
                                    if (belowEndVerticalCheck.collides) {
                                        belowClear = false;
                                    }
                                    
                                    if (belowClear) {
                                        routeY = routeBelow;
                                    } else {
                                        // [성능 최적화] If both above and below are blocked, try multiple alternative routes
                                        // 여러 대안 경로 시도: 더 위쪽, 더 아래쪽, 중간 경로 등
                                        let bestRouteY = null;
                                        let bestRouteScore = Infinity;
                                        
                                        // 대안 경로들 시도
                                        const alternativeRoutes = [
                                            highestTop - ROUTE_MARGIN * 2, // 더 위쪽
                                            lowestBottom + ROUTE_MARGIN * 2, // 더 아래쪽
                                            (highestTop + lowestBottom) / 2, // 중간
                                            startY, // 시작점 Y
                                            endY // 끝점 Y
                                        ];
                                        
                                        for (const altRouteY of alternativeRoutes) {
                                            const altHorizontalCheck = checkHorizontalCollision(altRouteY, routeStartX, routeEndX);
                                            const altStartVerticalCheck = checkVerticalCollision(routeStartX, startY, altRouteY);
                                            const altEndVerticalCheck = checkVerticalCollision(routeEndX, altRouteY, endY);
                                            
                                            if (!altHorizontalCheck.collides && !altStartVerticalCheck.collides && !altEndVerticalCheck.collides) {
                                                // 충돌이 없는 경로 발견
                                                const routeScore = Math.abs(startY - altRouteY) + Math.abs(endY - altRouteY);
                                                if (routeScore < bestRouteScore) {
                                                    bestRouteScore = routeScore;
                                                    bestRouteY = altRouteY;
                                                }
                                            }
                                        }
                                        
                                        if (bestRouteY !== null) {
                                            routeY = bestRouteY;
                                        } else {
                                            // 모든 대안이 실패한 경우, 가장 가까운 경로 선택
                                            const distAbove = Math.abs(startY - (highestTop - ROUTE_MARGIN));
                                            const distBelow = Math.abs(startY - (lowestBottom + ROUTE_MARGIN));
                                        if (distAbove <= distBelow) {
                                                routeY = highestTop - ROUTE_MARGIN;
                                        } else {
                                                routeY = lowestBottom + ROUTE_MARGIN;
                                            }
                                        }
                                    }
                                }
                            }

                            // Build path: start -> horizontal segment -> vertical segment (avoiding bars) -> horizontal segment -> vertical segment -> end
                            // Ensure vertical segments don't overlap with bars by checking start and end points
                            // [핵심 개선] 마커 위치를 정확히 유지하면서 경로 생성
                            let finalStartY = startY; // 마커('○') 위치 - 막대 그래프 시작/끝 중앙
                            let finalEndY = endY; // 마커('●') 위치 - 막대 그래프 시작/끝 중앙
                            
                            // Check if starting vertical segment (from startY to routeY) would overlap with any bar
                            const startVerticalCheck = checkVerticalCollision(routeStartX, startY, routeY);
                            if (startVerticalCheck.collides && startVerticalCheck.bar) {
                                const startBar = startVerticalCheck.bar;
                                const startBarTop = startBar.top;
                                const startBarBottom = startBar.top + startBar.height;
                                const startBarCenter = startBarTop + startBar.height / 2;
                                
                                // [성능 최적화] Determine if we should route above or below the start bar
                                // If startY is above bar center, route above; otherwise route below
                                // 여유 공간을 증가시켜 막대 그래프와 겹치지 않도록 개선
                                if (startY <= startBarCenter) {
                                    finalStartY = startBarTop - ROUTE_MARGIN; // Route above start bar with margin
                                } else {
                                    finalStartY = startBarBottom + ROUTE_MARGIN; // Route below start bar with margin
                                }
                                
                                // Update routeY if needed to maintain smooth path
                                if (Math.abs(finalStartY - routeY) < ROUTE_MARGIN) {
                                    routeY = finalStartY;
                                }
                            }
                            
                            // Check if ending vertical segment (from routeY to endY) would overlap with any bar
                            const endVerticalCheck = checkVerticalCollision(routeEndX, routeY, endY);
                            if (endVerticalCheck.collides && endVerticalCheck.bar) {
                                const endBar = endVerticalCheck.bar;
                                const endBarTop = endBar.top;
                                const endBarBottom = endBar.top + endBar.height;
                                const endBarCenter = endBarTop + endBar.height / 2;
                                
                                // [성능 최적화] Determine if we should route above or below the end bar
                                // 여유 공간을 증가시켜 막대 그래프와 겹치지 않도록 개선
                                if (endY <= endBarCenter) {
                                    finalEndY = endBarTop - ROUTE_MARGIN; // Route above end bar with margin
                                } else {
                                    finalEndY = endBarBottom + ROUTE_MARGIN; // Route below end bar with margin
                                }
                                
                                // Update routeY if needed to maintain smooth path
                                if (Math.abs(finalEndY - routeY) < ROUTE_MARGIN) {
                                    routeY = finalEndY;
                                }
                            }
                            
                            // Verify the final path doesn't collide with any bars
                            const finalStartVerticalCheck = checkVerticalCollision(routeStartX, finalStartY, routeY);
                            const finalEndVerticalCheck = checkVerticalCollision(routeEndX, routeY, finalEndY);
                            const finalHorizontalCheck = checkHorizontalCollision(routeY, routeStartX, routeEndX);
                            
                            // If there are still collisions, adjust routeY further
                            if (finalStartVerticalCheck.collides || finalEndVerticalCheck.collides || finalHorizontalCheck.collides) {
                                // Find a safe routeY that avoids all collisions
                                const allCollidingBars = [];
                                if (finalStartVerticalCheck.collides) allCollidingBars.push(finalStartVerticalCheck.bar);
                                if (finalEndVerticalCheck.collides) allCollidingBars.push(finalEndVerticalCheck.bar);
                                if (finalHorizontalCheck.collides) allCollidingBars.push(finalHorizontalCheck.bar);
                                
                                if (allCollidingBars.length > 0) {
                                    // [성능 최적화] 여유 공간을 증가시켜 막대 그래프와 겹치지 않도록 개선
                                    const safeTop = Math.min(...allCollidingBars.map(b => b.top)) - ROUTE_MARGIN;
                                    const safeBottom = Math.max(...allCollidingBars.map(b => b.top + b.height)) + ROUTE_MARGIN;
                                    
                                    // Choose the route that's closer to the original routeY
                                    if (Math.abs(routeY - safeTop) <= Math.abs(routeY - safeBottom)) {
                                        routeY = safeTop;
                                    } else {
                                        routeY = safeBottom;
                                    }
                                }
                            }
                            
                            // [성능 최적화] Build final path with adjusted points
                            // 최종 경로의 각 세그먼트가 막대 그래프와 겹치지 않도록 최종 검증
                            // [핵심 개선] 마커 위치를 정확히 유지 (막대 그래프 시작/끝 중앙)
                            let finalPathStartX = startX; // 마커('○') X 위치 - 막대 그래프 시작/끝
                            let finalPathStartY = startY; // 마커('○') Y 위치 - 막대 그래프 시작/끝 중앙
                            let finalPathEndX = endX; // 마커('●') X 위치 - 막대 그래프 시작/끝
                            let finalPathEndY = endY; // 마커('●') Y 위치 - 막대 그래프 시작/끝 중앙
                            
                            // 시작점과 첫 번째 수평 세그먼트 연결점 검증 (여유 공간 증가)
                            // [핵심 개선] 마커('○') 위치는 유지하고, 경로만 조정하여 막대 그래프와 겹치지 않도록
                            const startHorizontalCheck = checkHorizontalCollision(finalStartY, startX, routeStartX);
                            if (startHorizontalCheck.collides) {
                                // 충돌이 발생하면 경로를 조정하되, 마커 위치는 유지
                                // 마커에서 시작하는 수평 세그먼트가 막대 그래프와 겹치면 routeStartX를 조정
                                const adjustAmount = COLLISION_PADDING * 2; // 여유 공간 증가
                                // 마커 위치는 유지하고, 경로 시작점만 조정
                                const adjustedRouteStartX = routeStartX + (dir > 0 ? adjustAmount : -adjustAmount);
                                const recheck = checkHorizontalCollision(finalStartY, startX, adjustedRouteStartX);
                                if (!recheck.collides) {
                                    // 조정된 경로가 충돌하지 않으면 사용
                                    routeStartX = adjustedRouteStartX;
                                } else {
                                    // 여전히 충돌하면 수직으로 우회
                                    const bar = startHorizontalCheck.bar;
                                    const bypassY = startY < bar.top ? bar.top - ROUTE_MARGIN : bar.top + bar.height + ROUTE_MARGIN;
                                    finalPathStartY = bypassY;
                                }
                            }
                            
                            // 끝점과 마지막 수평 세그먼트 연결점 검증 (여유 공간 증가)
                            // [핵심 개선] 마커('●') 위치는 유지하고, 경로만 조정하여 막대 그래프와 겹치지 않도록
                            const endHorizontalCheck = checkHorizontalCollision(finalEndY, routeEndX, endX);
                            if (endHorizontalCheck.collides) {
                                // 충돌이 발생하면 경로를 조정하되, 마커 위치는 유지
                                // 마커로 끝나는 수평 세그먼트가 막대 그래프와 겹치면 routeEndX를 조정
                                const adjustAmount = COLLISION_PADDING * 2; // 여유 공간 증가
                                // 마커 위치는 유지하고, 경로 끝점만 조정
                                const adjustedRouteEndX = routeEndX + (dir > 0 ? -adjustAmount : adjustAmount);
                                const recheck = checkHorizontalCollision(finalEndY, adjustedRouteEndX, endX);
                                if (!recheck.collides) {
                                    // 조정된 경로가 충돌하지 않으면 사용
                                    routeEndX = adjustedRouteEndX;
                                } else {
                                    // 여전히 충돌하면 수직으로 우회
                                    const bar = endHorizontalCheck.bar;
                                    const bypassY = endY < bar.top ? bar.top - ROUTE_MARGIN : bar.top + bar.height + ROUTE_MARGIN;
                                    finalPathEndY = bypassY;
                                }
                            }
                            
                            // 최종 경로의 모든 세그먼트가 막대 그래프와 겹치지 않는지 최종 검증
                            const finalPathChecks = [
                                checkVerticalCollision(routeStartX, finalPathStartY, finalStartY),
                                checkHorizontalCollision(finalStartY, startX, routeStartX),
                                checkVerticalCollision(routeStartX, finalStartY, routeY),
                                checkHorizontalCollision(routeY, routeStartX, routeEndX),
                                checkVerticalCollision(routeEndX, routeY, finalEndY),
                                checkHorizontalCollision(finalEndY, routeEndX, endX),
                                checkVerticalCollision(routeEndX, finalEndY, finalPathEndY)
                            ];
                            
                            // 충돌이 있는 세그먼트가 있으면 경로를 추가로 조정
                            const collidingSegments = finalPathChecks.filter(check => check.collides);
                            if (collidingSegments.length > 0) {
                                // 모든 충돌하는 막대 그래프를 수집
                                const allCollidingBars = [];
                                collidingSegments.forEach(check => {
                                    if (check.bar && !allCollidingBars.includes(check.bar)) {
                                        allCollidingBars.push(check.bar);
                                    }
                                });
                                
                                if (allCollidingBars.length > 0) {
                                    // 충돌하는 막대 그래프들을 모두 피하는 안전한 경로 계산
                                    const safeTop = Math.min(...allCollidingBars.map(b => b.top)) - ROUTE_MARGIN;
                                    const safeBottom = Math.max(...allCollidingBars.map(b => b.top + b.height)) + ROUTE_MARGIN;
                                    
                                    // 원래 경로에 더 가까운 안전한 경로 선택
                                    const originalRouteY = routeY;
                                    if (Math.abs(originalRouteY - safeTop) <= Math.abs(originalRouteY - safeBottom)) {
                                        routeY = safeTop;
                                        finalStartY = Math.min(finalStartY, safeTop);
                                        finalEndY = Math.min(finalEndY, safeTop);
                                    } else {
                                        routeY = safeBottom;
                                        finalStartY = Math.max(finalStartY, safeBottom);
                                        finalEndY = Math.max(finalEndY, safeBottom);
                                    }
                                }
                            }
                            
                            // 최종 경로 생성 (직각 라우팅: 시작점 → 수평 → 수직 → 수평 → 수직 → 끝점)
                            // [핵심 개선] 마커('○', '●') 위치를 정확히 유지하면서 경로 생성
                            // 시작점(finalPathStartX, finalPathStartY)은 마커('○') 위치 - 막대 그래프 시작/끝 중앙
                            // 끝점(finalPathEndX, finalPathEndY)은 마커('●') 위치 - 막대 그래프 시작/끝 중앙
                            const d = `M ${finalPathStartX} ${finalPathStartY} L ${routeStartX} ${finalStartY} L ${routeStartX} ${routeY} L ${routeEndX} ${routeY} L ${routeEndX} ${finalEndY} L ${finalPathEndX} ${finalPathEndY}`;
                            const path = document.createElementNS(svgNS, 'path');
                            path.setAttribute('d', d);
                            path.setAttribute('class', `gantt-dependency-arrow dependency-${dep.type}`);
                            path.setAttribute('data-from', dep.projectId);
                            path.setAttribute('data-to', project.id);
                            path.setAttribute('data-dep-type', dep.type);
                            path.setAttribute('stroke', edgeColor);
                            path.setAttribute('stroke-width', '0.9');
                            path.setAttribute('fill', 'none');
                            path.setAttribute('stroke-dasharray', '6 4');
                            path.setAttribute('stroke-linecap', 'round');
                            path.setAttribute('marker-start', `url(#${startId})`);
                            path.setAttribute('marker-end', `url(#${endId})`);
                            path.setAttribute('id', `dependency-path-${dep.projectId}-${project.id}`);
                            
                            // Create an invisible wider path for easier hover detection
                            const hoverPath = document.createElementNS(svgNS, 'path');
                            hoverPath.setAttribute('d', d); // 동일한 경로 사용
                            hoverPath.setAttribute('fill', 'none');
                            hoverPath.setAttribute('stroke', 'transparent');
                            hoverPath.setAttribute('stroke-width', '12'); // Wider stroke for easier hover
                            hoverPath.setAttribute('data-from', dep.projectId);
                            hoverPath.setAttribute('data-to', project.id);
                            hoverPath.setAttribute('data-dep-type', dep.type);
                            
                            // Create a group to hold both paths with pointer events enabled
                            const pathGroup = document.createElementNS(svgNS, 'g');
                            pathGroup.style.pointerEvents = 'stroke';
                            pathGroup.style.cursor = 'pointer';
                            
                            // Add hoverPath first so it's behind the visible path
                            pathGroup.appendChild(hoverPath);
                            pathGroup.appendChild(path);
                            
                            // Add the group to SVG instead of individual paths
                            svg.appendChild(pathGroup);

                            // Dependency type descriptions for tooltip
                            const dependencyDescriptions = {
                                'start-to-start': {
                                    name: '시작→시작 (SS)',
                                    color: '파란색',
                                    colorCode: '#2563eb',
                                    description: '선행 작업이 시작되면 현재 작업도 동시에 시작됩니다.',
                                    intent: '두 작업이 동시에 시작되어야 하는 경우에 사용합니다.',
                                    purpose: '병렬 작업 시작을 보장하여 전체 프로젝트 일정을 단축합니다.'
                                },
                                'end-to-start': {
                                    name: '종료→시작 (FS)',
                                    color: '녹색',
                                    colorCode: '#10b981',
                                    description: '선행 작업이 완료되면 현재 작업이 시작됩니다.',
                                    intent: '선행 작업의 결과물이 필요하거나 완료 후에만 시작 가능한 경우에 사용합니다.',
                                    purpose: '작업 순서를 보장하여 작업 간 의존성을 명확히 관리합니다. 가장 일반적인 의존성 유형입니다.'
                                },
                                'end-to-end': {
                                    name: '종료→종료 (FF)',
                                    color: '주황색',
                                    colorCode: '#f59e0b',
                                    description: '선행 작업이 완료되면 현재 작업도 동시에 완료됩니다.',
                                    intent: '두 작업이 동시에 완료되어야 하는 경우에 사용합니다.',
                                    purpose: '관련 작업들의 동시 완료를 보장하여 다음 단계로의 전환을 원활하게 합니다.'
                                },
                                'start-to-end': {
                                    name: '시작→종료 (SF)',
                                    color: '빨간색',
                                    colorCode: '#ef4444',
                                    description: '선행 작업이 시작되면 현재 작업이 완료됩니다.',
                                    intent: '특수한 상황에서 선행 작업의 시작을 신호로 사용하는 경우에 사용합니다.',
                                    purpose: '작업 간 특수한 연계 관계를 표현하여 복잡한 프로젝트 일정을 관리합니다.'
                                }
                            };

                            const depInfo = dependencyDescriptions[dep.type] || {
                                name: dep.type,
                                color: '회색',
                                colorCode: edgeColor,
                                description: '의존성 유형 정보가 없습니다.',
                                intent: '',
                                purpose: ''
                            };

                            // Define tooltip functions
                            const showTooltip = function(e) {
                                const tooltip = document.getElementById('dependency-arrow-tooltip');
                                if (!tooltip) return;
                                
                                // Get project names
                                const fromProject = data.find(p => String(p.id) === String(dep.projectId));
                                const toProject = data.find(p => String(p.id) === String(project.id));
                                const fromName = fromProject ? fromProject.name : `ID:${dep.projectId}`;
                                const toName = toProject ? toProject.name : `ID:${project.id}`;
                                
                                // Build tooltip content
                                tooltip.innerHTML = `
                                    <div style="font-weight: 700; font-size: 14px; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.3);">
                                        <span style="display: inline-block; width: 12px; height: 12px; background: ${depInfo.colorCode}; border-radius: 2px; margin-right: 6px; vertical-align: middle;"></span>
                                        ${depInfo.name}
                                    </div>
                                    <div style="margin-bottom: 6px;"><strong>색상:</strong> ${depInfo.color} (${depInfo.colorCode})</div>
                                    <div style="margin-bottom: 6px;"><strong>적용 방법:</strong> ${depInfo.description}</div>
                                    <div style="margin-bottom: 6px;"><strong>의도:</strong> ${depInfo.intent}</div>
                                    <div style="margin-bottom: 6px;"><strong>목적:</strong> ${depInfo.purpose}</div>
                                    <div style="margin-top: 8px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.3); font-size: 12px; color: rgba(255,255,255,0.9);">
                                        <div><strong>선행 작업:</strong> ${fromName}</div>
                                        <div><strong>현재 작업:</strong> ${toName}</div>
                                    </div>
                                `;
                                tooltip.style.display = 'block';
                            };

                            const moveTooltip = function(e) {
                                const tooltip = document.getElementById('dependency-arrow-tooltip');
                                if (!tooltip || tooltip.style.display === 'none') return;
                                
                                // Position tooltip near cursor
                                const offset = 15;
                                tooltip.style.left = (e.clientX + offset) + 'px';
                                tooltip.style.top = (e.clientY + offset) + 'px';
                                
                                // Keep tooltip within viewport
                                const tooltipRect = tooltip.getBoundingClientRect();
                                const viewportWidth = window.innerWidth;
                                const viewportHeight = window.innerHeight;
                                
                                if (tooltipRect.right > viewportWidth) {
                                    tooltip.style.left = (e.clientX - tooltipRect.width - offset) + 'px';
                                }
                                if (tooltipRect.bottom > viewportHeight) {
                                    tooltip.style.top = (e.clientY - tooltipRect.height - offset) + 'px';
                                }
                            };

                            const hideTooltip = function(e) {
                                const tooltip = document.getElementById('dependency-arrow-tooltip');
                                if (tooltip) {
                                    tooltip.style.display = 'none';
                                }
                            };
                            
                            // Attach event handlers to both paths
                            path.addEventListener('mouseenter', showTooltip);
                            path.addEventListener('mousemove', moveTooltip);
                            path.addEventListener('mouseleave', hideTooltip);
                            
                            hoverPath.addEventListener('mouseenter', showTooltip);
                            hoverPath.addEventListener('mousemove', moveTooltip);
                            hoverPath.addEventListener('mouseleave', hideTooltip);

                            // Add the group to SVG now that event handlers are attached
                            svg.appendChild(pathGroup);
                            
                            // [성능 최적화] 렌더링 카운트 증가
                            renderedCount++;

                            // [개선] Flow circles along path using <animateMotion> - 원의 개수 20% 증가, 속도 10% 빠르게
                            const flowCount = 6; // 현재 5개에서 20% 증가: 5 * 1.2 = 6개
                            for (let i=0;i<flowCount;i++){
                                const fc = document.createElementNS(svgNS, 'circle');
                                fc.setAttribute('r', String(flowR));
                                fc.setAttribute('fill', edgeColor);
                                fc.setAttribute('opacity', '0.95');
                                const am = document.createElementNS(svgNS, 'animateMotion');
                                am.setAttribute('dur', '6.3s'); // 현재 7s에서 10% 빠르게: 7 * 0.9 = 6.3s
                                am.setAttribute('repeatCount', 'indefinite');
                                am.setAttribute('begin', `${i * 0.35}s`); // 원의 개수 증가에 맞춰 간격 조정
                                const mpath = document.createElementNS(svgNS, 'mpath');
                                try { mpath.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#${path.getAttribute('id') || ''}`); } catch(e){}
                                if (!path.getAttribute('id')) path.setAttribute('id', `dependency-path-${dep.projectId}-${project.id}`);
                                mpath.setAttribute('href', `#${path.getAttribute('id')}`);
                                am.appendChild(mpath);
                                fc.appendChild(am);
                                svg.appendChild(fc);
                            }
                        });
                    });

                    console.log('[dep-render] Rendered dependencies:', renderedCount, 'out of', totalDependencies);
                    
                    // [성능 최적화] 렌더링 불일치 확인
                    if (renderedCount !== totalDependencies) {
                        console.error(`[dep-render] RENDERING MISMATCH! Expected ${totalDependencies} dependencies but rendered ${renderedCount}`);
                        console.error('[dep-render] This indicates some dependencies were not rendered. Check warnings above.');
                    } else {
                        console.log('[dep-render] All dependencies rendered successfully!');
                    }
                    
                    // [핵심 수정] SVG 추가 - 무조건 추가 (디버깅용)
                    if (barPositions.size > 0) {
                        ganttBody.appendChild(svg);
                        console.log('[dep-render] ✅ SVG appended to DOM');
                        console.log(`[dep-render]   - Rendered dependencies: ${renderedCount}`);
                        console.log(`[dep-render]   - Bar positions: ${barPositions.size}`);
                        console.log(`[dep-render]   - SVG children: ${svg.children.length}`);
                        console.log('[dep-render]   - SVG style:', {
                            position: svg.style.position,
                            zIndex: svg.style.zIndex,
                            visibility: svg.style.visibility || 'visible',
                            display: svg.style.display || 'block'
                        });
                        
                        // DOM에 실제로 추가되었는지 확인
                        setTimeout(() => {
                            const checkSvg = ganttBody.querySelector('.gantt-dependency-svg');
                            if (checkSvg) {
                                const paths = checkSvg.querySelectorAll('path[data-from]');
                                console.log('[dep-render] ✅ SVG confirmed in DOM');
                                console.log(`[dep-render]   - Paths found in DOM: ${paths.length}`);
                            } else {
                                console.error('[dep-render] ❌ SVG NOT FOUND IN DOM AFTER APPEND!');
                            }
                        }, 50);
                    } else {
                        console.error('[dep-render] ❌ NO BAR POSITIONS - SVG not appended');
                    }
                    
                    console.log('[dep-render] ===== FUNCTION COMPLETED =====');
                } catch (e) {
                    // [핵심 수정] 에러 처리 강화
                    console.error('[dep-render] ❌❌❌ ERROR IN renderDependencyArrows ❌❌❌');
                    console.error('[dep-render] Error:', e);
                    console.error('[dep-render] Error message:', e.message);
                    console.error('[dep-render] Error stack:', e.stack);
                    console.error('[dep-render] ===== FUNCTION FAILED =====');
                    // 에러가 발생해도 재시도는 호출 측에서 처리
                    // Fallback to original implementation if available
                    try { if (_origRenderDependencyArrows) _origRenderDependencyArrows.apply(this, arguments); } catch (err){
                        console.error('[dep-render] Fallback also failed:', err);
                    }
                }
            };

            // Utility: allow runtime adjustment of dependency flow speed (seconds)
            window.setDependencyFlowSpeed = function(seconds){
                try {
                    if (!seconds || typeof seconds !== 'number') return;
                    const all = document.querySelectorAll('.gantt-dependency-svg animateMotion');
                    all.forEach(a => {
                        try { a.setAttribute('dur', `${seconds}s`); } catch(e){}
                    });
                } catch (e) { console.warn('[dep-enhance] setDependencyFlowSpeed failed', e); }
            };

            // Observe future additions of dependency SVGs and ensure their animateMotion uses the slower speed
            (function(){
                try {
                    const defaultSpeed = 6.3; // [개선] seconds - 현재 7s에서 10% 빠르게: 7 * 0.9 = 6.3s
                    // Apply immediately
                    window.setDependencyFlowSpeed(defaultSpeed);
                    if (window.MutationObserver) {
                        const obs = new MutationObserver(mutations => {
                            for (const m of mutations) {
                                for (const n of m.addedNodes) {
                                    if (n && n.nodeType === 1) {
                                        const el = n;
                                        if (el.matches && el.matches('.gantt-dependency-svg')) {
                                            const ams = el.querySelectorAll('animateMotion');
                                            ams.forEach(a => { try { a.setAttribute('dur', `${defaultSpeed}s`); } catch(e){} });
                                        } else {
                                            const svg = el.querySelector && el.querySelector('.gantt-dependency-svg');
                                            if (svg) {
                                                const ams = svg.querySelectorAll('animateMotion');
                                                ams.forEach(a => { try { a.setAttribute('dur', `${defaultSpeed}s`); } catch(e){} });
                                            }
                                        }
                                    }
                                }
                            }
                        });
                        obs.observe(document.body || document.documentElement, { childList: true, subtree: true });
                    }
                } catch (e) { console.warn('[dep-enhance] observer init failed', e); }
            })();

            console.info('[dep-enhance] runtime enhancements loaded (remap + orthogonal arrows)');
        } catch (e) {
            console.error('[dep-enhance] init failed', e);
        }
    })();
    </script>


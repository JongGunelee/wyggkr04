<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì”ì—¬ ê³µì‚¬ ê³µì •ê´€ë¦¬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
        }

        
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .gantt-titles .header,
        .gantt-titles .group-header,
        .gantt-titles .title-item {
            letter-spacing: -0.04em;
        }
        .gantt-titles .toggle-col-btn,
        .gantt-titles .group-toggle {
            letter-spacing: normal;
        }
        .gantt-chart-container {
            display: flex;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            height: 100%;
        }
        .gantt-titles {
            flex-shrink: 0;
            border-right: 1px solid #e2e8f0;
            background-color: #f8fafc;
            position: relative;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            --po-col-width: 120px;
            --dates-col-width: 170px;
            --progress-col-width: 70px;
            --progress-summary-col-width: 120px; /* ìƒˆë¡œ ì¶”ê°€ëœ ì§„í–‰ë¥  ìš”ì•½ ì—´ ë„ˆë¹„ */
            --name-padding: 55px;
            isolation: isolate;
        }
        .gantt-titles-body-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }
        .resizer {
            position: absolute;
            top: 0;
            right: -2.5px;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            z-index: 12;
        }
        .resizer:hover {
            background: rgba(100, 116, 139, 0.25);
        }
        .gantt-titles .header {
            font-weight: 700;
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            height: 88px;
            display: flex;
            align-items: center;
            background-color: #fff;
            position: sticky;
            top: 0;
            z-index: 12;
            flex-shrink: 0;
            box-sizing: border-box;
            width: 100%;
        }
        .gantt-titles .group-header {
            font-weight: 600;
            padding: 0 12px;
            height: 32px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            background-color: #f1f5f9;
            font-size: 14px;
        }
        .gantt-titles .group-header:hover {
            background-color: #e2e8f0;
        }
        .gantt-titles .group-toggle {
            display: inline-block;
            width: 20px;
            text-align: center;
        }
        .gantt-titles .title-item {
            padding: 0 12px;
            height: 32px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            border-bottom: 1px solid #f1f5f9;
            white-space: nowrap;
            font-size: 14px;
            box-sizing: border-box;
            width: 100%;
            position: relative;
        }
        .title-item .project-name {
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1 0 auto;
            padding-right: 10px;
            padding-left: 43px;
            box-sizing: border-box;
            width: calc(100% - var(--po-col-width) - var(--dates-col-width) - var(--progress-col-width));
            min-width: 0;
        }
        .title-item .project-po, .title-item .project-progress {
            text-align: right;
            padding-right: 10px;
            font-weight: 500;
            color: #64748b;
            flex-shrink: 0;
        }
        .title-item .project-dates {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            flex-shrink: 0;
            font-size: 13px;
            color: #475569;
        }
        .date-editor, .progress-editor {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: background-color 0.2s, color 0.2s;
        }
        .date-editor {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-weight: 500;
            white-space: nowrap;
        }
        .date-editor:hover, .progress-editor:hover {
            background-color: #e0e7ff;
        }
        .date-editor.date-changed {
            color: #b91c1c;
            font-weight: 700;
            background-color: rgba(248, 113, 113, 0.12);
        }
        .date-editor.date-changed::after {
            content: 'ë³€ê²½';
            font-size: 10px;
            line-height: 1;
            color: #b91c1c;
            background-color: rgba(254, 226, 226, 0.95);
            border-radius: 9999px;
            padding: 2px 6px;
        }
        .date-editor.date-completed {
            color: #9ca3af;
            font-weight: 400;
            background-color: transparent;
        }
        .date-editor.date-completed::after {
            display: none;
        }
        .date-editor.date-completed.date-changed {
            color: #b91c1c;
            font-weight: 700;
            background-color: rgba(248, 113, 113, 0.12);
        }
        .date-editor.date-completed.date-changed::after {
            display: inline-flex;
        }
        .date-editor.editing {
            background-color: #eef2ff;
            color: #312e81;
        }
        .date-edit-form {
            position: absolute;
            z-index: 50;
            top: 100%;
            left: 0;
            margin-top: 6px;
            background: #ffffff;
            border: 1px solid #c7d2fe;
            box-shadow: 0 8px 18px rgba(79, 70, 229, 0.15);
            border-radius: 8px;
            padding: 10px;
            min-width: 190px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .date-edit-form label {
            font-size: 11px;
            font-weight: 600;
            color: #4338ca;
        }
        .date-edit-form input[type="date"],
        .date-edit-form input[type="text"] {
            width: 100%;
            font-size: 12px;
            padding: 6px 8px;
            border: 1px solid #cbd5f5;
            border-radius: 4px;
            background-color: #f8fafc;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .date-edit-form input[type="date"]:focus,
        .date-edit-form input[type="text"]:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.35);
            outline: none;
            background-color: #ffffff;
        }
        .date-edit-helper {
            font-size: 11px;
            color: #64748b;
        }
        .date-edit-original {
            font-size: 11px;
            color: #94a3b8;
        }
        .date-edit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 6px;
        }
        .date-edit-actions button {
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .date-edit-actions .date-edit-save {
            background-color: #4f46e5;
            color: #ffffff;
        }
        .date-edit-actions .date-edit-save:hover {
            background-color: #4338ca;
        }
        .date-edit-actions .date-edit-cancel {
            background-color: #e2e8f0;
            color: #1e293b;
        }
        .date-edit-actions .date-edit-cancel:hover {
            background-color: #cbd5e1;
        }
        .date-input {
            width: 130px;
            font-size: 13px;
            padding: 2px;
            border: 1px solid #6366f1;
            border-radius: 4px;
            text-align: center;
        }
        .progress-input { width: 60px; }
        .gantt-timeline-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            contain: layout style paint;
        }
        .gantt-timeline-header-wrapper {
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
            position: relative; /* Today Marker positioning context */
            contain: layout style paint;
            will-change: transform;
        }
        .gantt-timeline-body-wrapper {
            overflow: auto;
            flex-grow: 1;
            contain: layout style paint;
            will-change: transform;
        }
        .gantt-timeline-header {
            z-index: 11;
            background-color: #fff;
            position: sticky;
            top: 0;
            height: 88px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            width: 100%;
            contain: layout style;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
            -webkit-font-smoothing: antialiased;
        }
        .gantt-year-month-header, .gantt-day-header, .gantt-weekday-header {
            display: flex;
            font-size: 12px;
            font-weight: 500;
            border-bottom: 1px solid #e2e8f0;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        .gantt-weekday-header {
            font-size: 11px;
             color: #64748b;
        }

        .gantt-month, .gantt-day, .gantt-weekday {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-right: 1px solid #e2e8f0;
            box-sizing: border-box;
            position: relative;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
            contain: layout style paint;
        }
        .gantt-month { height: 32px; }
        .gantt-day { height: 32px; }
        .gantt-weekday { height: 24px; }

        .gantt-body {
            position: relative;
        }
        .gantt-bar-row {
            height: 32px;
            border-bottom: 1px solid #f1f5f9;
            position: relative;
            z-index: 2;
            box-sizing: border-box;
            width: 100%;
        }
        .gantt-bar-row.hierarchy-summary-hidden {
            display: none !important;
        }
        .gantt-grid-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 0;
            border-left: 1px solid #e2e8f0;
            z-index: 1;
            pointer-events: none;
            backface-visibility: hidden;
            transform: translate3d(0, 0, 0);
        }
        .gantt-today-marker-container {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 15;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        .gantt-today-marker {
            width: 0;
            height: 100%;
            border-left: 3px dashed #1d4ed8;
            will-change: transform;
            transform: translateZ(0);
        }
        .gantt-today-label {
            position: absolute;
            top: 5px;
            background-color: #1d4ed8;
            color: white;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 4px;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transform: translateZ(0);
        }
        .gantt-bar {
            position: absolute;
            top: 4px;
            height: 24px;
            border-radius: 4px;
            opacity: 0.8;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            overflow: visible; /* [FIX] ë¼ë²¨ì´ ë§‰ëŒ€ ë°–ìœ¼ë¡œ í‘œì‹œë˜ë„ë¡ overflow ìˆ˜ì • */
            white-space: nowrap;
            z-index: 9;
        }
         .gantt-bar-progress {
            position: absolute;
            top: 11px;
            height: 10px;
            border-radius: 2px;
            background-color: rgba(0, 0, 0, 0.35);
            box-shadow: inset 0 1px 1px rgba(0,0,0,0.2);
            z-index: 10;
            pointer-events: none;
            transition: width 0.3s ease-in-out;
        }
        .gantt-bar-progress::after {
            content: attr(data-weighted-value);
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #94a3b8;
            white-space: nowrap;
        }
        .gantt-bar.hidden, .title-item.hidden {
            display: none;
        }
        .gantt-bar:hover {
            opacity: 1;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .tooltip {
            visibility: hidden;
            background-color: #1f2937;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 200;
            bottom: 125%;
            transform: translateX(-50%); /* JSì—ì„œ leftë¥¼ ë™ì ìœ¼ë¡œ ì„¤ì •í•˜ë¯€ë¡œ, ê°€ìš´ë° ì •ë ¬ì„ ìœ„í•´ transformë§Œ ìœ ì§€ */
            opacity: 0;
            transition: opacity 0.3s;
            width: 220px;
            font-size: 12px;
            pointer-events: none;
        }
        /* [FIX] íˆ´íŒì€ í´ë¦­ ì‹œì—ë§Œ ë³´ì´ë„ë¡ ë³€ê²½ */
        .gantt-bar.show-tooltip .tooltip {
            visibility: visible;
            opacity: 1;
        }
        #ganttFloatingTooltip {
            position: fixed;
            background-color: #1f2937;
            color: #fff;
            padding: 10px 12px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.35);
            pointer-events: none;
            z-index: 4000;
            max-width: 280px;
            font-size: 12px;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }
        #ganttFloatingTooltip.visible {
            opacity: 1;
            transform: translateY(0px);
        }
        #ganttHoverTooltip {
            position: fixed;
            background-color: rgba(15, 23, 42, 0.92);
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.3;
            pointer-events: none;
            z-index: 3500;
            opacity: 0;
            transform: translateY(-6px);
            transition: opacity 0.12s ease, transform 0.12s ease;
            max-width: 240px;
            white-space: nowrap;
        }
        #ganttHoverTooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.5); /* íˆ´íŒ ì¤‘ë³µ ë¬¸ì œ í•´ê²° */
            display: flex; justify-content: center; align-items: center;
            z-index: 50;
        }
        .modal-content {
            background-color: white;
            padding: 0;
            border-radius: 0.5rem;
            width: 400px;
            height: auto;
            min-height: 400px;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            resize: both;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
            border-radius: 50%; border-left-color: #4f46e5;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .summary-card {
             cursor: pointer;
             transition: transform 0.2s;
        }
        .summary-card:hover {
            transform: translateY(-4px);
        }
        .row-hover {
            background-color: #fef08a;
        }
        .fullscreen-modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
        }
        .resizable-modal-content {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            position: relative;
            width: 95vw;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .resizable-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e5e7eb;
            flex-shrink: 0;
        }
        .resizable-modal-body {
            flex-grow: 1;
            padding: 1rem;
            overflow: auto;
            display: flex; /* Added for fullscreen layout */
            flex-direction: column; /* Added for fullscreen layout */
        }
        #ganttViewContent {
             height: 100%;
             display: flex;
             flex-direction: column;
        }
        #ganttChartWrapper {
            flex-grow: 1;
             min-height: 0; /* Added for flex grow in column */
        }
        #ganttChartWrapper .gantt-chart-container {
            height: 100%;
        }
        .resizer-handle {
            position: absolute;
            background: transparent;
            z-index: 101;
        }
        .resizer-handle.n { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-handle.s { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-handle.e { top: 0; bottom: 0; right: -5px; width: 10px; cursor: ew-resize; }
        .resizer-handle.w { top: 0; bottom: 0; left: -5px; width: 10px; cursor: ew-resize; }
        .resizer-handle.ne { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-handle.sw { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-handle.nw { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; }
        .resizer-handle.se { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; }

        .header-col {
            display: flex;
            align-items: center;
        }
        .col-resizer {
            flex-shrink: 0;
            width: 6px;
            height: 40px;
            cursor: col-resize;
            background-color: transparent;
            z-index: 13;
            border-left: 1px solid transparent;
            border-right: 1px solid transparent;
            transition: background-color 0.2s;
        }
        .col-resizer:hover {
            background-color: rgba(100, 116, 139, 0.25);
            border-left: 1px solid #cbd5e1;
            border-right: 1px solid #cbd5e1;
        }
        #dataPanel.hidden {
            display: none;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        /* Ensure accordions start collapsed */
        .accordion-item:not(.open) .accordion-content {
            max-height: 0 !important;
            overflow: hidden !important;
        }
        .accordion-item:not(.open) .accordion-content,
        .sub-accordion-item:not(.open) .sub-accordion-content { /* Added sub-accordion */
             max-height: 0;
             overflow: hidden;
             padding-top: 0;
             padding-bottom: 0;
        }
        .accordion-item.open > .accordion-content,
        .sub-accordion-item.open > .sub-accordion-content { /* Added sub-accordion */
            max-height: 5000px; /* Allow expansion */
            transition: max-height 0.5s ease-in;
             /* Padding moved to content grid for sub-accordion */
        }

        /* [MODIFIED] Padding moved from sub-accordion-content.open to the grid inside it */
        .sub-accordion-item.open > .sub-accordion-content > .grid {
             padding-top: 1rem;
             padding-bottom: 1rem;
        }


        .accordion-item.open > .accordion-content.flex-grow {
            max-height: none;
        }
        .accordion-icon, .sub-accordion-icon, .control-section-icon { /* Added sub-accordion and control */
            transition: transform 0.3s ease;
        }
        .accordion-item.open > .accordion-header .accordion-icon,
        .sub-accordion-item.open > .sub-accordion-header .sub-accordion-icon, /* Added sub-accordion */
        .control-section-header.open .control-section-icon { /* Added control */
            transform: rotate(180deg);
        }

        /* Styles for sub-accordion in Settlement section */
        .sub-accordion-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0; /* Adjust padding as needed */
        }
        .sub-accordion-content {
             max-height: 0;
             overflow: hidden;
             transition: max-height 0.3s ease-out;
             /* Removed padding-top/bottom here, handled by .open */
        }
        /* End of sub-accordion styles */
        
        /* Main settlement accordion styles */
        .main-settlement-accordion-item {
            transition: all 0.3s ease;
        }
        
        .main-settlement-header {
            transition: background-color 0.2s ease;
        }
        
        .main-settlement-icon {
            transition: transform 0.3s ease;
        }
        
        .main-settlement-accordion-item.expanded .main-settlement-icon {
            transform: rotate(180deg);
        }
        
        .main-settlement-accordion-item.collapsed .main-settlement-icon {
            transform: rotate(0deg);
        }
        
        /* Settlement section scroll behavior
           Use available viewport space (subtract header/controls chrome) so the inner
           container can always show a scrollbar when content overflows even when
           the overall page scrolling is prevented (body { overflow: hidden }). */
        .settlement-scrollable {
            max-height: calc(100vh - 220px);
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }
        
        /* Enhanced scroll behavior for settlement section */
        .settlement-scrollable:hover {
            overflow-y: auto;
        }
        
        /* Ensure scrollbar is always visible when content overflows */
        .settlement-scrollable:not(:hover) {
            overflow-y: auto;
        }
        
        .settlement-scrollable::-webkit-scrollbar {
            width: 8px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        
        .settlement-scrollable::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Styles for control section toggles */
        .control-section-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 0.5rem;
        }
         .control-section-header h3 {
             margin-bottom: 0; /* Remove default margin */
         }
        .control-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding-top: 0;
            padding-bottom: 0;
        }
        .control-section-header.open + .control-section-content {
            max-height: 1000px; /* Adjust as needed */
            transition: max-height 0.5s ease-in, padding 0.5s ease-in;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        /* End control section styles */


        .milestone-track {
            height: 40px;
            position: sticky;
            top: 0;
            border-bottom: 1px solid #e2e8f0;
            background: #fff;
            z-index: 6;
            display: flex;
            align-items: center;
        }
        .milestone-title-row {
            height: 40px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            font-weight: 600;
            gap: 8px;
            padding: 0 8px;
            position: sticky;
            top: 0;
            background: #fff;
            z-index: 7;
        }
        .milestone-title-row span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            color: #1f2937;
        }
        .change-label {
            display: inline-flex;
            align-items: center;
            font-size: 0.75rem;
            font-weight: 700;
            color: #dc2626;
            margin-left: 6px;
            border: 1px solid #dc2626;
            border-radius: 999px;
            padding: 0 6px;
            line-height: 1.2;
        }
        .filter-toggle-btn {
            transition: all 0.2s ease;
        }
        .filter-toggle-btn.filter-toggle-active {
            background-color: #dbeafe !important;
            border: 2px solid #2563eb;
            color: #1e40af;
            font-weight: 600;
        }
        .milestone-marker {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 20px;
            height: 20px;
            background-color: #e11d48;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            cursor: pointer;
            z-index: 15;
        }
         .milestone-marker .tooltip {
            transform: translate(-50%, 0) rotate(-45deg);
            bottom: 25px;
        }
        #progressPopup {
            /* [FIX] Increased z-index to appear above fullscreen modal */
            z-index: 150 !important;
        }
        /* ê°œì„  ì‚¬í•­ 2: ê°„íŠ¸ ë°” ìœ„ì— í‘œì‹œë  ì´ë¦„ ë¼ë²¨ */
        .gantt-bar-label {
            position: absolute;
            bottom: 100%;
            left: 0;
            margin-bottom: 4px;
            background-color: rgba(31, 41, 55, 0.85); /* bg-gray-800/85 */
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
        }
        .gantt-bar-label { z-index: 30; } /* ë¼ë²¨ì´ ë‹¤ë¥¸ ìš”ì†Œ ìœ„ì— í•­ìƒ í‘œì‹œë˜ë„ë¡ z-index ì¶”ê°€ */
        .gantt-bar:hover .gantt-bar-label {
            visibility: visible;
            opacity: 1;
        }
        #progressPopup {
            /* [FIX] Increased z-index to appear above fullscreen modal */
            z-index: 150 !important;
        }
        #progressPopup button.progress-val-btn {
            width: 100%;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 0.375rem;
            transition: all 0.2s;
            background-color: #f3f4f6;
            color: #374151;
        }
        #progressPopup button.progress-val-btn:hover {
            background-color: #6366f1;
            color: white;
        }
        #progressPopup button.progress-val-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        #progressPopup .progress-input-area {
            grid-column: span 4 / span 4;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-top: 0.5rem;
            border-top-width: 1px;
            margin-top: 0.25rem;
        }
        #progressPopup .progress-input-area input {
            width: 100%;
            padding: 0.25rem;
            border-width: 1px;
            border-radius: 0.25rem;
        }
        #progressPopup .progress-input-area button {
            padding: 0.25rem 0.75rem;
            background-color: #6366f1;
            color: white;
            border-radius: 0.25rem;
            font-size: 0.75rem;
        }
        #progressPopup .progress-input-area button:hover {
            background-color: #4f46e5;
        }
        .search-highlight {
            background-color: #fde047;
            border-radius: 2px;
        }
        #mappingPreviewContainer table, #errorCorrectionContainer table {
            font-size: 0.8rem;
        }
        #mappingPreviewContainer th, #mappingPreviewContainer td,
        #errorCorrectionContainer th, #errorCorrectionContainer td {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            padding: 0.5rem;
        }
        #mappingPreviewContainer th, #errorCorrectionContainer th {
            position: sticky;
            top: 0;
            background: #f3f4f6;
        }
        #mappingPreviewContainer select {
            width: 100%;
            font-size: 0.75rem;
        }
        .error-input {
            border-color: #ef4444 !important; /* red-500 */
            box-shadow: 0 0 0 1px #ef4444;
        }
        /* Improved Toast Container */
        #toast-container {
            position: fixed;
            bottom: 1.25rem;
            right: 1.25rem;
            display: flex;
            flex-direction: column-reverse;
            gap: 0.75rem;
            z-index: 1000;
            max-height: 100vh;
            overflow-y: auto;
            padding: 1rem;
            pointer-events: none;
        }
        
        .toast {
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            color: white;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
            min-width: 300px;
            max-width: 500px;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .toast:hover {
            transform: translateX(-5px);
            box-shadow: 0 15px 20px -3px rgba(0, 0, 0, 0.15), 0 6px 8px -2px rgba(0, 0, 0, 0.1);
        }
        
        .toast-success { 
            background-color: #22c55e;
            border-left: 4px solid #16a34a;
        }
        
        .toast-error { 
            background-color: #ef4444;
            border-left: 4px solid #dc2626;
        }
        
        .toast-info { 
            background-color: #3b82f6;
            border-left: 4px solid #2563eb;
        }
        
        .toast-warning { 
            background-color: #f97316;
            border-left: 4px solid #ea580c;
        }

        .scrollable-accordion.open > .accordion-content {
            /* Keep explicit display to satisfy linters; actual scroll behavior handled elsewhere */
            display: block;
        }

        /* Improvement: Styles for focused accordion item */
        .accordion-item.is-focused {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .accordion-title-btn {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            user-select: none;
            transition: color 0.2s ease, transform 0.2s ease;
            border-radius: 0.375rem;
            padding: 0.15rem 0.35rem;
        }
        .accordion-title-btn:hover,
        .accordion-title-btn:focus-visible {
            color: #4338ca;
            background: rgba(99, 102, 241, 0.08);
        }
        .accordion-title-btn:focus-visible {
            outline: 2px solid rgba(99, 102, 241, 0.6);
            outline-offset: 2px;
        }
        .accordion-item.open .accordion-title-btn {
            color: #1d4ed8;
        }
        .accordion-hint-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            padding: 0.2rem 0.6rem;
            border-radius: 9999px;
            border: 1px dashed rgba(99, 102, 241, 0.6);
            background: rgba(129, 140, 248, 0.1);
            color: #4338ca;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            animation: accordionHintPulse 1.6s infinite;
            white-space: nowrap;
        }
        .accordion-hint-chip.hint-hidden {
            display: none;
        }
        .accordion-hint-chip.hint-visible {
            opacity: 1;
            transform: translateY(0);
        }
        @keyframes accordionHintPulse {
            0% { box-shadow: 0 0 0 0 rgba(129,140,248,0.4); }
            70% { box-shadow: 0 0 0 8px rgba(129,140,248,0); }
            100% { box-shadow: 0 0 0 0 rgba(129,140,248,0); }
        }
        .accordion-state-pill {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            padding: 0.15rem 0.55rem;
            border-radius: 9999px;
            border: 1px solid rgba(59,130,246,0.4);
            background: rgba(191,219,254,0.4);
            color: #1d4ed8;
            margin-left: 0.5rem;
            transition: transform 0.25s ease, background 0.25s ease, color 0.25s ease, border-color 0.25s ease;
        }
        .accordion-state-pill[data-state="open"] {
            background: rgba(34,197,94,0.18);
            color: #047857;
            border-color: rgba(16,185,129,0.5);
        }
        .accordion-state-pill[data-state="closed"] {
            background: rgba(191,219,254,0.5);
            color: #1d4ed8;
            border-color: rgba(59,130,246,0.45);
        }

        /* [REPLACED] - Start of accordion scroll fix */
        /* Focused content that should FILL the space (e.g., Gantt) */
        .accordion-item.is-focused > .accordion-content.flex-grow {
            flex-grow: 1;
            overflow-y: auto; /* Changed from hidden to auto */
            max-height: none !important;
        }

        /* Focused content that should SCROLL (e.g., Overview, Settlement) */
        .accordion-item.is-focused > .accordion-content.scrollable-content {
            flex-grow: 1; /* Grow to fill the 'is-focused' item's space */
            overflow-y: auto; /* Enable vertical scrolling */
            max-height: none; /* [FIX] Allow content to overflow and scroll by removing height constraint in focused mode */
        }

        /* Fallback for any other focused content (though all should be one of the above) */
        .accordion-item.is-focused > .accordion-content:not(.flex-grow):not(.scrollable-content) {
            flex-grow: 1;
            overflow-y: auto;
        }
        /* [REPLACED] - End of accordion scroll fix */

        /* Fullscreen Legend Style */
        #fullscreenModalBody > .controls-section {
             background-color: white;
             padding: 1rem;
             border-radius: 0.5rem;
             box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
             margin-bottom: 1rem;
             flex-shrink: 0;
        }
		/* Legend selection highlight */
		.legend-section [data-status-filter].legend-filter-active {
			background-color: rgba(59, 130, 246, 0.12);
			border-radius: 0.375rem;
            border: 2px solid transparent;
		}
        .legend-section [data-status-filter] {
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
        }
        .legend-section [data-status-filter].legend-filter-active {
            border-color: #ef4444;
            animation: legendBlink 1s linear infinite;
        }
        @keyframes legendBlink {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.6); }
            50% { box-shadow: 0 0 0 6px rgba(239,68,68,0); }
        }
        #shortcutContainer .shortcut-item.active-shortcut {
            border: 2px solid #ef4444;
            border-radius: 0.5rem;
            animation: legendBlink 1s linear infinite;
        }
		
		/* ê°œì„  ì‚¬í•­: ë‚ ì§œ ë²”ë¡€ í•­ëª© ìŠ¤íƒ€ì¼ (í¬ê¸° 80%, ê·¸ë£¹í™” ìƒ‰ìƒ) */
		.legend-section [data-status-filter="ì˜¤ëŠ˜ì‹œì‘"],
		.legend-section [data-status-filter="ì˜¤ëŠ˜ì¢…ë£Œ"],
		.legend-section [data-status-filter="ë‚´ì¼ì‹œì‘"],
		.legend-section [data-status-filter="ë‚´ì¼ì¢…ë£Œ"] {
			transform: scale(0.8);
			transform-origin: center;
		}
		
		/* ì˜¤ëŠ˜ ê·¸ë£¹ ìƒ‰ìƒ ê·¸ë£¹í™” (íŒŒë€ìƒ‰ ê³„ì—´) */
		.legend-section [data-status-filter="ì˜¤ëŠ˜ì‹œì‘"] {
			background-color: rgba(96, 165, 250, 0.15);
			border-left: 3px solid rgb(96, 165, 250);
			padding-left: 0.5rem;
			border-radius: 0.25rem;
		}
		.legend-section [data-status-filter="ì˜¤ëŠ˜ì¢…ë£Œ"] {
			background-color: rgba(59, 130, 246, 0.15);
			border-left: 3px solid rgb(59, 130, 246);
			padding-left: 0.5rem;
			border-radius: 0.25rem;
		}
		
		/* ë‚´ì¼ ê·¸ë£¹ ìƒ‰ìƒ ê·¸ë£¹í™” (ë³´ë¼ìƒ‰ ê³„ì—´) */
		.legend-section [data-status-filter="ë‚´ì¼ì‹œì‘"] {
			background-color: rgba(196, 181, 253, 0.2);
			border-left: 3px solid rgb(196, 181, 253);
			padding-left: 0.5rem;
			border-radius: 0.25rem;
		}
		.legend-section [data-status-filter="ë‚´ì¼ì¢…ë£Œ"] {
			background-color: rgba(147, 51, 234, 0.15);
			border-left: 3px solid rgb(147, 51, 234);
			padding-left: 0.5rem;
			border-radius: 0.25rem;
		}
        
        /* ê°œì„  ì‚¬í•­ 1: ë°”ë¡œê°€ê¸° ë©”ë‰´ ìŠ¤íƒ€ì¼ */
        .pinnable-control-wrapper {
            position: relative;
        }
        .pin-shortcut-btn {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background-color: #e5e7eb;
            color: #6b7280;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.5;
            z-index: 10;
        }
        .pinnable-control-wrapper:hover .pin-shortcut-btn {
            opacity: 1;
        }
        .pin-shortcut-btn.pinned {
            background-color: #4f46e5;
            color: white;
            opacity: 1;
        }
        #shortcutContainer {
            display: flex;
            align-items: center;
            gap: 0.4rem 0.5rem;
            margin-left: 0.5rem;
            flex-wrap: wrap;
            align-content: flex-start;
        }
        #shortcutContainer > * {
            flex-shrink: 0;
        }
        #shortcutContainer .shortcut-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.15rem;
            transition: transform 0.15s ease;
        }
        #shortcutContainer .shortcut-item[data-shortcut-id="toggleHierarchyOrderBtn"] {
            margin-left: 0.35rem;
            margin-right: 0.5rem;
        }
        .shortcut-item:hover {
            transform: translateY(-1px);
        }
        #shortcutContainer .shortcut-item select,
        #shortcutContainer .shortcut-item input,
        #shortcutContainer .shortcut-item button {
             font-size: 0.875rem;
             padding: 0.25rem 0.75rem;
             min-height: 28px;
             border-radius: 4px;
             border: 1px solid #e5e7eb;
             transition: all 0.2s ease;
        }
        #shortcutContainer .shortcut-item select:hover,
        #shortcutContainer .shortcut-item input:hover,
        #shortcutContainer .shortcut-item button:hover {
            border-color: #6366f1;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #shortcutContainer .shortcut-item select:focus,
        #shortcutContainer .shortcut-item input:focus,
        #shortcutContainer .shortcut-item button:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(99,102,241,0.2);
        }
        #shortcutContainer .shortcut-item input[type="text"] {
             width: 150px;
        }
        #shortcutContainer .shortcut-item button.js-zoom-btn {
            background-color: #f3f4f6;
            color: #4b5563;
            font-weight: 500;
        }
        #shortcutContainer .shortcut-item button.js-zoom-btn:hover {
            background-color: #e5e7eb;
            color: #1f2937;
        }

        /* Compact "ìœ í˜•" ë° "ì‹œê³µì‚¬" shortcut: ë¼ë²¨ ì œëª©ì´ í‘œì‹œë˜ëŠ” ìµœì†Œ ë„ˆë¹„ */
        #shortcutContainer .shortcut-type-small-wrapper,
        #shortcutContainer .shortcut-contractor-small-wrapper {
            display: inline-block;
            max-width: 70px; /* 'ì‹œê³µì‚¬', 'ìœ í˜•' ê¸€ìê°€ í‘œì‹œë˜ëŠ” ë„ˆë¹„ */
            overflow: hidden;
            vertical-align: middle;
        }
        #shortcutContainer .shortcut-type-small,
        #shortcutContainer .shortcut-contractor-small {
            width: 70px;
            max-width: 70px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            -webkit-appearance: none; /* better visual consistency */
            appearance: none;
        }
        /* Compact "ì§„ì²™ë¥ " ë° "ì •ë ¬" shortcut: ë¼ë²¨ ì œëª©ì´ í‘œì‹œë˜ëŠ” ìµœì†Œ ë„ˆë¹„ */
        #shortcutContainer .shortcut-progress-small-wrapper,
        #shortcutContainer .shortcut-sort-small-wrapper {
            display: inline-block;
            max-width: 70px; /* 'ì§„ì²™ë¥ ', 'ì •ë ¬' ê¸€ìê°€ í‘œì‹œë˜ëŠ” ë„ˆë¹„ */
            overflow: hidden;
            vertical-align: middle;
        }
        #shortcutContainer .shortcut-progress-small,
        #shortcutContainer .shortcut-sort-small {
            width: 70px;
            max-width: 70px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            -webkit-appearance: none; /* better visual consistency */
            appearance: none;
        }
        @media (max-width: 768px) {
            #shortcutContainer .shortcut-type-small-wrapper,
            #shortcutContainer .shortcut-type-small,
            #shortcutContainer .shortcut-contractor-small-wrapper,
            #shortcutContainer .shortcut-contractor-small,
            #shortcutContainer .shortcut-progress-small-wrapper,
            #shortcutContainer .shortcut-progress-small,
            #shortcutContainer .shortcut-sort-small-wrapper,
            #shortcutContainer .shortcut-sort-small {
                width: 80px;
                max-width: 80px;
            }
        }

        .sort-control-wrapper {
            position: relative;
        }
        .sort-control-inner {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }
        .sort-direction-toggle {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 2px 6px;
            font-size: 0.75rem;
            line-height: 1;
            background-color: #f9fafb;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 32px;
            min-height: 40px;
        }
        .sort-direction-toggle .sort-arrow {
            opacity: 0.4;
            font-size: 0.75rem;
            line-height: 1.1;
        }
        .sort-direction-toggle .sort-arrow.active {
            opacity: 1;
            color: #4c1d95;
            font-weight: 600;
        }
        .sort-direction-toggle:hover {
            border-color: #7c3aed;
            color: #4338ca;
            background-color: #f3e8ff;
        }
        .sort-direction-toggle--disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #e5e7eb;
            background-color: #f3f4f6;
        }
        .sort-direction-toggle--disabled .sort-arrow {
            opacity: 0.25;
        }
        #shortcutContainer .shortcut-sort-small-wrapper.sort-control-wrapper {
            max-width: 110px;
        }
        #shortcutContainer .shortcut-sort-small-wrapper .sort-control-inner {
            gap: 4px;
        }
        #shortcutContainer .shortcut-sort-small-wrapper .shortcut-sort-small {
            flex: 1 1 auto;
            width: auto;
            max-width: none;
        }
        #shortcutContainer .shortcut-sort-small-wrapper .sort-direction-toggle {
            min-width: 28px;
            min-height: 34px;
            font-size: 0.65rem;
        }

    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="w-full h-full p-4 md:p-8 flex flex-col">
        <!-- Main content area -->
        <main id="dashboardContent" class="flex flex-col flex-grow min-h-0 space-y-4">

            <!-- Accordion 1: ì´ê´„ -->
            <div class="accordion-item bg-white rounded-lg shadow-sm flex-shrink-0">
                <div class="accordion-header p-4 flex justify-between items-center border-b">
                    <h2 class="accordion-title-btn text-2xl font-bold flex items-baseline"
                        role="button"
                        tabindex="0"
                        aria-expanded="false"
                        aria-controls="accordion-panel-overview"
                        data-accordion-id="overview">
                        <span>ğŸ“Š ì´ê´„</span>
                        <span class="text-lg font-medium text-gray-400 ml-2">(POë¹„ìš© ê¸°ì¤€)</span>
                        <span class="accordion-hint-chip hint-hidden" data-accordion-hint="overview">
                            <span aria-hidden="true">ğŸ‘†</span>
                            <span>í´ë¦­í•˜ë©´ í¼ì³ì ¸ìš”</span>
                        </span>
                        <span class="accordion-state-pill" data-accordion-state="overview" data-state="closed" aria-live="polite">ì ‘í˜</span>
                    </h2>
                    <svg class="accordion-icon w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                 <!-- Improvement: Added scrollable-content class -->
                <div id="accordion-panel-overview" class="accordion-content p-4 scrollable-content">
                    <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-4">
                        <div class="summary-card bg-slate-100 border-l-4 border-slate-500 text-slate-700 p-4 rounded-lg shadow" data-filter-type="progress" data-filter-value="overall">
                            <div class="font-bold text-lg">ì´ê´„ ê³µì •ìœ¨</div>
                            <div id="overallProgress" class="text-3xl font-extrabold">0%</div>
                            <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                                <div id="overallProgressBar" class="bg-slate-600 h-2.5 rounded-full" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="summary-card bg-sky-100 border-l-4 border-sky-500 text-sky-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="all">
                            <div class="font-bold text-lg">ì „ì²´</div><div id="totalProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="ê³µì‚¬ì¤‘">
                            <div class="font-bold text-lg">ì§„í–‰ì¤‘</div><div id="inProgressProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-gray-100 border-l-4 border-gray-500 text-gray-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="ì°©ê³µì „">
                            <div class="font-bold text-lg">ì°©ê³µì „</div><div id="beforeStartProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                        <div class="summary-card bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="ì§€ì—°">
                            <div class="font-bold text-lg">ì§€ì—°</div><div id="delayedProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                         <div class="summary-card bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded-lg shadow" data-filter-type="status" data-filter-value="ì™„ë£Œ">
                            <div class="font-bold text-lg">ì™„ë£Œ</div><div id="completedProjects" class="text-3xl font-extrabold">0</div>
                        </div>
                    </div>
                    <!-- í˜„ì¬ ìš”ì•½ì´ ì–´ë–¤ í•„í„°(ì˜ˆ: ê³ ê°ì‚¬) ê¸°ì¤€ì¸ì§€ ì•Œë ¤ì£¼ëŠ” ë¼ë²¨ (ëˆˆì— íŠ€ì§€ ì•Šë„ë¡ ì—°í•œ ìƒ‰ìƒ) -->
                    <div id="summaryFilterLabel" class="mt-2 text-sm text-gray-500">í•„í„°: ì „ì²´</div>
                    <div id="overview-group-summaries" class="mt-4 space-y-4"></div>
                </div>
            </div>

            <!-- Accordion 2: ì •ì‚° -->
            <div class="accordion-item bg-white rounded-lg shadow-sm flex-shrink-0">
                <div class="accordion-header p-4 flex items-center border-b">
                    <h2 class="accordion-title-btn text-2xl font-bold flex items-baseline"
                        role="button"
                        tabindex="0"
                        aria-expanded="false"
                        aria-controls="accordion-panel-settlement"
                        data-accordion-id="settlement">
                        <span>ğŸ’° ì •ì‚°</span>
                        <span class="text-lg font-medium text-gray-400 ml-2">(POë¹„ìš© ê¸°ì¤€)</span>
                        <span class="accordion-hint-chip hint-hidden" data-accordion-hint="settlement">
                            <span aria-hidden="true">ğŸ‘†</span>
                            <span>ì •ì‚° ë‚´ìš©ì„ í¼ì³ë³´ì„¸ìš”</span>
                        </span>
                        <span class="accordion-state-pill" data-accordion-state="settlement" data-state="closed" aria-live="polite">ì ‘í˜</span>
                    </h2>
                    <div id="settlement-header-summaries" class="ml-auto text-right text-xl font-semibold text-gray-600"></div>
                    <svg class="accordion-icon w-6 h-6 flex-shrink-0 ml-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                 <!-- Improvement: Added scrollable-content class -->
                <div id="accordion-panel-settlement" class="accordion-content p-4 scrollable-content settlement-scrollable">
                    <div id="poSummary" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4"></div>
                    <!-- ê°œì„  ì‚¬í•­ 1: ê¸ˆì•¡ëŒ€ë³„ í”„ë¡œì íŠ¸ í˜„í™© ì„¹ì…˜ ì¶”ê°€ -->
                    <div id="poRangeSummary" class="mt-6"></div>
                    <!-- ê°œì„  ì‚¬í•­ 1: ì •ì‚° íš¨ìœ¨ ë¶„ì„ ì„¹ì…˜ ì¶”ê°€ -->
                    <div id="settlementEfficiencyAnalysis" class="mt-6"></div>
                    <div id="settlement-group-summaries" class="mt-4 space-y-4"></div> <!-- Added space-y-4 -->
                </div>
            </div>

            <!-- Accordion 3: ì¼ì • -->
            <div id="projectView" class="accordion-item bg-white rounded-lg shadow-sm flex flex-col flex-grow min-h-0">
                 <div class="accordion-header p-4 flex justify-between items-center border-b">
                     <div class="flex items-center flex-grow">
                        <h2 class="accordion-title-btn text-2xl font-bold transition-colors"
                            role="button"
                            tabindex="0"
                            aria-expanded="false"
                            aria-controls="accordion-panel-schedule"
                            data-accordion-id="schedule"
                            style="user-select: none;">
                            <span>ğŸ—“ï¸ ì¼ì •</span>
                            <span class="accordion-hint-chip hint-hidden" data-accordion-hint="schedule">
                                <span aria-hidden="true">ğŸ‘†</span>
                                <span>íƒ€ì„ë¼ì¸ì„ ì—´ì–´ë³´ì„¸ìš”</span>
                            </span>
                            <span class="accordion-state-pill" data-accordion-state="schedule" data-state="closed" aria-live="polite">ì ‘í˜</span>
                        </h2>
                        <!-- ê°œì„  ì‚¬í•­: ë°œì£¼ì²˜ì™€ ì‹œê³µì‚¬ ë°”ë¡œê°€ê¸° ì¶”ê°€ -->
                        <div class="flex items-center gap-2 ml-4" style="pointer-events: auto;">
                            <select id="header-customer-filter-shortcut" class="px-3 py-1 text-sm border border-gray-300 rounded hover:border-violet-500 focus:ring-2 focus:ring-violet-500 focus:border-violet-500 bg-white" style="pointer-events: auto;">
                                <option value="all">ë°œì£¼ì²˜</option>
                            </select>
                            <select id="header-contractor-filter-shortcut" class="px-3 py-1 text-sm border border-gray-300 rounded hover:border-violet-500 focus:ring-2 focus:ring-violet-500 focus:border-violet-500 bg-white" style="pointer-events: auto;">
                                <option value="all">ì‹œê³µì‚¬</option>
                            </select>
                        </div>
                     </div>
                     <svg class="accordion-icon w-6 h-6 flex-shrink-0 cursor-pointer" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                 </div>
                  <!-- Marked as flex-grow for layout -->
                 <div id="accordion-panel-schedule" class="accordion-content flex-grow flex flex-col min-h-0">
                    <div class="p-4 flex-grow flex flex-col min-h-0">
                        <div id="ganttViewContent" class="flex flex-col flex-grow min-h-0 h-full">
                            <!-- ê°œì„  ì‚¬í•­: ë²”ë¡€(Legend) ì„¹ì…˜ì„ ì»¨íŠ¸ë¡¤ íŒ¨ë„ ë°–ìœ¼ë¡œ ì´ë™ -->
                            <div id="legendSection" class="legend-section flex items-center gap-x-6 gap-y-2 border p-4 mb-4 rounded-lg shadow-md bg-white w-full flex-wrap">
                                <h3 class="text-lg font-semibold flex-shrink-0 flex items-center gap-3">
                                    <span>ë²”ë¡€</span>
                                    <div class="flex items-center gap-2 flex-wrap">
                                        <button id="fullscreenBtn" class="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 flex-shrink-0">ì „ì²´ í™”ë©´</button>
                                        <button id="legendGoToTodayBtn" class="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 flex-shrink-0">ì˜¤ëŠ˜</button>
                                        <button id="milestoneBtn" class="px-3 py-1 bg-rose-500 text-white text-sm rounded hover:bg-rose-600 flex-shrink-0">ë§ˆì¼ìŠ¤í†¤</button>
                                    </div>
                                </h3>
                                <div id="shortcutContainer" class="flex items-center gap-2 flex-shrink-0"></div>
                                <div class="flex flex-wrap items-center gap-x-4 gap-y-1">
								<div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ì „ì²´">
									<span class="w-4 h-4 rounded" style="background: linear-gradient(90deg, rgb(156, 163, 175), rgb(59, 130, 246), rgb(239, 68, 68), rgb(34, 197, 94));"></span>
									<span class="text-sm">ì „ì²´ <span id="legendAll" class="font-mono text-gray-500"></span></span>
								</div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ì°©ê³µì „">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(156, 163, 175);"></span>
                                        <span class="text-sm">ì°©ê³µì „ <span id="legendNotStarted" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ê³µì‚¬ì¤‘">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(59, 130, 246);"></span>
                                        <span class="text-sm">ê³µì‚¬ì¤‘ <span id="legendInProgress" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ì˜¤ëŠ˜ì‹œì‘">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(96, 165, 250);"></span>
                                        <span class="text-sm">ì˜¤ëŠ˜ ì‹œì‘ <span id="legendTodayStart" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ì˜¤ëŠ˜ì¢…ë£Œ">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(59, 130, 246);"></span>
                                        <span class="text-sm">ì˜¤ëŠ˜ ì¢…ë£Œ <span id="legendTodayEnd" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ë‚´ì¼ì‹œì‘">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(196, 181, 253);"></span>
                                        <span class="text-sm">ë‚´ì¼ ì‹œì‘ <span id="legendTomorrowStart" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ë‚´ì¼ì¢…ë£Œ">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(147, 51, 234);"></span>
                                        <span class="text-sm">ë‚´ì¼ ì¢…ë£Œ <span id="legendTomorrowEnd" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ì§€ì—°">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(239, 68, 68);"></span>
                                        <span class="text-sm">ì§€ì—° <span id="legendDelayed" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2 cursor-pointer p-1 rounded-md transition-colors hover:bg-gray-100" data-status-filter="ì™„ë£Œ">
                                        <span class="w-4 h-4 rounded" style="background-color: rgb(34, 197, 94);"></span>
                                        <span class="text-sm">ì™„ë£Œ <span id="legendCompleted" class="font-mono text-gray-500"></span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="w-4 h-4 rounded" style="background: linear-gradient(90deg, rgb(156, 163, 175), rgb(59, 130, 246), rgb(34, 197, 94));"></span>
                                        <span class="text-sm">ê·¸ë£¹ ì§„í–‰ë¥  <span id="legendGroupProgress" class="font-mono text-gray-500"></span></span>
                                    </div>
                                </div>
                            </div>

                            <div id="ganttChartWrapper" class="flex-grow min-h-0">
                                <div id="ganttChart" class="space-y-6 bg-white h-full"></div>
                            </div>
                        </div>
                    </div>
                 </div>
            </div>
        </main>
    </div>

    <!-- ê°œì„  ì‚¬í•­: ì„¤ì •(ì»¨íŠ¸ë¡¤) ìŠ¬ë¼ì´ë“œ íŒ¨ë„ -->
    <div id="controlsPanelOverlay" class="fixed inset-0 bg-black bg-opacity-40 z-[130] hidden transition-opacity duration-300"></div>
    <div id="controlsPanel" class="fixed top-0 right-0 h-full bg-white shadow-2xl z-[140] transform translate-x-full transition-transform duration-300 ease-in-out w-full max-w-sm">
        <div class="flex justify-between items-center p-4 border-b">
            <h2 class="text-xl font-bold">í•„í„° ë° íƒ€ì„ë¼ì¸ ì„¤ì •</h2>
            <button id="closeControlsPanelBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
        </div>
        <div class="p-4 overflow-y-auto h-[calc(100%-65px)]">
            <!-- ê¸°ì¡´ Controls Sectionì´ ì´ê³³ìœ¼ë¡œ ì´ë™ -->
            <section id="controlsSection">
                <!-- Filtering & Sorting Toggle -->
                <div class="control-section-header open">
                    <h3 class="text-lg font-semibold">í•„í„°ë§ ë° ì •ë ¬</h3>
                    <svg class="control-section-icon w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="control-section-content">
                    <div class="flex flex-col gap-4">
                        <div class="pinnable-control-wrapper">
                            <select id="progressFilter" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                <option value="all">ì§„ì²™ë¥ </option>
                                <option value="not_started">ë¯¸ì°©ìˆ˜ (0%)</option>
                                <option value="in_progress">ì§„í–‰ì¤‘ (1-99%)</option>
                                <option value="completed">ì™„ë£Œ (100%)</option>
                            </select>
                        </div>
                        <div class="pinnable-control-wrapper">
                            <select id="taskTypeFilter" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                <option value="all">ìœ í˜•</option>
                            </select>
                        </div>
                        <div id="customFilterContainer" class="flex flex-col gap-4"></div>
                        <div class="pinnable-control-wrapper sort-control-wrapper">
                            <div class="sort-control-inner">
                                <select id="sortBy" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                    <option value="default">ì •ë ¬</option>
                                    <option value="startDate">ì‹œì‘ì¼ ìˆœ</option>
                                    <option value="endDate">ì¢…ë£Œì¼ ìˆœ</option>
                                    <option value="duration">ê¸°ê°„ ìˆœ</option>
                                    <option value="progress">ì§„í–‰ ìˆœ</option>
                                </select>
                                <button type="button"
                                        class="sort-direction-toggle"
                                        data-sort-target="sortBy"
                                        aria-label="ì •ë ¬ ë°©í–¥ ì „í™˜"
                                        title="ì •ë ¬ ë°©í–¥ ì „í™˜">
                                    <span class="sort-arrow sort-arrow-up" aria-hidden="true">â–²</span>
                                    <span class="sort-arrow sort-arrow-down" aria-hidden="true">â–¼</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Timeline Toggle -->
                <div class="control-section-header open mt-4">
                    <h3 class="text-lg font-semibold">íƒ€ì„ë¼ì¸</h3>
                    <svg class="control-section-icon w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="control-section-content">
                    <div class="flex flex-col gap-4">
                         <div class="relative pinnable-control-wrapper">
                            <div class="relative">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 pointer-events-none" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                                </svg>
                                <input type="text" id="searchInput" placeholder="ê²€ìƒ‰..." class="w-full p-2 pl-10 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500 transition">
                            </div>
                        </div>
                        <div class="relative pinnable-control-wrapper">
                            <button id="zoomBtn" class="w-full text-left p-2 bg-gray-200 rounded hover:bg-gray-300 js-zoom-btn">ë‚ ì§œ ì„¤ì •</button>
                        </div>
                        <div class="pinnable-control-wrapper">
                            <button id="showChangesBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300 filter-toggle-btn">ë³€ê²½</button>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="pinnable-control-wrapper"><button id="expandAllBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300">í¼ì¹˜ê¸°</button></div>
                            <div class="pinnable-control-wrapper"><button id="collapseAllBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300">ì ‘ê¸°</button></div>
                        </div>
                        <div class="pinnable-control-wrapper">
                            <button id="toggleHierarchyOrderBtn" class="w-full p-2 bg-gray-200 text-sm rounded hover:bg-gray-300">ê³„ì¸µìˆœì„œ</button>
                        </div>
                         <div class="pinnable-control-wrapper">
                            <button id="goToTodayBtn" class="w-full p-2 bg-blue-500 text-white rounded-md">ì˜¤ëŠ˜</button>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>


    <!-- Data Detail Modal -->
    <div id="dataDetailModal" class="modal-overlay hidden">
        <div class="modal-content">
             <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 id="dataDetailTitle" class="text-xl font-bold text-gray-800">ìƒì„¸ ë°ì´í„°</h2>
                <button id="closeDataDetailModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="resizable-modal-body">
                <div id="dataDetailTableContainer" class="h-full overflow-y-auto">
                    <!-- Table will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Gantt Modal -->
    <div id="fullscreenModal" class="fullscreen-modal-overlay hidden">
        <div class="resizable-modal-content">
            <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">ì¼ì • (ì „ì²´ í™”ë©´)</h2>
                <button id="closeFullscreenModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
             <!-- Fullscreen body now uses flex-col for layout -->
            <div id="fullscreenModalBody" class="resizable-modal-body flex flex-col">
                 <!-- Legend and Gantt Chart will be moved here -->
            </div>
        </div>
    </div>

    <!-- Milestone Modal -->
    <div id="milestoneModal" class="modal-overlay hidden">
        <div class="modal-content w-auto min-w-[500px] h-auto min-h-[400px] resize overflow-visible">
            <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">ë§ˆì¼ìŠ¤í†¤ ê´€ë¦¬</h2>
                <button id="closeMilestoneModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="p-6 flex-grow flex flex-col">
                <div id="milestoneList" class="flex-grow mb-4 overflow-y-auto pr-2">
                    <!-- Milestone items will be injected here -->
                </div>
                <form id="addMilestoneForm" class="flex items-center gap-2 border-t pt-4">
                    <input type="date" id="milestoneDate" class="p-2 border rounded" required>
                    <input type="text" id="milestoneName" placeholder="ë§ˆì¼ìŠ¤í†¤ ì´ë¦„" class="p-2 border rounded flex-grow" required>
                    <button type="submit" class="p-2 bg-rose-500 text-white rounded hover:bg-rose-600">ì¶”ê°€</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Data Mapping Modal -->
    <div id="mappingModal" class="modal-overlay hidden">
        <div class="modal-content !max-w-6xl !w-auto !h-auto">
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">ë°ì´í„° ë§¤í•‘ ë° ë¯¸ë¦¬ë³´ê¸°</h2>
                <button id="closeMappingModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="p-6 space-y-4">
                <div class="flex items-center gap-4 bg-gray-50 p-3 rounded-md">
                    <label for="mappingHeaderRowCount" class="text-sm font-medium text-gray-700 flex-shrink-0">í—¤ë” ì‹œì‘ í–‰:</label>
                    <input type="number" id="mappingHeaderRowCount" value="1" min="1" class="w-20 p-1 border border-gray-300 rounded-md text-center focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                    <p class="text-sm text-gray-500">íŒŒì¼ì—ì„œ í—¤ë”(ì œëª©)ê°€ ì‹œì‘ë˜ëŠ” í–‰ ë²ˆí˜¸ë¥¼ ì§€ì •í•˜ì„¸ìš”.</p>
                </div>
                <!-- IMPROVEMENT: Added guidance text for data mapping -->
                <div class="bg-indigo-50 border-l-4 border-indigo-500 text-indigo-800 p-4 rounded-md mb-4 text-sm" role="alert">
                    <p class="font-bold">ë°ì´í„° ë§¤í•‘ ì•ˆë‚´</p>
                    <p>ì—…ë¡œë“œí•œ íŒŒì¼ì˜ ê° ì—´(Column)ì´ ì–´ë–¤ ë°ì´í„°ì— í•´ë‹¹í•˜ëŠ”ì§€ ì•„ë˜ ë“œë¡­ë‹¤ìš´ ë©”ë‰´ì—ì„œ ì„ íƒí•´ì£¼ì„¸ìš”.</p>
                    <ul class="list-disc list-inside mt-2">
                        <li><strong class="font-semibold">'ëª…ì¹­', 'ì‹œì‘ì¼', 'ì¢…ë£Œì¼'</strong>ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.</li>
                        <li>ì‹œìŠ¤í…œì—ì„œ ìë™ìœ¼ë¡œ ìµœì ì˜ ë§¤í•‘ì„ ì œì•ˆí•˜ì§€ë§Œ, í•„ìš”ì‹œ ì§ì ‘ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li>ë¶ˆí•„ìš”í•œ ì—´ì€ 'ë¬´ì‹œ'ë¡œ ì„¤ì •í•˜ì„¸ìš”.</li>
                    </ul>
                </div>
                <div id="mappingPreviewContainer" class="overflow-auto border rounded-md" style="max-height: 50vh;">
                    <!-- Mapping preview table will be injected here -->
                </div>
            </div>
            <div class="flex justify-end items-center p-4 border-t bg-gray-50 rounded-b-md">
                <button id="cancelMappingBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 mr-2">ì·¨ì†Œ</button>
                <button id="applyMappingBtn" class="px-4 py-2 bg-violet-600 text-white rounded-md hover:bg-violet-700">ë°ì´í„° ì ìš©</button>
            </div>
        </div>
    </div>

    <!-- Date Settings Modal -->
    <div id="zoomModal" class="modal-overlay hidden">
        <div class="modal-content w-auto min-w-[380px] h-auto min-h-[350px]">
            <div class="resizer-handle n" data-direction="n"></div>
            <div class="resizer-handle s" data-direction="s"></div>
            <div class="resizer-handle e" data-direction="e"></div>
            <div class="resizer-handle w" data-direction="w"></div>
            <div class="resizer-handle ne" data-direction="ne"></div>
            <div class="resizer-handle nw" data-direction="nw"></div>
            <div class="resizer-handle se" data-direction="se"></div>
            <div class="resizer-handle sw" data-direction="sw"></div>
            <div class="resizable-modal-header">
                <h2 class="text-lg font-bold text-gray-800">ë‚ ì§œ ì„¤ì •</h2>
                <button id="closeZoomModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div id="zoomPopover" class="resizable-modal-body p-4 space-y-3">
                <h4 class="font-bold text-sm">ê¸°ê°„ ì„¤ì •</h4>
                <div class="flex items-center gap-2">
                    <input type="date" id="zoomStartDate" class="w-full p-1 border rounded text-sm">
                    <span>~</span>
                    <input type="date" id="zoomEndDate" class="w-full p-1 border rounded text-sm">
                </div>
                <h4 class="font-bold text-sm pt-2">ì£¼ ë‹¨ìœ„ ì„ íƒ</h4>
                <div class="grid grid-cols-3 gap-2">
                    <button id="zoomPrevWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">ì´ì „ ì£¼</button>
                    <button id="zoomThisWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">ì´ë²ˆ ì£¼</button>
                    <button id="zoomNextWeek" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">ë‹¤ìŒ ì£¼</button>
                </div>
                <h4 class="font-bold text-sm pt-2">3ì£¼ ë‹¨ìœ„ ì„ íƒ</h4>
                <div class="grid grid-cols-2 gap-2">
                    <button id="zoomThreeWeeksToday" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">3ì£¼ê°„(ì˜¤ëŠ˜)</button>
                    <button id="zoomThreeWeeksSelected" class="p-1 bg-gray-100 text-xs rounded hover:bg-indigo-500 hover:text-white">3ì£¼ê°„(ì§€ì •)</button>
                </div>
                <div class="flex justify-end gap-2 pt-3 border-t">
                    <button id="zoomResetBtn" class="px-3 py-1 bg-gray-500 text-white text-xs rounded hover:bg-gray-600">ì´ˆê¸°í™”</button>
                    <button id="zoomApplyBtn" class="px-3 py-1 bg-indigo-500 text-white text-xs rounded hover:bg-indigo-600">ì ìš©</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Correction Modal -->
    <div id="errorCorrectionModal" class="modal-overlay hidden">
        <div class="modal-content !max-w-7xl !h-[90vh]">
            <div class="resizable-modal-header">
                <h2 class="text-xl font-bold text-gray-800">ë°ì´í„° ì—…ë¡œë“œ ì˜¤ë¥˜ ìˆ˜ì •</h2>
                <button id="closeErrorCorrectionModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <!-- IMPROVEMENT: Enhanced guidance text for error correction -->
            <div id="errorCorrectionInfo" class="p-4 bg-yellow-50 text-yellow-800 border-b text-sm">
                <!-- Info text will be injected here -->
            </div>
            <div class="flex-grow overflow-auto">
                <div id="errorCorrectionContainer" class="p-4">
                    <!-- Error correction table will be injected here -->
                </div>
            </div>
            <div class="flex justify-end items-center p-4 border-t bg-gray-50 rounded-b-md">
                <button id="discardErrorsBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 mr-2">ì˜¤ë¥˜ ë°ì´í„° ë¬´ì‹œí•˜ê³  ë‹«ê¸°</button>
                <button id="retryImportBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">ìˆ˜ì •ëœ í•­ëª© ê°€ì ¸ì˜¤ê¸°</button>
            </div>
        </div>
    </div>

    <!-- Floating Action Buttons -->
    <button id="filterTimelineFabBtn" aria-label="í•„í„° ë° íƒ€ì„ë¼ì¸ ì„¤ì •" title="í•„í„° ë° íƒ€ì„ë¼ì¸ ì„¤ì •" class="fixed bottom-28 right-8 bg-violet-600 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center text-2xl hover:bg-violet-700 transition-transform duration-200 ease-in-out hover:-translate-y-0.5 z-[140]">
        <span class="relative flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7 text-white" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 011 1v1a1 1 0 01-.293.707L13 11.414V17a1 1 0 01-.553.894l-2 1A1 1 0 019 18v-6.586L3.293 5.707A1 1 0 013 5V4z" clip-rule="evenodd"/>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5 text-violet-100 absolute -bottom-1 -right-1 drop-shadow-md" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10 3a7 7 0 100 14 7 7 0 000-14zm0 2a5 5 0 110 10 5 5 0 010-10zm-.75 2.75c0-.414.336-.75.75-.75s.75.336.75.75V10.5h1.75a.75.75 0 010 1.5h-2.5A.75.75 0 019.25 11V7.75z" clip-rule="evenodd"/>
            </svg>
        </span>
    </button>
    <button id="fabMenuBtn" class="fixed bottom-8 right-8 bg-indigo-600 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center text-3xl hover:bg-indigo-700 transition-transform duration-200 ease-in-out hover:rotate-90 z-[140]">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
        </svg>
    </button>

    <!-- Data Management Panel -->
    <div id="dataPanel" class="fixed top-0 left-0 w-full h-full bg-black bg-opacity-40 flex justify-center items-center z-[150] hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md" id="dataPanelContent">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold">ë°ì´í„° ê´€ë¦¬</h2>
                <button id="closeDataPanelBtn" class="text-gray-400 hover:text-gray-700">&times;</button>
            </div>

            <div class="space-y-3">
                <p class="text-sm text-center text-gray-500 pb-2">ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ê±°ë‚˜ í˜„ì¬ ë°ì´í„°ë¥¼ ì €ì¥í•˜ì„¸ìš”.</p>

                <div class="flex items-center justify-center gap-2 pt-1 pb-2">
                    <label for="headerRowCount" class="text-sm font-medium text-gray-700 flex-shrink-0">í—¤ë” ì‹œì‘ í–‰:</label>
                    <input type="number" id="headerRowCount" value="1" min="1" class="w-20 p-1 border border-gray-300 rounded-md text-center focus:ring-2 focus:ring-violet-500 focus:border-violet-500" title="í—¤ë”ê°€ ì‹œì‘ë˜ëŠ” ì‹¤ì œ í–‰ ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 1)">
                </div>

                <!-- Upload -->
                <button id="uploadBtn" class="w-full flex items-center justify-center gap-3 p-3 bg-violet-50 text-violet-700 rounded-lg hover:bg-violet-100 font-semibold transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>
                    <span>ë°ì´í„° ì—…ë¡œë“œ (.csv, .xlsx)</span>
                </button>
                <input type="file" id="fileInput" accept=".csv, .xls, .xlsx" class="hidden"/>

                <!-- Download Template -->
                <div class="flex gap-2 justify-center pt-2">
                     <button data-format="csv" class="download-template-btn flex-1 p-2 bg-gray-100 text-gray-700 text-sm rounded hover:bg-gray-200 transition">ì–‘ì‹ (.csv)</button>
                     <button data-format="xlsx" class="download-template-btn flex-1 p-2 bg-gray-100 text-gray-700 text-sm rounded hover:bg-gray-200 transition">ì–‘ì‹ (.xlsx)</button>
                </div>

                <!-- Export Data Section -->
                <div class="space-y-3 pb-2">
                    <p class="text-sm text-center text-gray-500">í˜„ì¬ ë°ì´í„°ë¥¼ ì—‘ì…€ ë˜ëŠ” CSVë¡œ ë‚´ë³´ë‚´ê¸°</p>
                    <div class="flex gap-2">
                        <button id="exportToExcelBtn" class="flex-1 flex items-center justify-center gap-2 p-3 bg-indigo-50 text-indigo-700 rounded-lg hover:bg-indigo-100 font-semibold transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                            <span>Excel ë‹¤ìš´ë¡œë“œ</span>
                        </button>
                        <button id="exportToCsvBtn" class="flex-1 flex items-center justify-center gap-2 p-3 bg-blue-50 text-blue-700 rounded-lg hover:bg-blue-100 font-semibold transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                            <span>CSV ë‹¤ìš´ë¡œë“œ</span>
                        </button>
                    </div>
                </div>
                
                <!-- Separator -->
                <hr class="my-4 border-t border-gray-200"/>

                <!-- Save current state -->
                <button id="saveHtmlBtn" class="w-full flex items-center justify-center gap-3 p-3 bg-green-50 text-green-700 rounded-lg hover:bg-green-100 font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed group relative" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6a1 1 0 10-2 0v5.586L7.707 10.293zM3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 11-2 0V5H5v1a1 1 0 11-2 0V4z" />
                    </svg>
                    <span>í˜„ì¬ ì‘ì—… ë‚´ìš© ì €ì¥</span>
                    <div class="opacity-0 group-hover:opacity-100 transition-opacity absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-1 bg-gray-800 text-white text-xs rounded whitespace-nowrap">
                        ëª¨ë“  ë°ì´í„°ì™€ ì„¤ì •ì´ ì €ì¥ë˜ë©°, ë‚˜ì¤‘ì— ì´ì–´ì„œ ì‘ì—…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
                    </div>
                </button>
                <p id="saveMessage" class="text-sm text-center text-gray-600 pt-2 pb-1 hidden flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>
                    <span>ì €ì¥ëœ íŒŒì¼ì€ ì¸í„°ë„· ì—†ì´ë„ ë‹¨ë…ìœ¼ë¡œ ì‹¤í–‰ë˜ë©° ëª¨ë“  ì‘ì—… ë‚´ìš©ì´ ë³´ì¡´ë©ë‹ˆë‹¤</span>
                </p>
                <!-- Auto-upload URL ì„¤ì • (ì‚¬ìš©ìê°€ ë³€ê²½ ê°€ëŠ¥) -->
                <div class="mt-4 border-t pt-3 space-y-2">
                    <label for="autoUploadUrlInput" class="text-sm font-medium text-gray-700">ìë™ ì—…ë¡œë”© URL (GitHub ë“±)</label>
                    <input id="autoUploadUrlInput" type="text" class="w-full p-2 border border-gray-300 rounded-md text-sm" placeholder="ìë™ ë¶ˆëŸ¬ì˜¬ íŒŒì¼ì˜ URLì„ ì…ë ¥í•˜ì„¸ìš”" />
                    <div class="flex items-center gap-2">
                        <input id="autoUploadEnabled" type="checkbox" class="w-4 h-4" />
                        <label for="autoUploadEnabled" class="text-sm text-gray-600">í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ìœ¼ë¡œ ë¶ˆëŸ¬ì˜¤ê¸°</label>
                        <button id="autoUploadNowBtn" class="ml-auto px-3 py-1 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700">ì§€ê¸ˆ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                    </div>
                    <p class="text-xs text-gray-500">ì¸í„°ë„· ì—°ê²°ì´ ì—†ê±°ë‚˜ íŒŒì¼ì´ ì—†ì„ ê²½ìš° ê¸°ì¡´ ë¡œì»¬ ì—…ë¡œë“œ ë°©ì‹ì´ ë™ì‘í•©ë‹ˆë‹¤.</p>
                    <button id="resetDateChangesBtn" class="w-full px-3 py-2 bg-orange-100 text-orange-700 text-sm rounded hover:bg-orange-200 transition disabled:opacity-50 disabled:cursor-not-allowed">ë‚ ì§œ ë³€ê²½ í‘œì‹œ ì´ˆê¸°í™”</button>
                </div>
            </div>
        </div>
    </div>

    <div id="progressPopup" class="hidden absolute bg-white border rounded-lg shadow-xl p-2 grid grid-cols-4 gap-2 w-56">
    </div>

    <div id="toast-container"></div>

    <!-- [DELETED] The template is no longer needed as we move the actual element. -->

    <!-- EMBEDDED_DATA_PLACEHOLDER -->
    <!-- EMBEDDED_MILESTONES_PLACEHOLDER -->
    <!-- EMBEDDED_SETTINGS_PLACEHOLDER -->

    <script>
        // Data Management Panel Elements
        const fabMenuBtn = document.getElementById('fabMenuBtn');
        const filterTimelineFabBtn = document.getElementById('filterTimelineFabBtn');
        const dataPanel = document.getElementById('dataPanel');
        const dataPanelContent = document.getElementById('dataPanelContent');
        const closeDataPanelBtn = document.getElementById('closeDataPanelBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const saveHtmlBtn = document.getElementById('saveHtmlBtn');
        const saveMessage = document.getElementById('saveMessage');
        const downloadTemplateBtns = document.querySelectorAll('.download-template-btn');
        const headerRowCountInput = document.getElementById('headerRowCount');
        const resetDateChangesBtn = document.getElementById('resetDateChangesBtn');

        const fileInput = document.getElementById('fileInput');
        const dashboardContent = document.getElementById('dashboardContent');
        const ganttChartWrapper = document.getElementById('ganttChartWrapper');
        const ganttChartContainer = document.getElementById('ganttChart');
        const exportToExcelBtn = document.getElementById('exportToExcelBtn');
        const exportToCsvBtn = document.getElementById('exportToCsvBtn');
        // Selectors updated after DOM changes for controls
        let taskTypeFilter, customFilterContainer, progressFilter, sortBy, searchInput;
        const SORT_DIRECTIONS = Object.freeze({ ASC: 'asc', DESC: 'desc' });
        let sortState = { mode: 'default', direction: SORT_DIRECTIONS.DESC };

        // Timeline controls (Selector might need update if ID changes)
        let goToTodayBtn;

        // Data Detail Modal
        const dataDetailModal = document.getElementById('dataDetailModal');
        const closeDataDetailModalBtn = document.getElementById('closeDataDetailModalBtn');
        const dataDetailTitle = document.getElementById('dataDetailTitle');
        const dataDetailTableContainer = document.getElementById('dataDetailTableContainer');

        // View Controls (Selectors might need update)
        let expandAllBtn, collapseAllBtn;
        let toggleHierarchyOrderBtn;
        let showChangesBtn;

        // Fullscreen Modal
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const fullscreenModal = document.getElementById('fullscreenModal');
        const fullscreenModalContent = fullscreenModal.querySelector('.resizable-modal-content');
        const fullscreenModalBody = document.getElementById('fullscreenModalBody');
        const closeFullscreenModalBtn = document.getElementById('closeFullscreenModalBtn');

        // Milestone Modal
        const milestoneBtn = document.getElementById('milestoneBtn');
        const legendGoToTodayBtn = document.getElementById('legendGoToTodayBtn');
        const milestoneModal = document.getElementById('milestoneModal');
        const closeMilestoneModalBtn = document.getElementById('closeMilestoneModalBtn');
        const addMilestoneForm = document.getElementById('addMilestoneForm');
        const milestoneList = document.getElementById('milestoneList');

        // Mapping Modal
        const mappingModal = document.getElementById('mappingModal');
        const closeMappingModalBtn = document.getElementById('closeMappingModalBtn');
        const cancelMappingBtn = document.getElementById('cancelMappingBtn');
        const applyMappingBtn = document.getElementById('applyMappingBtn');
        const mappingHeaderRowCount = document.getElementById('mappingHeaderRowCount');
        const mappingPreviewContainer = document.getElementById('mappingPreviewContainer');

        // Date Settings Modal
        const zoomModal = document.getElementById('zoomModal');
        const zoomModalContent = zoomModal.querySelector('.modal-content');
        const closeZoomModalBtn = document.getElementById('closeZoomModalBtn');

        // Error Correction Modal
        const errorCorrectionModal = document.getElementById('errorCorrectionModal');
        const closeErrorCorrectionModalBtn = document.getElementById('closeErrorCorrectionModalBtn');
        const errorCorrectionInfo = document.getElementById('errorCorrectionInfo');
        const errorCorrectionContainer = document.getElementById('errorCorrectionContainer');
        const discardErrorsBtn = document.getElementById('discardErrorsBtn');
        const retryImportBtn = document.getElementById('retryImportBtn');

        // ê°œì„  ì‚¬í•­: ì»¨íŠ¸ë¡¤ íŒ¨ë„ ìš”ì†Œ
        const controlsPanel = document.getElementById('controlsPanel');
        const controlsPanelOverlay = document.getElementById('controlsPanelOverlay');
        const closeControlsPanelBtn = document.getElementById('closeControlsPanelBtn');
        
        // ê°œì„  ì‚¬í•­ 1: ë°”ë¡œê°€ê¸° ë©”ë‰´ ìš”ì†Œ
        const shortcutContainer = document.getElementById('shortcutContainer');


        const progressPopup = document.getElementById('progressPopup');
        let floatingTooltip = document.getElementById('ganttFloatingTooltip');
        if (!floatingTooltip && typeof document !== 'undefined') {
            floatingTooltip = document.createElement('div');
            floatingTooltip.id = 'ganttFloatingTooltip';
            document.body.appendChild(floatingTooltip);
        }
        let hoverTooltip = document.getElementById('ganttHoverTooltip');
        if (!hoverTooltip && typeof document !== 'undefined') {
            hoverTooltip = document.createElement('div');
            hoverTooltip.id = 'ganttHoverTooltip';
            document.body.appendChild(hoverTooltip);
        }
        let activeTooltipBar = null;

    // Auto-upload controls
    const autoUploadUrlInput = document.getElementById('autoUploadUrlInput');
    const autoUploadEnabled = document.getElementById('autoUploadEnabled');
    const autoUploadNowBtn = document.getElementById('autoUploadNowBtn');

    // Zoom controls (Selector might need update)
    let zoomBtn, zoomPopover, zoomStartDate, zoomEndDate, zoomApplyBtn, zoomResetBtn;
        let zoomPrevWeek, zoomThisWeek, zoomNextWeek, zoomThreeWeeksToday, zoomThreeWeeksSelected;

        let projectData = [];
        let milestones = [];
        let openTaskGroups = new Set();
        let minDate, maxDate;
        let viewMinDate, viewMaxDate;
        let savedSettings = null;
        let hierarchyOrder = 'top'; // 'top': í—¤ë”ê°€ ìœ„, 'bottom': í—¤ë”ê°€ ì•„ë˜
        let showOnlyChanged = false;
        let isCustomZoomActive = false;
        const shortcutState = {
            expandAll: false,
            collapseAll: false
        };
        // Temporary automatic diagnostic flags. These are non-destructive and intended
        // to help collect runtime mapping mismatches in the user's browser console.
        // Set to true to enable automatic logging; remove or set to false after debug.
        if (typeof window !== 'undefined') {
            // ê¸°ë³¸ì ìœ¼ë¡œ ì½˜ì†” ìŠ¤íŒ¸ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ìë™ ì§„ë‹¨ì€ ë¹„í™œì„±í™”í•©ë‹ˆë‹¤.
            // ë¬¸ì œê°€ ë°œìƒí•˜ë©´ ê°œë°œì ë„êµ¬ì—ì„œ ìˆ˜ë™ìœ¼ë¡œ trueë¡œ ë°”ê¿”ì£¼ì„¸ìš”.
            window.__GANTT_AUTO_DEBUG = false; // ìë™ ì§„ë‹¨ ë¡œê·¸ ê¸°ë³¸ ë¹„í™œì„±í™”
            window.__GANTT_STRICT_DEBUG = false; // strict reorder ë‚´ë¶€ ë””ë²„ê¹… ë¡œê·¸ (ì˜µì…˜)
        }
        let rawImportData = null;
        let importMapping = null;
        let failedImportRows = [];
        let legendStatusFilter = null;
        let pinnedShortcuts = new Set(); // ê°œì„  ì‚¬í•­ 1: ë°”ë¡œê°€ê¸° ìƒíƒœ ì €ì¥
        const accordionHintState = {};
        let accordionStateObserver = null;

        function ensureShortcutOrderRules() {
            if (!(pinnedShortcuts instanceof Set)) return;
            let order = Array.from(pinnedShortcuts);
            if (!order.length) return;

            const moveToStart = (ids) => {
                const existing = ids.filter(id => order.includes(id));
                if (!existing.length) return;
                order = existing.concat(order.filter(id => !existing.includes(id)));
            };

            const moveAfter = (ids, anchorId, fallbackAtStart = false) => {
                const filtered = order.filter(id => !ids.includes(id));
                const anchorIndex = filtered.indexOf(anchorId);
                const existing = ids.filter(id => order.includes(id));
                if (!existing.length) {
                    order = filtered;
                    return;
                }
                if (anchorIndex >= 0) {
                    filtered.splice(anchorIndex + 1, 0, ...existing);
                } else if (fallbackAtStart) {
                    filtered.unshift(...existing);
                } else {
                    filtered.push(...existing);
                }
                order = filtered;
            };

            const ensurePresence = (id) => order.includes(id);

            moveToStart(['fullscreenBtn', 'expandAllBtn', 'collapseAllBtn']);

            if (ensurePresence('showChangesBtn')) {
                let filtered = order.filter(id => id !== 'showChangesBtn');
                const expandIdx = filtered.indexOf('expandAllBtn');
                if (expandIdx >= 0) {
                    filtered.splice(expandIdx, 0, 'showChangesBtn');
                } else {
                    filtered.unshift('showChangesBtn');
                }
                order = filtered;
            }

            // 'ë§ˆì¼ìŠ¤í†¤'ì„ 'ì „ì²´ í™”ë©´' ë°”ë¡œ ì˜†ì— ë°°ì¹˜
            if (ensurePresence('milestoneBtn')) {
                moveAfter(['milestoneBtn'], 'fullscreenBtn', true);
            }

            // 'ê³„ì¸µìˆœì„œ'ë¥¼ 'ë§ˆì¼ìŠ¤í†¤'ê³¼ 'í¼ì¹˜ê¸°' ì‚¬ì´ ì¤‘ì•™ì— ë°°ì¹˜
            if (ensurePresence('toggleHierarchyOrderBtn')) {
                const first = 'milestoneBtn';
                const second = 'expandAllBtn';
                if (ensurePresence(first) && ensurePresence(second)) {
                    const idxFirst = order.indexOf(first);
                    const idxSecond = order.indexOf(second);
                    const insertIndex = idxFirst >= 0 && idxSecond >= 0
                        ? Math.floor((idxFirst + idxSecond + 1) / 2)
                        : idxSecond;
                    const filtered = order.filter(id => id !== 'toggleHierarchyOrderBtn');
                    filtered.splice(Math.max(insertIndex, 0), 0, 'toggleHierarchyOrderBtn');
                    order = filtered;
                } else {
                    const anchorId = ensurePresence(first) ? first : (ensurePresence('fullscreenBtn') ? 'fullscreenBtn' : second);
                    moveAfter(['toggleHierarchyOrderBtn'], anchorId, true);
                }
            }

            const typeAdjacent = ['sortBy', 'progressFilter'].filter(ensurePresence);
            if (typeAdjacent.length > 0) {
                moveAfter(typeAdjacent, 'taskTypeFilter', false);
            }
            if (ensurePresence('zoomBtn') && ensurePresence('collapseAllBtn')) {
                moveAfter(['zoomBtn'], 'collapseAllBtn', true);
            }

            pinnedShortcuts = new Set(order);
        }
    const originalDateRegistry = new Map();
    const originalProgressRegistry = new Map();
    let projectRegistrySequence = 0;
        let pendingScrollRestore = null;
        
        // ê°œì„  ì‚¬í•­: ë Œë”ë§ ë””ë°”ìš´ì‹±ì„ ìœ„í•œ ë³€ìˆ˜
        let renderTimeout = null;
        let isRendering = false;
        
        // ê°œì„  ì‚¬í•­: ê²€ìƒ‰ ì…ë ¥ ë””ë°”ìš´ì‹±ì„ ìœ„í•œ ë³€ìˆ˜
        let searchInputTimeout = null;
        
        // ê°œì„  ì‚¬í•­: ê²€ìƒ‰ ì…ë ¥ ë””ë°”ìš´ì‹± ë˜í¼ í•¨ìˆ˜
        function debouncedRender() {
            if (searchInputTimeout) {
                clearTimeout(searchInputTimeout);
            }
            searchInputTimeout = setTimeout(() => {
                render();
            }, 300); // 300ms ë””ë°”ìš´ì‹±
        }

        let DAY_WIDTH = 40;

    // ê¸°ë³¸ ìë™ ì—…ë¡œë“œ URL
    const DEFAULT_AUTO_UPLOAD_URL = 'https://jonggunelee.github.io/wyggkr04/RawData/25ë…„ ì”ì—¬ ê³µì‚¬ ê³µì •ê´€ë¦¬_(ì…ë ¥).xlsx';

        // ì•ˆì „í•œ í‚¤ ìƒì„±: í•œê¸€(ë˜ëŠ” ë‹¤ë¥¸ ìœ ë‹ˆì½”ë“œ ë¬¸ì)ê³¼ ìˆ«ìëŠ” ë³´ì¡´í•˜ê³ 
        // ê·¸ ì™¸ íŠ¹ìˆ˜ë¬¸ìëŠ” '_'ë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤. ì „ì—­ì—ì„œ ì¬ì‚¬ìš©í•©ë‹ˆë‹¤.
        let customFieldDisplayNames = {}; // sanitizedKey -> original display name
        function sanitizeKey(key) {
            if (key === undefined || key === null) return '';
            try {
                // Keep Unicode letters and numbers, replace other chars with underscore
                return String(key).trim().replace(/[^\p{L}\p{N}]+/gu, '_').replace(/^_+|_+$/g, '').replace(/_+/g, '_');
            } catch (e) {
                // Fallback for environments without Unicode property escapes
                return String(key).trim().replace(/[^a-zA-Z0-9ê°€-í£]+/g, '_').replace(/^_+|_+$/g, '').replace(/_+/g, '_');
            }
        }

        const statusColors = {
            'ê³µì‚¬ì¤‘': 'bg-blue-500',
            'ì°©ê³µì „': 'bg-gray-400',
            'ì™„ë£Œ': 'bg-green-500',
            'ì§€ì—°': 'bg-red-500',
            'default': 'bg-sky-500'
        };

        let columnVisibility = {
            'project-name': true, 'project-po': false, 'project-progress': true, 'project-dates': true,
            'project-progress-summary': true // ìƒˆë¡œ ì¶”ê°€ëœ ì§„í–‰ë¥  ìš”ì•½ ì—´ ê°€ì‹œì„±
        };

        // Ensure any floating popovers are hidden before opening the data panel
        function hideFloatingPopovers() {
            try {
                if (zoomModal) {
                    zoomModal.classList.add('hidden');
                }
            } catch (e) {
                console.warn('hideFloatingPopovers error', e);
            }
        }

        function hideFloatingTooltip() {
            if (!floatingTooltip) return;
            floatingTooltip.classList.remove('visible');
            floatingTooltip.style.left = '';
            floatingTooltip.style.top = '';
            activeTooltipBar = null;
        }

        function hideHoverTooltip() {
            if (!hoverTooltip) return;
            hoverTooltip.classList.remove('visible');
            hoverTooltip.textContent = '';
        }

        function getActiveTimelineContainer() {
            if (!fullscreenModal.classList.contains('hidden')) {
                return fullscreenModalBody.querySelector('.gantt-timeline-body-wrapper');
            }
            const host = document.getElementById('ganttViewContent');
            return host ? host.querySelector('.gantt-timeline-body-wrapper') : document.querySelector('.gantt-timeline-body-wrapper');
        }

        function positionFloatingTooltip(barRect, options = {}) {
            if (!floatingTooltip) return;
            const { pointerX = null, pointerY = null, preferTopEdge = false } = options;
            const margin = 12;
            let topBoundary = 0;
            let bottomBoundary = window.innerHeight;
            const container = getActiveTimelineContainer();
            if (container) {
                const rect = container.getBoundingClientRect();
                topBoundary = Math.max(0, rect.top);
                bottomBoundary = Math.min(window.innerHeight, rect.bottom);
            }
            const tooltipRect = floatingTooltip.getBoundingClientRect();
            let left;
            if (typeof pointerX === 'number') {
                left = pointerX - tooltipRect.width / 2;
            } else {
                left = barRect.left + (barRect.width / 2) - tooltipRect.width / 2;
            }
            const maxLeft = window.innerWidth - tooltipRect.width - margin;
            left = Math.max(margin, Math.min(left, maxLeft));

            let top;
            if (preferTopEdge) {
                top = Math.max(8, topBoundary + margin);
            } else if (typeof pointerY === 'number') {
                top = pointerY - tooltipRect.height - margin;
                if (top < topBoundary + margin) {
                    top = pointerY + margin;
                }
            } else {
                top = barRect.top - tooltipRect.height - margin;
                if (top < topBoundary + margin) {
                    top = barRect.bottom + margin;
                }
            }
            if (top + tooltipRect.height > bottomBoundary - margin) {
                top = bottomBoundary - tooltipRect.height - margin;
            }

            floatingTooltip.style.left = `${left}px`;
            floatingTooltip.style.top = `${top}px`;
        }

        function showFloatingTooltip(bar, tooltipSource, options = {}) {
            if (!floatingTooltip || !tooltipSource || !bar) return;
            activeTooltipBar = bar;
            floatingTooltip.innerHTML = tooltipSource.innerHTML;
            floatingTooltip.classList.add('visible');
            requestAnimationFrame(() => {
                positionFloatingTooltip(bar.getBoundingClientRect(), options);
            });
        }

        if (typeof window !== 'undefined') {
            window.addEventListener('scroll', () => {
                if (floatingTooltip && floatingTooltip.classList.contains('visible')) {
                    hideFloatingTooltip();
                }
                hideHoverTooltip();
            }, true);
            window.addEventListener('resize', () => {
                hideFloatingTooltip();
                hideHoverTooltip();
            });
        }

        function initializeAccordionHints() {
            const hintElements = document.querySelectorAll('[data-accordion-hint]');
            hintElements.forEach(hint => {
                const key = hint.dataset.accordionHint;
                if (!key) return;
                if (accordionHintState[key]) {
                    hint.classList.remove('hint-visible');
                    hint.classList.add('hint-hidden');
                } else {
                    hint.classList.remove('hint-hidden');
                    requestAnimationFrame(() => hint.classList.add('hint-visible'));
                }
            });
        }

        function dismissAccordionHint(key) {
            if (!key || accordionHintState[key]) return;
            accordionHintState[key] = true;
            const hintElement = document.querySelector(`[data-accordion-hint="${key}"]`);
            if (hintElement) {
                hintElement.classList.remove('hint-visible');
                hintElement.classList.add('hint-hidden');
            }
        }

        function handleAccordionTitleKeydown(event) {
            if (event.defaultPrevented) return;
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                event.currentTarget.click();
            }
        }

        function attachAccordionTitleInteractions() {
            const titleButtons = document.querySelectorAll('.accordion-title-btn');
            titleButtons.forEach(button => {
                if (!button.hasAttribute('data-keydown-listener')) {
                    button.addEventListener('keydown', handleAccordionTitleKeydown);
                    button.setAttribute('data-keydown-listener', 'true');
                }
            });
        }

        function updateAccordionAriaStates() {
            const titleButtons = document.querySelectorAll('.accordion-title-btn');
            titleButtons.forEach(button => {
                const parentItem = button.closest('.accordion-item');
                const isOpen = parentItem ? parentItem.classList.contains('open') : false;
                button.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
            });
            updateAccordionStatePills();
        }

        function updateAccordionStatePills() {
            document.querySelectorAll('.accordion-state-pill').forEach(pill => {
                const key = pill.dataset.accordionState;
                if (!key) return;
                const titleButton = document.querySelector(`.accordion-title-btn[data-accordion-id="${key}"]`);
                const parentItem = titleButton ? titleButton.closest('.accordion-item') : null;
                const isOpen = parentItem ? parentItem.classList.contains('open') : false;
                pill.dataset.state = isOpen ? 'open' : 'closed';
                pill.textContent = isOpen ? 'í¼ì³ì§' : 'ì ‘í˜';
            });
        }

        function setupAccordionStateObserver() {
            if (typeof MutationObserver === 'undefined') {
                updateAccordionAriaStates();
                return;
            }
            if (accordionStateObserver) {
                accordionStateObserver.disconnect();
            }
            const items = document.querySelectorAll('#dashboardContent > .accordion-item');
            accordionStateObserver = new MutationObserver(updateAccordionAriaStates);
            items.forEach(item => accordionStateObserver.observe(item, { attributes: true, attributeFilter: ['class'] }));
            updateAccordionAriaStates();
        }

        fabMenuBtn.addEventListener('click', () => {
            hideFloatingPopovers();
            dataPanel.classList.remove('hidden');
        });
        closeDataPanelBtn.addEventListener('click', () => dataPanel.classList.add('hidden'));
        dataPanel.addEventListener('click', (e) => {
            if (e.target === dataPanel) dataPanel.classList.add('hidden');
        });
        uploadBtn.addEventListener('click', () => fileInput.click());
        saveHtmlBtn.addEventListener('click', saveAsStandaloneHTML);
        downloadTemplateBtns.forEach(btn => {
            btn.addEventListener('click', () => downloadTemplate(btn.dataset.format));
        });
        initializeAccordionHints();
        attachAccordionTitleInteractions();
        setupAccordionStateObserver();
        initializeSortDirectionButtons();
        updateSortDirectionIndicators();
        updateShowChangesButtonState();
        if (resetDateChangesBtn) {
            resetDateChangesBtn.addEventListener('click', async () => {
                if (resetDateChangesBtn.disabled) return;
                resetDateChangesBtn.disabled = true;
                try {
                    rebaselineOriginalDates(true, false);
                    render();
                    showToast('ëª¨ë“  ì‘ì—…ì˜ ë‚ ì§œ ë³€ê²½ í‘œì‹œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                } catch (error) {
                    console.error('resetDateChangesBtn error', error);
                    showToast('ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                } finally {
                    setTimeout(() => { resetDateChangesBtn.disabled = false; }, 300);
                }
            });
        }

        // Main Accordion Click Logic
        dashboardContent.addEventListener('click', e => {
            // ê°œì„  ì‚¬í•­ 1: ë°”ë¡œê°€ê¸° ë©”ë‰´ í´ë¦­ ì‹œ ì•„ì½”ë””ì–¸ í† ê¸€ ë°©ì§€
            if (e.target.closest('#shortcutContainer')) {
                return;
            }

            // ì œëª© ë²„íŠ¼ì„ ì§ì ‘ í´ë¦­í–ˆì„ ë•Œë§Œ í† ê¸€
            const titleElement = e.target.closest('.accordion-title-btn');
            if (titleElement && titleElement.closest('.accordion-header')) {
                e.stopPropagation();
                const accordionHeader = titleElement.closest('.accordion-header');
                const allAccordionItems = Array.from(dashboardContent.querySelectorAll('.accordion-item'));
                const clickedItem = accordionHeader ? accordionHeader.parentElement : null;
                if (!clickedItem) return;

                const accordionId = titleElement.dataset.accordionId;
                if (accordionId) {
                    dismissAccordionHint(accordionId);
                }

                const isFocused = allAccordionItems.some(item => item !== clickedItem && item.style.display === 'none');

                if (isFocused) {
                    // Un-focusing: show all items, remove special classes
                    clickedItem.classList.remove('open', 'is-focused');
                    allAccordionItems.forEach(item => {
                        item.style.display = '';
                        item.classList.remove('is-focused');
                    });
                } else {
                    // Focusing: hide other items, add special classes to clicked item
                    const isOpening = !clickedItem.classList.contains('open');
                    if (isOpening) {
                        allAccordionItems.forEach(item => {
                            if (item === clickedItem) {
                                item.classList.add('open', 'is-focused');
                                item.style.display = '';
                            } else {
                                item.style.display = 'none';
                                item.classList.remove('open', 'is-focused');
                            }
                        });
                    } else {
                        // This case handles closing an item when it's not focused
                        clickedItem.classList.remove('open', 'is-focused');
                    }
                }
                // Ensure sub-accordions inside the just-opened/focused section are rendered correctly (if applicable)
                if (clickedItem.id === 'settlement-accordion' && clickedItem.classList.contains('open')) {
                    setupSettlementAccordions(); // Re-setup listeners if needed
                }
                 // Add listeners for control section toggles if schedule accordion is opened
                if (clickedItem.id === 'projectView' && clickedItem.classList.contains('open')) {
                    setupControlSectionToggles(clickedItem.querySelector('#controlsSection'));
                }
                updateAccordionAriaStates();
                setTimeout(render, 350); // Delay render slightly
                return;
            }

             // Sub-accordion click logic within Settlement
            const subAccordionHeader = e.target.closest('.sub-accordion-header');
            if (subAccordionHeader) {
                e.stopPropagation();
                const subAccordionItem = subAccordionHeader.parentElement;
                subAccordionItem.classList.toggle('open');
            }


            const card = e.target.closest('[data-filter-type]');
            if (card) {
                handleCardClick(e);
            }

             // Control Section Toggle Logic
            const controlHeader = e.target.closest('.control-section-header');
            if (controlHeader) {
                e.stopPropagation();
                controlHeader.classList.toggle('open');
            }
        });

        // Function to set up control section toggles
        function setupControlSectionToggles(controlsSectionElement) {
            if (!controlsSectionElement) return;
            controlsSectionElement.querySelectorAll('.control-section-header').forEach(header => {
                // Remove existing listener first to avoid duplicates
                header.removeEventListener('click', toggleControlSection);
                header.addEventListener('click', toggleControlSection);
            });
        }

        // Event handler for control section toggles
        function toggleControlSection(e) {
             // Only toggle if the click is directly on the header or the icon, not inputs inside
             if (e.target.closest('select, input, button') && !e.target.closest('.control-section-icon')) {
                 return;
             }
            e.currentTarget.classList.toggle('open');
        }
        
        // ê°œì„  ì‚¬í•­: ì»¨íŠ¸ë¡¤ íŒ¨ë„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        function closeControlsPanel() {
            controlsPanel.classList.add('translate-x-full');
            controlsPanelOverlay.classList.add('hidden');
        }
        function openControlsPanel(e) {
            if (e) e.stopPropagation(); // ì•„ì½”ë””ì–¸ í† ê¸€ ë°©ì§€
            hideFloatingPopovers();
            controlsPanel.classList.remove('translate-x-full');
            controlsPanelOverlay.classList.remove('hidden');
            // íŒ¨ë„ ì˜¤í”ˆ ì‹œ ì»¨íŠ¸ë¡¤ ì°¸ì¡°ì™€ í† ê¸€, ë°”ë¡œê°€ê¸° ì´ˆê¸°í™” ë³´ì¥
            updateControlReferences();
            setupControlSectionToggles(document.getElementById('controlsSection'));
            if (typeof setupPinnableControls === 'function') setupPinnableControls();
            
            // ì¶”ê°€: ì¤Œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì§ì ‘ í™•ì¸ ë° ì¬ì„¤ì •
            setTimeout(() => {
                const zoomBtn = document.getElementById('zoomBtn');
                if (zoomBtn && !zoomBtn.hasAttribute('data-listener-attached')) {
                    zoomBtn.addEventListener('click', handleZoomButtonClick);
                    zoomBtn.setAttribute('data-listener-attached', 'true');
                }
            }, 100);
        }
        if (filterTimelineFabBtn) {
            filterTimelineFabBtn.addEventListener('click', openControlsPanel);
        }
        if (legendGoToTodayBtn) {
            legendGoToTodayBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (typeof scrollToToday === 'function') {
                    scrollToToday();
                } else if (goToTodayBtn) {
                    goToTodayBtn.click();
                }
            });
        }
        closeControlsPanelBtn.addEventListener('click', closeControlsPanel);
        controlsPanelOverlay.addEventListener('click', closeControlsPanel);

        // ê°œì„  ì‚¬í•­ 1: ë°”ë¡œê°€ê¸° ë©”ë‰´ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateShortcuts() {
    const shortcutContainer = document.getElementById('shortcutContainer');
    if (!shortcutContainer) return;
    
    shortcutContainer.innerHTML = '';
    const controlContainer = document.getElementById('controlsPanel');
    if (!controlContainer) return;

    pinnedShortcuts.forEach(id => {
        const originalElement = controlContainer.querySelector(`#${id}`);
        if (!originalElement) return;

        const shortcutWrapper = document.createElement('div');
        shortcutWrapper.className = 'shortcut-item';
        shortcutWrapper.dataset.shortcutId = id;
        shortcutWrapper.addEventListener('click', e => e.stopPropagation());

        const clonedElement = originalElement.cloneNode(true);
        clonedElement.id = `shortcut-${id}`;
        clonedElement.dataset.shortcutCloneId = id;
        const updateWrapperTooltip = () => {
            const tip = getShortcutTooltipText(originalElement);
            if (tip) {
                shortcutWrapper.title = tip;
                clonedElement.title = tip;
            } else {
                shortcutWrapper.removeAttribute('title');
                clonedElement.removeAttribute('title');
            }
        };
        updateWrapperTooltip();

        // í˜„ì¬ ê°’ ë³µì‚¬
        if (clonedElement.tagName === 'SELECT' || clonedElement.tagName === 'INPUT') {
            clonedElement.value = originalElement.value;
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ê°•í™”
        if (clonedElement.classList.contains('js-zoom-btn')) {
            clonedElement.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                toggleZoomPopover(clonedElement);
                updateWrapperTooltip();
            });
        } else if (clonedElement.tagName === 'SELECT') {
            clonedElement.addEventListener('change', (e) => {
                e.stopPropagation();
                originalElement.value = clonedElement.value;
                originalElement.dispatchEvent(new Event('change', { bubbles: true })); // ì´ë²¤íŠ¸ ì „íŒŒ
                updateWrapperTooltip();
            });
        } else if (clonedElement.tagName === 'INPUT') {
            clonedElement.addEventListener('input', (e) => {
                e.stopPropagation();
                originalElement.value = clonedElement.value;
                originalElement.dispatchEvent(new Event('input')); // ì´ë²¤íŠ¸ ì „íŒŒ
                render();
                updateWrapperTooltip();
            });
        } else if (clonedElement.tagName === 'BUTTON') {
            clonedElement.addEventListener('click', (e) => {
                e.stopPropagation();
                originalElement.click();
                updateWrapperTooltip();
            });
        }
        
        // If this is the task type filter, contractor filter, progress filter, or sort by, wrap it in a compact wrapper so long labels are truncated
        if (originalElement.id === 'taskTypeFilter' || originalElement.id === 'contractor-filter' || 
            originalElement.id === 'progressFilter' || originalElement.id === 'sortBy') {
            try {
                const smallWrap = document.createElement('div');
                if (originalElement.id === 'taskTypeFilter') {
                    smallWrap.className = 'shortcut-type-small-wrapper';
                    clonedElement.classList.add('shortcut-type-small');
                } else if (originalElement.id === 'contractor-filter') {
                    smallWrap.className = 'shortcut-contractor-small-wrapper';
                    clonedElement.classList.add('shortcut-contractor-small');
                } else if (originalElement.id === 'progressFilter') {
                    smallWrap.className = 'shortcut-progress-small-wrapper';
                    clonedElement.classList.add('shortcut-progress-small');
                } else if (originalElement.id === 'sortBy') {
                    smallWrap.className = 'shortcut-sort-small-wrapper sort-control-wrapper';
                    clonedElement.classList.add('shortcut-sort-small');
                }
                // copy visible selected option as tooltip for full value
                if (originalElement.options && originalElement.selectedIndex >= 0) {
                    clonedElement.title = originalElement.options[originalElement.selectedIndex].text || originalElement.value || '';
                } else {
                    clonedElement.title = originalElement.value || '';
                }
                if (originalElement.id === 'sortBy') {
                    const inner = document.createElement('div');
                    inner.className = 'sort-control-inner';
                    inner.appendChild(clonedElement);
                    const toggleBtn = createSortDirectionButton();
                    inner.appendChild(toggleBtn);
                    smallWrap.appendChild(inner);
                    initializeSortDirectionButtons(inner);
                } else {
                    smallWrap.appendChild(clonedElement);
                }
                shortcutWrapper.appendChild(smallWrap);
            } catch (e) {
                // Fallback to default append if anything goes wrong
                shortcutWrapper.appendChild(clonedElement);
            }
        } else {
            shortcutWrapper.appendChild(clonedElement);
        }
        shortcutContainer.appendChild(shortcutWrapper);
    });

    initializeSortDirectionButtons(shortcutContainer);
    updateSortDirectionIndicators();
    updateShowChangesButtonState();
    updateShortcutActiveStates();

    // í•€ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    controlContainer.querySelectorAll('.pin-shortcut-btn').forEach(btn => {
        const controlId = btn.dataset.controlId;
        if (pinnedShortcuts.has(controlId)) {
            btn.classList.add('pinned');
            btn.innerHTML = '&#128205;'; // í•€ ì´ëª¨ì§€
        } else {
            btn.classList.remove('pinned');
            btn.innerHTML = '&#128278;'; // ë§í¬ ì´ëª¨ì§€
        }
        
        // íˆ´íŒ ì¶”ê°€
        btn.title = pinnedShortcuts.has(controlId) ? 
            'ë°”ë¡œê°€ê¸°ì—ì„œ ì œê±°' : 
            'ë°”ë¡œê°€ê¸°ë¡œ ì¶”ê°€';
    });
}
        
        // ê°œì„ ì‚¬í•­ 2: ì›ë³¸ ì»¨íŠ¸ë¡¤ì—ì„œ ë°”ë¡œê°€ê¸°ë¡œ ë™ê¸°í™”í•˜ëŠ” í•¨ìˆ˜
        function syncShortcutsFromOriginal() {
            const controlContainer = document.getElementById('controlsPanel');
            
            pinnedShortcuts.forEach(id => {
                const originalElement = controlContainer.querySelector(`#${id}`);
                const shortcutElement = document.querySelector(`#shortcut-${id}`);
                
                if (!originalElement || !shortcutElement) return;
                
                // SELECTë‚˜ INPUTì˜ ê²½ìš° ê°’ ë™ê¸°í™”
                if ((originalElement.tagName === 'SELECT' || originalElement.tagName === 'INPUT') && 
                    (shortcutElement.tagName === 'SELECT' || shortcutElement.tagName === 'INPUT')) {
                    if (shortcutElement.value !== originalElement.value) {
                        shortcutElement.value = originalElement.value;
                    }
                }
            });
        }
        
        // ê°œì„  ì‚¬í•­ 1: ë°”ë¡œê°€ê¸° í•€ ì„¤ì • í•¨ìˆ˜
        function setupPinnableControls() {
            const controlContainer = document.getElementById('controlsPanel');
            controlContainer.querySelectorAll('.pinnable-control-wrapper').forEach(wrapper => {
                const control = wrapper.querySelector('select, input, button');
                if (!control) return;

                // If a pin button already exists, ensure it has a dataset.controlId set
                let existingPin = wrapper.querySelector('.pin-shortcut-btn');
                // Ensure control has a stable id for referencing
                if (!control.id) {
                    // Generate a stable-ish id using the control type and a short random suffix
                    control.id = `ctrl-${(control.tagName || 'el').toLowerCase()}-${Math.random().toString(36).slice(2,8)}`;
                }

                if (existingPin) {
                    existingPin.dataset.controlId = control.id;
                } else {
                    const pinBtn = document.createElement('button');
                    pinBtn.className = 'pin-shortcut-btn';
                    pinBtn.title = 'í—¤ë”ì— ë°”ë¡œê°€ê¸°ë¡œ ê³ ì •';
                    pinBtn.dataset.controlId = control.id;
                    pinBtn.setAttribute('type', 'button');
                    pinBtn.innerHTML = '&#128278;';
                    wrapper.appendChild(pinBtn);
                }
            });
            updateShortcuts(); // Initial render of shortcuts
        }

        // **ê°œì„  ì‚¬í•­ 1 ìˆ˜ì •: ì¤Œ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬**
        function handleZoomButtonClick(e) {
            e.stopPropagation();
            e.preventDefault();
            toggleZoomPopover(e.currentTarget);
        }

        // **ê°œì„  ì‚¬í•­ 1 ìˆ˜ì •: ë‚ ì§œ ì„¤ì • ëª¨ë‹¬ í† ê¸€ í•¨ìˆ˜**
        function toggleZoomPopover(buttonEl) {
            if (!zoomModal) return;
            
            const isHidden = zoomModal.classList.contains('hidden');

            if (isHidden) {
                zoomModal.classList.remove('hidden');
                // íŒì˜¤ë²„ ë‚´ë¶€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¬ì„¤ì •
                setupZoomPopoverListeners();
            } else {
                zoomModal.classList.add('hidden');
            }
        }

        // ì¤Œ íŒì˜¤ë²„ ë‚´ë¶€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupZoomPopoverListeners() {
            if (!zoomPopover) return;
            
            // ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì œê±°
            const applyBtn = zoomPopover.querySelector('#zoomApplyBtn');
            const resetBtn = zoomPopover.querySelector('#zoomResetBtn');
            const prevWeekBtn = zoomPopover.querySelector('#zoomPrevWeek');
            const thisWeekBtn = zoomPopover.querySelector('#zoomThisWeek');
            const nextWeekBtn = zoomPopover.querySelector('#zoomNextWeek');
            const threeWeeksTodayBtn = zoomPopover.querySelector('#zoomThreeWeeksToday');
            const threeWeeksSelectedBtn = zoomPopover.querySelector('#zoomThreeWeeksSelected');
            
            // ìƒˆ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            if (applyBtn) {
                applyBtn.removeEventListener('click', handleZoomApply);
                applyBtn.addEventListener('click', handleZoomApply);
            }
            if (resetBtn) {
                resetBtn.removeEventListener('click', handleZoomReset);
                resetBtn.addEventListener('click', handleZoomReset);
            }
            if (prevWeekBtn) {
                prevWeekBtn.removeEventListener('click', () => applyWeekZoom(-1));
                prevWeekBtn.addEventListener('click', () => applyWeekZoom(-1));
            }
            if (thisWeekBtn) {
                thisWeekBtn.removeEventListener('click', () => applyWeekZoom(0));
                thisWeekBtn.addEventListener('click', () => applyWeekZoom(0));
            }
            if (nextWeekBtn) {
                nextWeekBtn.removeEventListener('click', () => applyWeekZoom(1));
                nextWeekBtn.addEventListener('click', () => applyWeekZoom(1));
            }
            if (threeWeeksTodayBtn) {
                threeWeeksTodayBtn.removeEventListener('click', handleZoomThreeWeeksToday);
                threeWeeksTodayBtn.addEventListener('click', handleZoomThreeWeeksToday);
            }
            if (threeWeeksSelectedBtn) {
                threeWeeksSelectedBtn.removeEventListener('click', handleZoomThreeWeeksSelected);
                threeWeeksSelectedBtn.addEventListener('click', handleZoomThreeWeeksSelected);
            }
        }


        // Function to update control element references
        function updateControlReferences(container = document) {
            // ì»¨íŠ¸ë¡¤ ìš”ì†Œë“¤ì€ ì´ì œ ë©”ì¸ document ë˜ëŠ” ì»¨íŠ¸ë¡¤ íŒ¨ë„ ë‚´ì— ìˆìŒ
            const controlContainer = document.getElementById('controlsPanel');

            taskTypeFilter = controlContainer.querySelector('#taskTypeFilter');
            customFilterContainer = controlContainer.querySelector('#customFilterContainer');
            progressFilter = controlContainer.querySelector('#progressFilter');
            sortBy = controlContainer.querySelector('#sortBy');
            searchInput = controlContainer.querySelector('#searchInput');
            goToTodayBtn = controlContainer.querySelector('#goToTodayBtn');
            expandAllBtn = controlContainer.querySelector('#expandAllBtn');
            collapseAllBtn = controlContainer.querySelector('#collapseAllBtn');
            showChangesBtn = controlContainer.querySelector('#showChangesBtn');
            // Prefer a document-level reference (covers the main control and any cloned shortcuts).
            toggleHierarchyOrderBtn = document.querySelector('#toggleHierarchyOrderBtn') || (controlContainer && controlContainer.querySelector('#toggleHierarchyOrderBtn'));
            zoomBtn = controlContainer.querySelector('#zoomBtn');
            zoomPopover = document.getElementById('zoomPopover'); // **ìˆ˜ì •: í•­ìƒ documentì—ì„œ ì°¾ë„ë¡**
            zoomStartDate = document.getElementById('zoomStartDate');
            zoomEndDate = document.getElementById('zoomEndDate');
            zoomApplyBtn = document.getElementById('zoomApplyBtn');
            zoomResetBtn = document.getElementById('zoomResetBtn');
            zoomPrevWeek = document.getElementById('zoomPrevWeek');
            zoomThisWeek = document.getElementById('zoomThisWeek');
            zoomNextWeek = document.getElementById('zoomNextWeek');
            zoomThreeWeeksToday = document.getElementById('zoomThreeWeeksToday');
            zoomThreeWeeksSelected = document.getElementById('zoomThreeWeeksSelected');

            // Re-attach listeners if elements exist
            if (taskTypeFilter) {
                taskTypeFilter.removeEventListener('change', render);
                taskTypeFilter.addEventListener('change', render);
                ensureControlDefaultValue(taskTypeFilter);
            }
            if (progressFilter) {
                progressFilter.removeEventListener('change', render);
                progressFilter.addEventListener('change', render);
                ensureControlDefaultValue(progressFilter);
            }
            if (sortBy) {
                sortBy.removeEventListener('change', handleSortControlChange);
                sortBy.addEventListener('change', handleSortControlChange);
                ensureControlDefaultValue(sortBy);
            }
            // ê°œì„  ì‚¬í•­: ê²€ìƒ‰ ì…ë ¥ì— ë””ë°”ìš´ì‹± ì ìš©í•˜ì—¬ ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‹œ ì„±ëŠ¥ ìµœì í™”
            if (searchInput) {
                searchInput.removeEventListener('input', debouncedRender);
                searchInput.removeEventListener('input', render);
                searchInput.addEventListener('input', debouncedRender);
                ensureControlDefaultValue(searchInput);
            }
            if (goToTodayBtn) goToTodayBtn.addEventListener('click', scrollToToday);
            attachShortcutToggleListener(expandAllBtn, 'expand');
            attachShortcutToggleListener(collapseAllBtn, 'collapse');
            if (showChangesBtn) {
                showChangesBtn.removeEventListener('click', toggleShowChangesFilter);
                showChangesBtn.addEventListener('click', toggleShowChangesFilter);
                updateShowChangesButtonState();
            }
            if (toggleHierarchyOrderBtn) {
                toggleHierarchyOrderBtn.removeEventListener('click', toggleHierarchyOrder);
                toggleHierarchyOrderBtn.addEventListener('click', toggleHierarchyOrder);
                // ë²„íŠ¼ í…ìŠ¤íŠ¸ ë° ìŠ¤íƒ€ì¼ ì´ˆê¸°í™” (í˜„ì¬ ìƒíƒœë¥¼ ì‹œê°ì ìœ¼ë¡œ ëª…í™•íˆ í‘œì‹œ)
                const isBottomMode = hierarchyOrder === 'bottom';
                // Update all matching buttons in the document (main control + any cloned shortcut buttons)
                const allToggleButtons = Array.from(document.querySelectorAll('#toggleHierarchyOrderBtn, [id*="toggleHierarchyOrderBtn"]'));
                allToggleButtons.forEach(btn => {
                    try {
                        btn.textContent = isBottomMode ? 'ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ)' : 'ê³„ì¸µìˆœì„œ (ìƒâ†’í•˜)';
                        if (isBottomMode) {
                            btn.style.backgroundColor = '#dbeafe';
                            btn.style.border = '2px solid #3b82f6';
                            btn.style.fontWeight = 'bold';
                            btn.style.color = '#1e40af';
                        } else {
                            btn.style.backgroundColor = '#fef3c7';
                            btn.style.border = '2px solid #f59e0b';
                            btn.style.fontWeight = 'bold';
                            btn.style.color = '#92400e';
                        }
                    } catch (e) {
                        // ignore individual button style failures
                    }
                });
            }
            
            // **ê°œì„  ì‚¬í•­ 1 ìˆ˜ì •: ì›ë³¸ ì¤Œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ**
            if(zoomBtn) {
                // Remove any existing listeners to prevent duplicates
                zoomBtn.removeEventListener('click', handleZoomButtonClick);
                zoomBtn.addEventListener('click', handleZoomButtonClick);
            }

            // ì¤Œ íŒì˜¤ë²„ ë‚´ë¶€ ë²„íŠ¼ë“¤ì€ íŒì˜¤ë²„ê°€ ì—´ë¦´ ë•Œ setupZoomPopoverListenersì—ì„œ ì²˜ë¦¬

             // Add listeners for custom filters
             if(customFilterContainer) {
                 customFilterContainer.querySelectorAll('select').forEach(select => {
                     select.removeEventListener('change', render); // Prevent duplicates
                     select.addEventListener('change', render);
                 });
             }
             setupControlSectionToggles(controlContainer.querySelector('#controlsSection'));

            // ê°œì„  ì‚¬í•­: í—¤ë” íƒ€ì´í‹€ ì˜† ë°”ë¡œê°€ê¸° í•„í„°ë“¤ ë™ê¸°í™”
            const headerCustomFilter = document.getElementById('header-customer-filter-shortcut');
            const headerContractorFilter = document.getElementById('header-contractor-filter-shortcut');
            const mainCustomerFilter = controlContainer.querySelector('#customer-filter');
            const mainContractorFilter = controlContainer.querySelector('#contractor-filter');

            // í—¤ë” ë°”ë¡œê°€ê¸° ë™ê¸°í™”
            if (headerCustomFilter && mainCustomerFilter) {
                headerCustomFilter.innerHTML = mainCustomerFilter.innerHTML;
                // ì´ˆê¸° ì„¤ì •ì„ 'ê³ ê°ì‚¬'ë¡œ ê°•ì œ ì„¤ì •
                if (headerCustomFilter.querySelector('option[value="ê³ ê°ì‚¬"]')) {
                    // ë©”ì¸ í•„í„°ë¥¼ ë¨¼ì € 'ê³ ê°ì‚¬'ë¡œ ì„¤ì • (change ì´ë²¤íŠ¸ ë°œìƒ ë°©ì§€ë¥¼ ìœ„í•´ ì§ì ‘ ì„¤ì •)
                    mainCustomerFilter.value = 'ê³ ê°ì‚¬';
                    headerCustomFilter.value = 'ê³ ê°ì‚¬';
                    ensureControlDefaultValue(mainCustomerFilter);
                    // í•„í„° ë³€ê²½ì„ ë°˜ì˜í•˜ê¸° ìœ„í•´ render í˜¸ì¶œ
                    if (typeof render === 'function') {
                        render();
                    }
                } else {
                    headerCustomFilter.value = mainCustomerFilter.value;
                }
                
                // í´ë¦­ ì‹œ ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€
                headerCustomFilter.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                headerCustomFilter.addEventListener('change', (e) => {
                    e.stopPropagation();
                    mainCustomerFilter.value = e.target.value;
                    mainCustomerFilter.dispatchEvent(new Event('change'));
                });
                mainCustomerFilter.addEventListener('change', () => {
                    headerCustomFilter.innerHTML = mainCustomerFilter.innerHTML;
                    // ì‚¬ìš©ìê°€ ì§ì ‘ ë³€ê²½í•œ ê²½ìš°ì—ë§Œ ë™ê¸°í™” (ì´ˆê¸°í™” ì‹œì ì´ ì•„ë‹Œ ê²½ìš°)
                    headerCustomFilter.value = mainCustomerFilter.value;
                });
            }

            if (headerContractorFilter && mainContractorFilter) {
                headerContractorFilter.innerHTML = mainContractorFilter.innerHTML;
                headerContractorFilter.value = mainContractorFilter.value;
                ensureControlDefaultValue(mainContractorFilter);
                
                // í´ë¦­ ì‹œ ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€
                headerContractorFilter.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                headerContractorFilter.addEventListener('change', (e) => {
                    e.stopPropagation();
                    mainContractorFilter.value = e.target.value;
                    mainContractorFilter.dispatchEvent(new Event('change'));
                });
                mainContractorFilter.addEventListener('change', () => {
                    headerContractorFilter.innerHTML = mainContractorFilter.innerHTML;
                    headerContractorFilter.value = mainContractorFilter.value;
                });
            }

            updateGroupToggleButtons();
            updateZoomButtonState();
            updateShortcutActiveStates();

        }

        function getPrimarySortControl() {
            return sortBy || document.querySelector('#sortBy');
        }

        function handleSortControlChange(event) {
            sortState.mode = event.target.value || 'default';
            sortState.direction = SORT_DIRECTIONS.DESC;
            updateSortDirectionIndicators();
            render();
        }

        function handleSortDirectionButtonClick(event) {
            event.stopPropagation();
            event.preventDefault();
            const sortControl = getPrimarySortControl();
            if (!sortControl) return;
            const currentMode = sortControl.value || 'default';
            if (!currentMode || currentMode === 'default') {
                showToast('ì •ë ¬ ê¸°ì¤€ì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.', 'info');
                return;
            }
            sortState.mode = currentMode;
            sortState.direction = sortState.direction === SORT_DIRECTIONS.DESC ? SORT_DIRECTIONS.ASC : SORT_DIRECTIONS.DESC;
            updateSortDirectionIndicators();
            render();
        }

        function initializeSortDirectionButtons(context = document) {
            if (!context) return;
            context.querySelectorAll('.sort-direction-toggle').forEach(btn => {
                if (btn.dataset.listenerAttached === 'true') return;
                btn.addEventListener('click', handleSortDirectionButtonClick);
                btn.dataset.listenerAttached = 'true';
            });
        }

        function syncSortStateWithSelect(options = {}) {
            const { preserveDirection = true } = options;
            const sortControl = getPrimarySortControl();
            if (!sortControl) return;
            const currentMode = sortControl.value || 'default';
            if (sortState.mode !== currentMode) {
                sortState.mode = currentMode;
                if (!preserveDirection) {
                    sortState.direction = SORT_DIRECTIONS.DESC;
                }
            }
            updateSortDirectionIndicators();
        }

        function updateSortDirectionIndicators() {
            const sortControl = getPrimarySortControl();
            const mode = sortControl ? sortControl.value : 'default';
            const isActive = mode && mode !== 'default';
            const effectiveDirection = (sortState.mode === mode ? sortState.direction : SORT_DIRECTIONS.DESC);
            document.querySelectorAll('.sort-direction-toggle').forEach(btn => {
                if (!isActive) {
                    btn.classList.add('sort-direction-toggle--disabled');
                    btn.setAttribute('aria-disabled', 'true');
                } else {
                    btn.classList.remove('sort-direction-toggle--disabled');
                    btn.setAttribute('aria-disabled', 'false');
                }
                const up = btn.querySelector('.sort-arrow-up');
                const down = btn.querySelector('.sort-arrow-down');
                if (up) up.classList.toggle('active', isActive && effectiveDirection === SORT_DIRECTIONS.ASC);
                if (down) down.classList.toggle('active', isActive && effectiveDirection === SORT_DIRECTIONS.DESC);
            });
        }

        function updateShowChangesButtonState() {
            const buttons = document.querySelectorAll('#showChangesBtn, #shortcut-showChangesBtn');
            buttons.forEach(btn => {
                if (!btn) return;
                btn.classList.toggle('filter-toggle-active', showOnlyChanged);
                btn.textContent = showOnlyChanged ? 'ë³€ê²½ (í•„í„°ì¤‘)' : 'ë³€ê²½';
            });
            updateShortcutActiveStates();
        }

        function toggleShowChangesFilter() {
            showOnlyChanged = !showOnlyChanged;
            updateShowChangesButtonState();
            render();
        }

        function updateShortcutActiveStates() {
            if (!shortcutContainer) return;
            shortcutContainer.querySelectorAll('.shortcut-item').forEach(wrapper => {
                const controlId = wrapper.dataset.shortcutId;
                if (!controlId) return;
                const original = document.getElementById(controlId);
                const isActive = isControlActive(controlId, original);
                wrapper.classList.toggle('active-shortcut', !!isActive);
            });
            refreshShortcutTooltips();
        }

        function refreshShortcutTooltips() {
            if (!shortcutContainer) return;
            shortcutContainer.querySelectorAll('.shortcut-item').forEach(wrapper => {
                const controlId = wrapper.dataset.shortcutId;
                if (!controlId) return;
                const original = document.getElementById(controlId);
                if (!original) return;
                const tip = getShortcutTooltipText(original);
                const clone = wrapper.querySelector(`[data-shortcut-clone-id="${controlId}"]`);
                if (tip) {
                    wrapper.title = tip;
                    if (clone) clone.title = tip;
                } else {
                    wrapper.removeAttribute('title');
                    if (clone) clone.removeAttribute('title');
                }
            });
        }
        function getShortcutTooltipText(element) {
            if (!element) return '';
            if (element.tagName === 'SELECT') {
                const option = element.options && element.options[element.selectedIndex];
                return (option && option.text && option.text.trim()) || element.value || '';
            }
            if (element.tagName === 'INPUT') {
                return element.value || element.placeholder || '';
            }
            if (element.tagName === 'BUTTON') {
                return (element.textContent || '').trim();
            }
            return element.getAttribute('title') || (element.textContent || '').trim();
        }

        function ensureControlDefaultValue(control) {
            if (!control) return;
            if (typeof control.dataset.defaultValue === 'undefined') {
                control.dataset.defaultValue = control.value ?? '';
            }
        }

        function updateGroupToggleButtons() {
            if (expandAllBtn) {
                expandAllBtn.classList.toggle('filter-toggle-active', !!shortcutState.expandAll);
            }
            if (collapseAllBtn) {
                collapseAllBtn.classList.toggle('filter-toggle-active', !!shortcutState.collapseAll);
            }
        }

        function updateZoomButtonState() {
            if (!zoomBtn) return;
            zoomBtn.classList.toggle('filter-toggle-active', isCustomZoomActive);
        }

        function isControlActive(controlId, controlElement) {
            if (!controlId || !controlElement) return false;
            if (controlElement.classList.contains('filter-toggle-active') || controlElement.classList.contains('legend-filter-active')) {
                return true;
            }
            switch (controlId) {
                case 'expandAllBtn':
                    return !!shortcutState.expandAll;
                case 'collapseAllBtn':
                    return !!shortcutState.collapseAll;
                case 'zoomBtn':
                    return isCustomZoomActive;
                case 'sortBy':
                case 'progressFilter':
                case 'taskTypeFilter':
                case 'customer-filter':
                case 'contractor-filter':
                    const defaultValue = controlElement.dataset.defaultValue ?? (controlId === 'sortBy' ? 'default' : 'all');
                    return (controlElement.value || '').trim() !== (defaultValue || '').trim();
                case 'searchInput':
                    return !!(controlElement.value || '').trim();
                case 'showChangesBtn':
                    return showOnlyChanged;
                default:
                    return false;
            }
        }

        function attachShortcutToggleListener(button, type) {
            if (!button) return;
            if (button.__shortcutHandler) {
                button.removeEventListener('click', button.__shortcutHandler);
            }
            const handler = () => {
                if (type === 'expand') {
                    const togglingOn = !shortcutState.expandAll;
                    shortcutState.expandAll = togglingOn;
                    if (togglingOn) {
                        shortcutState.collapseAll = false;
                        toggleAllGroups(true);
                    }
                } else if (type === 'collapse') {
                    const togglingOn = !shortcutState.collapseAll;
                    shortcutState.collapseAll = togglingOn;
                    if (togglingOn) {
                        shortcutState.expandAll = false;
                        toggleAllGroups(false);
                    }
                }
                updateGroupToggleButtons();
                updateShortcutActiveStates();
            };
            button.addEventListener('click', handler);
            button.__shortcutHandler = handler;
        }

        function compareValuesWithDirection(valueA, valueB, direction = SORT_DIRECTIONS.DESC) {
            const isAscending = direction === SORT_DIRECTIONS.ASC;
            const fallback = isAscending ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
            const safeA = (typeof valueA === 'number' && !Number.isNaN(valueA)) ? valueA : fallback;
            const safeB = (typeof valueB === 'number' && !Number.isNaN(valueB)) ? valueB : fallback;
            return isAscending ? safeA - safeB : safeB - safeA;
        }

        function getProjectMetricValue(project, mode) {
            if (!project || !mode) return null;
            switch (mode) {
                case 'startDate':
                    return project.startDate instanceof Date && !isNaN(project.startDate) ? project.startDate.getTime() : null;
                case 'endDate':
                    return project.endDate instanceof Date && !isNaN(project.endDate) ? project.endDate.getTime() : null;
                case 'duration':
                    if (project.startDate instanceof Date && project.endDate instanceof Date && !isNaN(project.startDate) && !isNaN(project.endDate)) {
                        return dateDiffInDays(project.startDate, project.endDate) + 1;
                    }
                    return null;
                case 'progress':
                    return typeof project.progress === 'number' ? project.progress : (project.progress || 0);
                default:
                    return null;
            }
        }

        function createSortDirectionButton() {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'sort-direction-toggle';
            btn.dataset.sortTarget = 'sortBy';
            btn.setAttribute('aria-label', 'ì •ë ¬ ë°©í–¥ ì „í™˜');
            btn.title = 'ì •ë ¬ ë°©í–¥ ì „í™˜';
            btn.innerHTML = '<span class="sort-arrow sort-arrow-up" aria-hidden="true">â–²</span><span class="sort-arrow sort-arrow-down" aria-hidden="true">â–¼</span>';
            return btn;
        }

        // --- Functions for Zoom Popover Handlers ---
        function handleZoomApply() {
            const start = zoomStartDate.value;
            const end = zoomEndDate.value;
            if (start && end) {
                const newMinDate = parseLocalDateString(start);
                const newMaxDate = parseLocalDateString(end);
                if (newMinDate > newMaxDate) {
                    showToast('ì‹œì‘ì¼ì€ ì¢…ë£Œì¼ë³´ë‹¤ ëŠ¦ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                    return;
                }
                viewMinDate = newMinDate;
                viewMaxDate = newMaxDate;
                isCustomZoomActive = true;
                updateZoomButtonState();
                render();
                updateShortcutActiveStates();
                if(zoomModal) zoomModal.classList.add('hidden');
            } else {
                showToast('ì‹œì‘ì¼ê³¼ ì¢…ë£Œì¼ì„ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
            }
        }

        function handleZoomReset() {
             if (minDate && maxDate) {
                viewMinDate = new Date(minDate);
                viewMaxDate = new Date(maxDate);
                isCustomZoomActive = false;
                updateZoomButtonState();
                render();
                updateShortcutActiveStates();
                if(zoomModal) zoomModal.classList.add('hidden');
                if(zoomStartDate) zoomStartDate.value = '';
                if(zoomEndDate) zoomEndDate.value = '';
                
                // ê°œì„ ì‚¬í•­ 3: ê²½ê³  ìƒíƒœ ì œê±°
                const zoomBtn = document.getElementById('zoomBtn');
                if (zoomBtn) {
                    zoomBtn.classList.remove('bg-yellow-200');
                }
                showToast('ë‚ ì§œ ì„¤ì •ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
            }
        }

        function handleZoomThreeWeeksToday() {
             const today = new Date();
            today.setHours(0, 0, 0, 0);
            const getStartOfWeek = (date) => {
                const d = new Date(date); const day = d.getDay(); const diff = d.getDate() - day;
                return new Date(d.setDate(diff));
            };
            const startOfCurrentWeek = getStartOfWeek(today);
            const startOfView = new Date(startOfCurrentWeek);
            startOfView.setDate(startOfCurrentWeek.getDate() - 7);
            const endOfView = new Date(startOfView);
            endOfView.setDate(startOfView.getDate() + 20);
            viewMinDate = startOfView; viewMaxDate = endOfView;
            isCustomZoomActive = true;
            updateZoomButtonState();
            render();
            updateShortcutActiveStates();
            if(zoomModal) zoomModal.classList.add('hidden');
        }

        function handleZoomThreeWeeksSelected() {
             const start = zoomStartDate.value;
            if (!start) {
                showToast('ê¸°ê°„ ì„¤ì •ì—ì„œ ì‹œì‘ì¼ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
                return;
            }
            const startDate = parseLocalDateString(start);
            // ensure local midnight
            if (startDate) startDate.setHours(0,0,0,0);
            const threeWeeksLater = startDate ? new Date(startDate) : null;
            threeWeeksLater.setDate(startDate.getDate() + 21);
            viewMinDate = startDate; viewMaxDate = threeWeeksLater;
            isCustomZoomActive = true;
            updateZoomButtonState();
            render();
            updateShortcutActiveStates();
            if(zoomModal) zoomModal.classList.add('hidden');
        }

        function applyWeekZoom(weekOffset) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const getStartOfWeek = (date) => {
                const d = new Date(date);
                const day = d.getDay();
                const diff = d.getDate() - day;
                return new Date(d.setDate(diff));
            };
            
            const startOfCurrentWeek = getStartOfWeek(today);
            const targetWeekStart = new Date(startOfCurrentWeek);
            targetWeekStart.setDate(startOfCurrentWeek.getDate() + (weekOffset * 7));
            
            const targetWeekEnd = new Date(targetWeekStart);
            targetWeekEnd.setDate(targetWeekStart.getDate() + 6);
            
            viewMinDate = targetWeekStart;
            viewMaxDate = targetWeekEnd;
            isCustomZoomActive = true;
            updateZoomButtonState();
            render();
            updateShortcutActiveStates();
            if(zoomModal) zoomModal.classList.add('hidden');
        }
        // --- End Zoom Popover Handlers ---


        fileInput.addEventListener('change', handleFileSelect, false);
        // Event listeners for controls are now attached in updateControlReferences


        function globalClickListener(e) {
            const toggleBtn = e.target.closest('.toggle-col-btn');
            const dateEditor = e.target.closest('.date-editor');
            const progressEditor = e.target.closest('.progress-editor');

            if (!progressPopup.classList.contains('hidden') && !progressPopup.contains(e.target) && !e.target.closest('.progress-editor')) {
                progressPopup.classList.add('hidden');
            }

            // **ê°œì„  ì‚¬í•­ 1 ìˆ˜ì •: ë‚ ì§œ ì„¤ì • ëª¨ë‹¬ ìˆ¨ê¸°ê¸° ë¡œì§ (ë°°ê²½ í´ë¦­ ì‹œ)**
            if (zoomModal && !zoomModal.classList.contains('hidden') && e.target === zoomModal && !e.target.closest('.modal-content')) {
                zoomModal.classList.add('hidden');
            }


            if (toggleBtn) {
                e.stopPropagation();
                handleColumnToggle(toggleBtn);
            }
            else if (dateEditor && !dateEditor.closest('.group-header')) {
                e.stopPropagation();
                handleDateEditClick(dateEditor);
            }
            else if (progressEditor) {
                e.stopPropagation();
                handleProgressEditClick(progressEditor);
            }
        }

        function globalMousedownListener(e) {
            if (e.target.classList.contains('resizer')) handleResizeMousedown(e);
            if (e.target.classList.contains('col-resizer')) handleColResizeMousedown(e);
        }

        // Attach listeners once to the body, they will work even when elements move
        document.body.addEventListener('click', globalClickListener);
        document.body.addEventListener('mousedown', globalMousedownListener);

        // ëª¨ë‹¬ ë‹«ê¸° í•¨ìˆ˜ ì •ì˜
        function closeDetailModal() {
            dataDetailModal.classList.add('hidden');
            // ëª¨ë‹¬ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
            dataDetailModal.style.display = '';
            dataDetailModal.style.justifyContent = '';
            dataDetailModal.style.alignItems = '';
            
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.position = '';
                modalContent.style.width = '';
                modalContent.style.maxWidth = '';
                modalContent.style.height = '';
                modalContent.style.maxHeight = '';
                modalContent.style.margin = '';
                modalContent.style.transform = '';
                modalContent.style.top = '';
                modalContent.style.left = '';
                modalContent.style.overflow = '';
            }
            
            // ìŠ¤í¬ë¡¤ë°” ìœ„ì¹˜ ì´ˆê¸°í™”
            if (dataDetailTableContainer) {
                dataDetailTableContainer.scrollTop = 0;
                dataDetailTableContainer.style.maxHeight = '';
            }
        }

        // ëª¨ë‹¬ ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
        closeDataDetailModalBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeDetailModal();
        });

        // ESC í‚¤ë¡œ ëª¨ë‹¬ ë‹«ê¸°
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !dataDetailModal.classList.contains('hidden')) {
                closeDetailModal();
            }
        });

        // Date Settings Modal close button
        closeZoomModalBtn.addEventListener('click', () => {
            if (zoomModal) zoomModal.classList.add('hidden');
        });
        // Close modal on background click
        zoomModal.addEventListener('click', (e) => {
            if (e.target === zoomModal) {
                zoomModal.classList.add('hidden');
            }
        });
        // ESC key to close modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && zoomModal && !zoomModal.classList.contains('hidden')) {
                zoomModal.classList.add('hidden');
            }
        });

        fullscreenBtn.addEventListener('click', openFullscreenModal);
        closeFullscreenModalBtn.addEventListener('click', closeFullscreenModal);

        milestoneBtn.addEventListener('click', (e) => { // ê°œì„  ì‚¬í•­ 1: ë§ˆì¼ìŠ¤í†¤ ë²„íŠ¼ í´ë¦­ ë¡œì§ ê°œì„ 
            e.stopPropagation(); // ì•„ì½”ë””ì–¸ í—¤ë”ì˜ í´ë¦­ ì´ë²¤íŠ¸ê°€ ë°”ë¡œ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ ë°©ì§€

            const projectViewAccordion = document.getElementById('projectView');
            const isAccordionOpen = projectViewAccordion.classList.contains('open');

            // ì•„ì½”ë””ì–¸ì´ ë‹«í˜€ ìˆìœ¼ë©´, ë¨¼ì € ì—´ì–´ì¤ë‹ˆë‹¤.
            if (!isAccordionOpen) {
                const accordionHeader = projectViewAccordion.querySelector('.accordion-header');
                if (accordionHeader) {
                    // ë©”ì¸ ì•„ì½”ë””ì–¸ ë¡œì§ì„ íŠ¸ë¦¬ê±°í•˜ì—¬ ê°„íŠ¸ ë·°ë¡œ ì „í™˜í•©ë‹ˆë‹¤.
                    accordionHeader.click();
                }
            }

            // ë§ˆì¼ìŠ¤í†¤ ëª¨ë‹¬ì„ ë Œë”ë§í•˜ê³  í‘œì‹œí•©ë‹ˆë‹¤.
            renderMilestoneModal();
            milestoneModal.classList.remove('hidden');

            // ì•„ì½”ë””ì–¸ì´ ì—´ë¦¬ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ì„ ê³ ë ¤í•˜ì—¬,
            // ì ì‹œ í›„ ê°„íŠ¸ ì°¨íŠ¸ë¥¼ ë‹¤ì‹œ ë Œë”ë§í•˜ì—¬ ìŠ¤í¬ë¡¤ ê¸°ëŠ¥ì˜ ì•ˆì •ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
            setTimeout(() => render(), 350);
        });
        closeMilestoneModalBtn.addEventListener('click', () => milestoneModal.classList.add('hidden'));
        // ë°°ê²½ í´ë¦­ìœ¼ë¡œ ì¸í•œ ë‹«ê¸° ê¸°ëŠ¥ ì œê±° (milestoneModal click ì´ë²¤íŠ¸ ì œê±°)
        addMilestoneForm.addEventListener('submit', handleAddMilestone);
        milestoneList.addEventListener('click', (e) => {
            // ê°œì„  ì‚¬í•­ 1: ë§ˆì¼ìŠ¤í†¤ ì´ë™ ê¸°ëŠ¥ê³¼ ì‚­ì œ ê¸°ëŠ¥ì„ ë¶„ë¦¬í•˜ì—¬ ì²˜ë¦¬
            if (e.target.closest('.delete-milestone-btn')) handleMilestoneDelete(e);
            else if (e.target.closest('.milestone-nav-item')) handleMilestoneNavigate(e);
        });

        closeMappingModalBtn.addEventListener('click', () => mappingModal.classList.add('hidden'));
        cancelMappingBtn.addEventListener('click', () => mappingModal.classList.add('hidden'));
        applyMappingBtn.addEventListener('click', applyMapping);
        mappingHeaderRowCount.addEventListener('change', () => openMappingModal(rawImportData));

        closeErrorCorrectionModalBtn.addEventListener('click', () => errorCorrectionModal.classList.add('hidden'));
        discardErrorsBtn.addEventListener('click', () => errorCorrectionModal.classList.add('hidden'));
        retryImportBtn.addEventListener('click', handleRetryImport);

        const holidays = new Set([]);

        function isHoliday(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return holidays.has(`${yyyy}-${mm}-${dd}`);
        }

        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toast-container');
            if (!container) {
                const newContainer = document.createElement('div');
                newContainer.id = 'toast-container';
                document.body.appendChild(newContainer);
            }
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type} flex items-center gap-2`;
            
            // Add appropriate icon based on type
            let icon = '';
            switch(type) {
                case 'success':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>';
                    break;
                case 'error':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/></svg>';
                    break;
                case 'warning':
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/></svg>';
                    break;
                default:
                    icon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>';
            }
            
            toast.innerHTML = `${icon}<span>${message}</span>`;
            document.getElementById('toast-container').appendChild(toast);

            requestAnimationFrame(() => toast.classList.add('show'));

            const timer = setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);

            // í˜¸ë²„ ì‹œ íƒ€ì´ë¨¸ ì¼ì‹œ ì¤‘ì§€
            toast.addEventListener('mouseenter', () => clearTimeout(timer));
            toast.addEventListener('mouseleave', () => {
                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => toast.remove());
                }, duration / 2);
            });
        }

        function formatDate(date) {
            if (!(date instanceof Date) || isNaN(date)) return '';
            const year = date.getFullYear().toString().slice(-2);
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Full YYYY-MM-DD local format (avoids timezone-to-UTC issues from toISOString)
        function formatDateYMD(date) {
            if (!(date instanceof Date) || isNaN(date)) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            // ë‚ ì§œë¥¼ YYYY-MM-DD í˜•ì‹ìœ¼ë¡œë§Œ ë°˜í™˜
            return `${year}-${month}-${day}`;
        }

        function normalizeDateInput(value) {
            if (value instanceof Date && !isNaN(value)) {
                return formatDateYMD(value);
            }
            if (value === null || value === undefined) return '';
            const str = String(value).trim();
            if (!str) return '';
            const normalizedSeparators = str.replace(/[ë…„ì›”ì¼.\/\-]/g, '-').replace(/\s+/g, '-');
            const fullYearMatch = normalizedSeparators.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
            if (fullYearMatch) {
                const [, y, m, d] = fullYearMatch;
                return `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
            }
            const twoDigitMatch = normalizedSeparators.match(/^(\d{2})-(\d{1,2})-(\d{1,2})$/);
            if (twoDigitMatch) {
                const [, yy, m, d] = twoDigitMatch;
                const year = (parseInt(yy, 10) >= 70 ? 1900 : 2000) + parseInt(yy, 10);
                return `${year}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
            }
            const compactMatch = str.match(/^(\d{2,4})(\d{2})(\d{2})$/);
            if (compactMatch) {
                let [, y, m, d] = compactMatch;
                if (y.length === 2) {
                    const yearNum = parseInt(y, 10);
                    y = ((yearNum >= 70 ? 1900 : 2000) + yearNum).toString();
                }
                return `${y}-${m}-${d}`;
            }
            const parsed = new Date(str);
            if (!isNaN(parsed)) {
                return formatDateYMD(parsed);
            }
            return str;
        }

        function getNormalizedProjectDateString(project, dateKey) {
            if (!project) return '';
            const dateValue = project[dateKey];
            if (dateValue instanceof Date && !isNaN(dateValue)) {
                return formatDateYMD(dateValue);
            }
            const stringKey = `${dateKey}Str`;
            if (project[stringKey]) {
                const normalized = normalizeDateInput(project[stringKey]);
                project[stringKey] = normalized;
                return normalized;
            }
            return '';
        }

        function escapeAttribute(value) {
            if (value === null || value === undefined) return '';
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function getProjectRegistryKey(project, fallbackId = '', fallbackName = '') {
            if (project?.__registryKey) return project.__registryKey;
            if (!project && !fallbackId && !fallbackName) return '';
            let idSource = (project && typeof project.id !== 'undefined' && project.id !== null && project.id !== '') ? project.id : fallbackId;
            if (idSource === undefined || idSource === null || idSource === '') {
                idSource = fallbackName ? `name:${fallbackName}` : `auto:${projectRegistrySequence}`;
            }
            if (idSource === '') return '';
            const idPart = String(idSource);
            const nameSource = project?.name ?? fallbackName ?? '';
            const namePart = nameSource ? `__${String(nameSource).trim()}` : '';
            const key = `${idPart}${namePart}__seq${projectRegistrySequence++}`;
            if (project) {
                project.__registryKey = key;
            }
            return key;
        }

        function recordOriginalDates(project) {
            if (!project || typeof project.id === 'undefined' || project === null) return;
            const uniqueKey = getProjectRegistryKey(project);
            if (!uniqueKey) return;
            if (!originalDateRegistry.has(uniqueKey)) {
                originalDateRegistry.set(uniqueKey, {
                    start: getNormalizedProjectDateString(project, 'startDate'),
                    end: getNormalizedProjectDateString(project, 'endDate')
                });
                originalProgressRegistry.set(uniqueKey, typeof project.progress === 'number' ? project.progress : (project.progress || 0));
            }
        }

        // ê°œì„  ì‚¬í•­: ë°ì´í„° ë¡œë“œ ì‹œ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ê°•ì œ ì¬ì„¤ì •í•˜ëŠ” í•¨ìˆ˜
        function ensureProjectDateField(project, dateKey) {
            if (!project) return;
            const stringKey = `${dateKey}Str`;
            const currentDate = project[dateKey];
            let normalizedString = '';
            if (currentDate instanceof Date && !isNaN(currentDate)) {
                normalizedString = formatDateYMD(new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate()));
            } else if (project[stringKey]) {
                normalizedString = normalizeDateInput(project[stringKey]);
            } else if (typeof currentDate === 'string' && currentDate.trim()) {
                normalizedString = normalizeDateInput(currentDate);
            }
            if (normalizedString) {
                project[stringKey] = normalizedString;
                project[dateKey] = parseLocalDateString(normalizedString);
            } else {
                project[stringKey] = '';
                project[dateKey] = null;
            }
        }

        function normalizeAllProjectDates(projects) {
            if (!Array.isArray(projects)) return;
            projects.forEach(project => {
                ensureProjectDateField(project, 'startDate');
                ensureProjectDateField(project, 'endDate');
            });
        }

        function resetOriginalDatesForProjects(projects) {
            if (!Array.isArray(projects)) return;
            projects.forEach((project, index) => {
                if (!project || typeof project.id === 'undefined' || project === null) return;
                
                const uniqueKey = getProjectRegistryKey(project, project.id ?? index, project.name ?? `project_${index}`);
                if (!uniqueKey) return;
                if (originalDateRegistry.has(uniqueKey)) return;
                
                const startDateStr = getNormalizedProjectDateString(project, 'startDate');
                const endDateStr = getNormalizedProjectDateString(project, 'endDate');
                
                originalDateRegistry.set(uniqueKey, {
                    start: startDateStr,
                    end: endDateStr
                });
                originalProgressRegistry.set(uniqueKey, typeof project.progress === 'number' ? project.progress : (project.progress || 0));
            });
        }

        function rebaselineOriginalDates(skipRender = true, showToastMessage = false) {
            originalDateRegistry.clear();
            normalizeAllProjectDates(projectData);
            resetOriginalDatesForProjects(projectData);
            if (!skipRender) {
                render();
            }
            if (showToastMessage) {
                showToast('ëª¨ë“  ì‘ì—…ì˜ ë‚ ì§œ ë³€ê²½ í‘œì‹œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
            }
        }

        function getOriginalProgress(project) {
            if (!project || typeof project.id === 'undefined') return '';
            const uniqueKey = getProjectRegistryKey(project);
            if (!uniqueKey) return '';
            const v = originalProgressRegistry.get(uniqueKey);
            return (typeof v === 'number') ? v : '';
        }

        function projectHasChanges(project) {
            if (!project) return false;
            const startCurrent = getNormalizedProjectDateString(project, 'startDate');
            const endCurrent = getNormalizedProjectDateString(project, 'endDate');
            const originalStart = getOriginalDateValue(project, 'startDate');
            const originalEnd = getOriginalDateValue(project, 'endDate');
            const currentProgress = typeof project.progress === 'number' ? project.progress : (project.progress || 0);
            const originalProgress = getOriginalProgress(project);

            const startChanged = originalStart && startCurrent && originalStart !== startCurrent;
            const endChanged = originalEnd && endCurrent && originalEnd !== endCurrent;
            const progressChanged = typeof originalProgress === 'number' && originalProgress !== currentProgress;

            return !!(startChanged || endChanged || progressChanged);
        }

        function ensureOriginalDatesForProjects(projects) {
            if (!Array.isArray(projects)) return;
            projects.forEach(recordOriginalDates);
        }

        function getOriginalDateValue(project, dateType) {
            if (!project || typeof project.id === 'undefined' || dateType === undefined) return '';
            const uniqueKey = getProjectRegistryKey(project);
            if (!uniqueKey) return '';
            const entry = originalDateRegistry.get(uniqueKey);
            if (!entry) return '';
            const raw = dateType === 'startDate' ? entry.start : entry.end;
            return normalizeDateInput(raw);
        }

        function isProjectDateChanged(project, dateType) {
            if (!project || typeof project.id === 'undefined') return false;
            const originalValue = getOriginalDateValue(project, dateType);
            if (!originalValue) return false;
            const currentDateRaw = project[dateType] instanceof Date && !isNaN(project[dateType])
                ? formatDateYMD(project[dateType])
                : (project[`${dateType}Str`] || '');
            const currentValue = normalizeDateInput(currentDateRaw);
            if (!currentValue && !originalValue) return false;
            
            return currentValue !== originalValue;
        }

        function captureScrollState(skipAutoScroll = false) {
            const state = { skipAutoScroll };
            const containerCandidate = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (containerCandidate) {
                state.containerId = containerCandidate.id || (containerCandidate === fullscreenModalBody ? 'fullscreenModalBody' : null);
                state.scrollTop = containerCandidate.scrollTop;
                const timeline = containerCandidate.querySelector('.gantt-timeline-body-wrapper');
                if (timeline) {
                    state.timelineScrollLeft = timeline.scrollLeft;
                    state.timelineScrollTop = timeline.scrollTop;
                }
            }
            if (typeof window !== 'undefined') {
                state.windowScrollX = window.scrollX;
                state.windowScrollY = window.scrollY;
            }
            return state;
        }

        function restoreScrollState() {
            if (!pendingScrollRestore) return;
            const { containerId, scrollTop, timelineScrollLeft, timelineScrollTop, windowScrollX, windowScrollY } = pendingScrollRestore;
            let container = null;
            if (containerId) {
                if (containerId === 'fullscreenModalBody') {
                    container = fullscreenModalBody;
                } else {
                    container = document.getElementById(containerId);
                }
            }
            if (!container) {
                container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            }
            if (container && typeof scrollTop === 'number') {
                container.scrollTop = scrollTop;
            }
            if (container) {
                const timeline = container.querySelector('.gantt-timeline-body-wrapper');
                if (timeline) {
                    if (typeof timelineScrollLeft === 'number') timeline.scrollLeft = timelineScrollLeft;
                    if (typeof timelineScrollTop === 'number') timeline.scrollTop = timelineScrollTop;
                }
            }
            if (typeof window !== 'undefined') {
                const targetX = typeof windowScrollX === 'number' ? windowScrollX : window.scrollX;
                const targetY = typeof windowScrollY === 'number' ? windowScrollY : window.scrollY;
                window.scrollTo(targetX, targetY);
            }
            pendingScrollRestore = null;
        }

        function getExportCustomFieldDescriptors() {
            const descriptors = [];
            if (customFieldDisplayNames && typeof customFieldDisplayNames === 'object') {
                Object.keys(customFieldDisplayNames).forEach(key => {
                    if (!key) return;
                    descriptors.push({
                        key,
                        label: customFieldDisplayNames[key] || key
                    });
                });
            }
            return descriptors.sort((a, b) => a.label.localeCompare(b.label, 'ko-KR'));
        }

        function buildProjectExportRows() {
            ensureOriginalDatesForProjects(projectData);

            const rows = [];
            const customDescriptors = getExportCustomFieldDescriptors();
            let changedProjectCount = 0;

            const headerLabels = [
                'No.',
                'í”„ë¡œì íŠ¸ ID',
                'í”„ë¡œì íŠ¸ ëª…',
                'ì‘ì—… ìœ í˜•',
                'ìƒíƒœ',
                'ì‹œì‘ì¼(í˜„ì¬)',
                'ì‹œì‘ì¼(ì›ë³¸)',
                'ì¢…ë£Œì¼(í˜„ì¬)',
                'ì¢…ë£Œì¼(ì›ë³¸)',
                'ë‚ ì§œ ë³€ê²½ ì—¬ë¶€',
                'ë³€ê²½ ìƒì„¸',
                'ê¸°ê°„(ì¼)',
                'ì •ì‚° ê¸ˆì•¡',
                'ì§„í–‰ë¥ (%)'
            ];

            customDescriptors.forEach(desc => headerLabels.push(desc.label));

            headerLabels.push('ë¹„ê³ ');

            projectData.forEach((project, index) => {
                const startCurrent = project.startDate instanceof Date && !isNaN(project.startDate) ? formatDateYMD(project.startDate) : (project.startDateStr || '');
                const endCurrent = project.endDate instanceof Date && !isNaN(project.endDate) ? formatDateYMD(project.endDate) : (project.endDateStr || '');

                const registryKey = getProjectRegistryKey(project);
                const originalDates = registryKey ? (originalDateRegistry.get(registryKey) || {}) : {};
                const startOriginal = originalDates.start || startCurrent;
                const endOriginal = originalDates.end || endCurrent;

                const changeDetails = [];
                const changedStart = startOriginal && startCurrent && startOriginal !== startCurrent;
                const changedEnd = endOriginal && endCurrent && endOriginal !== endCurrent;

                if (changedStart) {
                    changeDetails.push(`ì‹œì‘ì¼: ${startOriginal} â†’ ${startCurrent}`);
                }
                if (changedEnd) {
                    changeDetails.push(`ì¢…ë£Œì¼: ${endOriginal} â†’ ${endCurrent}`);
                }

                const hasDateChange = changeDetails.length > 0;
                if (hasDateChange) changedProjectCount += 1;

                const durationDays = (project.startDate instanceof Date && project.endDate instanceof Date && !isNaN(project.startDate) && !isNaN(project.endDate))
                    ? (dateDiffInDays(project.startDate, project.endDate) + 1)
                    : '';

                const row = {
                    'No.': index + 1,
                    'í”„ë¡œì íŠ¸ ID': project.id || '',
                    'í”„ë¡œì íŠ¸ ëª…': project.name || '',
                    'ì‘ì—… ìœ í˜•': project.taskType || '',
                    'ìƒíƒœ': project.status || '',
                    'ì‹œì‘ì¼(í˜„ì¬)': startCurrent || '',
                    'ì‹œì‘ì¼(ì›ë³¸)': startOriginal || '',
                    'ì¢…ë£Œì¼(í˜„ì¬)': endCurrent || '',
                    'ì¢…ë£Œì¼(ì›ë³¸)': endOriginal || '',
                    'ë‚ ì§œ ë³€ê²½ ì—¬ë¶€': hasDateChange ? 'ë³€ê²½' : 'ìœ ì§€',
                    'ë³€ê²½ ìƒì„¸': changeDetails.join(' / '),
                    'ê¸°ê°„(ì¼)': durationDays,
                    'ì •ì‚° ê¸ˆì•¡': typeof project.poAmount === 'number' ? project.poAmount : (project.poAmount || 0),
                    'ì§„í–‰ë¥ (%)': typeof project.progress === 'number' ? project.progress : (project.progress || 0),
                    'ë¹„ê³ ': project.memo || ''
                };

                customDescriptors.forEach(desc => {
                    row[desc.label] = project.customFields?.[desc.key] ?? '';
                });

                rows.push(row);
            });

            return { headerLabels, rows, changedProjectCount };
        }

        function createWorkbookFromRows(headerLabels, rows, changedProjectCount) {
            const workbook = XLSX.utils.book_new();

            const aoa = [headerLabels];
            rows.forEach(row => {
                const rowValues = headerLabels.map(header => row[header] ?? '');
                aoa.push(rowValues);
            });

            const worksheet = XLSX.utils.aoa_to_sheet(aoa);
            worksheet['!cols'] = headerLabels.map(label => {
                const baseWidth = label.length + 6;
                const minWidth = 12;
                return { wch: Math.max(baseWidth, minWidth) };
            });

            XLSX.utils.book_append_sheet(workbook, worksheet, 'í”„ë¡œì íŠ¸');

            const now = new Date();
            const summarySheetData = [
                ['ìƒì„± ì¼ì‹œ', now.toLocaleString('ko-KR')],
                ['ì´ í”„ë¡œì íŠ¸ ìˆ˜', projectData.length],
                ['ë‚ ì§œê°€ ë³€ê²½ëœ í”„ë¡œì íŠ¸ ìˆ˜', changedProjectCount],
                ['ì•ˆë‚´', 'ë‚ ì§œ ë³€ê²½ ì—¬ë¶€/ë³€ê²½ ìƒì„¸ ì—´ì„ í™•ì¸í•˜ì—¬ í˜„ì¥ ìˆ˜ì •ëœ í•­ëª©ì„ íŒŒì•…í•˜ì„¸ìš”.'],
                ['ì„¤ëª…', 'ì›ë³¸ ë‚ ì§œëŠ” ìµœì´ˆ ì…ë ¥ê°’ì„ ë‚˜íƒ€ë‚´ë©°, í˜„ì¬ ë‚ ì§œì™€ ë‹¤ë¥¼ ê²½ìš° ë³€ê²½ìœ¼ë¡œ í‘œê¸°ë©ë‹ˆë‹¤.']
            ];

            const summarySheet = XLSX.utils.aoa_to_sheet(summarySheetData);
            summarySheet['!cols'] = [{ wch: 24 }, { wch: 60 }];
            XLSX.utils.book_append_sheet(workbook, summarySheet, 'ìš”ì•½');

            return workbook;
        }

        function handleExcelExport() {
            if (!Array.isArray(projectData) || projectData.length === 0) {
                showToast('ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                return;
            }

                try {
                    const { headerLabels, rows, changedProjectCount } = buildProjectExportRows();
                    const workbook = createWorkbookFromRows(headerLabels, rows, changedProjectCount);

                    // Append ì—…ë°ì´íŠ¸ ì´ë ¥ ì‹œíŠ¸ (ì¼ê´€ëœ ì „/í›„ ì»¬ëŸ¼: ì‹œì‘/ì¢…ë£Œì¼, ì§„í–‰ë¥ )
                    try {
                        const updatedProjectIds = window.__getUpdatedProjects ? window.__getUpdatedProjects() : [];
                        if (Array.isArray(updatedProjectIds) && updatedProjectIds.length > 0) {
                            const updateHistoryData = [];
                            updateHistoryData.push(['ì—…ë°ì´íŠ¸ í•­ëª© ìƒì„¸ ì´ë ¥']);
                            updateHistoryData.push(['']);
                            updateHistoryData.push([
                                'í”„ë¡œì íŠ¸ ID', 'ëª…ì¹­',
                                'ë³€ê²½ì „ ì‹œì‘ì¼', 'ë³€ê²½í›„ ì‹œì‘ì¼',
                                'ë³€ê²½ì „ ì¢…ë£Œì¼', 'ë³€ê²½í›„ ì¢…ë£Œì¼',
                                'ë³€ê²½ì „ ì§„í–‰ë¥ (%)', 'ë³€ê²½í›„ ì§„í–‰ë¥ (%)',
                                'ë³€ê²½ ì‹œê°„'
                            ]);

                            // Helper to format current date fields consistently
                            const fmtDateForProject = (p, type) => {
                                if (!p) return '';
                                if (p[type] instanceof Date && !isNaN(p[type])) return formatDateYMD(p[type]);
                                return p[`${type}Str`] || '';
                            };

                            // Compute overall original/current progress if requested
                            const includeOverall = updatedProjectIds.includes('overall');
                            if (includeOverall) {
                                const totalPo = projectData.reduce((s, p) => s + (p.poAmount || 0), 0);
                                const origWeighted = projectData.reduce((s, p) => {
                                    const op = getOriginalProgress(p);
                                    return s + ((Number(op) || 0) * (p.poAmount || 0));
                                }, 0);
                                const currentWeighted = projectData.reduce((s, p) => s + ((p.progress || 0) * (p.poAmount || 0)), 0);
                                const origOverall = totalPo > 0 ? Math.round(origWeighted / totalPo * 100) / 100 : 0;
                                const currOverall = totalPo > 0 ? Math.round(currentWeighted / totalPo * 100) / 100 : 0;
                                updateHistoryData.push(['overall', 'ì „ì²´ ì§„í–‰ë¥ ', '', '', '', '', origOverall + '%', currOverall + '%', new Date().toLocaleString('ko-KR')]);
                            }

                            updatedProjectIds.forEach(pid => {
                                if (pid === 'overall') return; // already handled
                                const project = projectData.find(p => p.id === pid);
                                if (!project) return;

                                const registryKey = getProjectRegistryKey(project, pid, project.name);
                                const originalDates = registryKey ? (originalDateRegistry.get(registryKey) || { start: '', end: '' }) : { start: '', end: '' };
                                const originalStart = originalDates.start || '';
                                const originalEnd = originalDates.end || '';
                                const currentStart = fmtDateForProject(project, 'startDate');
                                const currentEnd = fmtDateForProject(project, 'endDate');

                                const originalProg = getOriginalProgress(project);
                                const currentProg = (typeof project.progress === 'number') ? project.progress : (project.progress || 0);

                                // Only include rows where something actually changed
                                const changed = (originalStart !== currentStart) || (originalEnd !== currentEnd) || (Number(originalProg) !== Number(currentProg));
                                if (changed) {
                                    updateHistoryData.push([
                                        pid,
                                        project.name || '',
                                        originalStart || '', currentStart || '',
                                        originalEnd || '', currentEnd || '',
                                        (originalProg === '' ? '' : String(originalProg) + '%'), String(currentProg) + '%',
                                        new Date().toLocaleString('ko-KR')
                                    ]);
                                }
                            });

                            if (updateHistoryData.length > 3) {
                                const updateHistorySheet = XLSX.utils.aoa_to_sheet(updateHistoryData);
                                XLSX.utils.book_append_sheet(workbook, updateHistorySheet, 'ì—…ë°ì´íŠ¸ ì´ë ¥');
                            }
                        }
                    } catch (e) {
                        console.warn('update history sheet creation failed', e);
                    }

                    const now = new Date();
                    const fileNameTimestamp = [
                        now.getFullYear(),
                        String(now.getMonth() + 1).padStart(2, '0'),
                        String(now.getDate()).padStart(2, '0'),
                        String(now.getHours()).padStart(2, '0'),
                        String(now.getMinutes()).padStart(2, '0')
                    ].join('');
                    const fileName = `ê³µì •ê´€ë¦¬_ë‚´ë³´ë‚´ê¸°_${fileNameTimestamp}.xlsx`;
                    XLSX.writeFile(workbook, fileName, { compression: true });
                    showToast('ì—‘ì…€ íŒŒì¼ë¡œ ë‚´ë³´ëƒˆìŠµë‹ˆë‹¤.', 'success');
                } catch (error) {
                    console.error('Excel export failed:', error);
                    showToast('ì—‘ì…€ ë‚´ë³´ë‚´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                }
        }

        if (exportToExcelBtn && !exportToExcelBtn.dataset.enhancedExportAttached) {
            exportToExcelBtn.dataset.enhancedExportAttached = 'true';
            exportToExcelBtn.addEventListener('click', (event) => {
                event.preventDefault();
                handleExcelExport();
            });
        }

        // Parse a local YYYY-MM-DD (or similar) string into a Date at local midnight.
        // If input is already a Date, returns a copy normalized to local midnight.
        function parseLocalDateString(s) {
            if (!s) return null;
            
            // ë‚ ì§œê°€ ì´ë¯¸ Date ê°ì²´ì¸ ê²½ìš°, ë¡œì»¬ ìì •ìœ¼ë¡œ ë§ì¶° ë³µì œ
            if (s instanceof Date && !isNaN(s)) {
                return new Date(s.getFullYear(), s.getMonth(), s.getDate());
            }

            // Excel ì‹œë¦¬ì–¼ ë‚ ì§œ ë²ˆí˜¸ ì²˜ë¦¬ (1900ë…„ ê¸°ì¤€)
            if (typeof s === 'number' && s > 0) {
                try {
                    const msPerDay = 24 * 60 * 60 * 1000;
                    const jan1_1900 = new Date(Date.UTC(1900, 0, 1));
                    const daysSince1900 = s - 1; // Excelì˜ 1ì€ 1900ë…„ 1ì›” 1ì¼
                    const utcDate = new Date(jan1_1900.getTime() + (daysSince1900 * msPerDay));
                    return new Date(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate());
                } catch (e) {
                    console.error('Excel date parsing error:', e);
                    return null;
                }
            }

            // ë¬¸ìì—´ ì²˜ë¦¬
            try {
                const str = String(s).trim();
                const normalized = normalizeDateInput(str);
                if (normalized && /^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
                    const [year, month, day] = normalized.split('-').map(n => parseInt(n, 10));
                    return new Date(year, month - 1, day);
                }

                // ë‹¤ë¥¸ í˜•ì‹ì˜ ë‚ ì§œ ë¬¸ìì—´ ì²˜ë¦¬
                const tempDate = new Date(str);
                if (!isNaN(tempDate)) {
                    return new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());
                }
            } catch (e) {
                console.error('Date string parsing error:', e);
            }
            
            return null;
        }

        function formatCurrency(amount) {
            if (amount === null || amount === undefined || isNaN(amount)) {
                return '0ì›';
            }
            return `${parseInt(amount, 10).toLocaleString('ko-KR')}ì›`;
        }

        function formatAmountWithUnit(amount) {
            if (!amount || isNaN(amount)) return '';
            if (amount >= 100000000) { // ì–µ
                return `(${(amount / 100000000).toFixed(1)}ì–µ)`;
            } else if (amount >= 1000000) { // ë°±ë§Œì›
                return `(${(amount / 1000000).toFixed(1)}ë°±ë§Œì›)`;
            } else if (amount >= 100000) { // ì‹­ë§Œì›
                return `(${(amount / 100000).toFixed(1)}ì‹­ë§Œì›)`;
            }
            return '';
        }

        function getGroupProgressColor(progress) {
            const p = Math.max(0, Math.min(100, progress));
            const gray = { r: 156, g: 163, b: 175 }; // gray-400
            const blue = { r: 59, g: 130, b: 246 };  // blue-500
            const green = { r: 34, g: 197, b: 94 }; // green-500

            let r, g, b;
            if (p < 50) {
                const t = p / 50;
                r = Math.round(gray.r + t * (blue.r - gray.r));
                g = Math.round(gray.g + t * (blue.g - gray.g));
                b = Math.round(gray.b + t * (blue.b - gray.b));
            } else {
                const t = (p - 50) / 50;
                r = Math.round(blue.r + t * (green.r - blue.r));
                g = Math.round(blue.g + t * (green.g - blue.g));
                b = Math.round(blue.b + t * (green.b - blue.b));
            }
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Returns a CSS linear-gradient string based on progress value (0-100)
        function getProgressGradient(progress) {
            const p = Math.max(0, Math.min(100, Number(progress) || 0));
            // Use distinct, high-contrast color stops for start/mid/end
            const red = '#ef4444';   // red-500
            const orange = '#fb923c';// orange-400
            const amber = '#f59e0b'; // amber-500
            const green = '#10b981'; // emerald-500

            if (p < 30) {
                // low progress: red -> orange (strong warning)
                return `linear-gradient(90deg, ${red}, ${orange})`;
            } else if (p < 70) {
                // mid progress: orange -> amber -> green (transition)
                return `linear-gradient(90deg, ${orange}, ${amber}, ${green})`;
            } else {
                // high progress: amber -> green (success)
                return `linear-gradient(90deg, ${amber}, ${green})`;
            }
        }

        function updateAndApplyDateRange() {
            if (projectData.length === 0 && milestones.length === 0) {
                minDate = null; maxDate = null;
                viewMinDate = null; viewMaxDate = null;
                return;
            }

            const allDates = [
                ...projectData.map(p => p.startDate),
                ...projectData.map(p => p.endDate),
                ...milestones.map(m => parseLocalDateString(m.date))
            ].filter(d => d && !isNaN(d));

            if (allDates.length > 0) {
                const oldMinDateStr = minDate ? formatDateYMD(minDate) : null;
                const oldMaxDateStr = maxDate ? formatDateYMD(maxDate) : null;
                const viewMinDateStr = viewMinDate ? formatDateYMD(viewMinDate) : null;
                const viewMaxDateStr = viewMaxDate ? formatDateYMD(viewMaxDate) : null;

                const wasShowingFullRange = (viewMinDateStr === oldMinDateStr) && (viewMaxDateStr === oldMaxDateStr);

                minDate = new Date(Math.min(...allDates));
                maxDate = new Date(Math.max(...allDates));
                minDate.setDate(minDate.getDate() - 7);
                maxDate.setDate(maxDate.getDate() + 14);

                if (wasShowingFullRange || !viewMinDate) {
                     viewMinDate = new Date(minDate);
                     viewMaxDate = new Date(maxDate);
                }
            }
            isCustomZoomActive = false;
            updateZoomButtonState();
            updateShortcutActiveStates();
        }

        function toggleAllGroups(expand) {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody.querySelector('#ganttChartWrapper'); // Target chart wrapper
            if (!container) return;
            const groupHeaders = container.querySelectorAll('.group-header');

            groupHeaders.forEach(header => {
                const groupContainer = header.nextElementSibling;
                if (groupContainer && groupContainer.classList.contains('group-item-container')) {
                    const isCollapsed = groupContainer.classList.contains('hidden');

                    if (expand && isCollapsed) header.click();
                    else if (!expand && !isCollapsed) header.click();
                }
            });
            
            // ê°œì„  ì‚¬í•­: ê³„ì¸µìˆœì„œ ìœ ì§€ - ëª¨ë“  ê·¸ë£¹ ì ‘ê¸°/í¼ì¹˜ê¸° í›„ì—ë„ ê³„ì¸µìˆœì„œ ì¬ì ìš©
            setTimeout(() => {
                const containerRef = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                if (containerRef) {
                    applyHierarchyOrder(containerRef);
                }
            }, 350); // ì ‘ê¸°/í¼ì¹˜ê¸° ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì ìš©

            updateGroupToggleButtons();
            updateShortcutActiveStates();
        }

        // ê°œì„  ì‚¬í•­: ê³„ì¸µ ìˆœì„œ ë³€ê²½ í•¨ìˆ˜
        function toggleHierarchyOrder() {
            hierarchyOrder = hierarchyOrder === 'top' ? 'bottom' : 'top';
            shortcutState.expandAll = false;
            shortcutState.collapseAll = false;
            
            // ë²„íŠ¼ ì°¸ì¡° ì—…ë°ì´íŠ¸ (ìµœì‹  ìƒíƒœ ë³´ì¥)
            updateControlReferences();
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ ë° ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ (í˜„ì¬ ìƒíƒœë¥¼ ì‹œê°ì ìœ¼ë¡œ ëª…í™•íˆ í‘œì‹œ)
            const isBottomMode = hierarchyOrder === 'bottom';
            const buttonText = isBottomMode ? 'ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ)' : 'ê³„ì¸µìˆœì„œ (ìƒâ†’í•˜)';
            
            // Update any matching toggle buttons across the document (main control + cloned shortcuts)
            const matchingButtons = Array.from(document.querySelectorAll('#toggleHierarchyOrderBtn, [id*="toggleHierarchyOrderBtn"]'));
            matchingButtons.forEach(btn => {
                try {
                    btn.textContent = buttonText;
                    if (isBottomMode) {
                        btn.style.backgroundColor = '#dbeafe';
                        btn.style.border = '2px solid #3b82f6';
                        btn.style.fontWeight = 'bold';
                        btn.style.color = '#1e40af';
                    } else {
                        btn.style.backgroundColor = '#fef3c7';
                        btn.style.border = '2px solid #f59e0b';
                        btn.style.fontWeight = 'bold';
                        btn.style.color = '#92400e';
                    }
                } catch (e) {
                    // ignore styling errors for specific buttons
                }
            });
            
            // ì „ì—­ ë²„íŠ¼ ì°¸ì¡°ë„ ì—…ë°ì´íŠ¸
            if (toggleHierarchyOrderBtn) {
                toggleHierarchyOrderBtn.textContent = buttonText;
                if (isBottomMode) {
                    toggleHierarchyOrderBtn.style.backgroundColor = '#dbeafe';
                    toggleHierarchyOrderBtn.style.border = '2px solid #3b82f6';
                    toggleHierarchyOrderBtn.style.fontWeight = 'bold';
                    toggleHierarchyOrderBtn.style.color = '#1e40af';
                } else {
                    toggleHierarchyOrderBtn.style.backgroundColor = '#fef3c7';
                    toggleHierarchyOrderBtn.style.border = '2px solid #f59e0b';
                    toggleHierarchyOrderBtn.style.fontWeight = 'bold';
                    toggleHierarchyOrderBtn.style.color = '#92400e';
                }
            }
            
            // ì €ì¥ ì„¤ì •ì— ì¶”ê°€
            if (savedSettings) {
                savedSettings.hierarchyOrder = hierarchyOrder;
            }
            
            // ê°œì„  ì‚¬í•­: ê³„ì¸µ ìˆœì„œê°€ 'bottom'ì¼ ë•ŒëŠ” ëª¨ë“  ê·¸ë£¹ì„ ìë™ìœ¼ë¡œ í¼ì¹¨
            if (hierarchyOrder === 'bottom') {
                // ëª¨ë“  ê·¸ë£¹ì„ openTaskGroupsì— ì¶”ê°€í•˜ì—¬ í¼ì³ì§„ ìƒíƒœë¡œ ìœ ì§€
                const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                if (container) {
                    const groupHeaders = container.querySelectorAll('.group-header');
                    groupHeaders.forEach(header => {
                        const taskTypeMatch = header.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/);
                        if (taskTypeMatch) {
                            const taskType = taskTypeMatch[1];
                            openTaskGroups.add(taskType);
                        }
                    });
                }
                toggleAllGroups(true);
            }
            
            // ê°œì„  ì‚¬í•­: ê¸°ì¡´ DOMì— ì¦‰ì‹œ ì ìš©
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (container) {
                applyHierarchyOrder(container);
                // ê°œì„  ì‚¬í•­: ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ) ëª¨ë“œì¼ ë•Œ ëª¨ë“  ìƒìœ„ ê³„ì¸µ ê·¸ë£¹ í—¤ë” ìˆ¨ê¹€ ì²˜ë¦¬
                if (hierarchyOrder === 'bottom') {
                    const allGroupHeaders = container.querySelectorAll('.group-header');
                    allGroupHeaders.forEach(header => {
                        header.style.display = 'none';
                    });
                } else {
                    const allGroupHeaders = container.querySelectorAll('.group-header');
                    allGroupHeaders.forEach(header => {
                        header.style.display = '';
                    });
                }
            }
            
            // ì¦‰ì‹œ ë Œë”ë§í•˜ì—¬ ìˆœì„œ ë³€ê²½ ì ìš©
            render();
            
            // ë Œë”ë§ ì™„ë£Œ í›„ í™•ì‹¤íˆ ì ìš©ë˜ë„ë¡ ì¬ì ìš©
            setTimeout(() => {
                const containerAfterRender = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                if (containerAfterRender) {
                    applyHierarchyOrder(containerAfterRender);
                    // ê°œì„  ì‚¬í•­: ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ) ëª¨ë“œì¼ ë•Œ ëª¨ë“  ìƒìœ„ ê³„ì¸µ ê·¸ë£¹ í—¤ë” ìˆ¨ê¹€ ì²˜ë¦¬
                    if (hierarchyOrder === 'bottom') {
                        const allGroupHeadersAfter = containerAfterRender.querySelectorAll('.group-header');
                        allGroupHeadersAfter.forEach(header => {
                            header.style.display = 'none';
                        });
                    } else {
                        const allGroupHeadersAfter = containerAfterRender.querySelectorAll('.group-header');
                        allGroupHeadersAfter.forEach(header => {
                            header.style.display = '';
                        });
                    }
                }
            }, 100);
            
            showToast(`ê³„ì¸µ ìˆœì„œê°€ ${hierarchyOrder === 'top' ? 'ìƒìœ„â†’í•˜ìœ„' : 'í•˜ìœ„â†’ìƒìœ„'}ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
        }

        function syncGroupSummaryVisibility(groupMap) {
            if (!groupMap) return;
            groupMap.forEach(entry => {
                if (!entry || !entry.groupBarRow) return;
                if (hierarchyOrder === 'bottom') {
                    entry.groupBarRow.classList.add('hierarchy-summary-hidden');
                } else {
                    entry.groupBarRow.classList.remove('hierarchy-summary-hidden');
                }
            });
        }

        // ê°œì„  ì‚¬í•­: ê³„ì¸µ ìˆœì„œì— ë”°ë¼ DOM ìˆœì„œ ì¡°ì • í•¨ìˆ˜
        function applyHierarchyOrder(container) {
            if (!container) return;
            
            const titlesBody = container.querySelector('.gantt-titles-body-wrapper div');
            if (!titlesBody) return;

            // Retry guard: if DOM isn't fully ready (some gantt bar rows not present yet),
            // try again a few times with a short delay. This helps with race conditions
            // where bars are rendered slightly after the titles and avoids mis-mapping.
            if (!container.__applyHierarchyRetryCount) container.__applyHierarchyRetryCount = 0;
            
            // ê·¸ë˜í”„ ì˜ì—­ì˜ ë§‰ëŒ€ ê·¸ë˜í”„ ì»¨í…Œì´ë„ˆ ì°¾ê¸°
            const ganttBody = container.querySelector('.gantt-body');
            const ganttRowsBody = ganttBody ? ganttBody.querySelector('div:first-child') : null;
            
            // ê°œì„  ì‚¬í•­: ê·¸ë£¹ í—¤ë”ì™€ ì»¨í…Œì´ë„ˆë¥¼ ì •í™•íˆ ë§¤ì¹­í•˜ê¸° ìœ„í•´ data-task-type ì†ì„± ì‚¬ìš©
            const groupHeaders = Array.from(titlesBody.querySelectorAll('.group-header'));
            const groupContainers = Array.from(titlesBody.querySelectorAll('.group-item-container'));
            
            // taskTypeì„ ê¸°ë°˜ìœ¼ë¡œ í—¤ë”ì™€ ì»¨í…Œì´ë„ˆ ë§¤ì¹­
            const groupsToProcess = [];
            groupHeaders.forEach(header => {
                const taskType = header.dataset.taskType;
                if (taskType) {
                    // í•´ë‹¹ taskTypeì„ ê°€ì§„ ì»¨í…Œì´ë„ˆ ì°¾ê¸°
                    const matchedContainer = groupContainers.find(container => {
                        return container.dataset.taskType === taskType && 
                               !groupsToProcess.some(g => g.groupContainer === container);
                    });
                    
                    if (matchedContainer) {
                        groupsToProcess.push({ header, groupContainer: matchedContainer, taskType });
                    }
                }
            });
            
            // data-task-type ì†ì„±ì´ ì—†ëŠ” ê²½ìš°, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (í…ìŠ¤íŠ¸ ë§¤ì¹­)
            const unmatchedHeaders = groupHeaders.filter(h => !groupsToProcess.some(g => g.header === h));
            const unmatchedContainers = groupContainers.filter(c => !groupsToProcess.some(g => g.groupContainer === c));
            
            unmatchedHeaders.forEach(header => {
                const taskTypeMatch = header.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/);
                if (taskTypeMatch) {
                    const taskType = taskTypeMatch[1];
                    const matchedContainer = unmatchedContainers.find(container => {
                        const firstItem = container.querySelector('.title-item');
                        if (firstItem) {
                            const projectId = firstItem.dataset.projectId;
                            if (projectId) {
                                const project = projectData.find(p => p.id === projectId);
                                if (project && project.taskType === taskType) {
                                    return !groupsToProcess.some(g => g.groupContainer === container);
                                }
                            }
                        }
                        return false;
                    });
                    
                    if (matchedContainer) {
                        groupsToProcess.push({ header, groupContainer: matchedContainer, taskType });
                    }
                }
            });
            
            // ì—¬ì „íˆ ë§¤ì¹­ë˜ì§€ ì•Šì€ ê²½ìš°, ì¸ì ‘í•œ í˜•ì œ ìš”ì†Œë¡œ ë§¤ì¹­
            const stillUnmatchedHeaders = groupHeaders.filter(h => !groupsToProcess.some(g => g.header === h));
            stillUnmatchedHeaders.forEach(header => {
                let nextSibling = header.nextElementSibling;
                let groupContainer = null;
                
                while (nextSibling) {
                    if (nextSibling.classList.contains('group-item-container')) {
                        groupContainer = nextSibling;
                        break;
                    }
                    nextSibling = nextSibling.nextElementSibling;
                }
                
                if (groupContainer && !groupsToProcess.some(g => g.groupContainer === groupContainer)) {
                    groupsToProcess.push({ header, groupContainer });
                }
            });

            // supplemental matching moved later where groupToElementsMap is available
            
            // ëª¨ë“  ê·¸ë£¹ì— ëŒ€í•´ ìˆœì„œ ì ìš©
            // ê°œì„  ì‚¬í•­: 'bottom' ëª¨ë“œì—ì„œëŠ” ê·¸ë£¹ í—¤ë”ë¥¼ ì»¨í…Œì´ë„ˆ ë°”ë¡œ ë‹¤ìŒìœ¼ë¡œ ì´ë™í•˜ë˜, DOM ìˆœì„œë¥¼ ì •í™•íˆ ìœ ì§€
            if (hierarchyOrder === 'bottom') {
                // 'bottom' ëª¨ë“œ: ê·¸ë£¹ í—¤ë”ë¥¼ ì»¨í…Œì´ë„ˆ ì•„ë˜ë¡œ ì´ë™í•˜ê³  ìˆ¨ê¹€
                // ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ìˆœì„œ ë³€ê²½ ì¶©ëŒ ë°©ì§€
                groupsToProcess.reverse().forEach(({ header, groupContainer }) => {
                    // í—¤ë”ê°€ ì´ë¯¸ ì»¨í…Œì´ë„ˆ ë‹¤ìŒì— ìˆëŠ”ì§€ í™•ì¸
                    const currentContainerNext = groupContainer.nextElementSibling;
                    if (currentContainerNext !== header) {
                        // í—¤ë”ë¥¼ ì»¨í…Œì´ë„ˆ ë°”ë¡œ ë‹¤ìŒìœ¼ë¡œ ì´ë™
                        if (currentContainerNext) {
                            titlesBody.insertBefore(header, currentContainerNext);
                        } else {
                            // ì»¨í…Œì´ë„ˆê°€ ë§ˆì§€ë§‰ì´ë©´ ëì— ì¶”ê°€
                            titlesBody.appendChild(header);
                        }
                    }
                    // ê°œì„  ì‚¬í•­: ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ) ëª¨ë“œì¼ ë•Œ ëª¨ë“  ìƒìœ„ ê³„ì¸µ ê·¸ë£¹ í—¤ë” ìˆ¨ê¹€
                    header.style.display = 'none';
                });
            } else {
                // 'top' ëª¨ë“œ: ê¸°ì¡´ ë¡œì§ ìœ ì§€ (ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ìˆœì„œ ë³€ê²½ ì¶©ëŒ ë°©ì§€)
                groupsToProcess.reverse().forEach(({ header, groupContainer }) => {
                    // ìƒìœ„â†’í•˜ìœ„: í—¤ë”ë¥¼ ì»¨í…Œì´ë„ˆ ìœ„ë¡œ ì´ë™ (ê¸°ë³¸ ìˆœì„œ)
                    const currentHeaderNext = header.nextElementSibling;
                    if (currentHeaderNext !== groupContainer) {
                        titlesBody.insertBefore(header, groupContainer);
                    }
                    // ê°œì„  ì‚¬í•­: ê³„ì¸µìˆœì„œ (ìƒâ†’í•˜) ëª¨ë“œì¼ ë•Œ ëª¨ë“  ìƒìœ„ ê³„ì¸µ ê·¸ë£¹ í—¤ë” í‘œì‹œ
                    header.style.display = '';
                });
            }
            
            // ê°œì„  ì‚¬í•­: ë§¤ì¹­ë˜ì§€ ì•Šì€ ëª¨ë“  ê·¸ë£¹ í—¤ë”ë„ ìˆ¨ê¹€/í‘œì‹œ ì²˜ë¦¬
            const allGroupHeaders = Array.from(titlesBody.querySelectorAll('.group-header'));
            allGroupHeaders.forEach(header => {
                if (!groupsToProcess.some(g => g.header === header)) {
                    if (hierarchyOrder === 'bottom') {
                        header.style.display = 'none';
                    } else {
                        header.style.display = '';
                    }
                }
            });
            
            // ê°œì„  ì‚¬í•­: ì‘ì—… ëª©ë¡ê³¼ ê·¸ë˜í”„ ë§‰ëŒ€ì˜ ìˆœì„œ ë™ê¸°í™”
            if (ganttRowsBody) {
                // ì‘ì—… ëª©ë¡ì—ì„œ ì „ì²´ ìˆœì„œ ì¶”ì¶œ (ê·¸ë£¹ í—¤ë”, ê·¸ë£¹ ì»¨í…Œì´ë„ˆ, title-item í¬í•¨)
                // í•µì‹¬: ê·¸ë£¹ í—¤ë” ì¬ë°°ì¹˜ í›„ì˜ ìµœì‹  DOM ìˆœì„œë¥¼ ë°˜ì˜í•˜ê¸° ìœ„í•´ ë‹¤ì‹œ ê°€ì ¸ì˜¤ê¸°
                // DOM ì¡°ì‘ì´ ì™„ë£Œëœ í›„ ìµœì‹  ìƒíƒœë¥¼ ê°€ì ¸ì˜´
                const allTitleElements = Array.from(titlesBody.children);
                const titleOrderMap = new Map(); // ìˆœì„œ ì¸ë±ìŠ¤ -> ìš”ì†Œ
                const groupToElementsMap = new Map(); // taskType -> {groupBarRow, childBarRowsContainer}
                
                // ê·¸ë˜í”„ ì˜ì—­ì˜ ëª¨ë“  ìš”ì†Œë¥¼ ë§µì— ì €ì¥
                const allGraphElements = Array.from(ganttRowsBody.children);
                allGraphElements.forEach(element => {
                    if (element.classList.contains('gantt-bar-row') && !element.dataset.projectId) {
                        // ê·¸ë£¹ ë°”
                        const groupBar = element.querySelector('.gantt-bar');
                        if (groupBar) {
                            const barName = groupBar.dataset.name;
                            if (barName) {
                                const taskTypeMatch = barName.match(/^(.+?)\s*\(ìš”ì•½\)/);
                                if (taskTypeMatch) {
                                    const taskType = taskTypeMatch[1];
                                    if (!groupToElementsMap.has(taskType)) {
                                        groupToElementsMap.set(taskType, { groupBarRow: null, childBarRowsContainer: null });
                                    }
                                    groupToElementsMap.get(taskType).groupBarRow = element;
                                }
                            }
                        }
                    } else if (element.querySelector && element.querySelector('.gantt-bar-row[data-project-id]')) {
                        // ìì‹ ë°” ì»¨í…Œì´ë„ˆ
                        const firstBarRow = element.querySelector('.gantt-bar-row[data-project-id]');
                        if (firstBarRow) {
                            const projectId = firstBarRow.dataset.projectId;
                            const titleItem = titlesBody.querySelector(`.title-item[data-project-id="${projectId}"]`);
                            if (titleItem) {
                                const groupContainer = titleItem.closest('.group-item-container');
                                if (groupContainer) {
                                    const taskType = groupContainer.dataset.taskType;
                                    if (taskType) {
                                        if (!groupToElementsMap.has(taskType)) {
                                            groupToElementsMap.set(taskType, { groupBarRow: null, childBarRowsContainer: null });
                                        }
                                        groupToElementsMap.get(taskType).childBarRowsContainer = element;
                                    }
                                }
                            }
                        }
                    }
                });

                // ì¶”ê°€ ë³´ê°•: ê·¸ë˜í”„(ê°„íŠ¸) ìª½ì—ì„œ ê·¸ë£¹ ìš”ì•½ ë°”ë‚˜ ìì‹ ì»¨í…Œì´ë„ˆë¥¼ ëª» ì°¾ëŠ” ê²½ìš°
                // ì ê²€í•˜ì—¬ groupToElementsMapì„ ë³´ì™„í•©ë‹ˆë‹¤. (í”„ë¡œì íŠ¸ id ê¸°ë°˜ íƒìƒ‰)
                try {
                    if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: supplemental matching START', { groupHeaders: groupHeaders.length, groupContainers: groupContainers.length });
                    const allTaskTypes = new Set();
                    groupHeaders.forEach(h => {
                        const tt = h.dataset.taskType;
                        if (tt) allTaskTypes.add(tt);
                        else {
                            const m = h.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/);
                            if (m) allTaskTypes.add(m[1]);
                            }
                    });
                    groupContainers.forEach(c => {
                        if (c.dataset.taskType) allTaskTypes.add(c.dataset.taskType);
                    });

                    allTaskTypes.forEach(taskType => {
                        if (!groupToElementsMap.has(taskType)) {
                            groupToElementsMap.set(taskType, { groupBarRow: null, childBarRowsContainer: null });
                        }

                            // After initial setup, wire focus sync between headers and rows
                            try {
                                const allGroupHeaders = Array.from(document.querySelectorAll('.group-header'));
                                allGroupHeaders.forEach(h => {
                                    try {
                                        const taskType = h.dataset.taskType || (h.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/)||[])[1];
                                        let row = null;
                                        if (taskType) row = findGroupBarRow(taskType);
                                        else {
                                            // fallback: nearest .gantt-bar-row sibling by visual index
                                            const firstTitle = h.nextElementSibling || h;
                                            row = document.querySelector('.gantt-bar-row');
                                        }
                                        applyFocusSync(h, row, taskType);
                                    } catch(e){}
                                });
                            } catch(e) { /* non-critical */ }

                        const entry = groupToElementsMap.get(taskType);

                        // 1) ê·¸ë£¹ ìš”ì•½ ë°” ê²€ìƒ‰: ì´ë¦„ì— '(ìš”ì•½)'ì´ í¬í•¨ëœ gantt-barë¥¼ ì°¾ì•„ ë¶€ëª¨ .gantt-bar-rowë¥¼ ì‚¬ìš©
                        if (!entry.groupBarRow) {
                            const candidateBar = Array.from(ganttRowsBody.querySelectorAll('.gantt-bar')).find(b => {
                                const name = b.dataset && b.dataset.name ? b.dataset.name : '';
                                return name && name.indexOf(taskType) === 0 && name.indexOf('(ìš”ì•½)') !== -1;
                            });
                            if (candidateBar) {
                                const barRow = candidateBar.closest('.gantt-bar-row');
                                if (barRow) entry.groupBarRow = barRow;
                            }
                        }

                        // 2) ìì‹ ë°” ì»¨í…Œì´ë„ˆ ê²€ìƒ‰: titlesBodyì˜ í•´ë‹¹ ê·¸ë£¹ì— ì†í•œ projectId ì¤‘ í•˜ë‚˜ë¥¼ í¬í•¨í•˜ëŠ” .gantt-bar-rowì˜ ë¶€ëª¨
                        if (!entry.childBarRowsContainer) {
                            const titleItemsInGroup = Array.from(titlesBody.querySelectorAll(`.group-item-container[data-task-type="${taskType}"] .title-item`));
                            const projectIds = titleItemsInGroup.map(t => t.dataset.projectId).filter(Boolean);
                            if (projectIds.length) {
                                const candidateBarRow = Array.from(ganttRowsBody.querySelectorAll('.gantt-bar-row[data-project-id]')).find(br => projectIds.includes(br.dataset.projectId));
                                if (candidateBarRow) {
                                    // ë¶€ëª¨ê°€ ë°”ë¡œ ìì‹ ì»¨í…Œì´ë„ˆì¼ ê°€ëŠ¥ì„±ì´ ë†’ìœ¼ë¯€ë¡œ parentNode ì‚¬ìš©
                                    entry.childBarRowsContainer = candidateBarRow.parentNode || candidateBarRow;
                                }
                            }
                        }

                        // ê°œë°œìš© ë¡œê·¸: ê° taskTypeë³„ ë§¤ì¹­ ìƒíƒœ
                        try {
                            console.debug('applyHierarchyOrder: match', taskType, {
                                hasGroupBarRow: !!entry.groupBarRow,
                                hasChildBarRowsContainer: !!entry.childBarRowsContainer,
                                sampleProjectIds: (Array.from(titlesBody.querySelectorAll(`.group-item-container[data-task-type="${taskType}"] .title-item`))||[]).slice(0,3).map(t=>t.dataset.projectId)
                            });
                        } catch(e) {
                            // ignore debug failures
                        }
                    });
                    if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: supplemental matching END');
                } catch (e) {
                    // ì•ˆì •ì„±: ë³´ê°• ë¡œì§ì—ì„œ ì˜¤ë¥˜ ë°œìƒ ì‹œ ë¬´ì‹œí•˜ê³  ê¸°ì¡´ ë™ì‘ ìœ ì§€
                    console.warn('applyHierarchyOrder: supplemental matching failed', e);
                }
                
                syncGroupSummaryVisibility(groupToElementsMap);
                
                // ì‘ì—… ëª©ë¡ ìˆœì„œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê·¸ë˜í”„ ìš”ì†Œ ì¬ì •ë ¬
                // ê°œë°œìš© ìƒì„¸ ë¡œê·¸: titles ìˆœì„œ ë° ganttRowsBody í˜„ì¬ ìƒíƒœ ì¶œë ¥
                try {
                    const titleSeq = allTitleElements.map(el => {
                        if (el.classList.contains('group-header')) {
                            return { type: 'group-header', taskType: el.dataset.taskType || (el.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/)||[])[1] };
                        } else if (el.classList.contains('group-item-container')) {
                            const ids = Array.from(el.querySelectorAll('.title-item')).map(t=>t.dataset.projectId).filter(Boolean);
                            return { type: 'group-container', taskType: el.dataset.taskType, projectIds: ids };
                        } else if (el.classList.contains('title-item')) {
                            return { type: 'title-item', projectId: el.dataset.projectId };
                        }
                        return { type: 'unknown' };
                    });

                    const ganttSeq = Array.from(ganttRowsBody.children).map(el => {
                        if (el.classList.contains('gantt-bar-row') && !el.dataset.projectId) {
                            const bar = el.querySelector('.gantt-bar');
                            const name = bar && bar.dataset ? bar.dataset.name : null;
                            return { type: 'group-bar-row', name };
                        } else if (el.querySelector && el.querySelector('.gantt-bar-row[data-project-id]')) {
                            const ids = Array.from(el.querySelectorAll('.gantt-bar-row[data-project-id]')).map(b=>b.dataset.projectId).filter(Boolean);
                            return { type: 'child-bar-container', projectIds: ids };
                        } else if (el.dataset && el.dataset.projectId) {
                            return { type: 'bar-row-project', projectId: el.dataset.projectId };
                        }
                        return { type: 'unknown' };
                    });

                    if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: TITLE SEQ', titleSeq);
                    if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: GANTT SEQ', ganttSeq);
                } catch (e) {
                    // ignore logging errors
                }
                // ê°œì„  ì‚¬í•­: ì‘ì—… ëª©ë¡ì˜ ì‹¤ì œ ì‹œê°ì  ìˆœì„œë¥¼ ì •í™•íˆ ê³„ì‚°í•˜ì—¬ ê·¸ë˜í”„ ì˜ì—­ê³¼ ì™„ì „íˆ ë™ê¸°í™”
                // Build quick lookup for project bar rows
                const projectBarRowById = new Map();
                Array.from(ganttRowsBody.querySelectorAll('.gantt-bar-row[data-project-id]')).forEach(br => {
                    if (br.dataset && br.dataset.projectId) projectBarRowById.set(br.dataset.projectId, br);
                });

                // If number of detected project bar rows is less than the number of title items,
                // it's likely rendering is still in progress or DOM structure is wrapped differently.
                // Retry a few times before proceeding to avoid incorrect ordering.
                try {
                    const expectedCount = Array.from(titlesBody.querySelectorAll('.title-item[data-project-id]')).length;
                    const foundCount = projectBarRowById.size;
                    if (foundCount < expectedCount && container.__applyHierarchyRetryCount < 3) {
                        container.__applyHierarchyRetryCount = (container.__applyHierarchyRetryCount || 0) + 1;
                        // Small delay to allow other rendering tasks to complete
                        setTimeout(() => {
                            try { applyHierarchyOrder(container); }
                            catch(e){ console.warn('applyHierarchyOrder: retry failed', e); }
                        }, 80);
                        // Avoid continuing this run; a retry will handle it
                        if (window && window.__GANTT_AUTO_DEBUG) console.debug('applyHierarchyOrder: retry scheduled', { expectedCount, foundCount, retry: container.__applyHierarchyRetryCount });
                        return;
                    }
                } catch (e) {
                    // ignore retry detection errors
                }
                // Supplemental matching: sometimes bars are wrapped or have slightly different DOM positions
                // If a title-projectId exists but not in the map, try broader searches to find any element related to that projectId.
                try {
                    const titleProjectIds = new Set();
                    Array.from(titlesBody.querySelectorAll('.title-item[data-project-id]')).forEach(t => {
                        if (t.dataset && t.dataset.projectId) titleProjectIds.add(t.dataset.projectId);
                    });

                    titleProjectIds.forEach(pid => {
                        if (!projectBarRowById.has(pid)) {
                            // 1) direct selector in ganttRowsBody for any element with dataset.projectId
                            let found = ganttRowsBody.querySelector(`.gantt-bar-row[data-project-id="${pid}"]`);
                            if (!found) {
                                // 2) broader: any element under ganttRowsBody that contains an inner .gantt-bar-row[data-project-id]
                                const candidate = Array.from(ganttRowsBody.querySelectorAll('[data-project-id], .gantt-bar-row')).find(el => {
                                    try {
                                        if (el.dataset && el.dataset.projectId === pid) return true;
                                        return !!el.querySelector && !!el.querySelector(`.gantt-bar-row[data-project-id="${pid}"]`);
                                    } catch (e) { return false; }
                                });
                                if (candidate) {
                                    // prefer the nearest .gantt-bar-row child if exists
                                    const inner = candidate.querySelector && candidate.querySelector(`.gantt-bar-row[data-project-id="${pid}"]`);
                                    found = inner || candidate;
                                }
                            }
                            if (found) {
                                projectBarRowById.set(pid, found);
                            }
                        }
                    });
                } catch (e) {
                    console.warn('applyHierarchyOrder: supplemental projectBarRowById matching failed', e);
                }
                
                // ê°œì„  ì‚¬í•­: ë‘ ëª¨ë“œ ëª¨ë‘ì—ì„œ ì‘ì—… ëª©ë¡ì˜ ì‹¤ì œ ì‹œê°ì  ìˆœì„œë¥¼ ì •í™•íˆ ë°˜ì˜
                // ì‘ì—… ëª©ë¡ì˜ ëª¨ë“  title-itemê³¼ ê·¸ë˜í”„ ì˜ì—­ì˜ bar-rowë¥¼ 1:1ë¡œ ì •í™•íˆ ë§¤í•‘
                let visibleContainers = []; // ìƒìœ„ ìŠ¤ì½”í”„ë¡œ ì´ë™í•˜ì—¬ ì¬ë°°ì¹˜ ë¡œì§ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡
                
                if (hierarchyOrder === 'bottom') {
                    // 'bottom' ëª¨ë“œ: ì‘ì—… ëª©ë¡ì˜ ì‹¤ì œ ì‹œê°ì  ìˆœì„œë¥¼ ì •í™•íˆ ê³„ì‚°
                    // 1ë‹¨ê³„: ëª¨ë“  title-itemì„ DOM ìˆœì„œëŒ€ë¡œ ìˆ˜ì§‘ (ê·¸ë£¹ ì»¨í…Œì´ë„ˆ ìˆœì„œ ìœ ì§€)
                    visibleContainers = [];
                    const allTitleItemsOrdered = []; // ì‘ì—… ëª©ë¡ì˜ ëª¨ë“  title-itemì„ ìˆœì„œëŒ€ë¡œ
                    
                    allTitleElements.forEach(titleElement => {
                        // ìˆ¨ê²¨ì§„ ê·¸ë£¹ í—¤ë”ëŠ” ë¬´ì‹œí•˜ê³ , group-item-containerë§Œ ì²˜ë¦¬
                        if (titleElement.classList.contains('group-item-container')) {
                            visibleContainers.push(titleElement);
                            // ê° ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ title-itemì„ ìˆœì„œëŒ€ë¡œ ìˆ˜ì§‘
                            const titleItems = Array.from(titleElement.querySelectorAll('.title-item'));
                            titleItems.forEach(item => {
                                allTitleItemsOrdered.push(item);
                            });
                        }
                    });
                    
                    // 2ë‹¨ê³„: ê° ê·¸ë£¹ ì»¨í…Œì´ë„ˆë¥¼ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬í•˜ê³ , ë‚´ë¶€ í•­ëª© ìˆœì„œ ì •ë ¬
                    visibleContainers.forEach(container => {
                        const taskType = container.dataset.taskType;
                        if (taskType && groupToElementsMap.has(taskType)) {
                            const graphElements = groupToElementsMap.get(taskType);
                            
                            // í•˜â†’ìƒ: ìì‹ ì»¨í…Œì´ë„ˆ ë¨¼ì €, ê·¸ë£¹ ë°” ë‚˜ì¤‘
                            // ë¨¼ì € ìì‹ ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ê°œë³„ í”„ë¡œì íŠ¸ ë°”ë¥¼ ì‘ì—… ëª©ë¡ ìˆœì„œì— ì •í™•íˆ ë§ê²Œ ì •ë ¬
                            if (graphElements.childBarRowsContainer) {
                                const childContainer = graphElements.childBarRowsContainer;
                                const groupTitleItems = Array.from(container.querySelectorAll('.title-item'));
                                const groupTitleOrder = groupTitleItems.map(item => item.dataset.projectId).filter(id => id);
                                
                                // ìì‹ ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ëª¨ë“  ë°”ë¥¼ ìˆ˜ì§‘
                                const barRowsMap = new Map();
                                const allBarRows = Array.from(childContainer.querySelectorAll('.gantt-bar-row[data-project-id]'));
                                allBarRows.forEach(barRow => {
                                    const projectId = barRow.dataset.projectId;
                                    if (projectId) {
                                        if (!barRowsMap.has(projectId)) {
                                            barRowsMap.set(projectId, []);
                                        }
                                        barRowsMap.get(projectId).push(barRow);
                                    }
                                });
                                
                                // ì‘ì—… ëª©ë¡ì˜ ì •í™•í•œ ìˆœì„œëŒ€ë¡œ ë°”ë¥¼ ì¬ë°°ì¹˜
                                // ì´ë ‡ê²Œ í•˜ë©´ ì‘ì—… ëª©ë¡ì˜ title-itemê³¼ ê·¸ë˜í”„ì˜ bar-rowê°€ 1:1ë¡œ ì •í™•íˆ ëŒ€ì‘ë¨
                                groupTitleOrder.forEach(projectId => {
                                    if (barRowsMap.has(projectId)) {
                                        const bars = barRowsMap.get(projectId);
                                        bars.forEach(bar => {
                                            childContainer.appendChild(bar);
                                        });
                                    }
                                });
                                
                                // ë‚˜ë¨¸ì§€ ë°”ë„ ì¶”ê°€ (ìˆœì„œê°€ ì—†ëŠ” ê²½ìš°, ì•ˆì „ì¥ì¹˜)
                                allBarRows.forEach(barRow => {
                                    const projectId = barRow.dataset.projectId;
                                    if (projectId && !groupTitleOrder.includes(projectId)) {
                                        childContainer.appendChild(barRow);
                                    }
                                });
                            }
                        }
                    });
                } else {
                    // 'top' ëª¨ë“œ: ê° ê·¸ë£¹ ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ê°œë³„ í”„ë¡œì íŠ¸ ë°”ë¥¼ ì‘ì—… ëª©ë¡ ìˆœì„œì— ë§ê²Œ ì •ë ¬
                    allTitleElements.forEach(titleElement => {
                        if (titleElement.classList.contains('group-item-container')) {
                            const taskType = titleElement.dataset.taskType;
                            
                            if (taskType && groupToElementsMap.has(taskType)) {
                                const graphElements = groupToElementsMap.get(taskType);
                                
                                // ìƒâ†’í•˜: ê·¸ë£¹ ë°” ë¨¼ì €, ìì‹ ì»¨í…Œì´ë„ˆ ë‚˜ì¤‘
                                // ë¨¼ì € ìì‹ ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ê°œë³„ í”„ë¡œì íŠ¸ ë°”ë¥¼ ì‘ì—… ëª©ë¡ ìˆœì„œì— ë§ê²Œ ì •ë ¬
                                if (graphElements.childBarRowsContainer) {
                                    const childContainer = graphElements.childBarRowsContainer;
                                    const groupTitleItems = Array.from(titleElement.querySelectorAll('.title-item'));
                                    const groupTitleOrder = groupTitleItems.map(item => item.dataset.projectId).filter(id => id);
                                    
                                    // ìì‹ ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ëª¨ë“  ë°”ë¥¼ ìˆ˜ì§‘
                                    const barRowsMap = new Map();
                                    const allBarRows = Array.from(childContainer.querySelectorAll('.gantt-bar-row[data-project-id]'));
                                    allBarRows.forEach(barRow => {
                                        const projectId = barRow.dataset.projectId;
                                        if (projectId) {
                                            if (!barRowsMap.has(projectId)) {
                                                barRowsMap.set(projectId, []);
                                            }
                                            barRowsMap.get(projectId).push(barRow);
                                        }
                                    });
                                    
                                    // ì‘ì—… ëª©ë¡ì˜ ì •í™•í•œ ìˆœì„œëŒ€ë¡œ ë°”ë¥¼ ì¬ë°°ì¹˜
                                    groupTitleOrder.forEach(projectId => {
                                        if (barRowsMap.has(projectId)) {
                                            const bars = barRowsMap.get(projectId);
                                            bars.forEach(bar => {
                                                childContainer.appendChild(bar);
                                            });
                                        }
                                    });
                                    
                                    // ë‚˜ë¨¸ì§€ ë°”ë„ ì¶”ê°€ (ìˆœì„œê°€ ì—†ëŠ” ê²½ìš°, ì•ˆì „ì¥ì¹˜)
                                    allBarRows.forEach(barRow => {
                                        const projectId = barRow.dataset.projectId;
                                        if (projectId && !groupTitleOrder.includes(projectId)) {
                                            childContainer.appendChild(barRow);
                                        }
                                    });
                                }
                            }
                        }
                    });
                }
                
                // ì¬ì •ë ¬ëœ ìˆœì„œë¡œ ê·¸ë˜í”„ ìš”ì†Œ ì¬ë°°ì¹˜
                // í•µì‹¬ ê°œì„ : ì‘ì—… ëª©ë¡ì˜ ì‹¤ì œ ì‹œê°ì  ìˆœì„œë¥¼ ì •í™•íˆ ë°˜ì˜í•˜ì—¬ ê·¸ë˜í”„ ì˜ì—­ì„ ì™„ì „íˆ ì¬êµ¬ì„±
                // ì‘ì—… ëª©ë¡ì˜ ê° í–‰ê³¼ ê·¸ë˜í”„ ì˜ì—­ì˜ ê° í–‰ì„ 1:1ë¡œ ì •í™•íˆ ë§¤í•‘
                
                // ì¬ë°°ì¹˜í•  ëª¨ë“  ê·¸ë˜í”„ ìš”ì†Œ ìˆ˜ì§‘ (ganttRowsBodyì˜ ì§ì ‘ ìì‹ ìš”ì†Œë§Œ)
                const allGraphElementsToReorder = Array.from(ganttRowsBody.children).filter(el => {
                    return (el.classList.contains('gantt-bar-row') && !el.dataset.projectId) ||
                           (el.querySelector && el.querySelector('.gantt-bar-row[data-project-id]'));
                });
                
                // ì‘ì—… ëª©ë¡ì˜ ì‹¤ì œ ì‹œê°ì  ìˆœì„œë¥¼ ì •í™•íˆ ê³„ì‚°
                // ì‘ì—… ëª©ë¡ì—ì„œ ë³´ì´ëŠ” ëª¨ë“  í–‰ì„ ì‹¤ì œ DOM ìˆœì„œëŒ€ë¡œ ìˆ˜ì§‘
                const orderedTitleRows = [];
                
                // ì‘ì—… ëª©ë¡ì˜ ëª¨ë“  ì§ì ‘ ìì‹ ìš”ì†Œë¥¼ ìˆœì„œëŒ€ë¡œ ìˆœíšŒ
                const walkTitleElements = (parent) => {
                    Array.from(parent.children).forEach(element => {
                        if (element.style.display === 'none') return;
                        
                        if (element.classList.contains('group-header')) {
                            if (hierarchyOrder === 'top') {
                                // 'top' ëª¨ë“œì—ì„œë§Œ ê·¸ë£¹ í—¤ë” í‘œì‹œ
                                const taskType = element.dataset.taskType || element.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/)?.[1];
                                orderedTitleRows.push({ type: 'group-header', element: element, taskType: taskType });
                            }
                        } else if (element.classList.contains('group-item-container')) {
                            const taskType = element.dataset.taskType;
                            // ê·¸ë£¹ ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ëª¨ë“  title-itemì„ ìˆœì„œëŒ€ë¡œ ìˆ˜ì§‘
                            const titleItems = Array.from(element.querySelectorAll('.title-item'));
                            titleItems.forEach(item => {
                                if (item.style.display !== 'none') {
                                    orderedTitleRows.push({ 
                                        type: 'title-item', 
                                        element: item, 
                                        taskType: taskType,
                                        projectId: item.dataset.projectId 
                                    });
                                }
                            });
                        } else if (element.classList.contains('title-item')) {
                            // ì§ì ‘ ìì‹ì¸ title-item (ì¼ë°˜ì ìœ¼ë¡œëŠ” ì—†ì§€ë§Œ ì•ˆì „ì¥ì¹˜)
                            if (element.style.display !== 'none') {
                                const projectId = element.dataset.projectId;
                                const groupContainer = element.closest('.group-item-container');
                                const taskType = groupContainer ? groupContainer.dataset.taskType : null;
                                orderedTitleRows.push({ 
                                    type: 'title-item', 
                                    element: element, 
                                    taskType: taskType,
                                    projectId: projectId 
                                });
                            }
                        }
                    });
                };
                
                walkTitleElements(titlesBody);
                
                // ì‘ì—… ëª©ë¡ì˜ ìˆœì„œëŒ€ë¡œ ê·¸ë˜í”„ ìš”ì†Œë¥¼ ì •í™•íˆ ì¬ë°°ì¹˜
                // í•µì‹¬: ì‘ì—… ëª©ë¡ì˜ ì‹¤ì œ DOM ìˆœì„œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê·¸ë˜í”„ ì˜ì—­ ì¬ë°°ì¹˜
                const finalOrderedElements = [];
                const processedGraphElements = new Set();
                const processedTaskTypes = new Set();
                
                // ì‘ì—… ëª©ë¡ì˜ ì‹¤ì œ DOM ìˆœì„œë¥¼ ë”°ë¼ê°€ë©´ì„œ ê·¸ë˜í”„ ìš”ì†Œ ì¬ë°°ì¹˜
                // í•µì‹¬: ì‘ì—… ëª©ë¡ì—ì„œ ê° ê·¸ë£¹ì´ ë‚˜íƒ€ë‚˜ëŠ” ìˆœì„œë¥¼ ì •í™•íˆ ì¶”ì 
                // allTitleElementsëŠ” ì´ë¯¸ ê·¸ë£¹ í—¤ë” ì¬ë°°ì¹˜ í›„ì˜ ìµœì‹  ìˆœì„œë¥¼ ë°˜ì˜
                
                // ë¨¼ì € ì‘ì—… ëª©ë¡ì—ì„œ ë³´ì´ëŠ” ëª¨ë“  ê·¸ë£¹ì˜ ìˆœì„œë¥¼ ì •í™•íˆ ì¶”ì 
                const taskTypeOrder = [];
                const seenTaskTypes = new Set();
                
                allTitleElements.forEach(titleElement => {
                    if (titleElement.style.display === 'none') return;
                    
                    let taskType = null;
                    
                    if (titleElement.classList.contains('group-header')) {
                        if (hierarchyOrder === 'top') {
                            // 'top' ëª¨ë“œì—ì„œë§Œ ê·¸ë£¹ í—¤ë” ì²˜ë¦¬
                            taskType = titleElement.dataset.taskType || titleElement.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/)?.[1];
                            if (taskType && !seenTaskTypes.has(taskType)) {
                                taskTypeOrder.push({ taskType, isGroupHeader: true, element: titleElement });
                                seenTaskTypes.add(taskType);
                            }
                        }
                    } else if (titleElement.classList.contains('group-item-container')) {
                        // ê·¸ë£¹ ì»¨í…Œì´ë„ˆê°€ ë³´ì´ëŠ” ê²½ìš°ë§Œ ì²˜ë¦¬ (ìˆ¨ê²¨ì§„ ê²½ìš° ì œì™¸)
                        if (titleElement.style.display !== 'none' && !titleElement.classList.contains('hidden')) {
                            taskType = titleElement.dataset.taskType;
                            if (taskType && !seenTaskTypes.has(taskType)) {
                                taskTypeOrder.push({ taskType, isGroupHeader: false, element: titleElement });
                                seenTaskTypes.add(taskType);
                            }
                        }
                    }
                });
                
                // ì‘ì—… ëª©ë¡ ìˆœì„œëŒ€ë¡œ ê·¸ë˜í”„ ìš”ì†Œ ì¬ë°°ì¹˜
                taskTypeOrder.forEach(({ taskType, isGroupHeader }) => {
                    if (groupToElementsMap.has(taskType)) {
                        const graphElements = groupToElementsMap.get(taskType);
                        
                        if (hierarchyOrder === 'bottom') {
                            // í•˜â†’ìƒ: ìì‹ ì»¨í…Œì´ë„ˆ ë¨¼ì €, ê·¸ë£¹ ë°” ë‚˜ì¤‘
                            if (graphElements.childBarRowsContainer && 
                                allGraphElementsToReorder.includes(graphElements.childBarRowsContainer) &&
                                !processedGraphElements.has(graphElements.childBarRowsContainer)) {
                                finalOrderedElements.push(graphElements.childBarRowsContainer);
                                processedGraphElements.add(graphElements.childBarRowsContainer);
                            }
                            if (graphElements.groupBarRow && 
                                allGraphElementsToReorder.includes(graphElements.groupBarRow) &&
                                !processedGraphElements.has(graphElements.groupBarRow)) {
                                finalOrderedElements.push(graphElements.groupBarRow);
                                processedGraphElements.add(graphElements.groupBarRow);
                            }
                        } else {
                            // ìƒâ†’í•˜: ê·¸ë£¹ ë°” ë¨¼ì €, ìì‹ ì»¨í…Œì´ë„ˆ ë‚˜ì¤‘
                            if (isGroupHeader) {
                                // ê·¸ë£¹ í—¤ë”ê°€ ë‚˜íƒ€ë‚˜ë©´ ê·¸ë£¹ ë°” ì¶”ê°€
                                if (graphElements.groupBarRow && 
                                    allGraphElementsToReorder.includes(graphElements.groupBarRow) &&
                                    !processedGraphElements.has(graphElements.groupBarRow)) {
                                    finalOrderedElements.push(graphElements.groupBarRow);
                                    processedGraphElements.add(graphElements.groupBarRow);
                                }
                            } else {
                                // ê·¸ë£¹ ì»¨í…Œì´ë„ˆê°€ ë‚˜íƒ€ë‚˜ë©´ (ê·¸ë£¹ í—¤ë”ê°€ ì—†ëŠ” ê²½ìš°) ê·¸ë£¹ ë°” ë¨¼ì €, ìì‹ ì»¨í…Œì´ë„ˆ ë‚˜ì¤‘
                                if (graphElements.groupBarRow && 
                                    allGraphElementsToReorder.includes(graphElements.groupBarRow) &&
                                    !processedGraphElements.has(graphElements.groupBarRow)) {
                                    finalOrderedElements.push(graphElements.groupBarRow);
                                    processedGraphElements.add(graphElements.groupBarRow);
                                }
                                if (graphElements.childBarRowsContainer && 
                                    allGraphElementsToReorder.includes(graphElements.childBarRowsContainer) &&
                                    !processedGraphElements.has(graphElements.childBarRowsContainer)) {
                                    finalOrderedElements.push(graphElements.childBarRowsContainer);
                                    processedGraphElements.add(graphElements.childBarRowsContainer);
                                }
                            }
                        }
                    }
                });
                
                // ë§¤ì¹­ë˜ì§€ ì•Šì€ ìš”ì†Œë“¤ë„ ì¶”ê°€ (ì•ˆì „ì¥ì¹˜)
                allGraphElementsToReorder.forEach(element => {
                    if (!processedGraphElements.has(element)) {
                        finalOrderedElements.push(element);
                        processedGraphElements.add(element);
                    }
                });

                // ì¶”ê°€ ì•ˆì „ì¥ì¹˜: ì‘ì—… ëª©ë¡(orderedTitleRows) ê¸°ë°˜ìœ¼ë¡œ ë” ì—„ë°€í•œ 1:1 ì¬ì •ë ¬ì„ ì‹œë„
                // ê¸°ì¡´ finalOrderedElementsê°€ ì •ìƒ ë™ì‘í•˜ì§€ ì•ŠëŠ” ê²½ìš°(êµ¬ì¡°ì  ë¶ˆì¼ì¹˜) ì´ë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
                try {
                    const strictOrderedElements = [];

                    // Debug flag: set window.__GANTT_STRICT_DEBUG = true in the console to enable detailed matching logs
                    const debugStrict = !!(window && window.__GANTT_STRICT_DEBUG);

                    // Build mapping: taskType -> ordered list of projectIds (appearance order in titles)
                    const taskTypeToProjectOrder = new Map();
                    orderedTitleRows.forEach(row => {
                        if (row.type === 'title-item' && row.projectId) {
                            const tt = row.taskType || (row.element && row.element.closest('.group-item-container')?.dataset.taskType) || null;
                            if (tt) {
                                if (!taskTypeToProjectOrder.has(tt)) taskTypeToProjectOrder.set(tt, []);
                                const arr = taskTypeToProjectOrder.get(tt);
                                if (!arr.includes(row.projectId)) arr.push(row.projectId);
                            }
                        }
                        if (row.type === 'group-header') {
                            const tt = row.taskType;
                            if (tt && !taskTypeToProjectOrder.has(tt)) taskTypeToProjectOrder.set(tt, []);
                        }
                    });

                    if (debugStrict) console.debug('applyHierarchyOrder: taskTypeToProjectOrder', Array.from(taskTypeToProjectOrder.entries()).slice(0,50));

                    // Helper: get group entry reliable (fallback to groupToElementsMap or via supplemental searches)
                    const getGroupEntry = (taskType) => {
                        if (groupToElementsMap.has(taskType)) return groupToElementsMap.get(taskType);
                        return { groupBarRow: null, childBarRowsContainer: null };
                    };

                    // Assemble strict order based on detected taskType order (taskTypeOrder was built earlier)
                    const seenTypes = new Set();
                    taskTypeOrder.forEach(({ taskType }) => {
                        if (seenTypes.has(taskType)) return;
                        seenTypes.add(taskType);

                        const entry = getGroupEntry(taskType);
                        const projList = taskTypeToProjectOrder.get(taskType) || [];

                        // Debug: report missing mappings per taskType
                        if (debugStrict) {
                            const missingProjectIds = projList.filter(pid => !projectBarRowById.has(pid));
                            console.debug('applyHierarchyOrder: taskType', taskType, {
                                projListCount: projList.length,
                                hasGroupBarRow: !!entry.groupBarRow,
                                hasChildContainer: !!entry.childBarRowsContainer,
                                missingProjectIds: missingProjectIds.slice(0,20)
                            });
                        }

                        if (hierarchyOrder === 'bottom') {
                            // í•˜â†’ìƒ: ìì‹ ë°” ë¨¼ì €
                            // Append child bar rows in the exact title order (projectId order)
                            if (entry.childBarRowsContainer) {
                                projList.forEach(pid => {
                                    const br = projectBarRowById.get(pid);
                                    if (br) strictOrderedElements.push(br);
                                });
                                // Also append any remaining child bar rows that weren't listed
                                Array.from(entry.childBarRowsContainer.querySelectorAll('.gantt-bar-row[data-project-id]')).forEach(br => {
                                    if (!strictOrderedElements.includes(br)) strictOrderedElements.push(br);
                                });
                            }
                            // Then append group summary bar row
                            if (entry.groupBarRow) strictOrderedElements.push(entry.groupBarRow);
                        } else {
                            // ìƒâ†’í•˜: ê·¸ë£¹ ë°” ë¨¼ì €
                            if (entry.groupBarRow) strictOrderedElements.push(entry.groupBarRow);
                            if (entry.childBarRowsContainer) {
                                projList.forEach(pid => {
                                    const br = projectBarRowById.get(pid);
                                    if (br) strictOrderedElements.push(br);
                                });
                                Array.from(entry.childBarRowsContainer.querySelectorAll('.gantt-bar-row[data-project-id]')).forEach(br => {
                                    if (!strictOrderedElements.includes(br)) strictOrderedElements.push(br);
                                });
                            }
                        }
                    });

                    // Append any remaining graph elements not covered yet
                    allGraphElementsToReorder.forEach(el => {
                        if (!strictOrderedElements.includes(el)) strictOrderedElements.push(el);
                    });

                    if (debugStrict) {
                        console.debug('applyHierarchyOrder: strictOrderedElements count', strictOrderedElements.length);
                        try {
                            const sampleIds = strictOrderedElements.slice(0,30).map(el => el.dataset ? (el.dataset.projectId || (el.querySelector && el.querySelector('.gantt-bar')?.dataset?.name) || el.className) : el.className);
                            console.debug('applyHierarchyOrder: strictOrderedElements sample', sampleIds);
                        } catch(e) {}
                    }

                    // If strict ordering seems valid (non-empty), use it; otherwise fall back to finalOrderedElements
                    const toUse = strictOrderedElements.length > 0 ? strictOrderedElements : finalOrderedElements;

                    // ì •í™•í•œ ìˆœì„œë¡œ ì¬ì‚½ì…
                    toUse.forEach(element => {
                        ganttRowsBody.appendChild(element);
                    });
                } catch (e) {
                    // ë¬¸ì œ ë°œìƒ ì‹œ ì•ˆì „í•˜ê²Œ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ë³µêµ¬
                    console.warn('applyHierarchyOrder: strict reorder failed, falling back', e);
                    finalOrderedElements.forEach(element => {
                        ganttRowsBody.appendChild(element);
                    });
                }
                
                // ìì‹ ë°” ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ê°œë³„ ë°”ë„ ì‘ì—… ëª©ë¡ ìˆœì„œì— ë§ê²Œ ì¬ì •ë ¬
                // ê°œì„  ì‚¬í•­: ë‘ ëª¨ë“œ ëª¨ë‘ì—ì„œ ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬í–ˆìœ¼ë¯€ë¡œ ì´ ë¶€ë¶„ì€ ì œê±°
                // (ê° ê·¸ë£¹ ë‚´ë¶€ì˜ ë°” ìˆœì„œëŠ” ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬ë¨)
            }
        }


        function openFullscreenModal() {
            const ganttViewContent = document.getElementById('ganttViewContent');
            // ê°œì„  ì‚¬í•­: ì»¨íŠ¸ë¡¤ íŒ¨ë„ ëŒ€ì‹  ë²”ë¡€(Legend)ì™€ ê°„íŠ¸ ì°¨íŠ¸ë¥¼ ì´ë™
            const legendSection = ganttViewContent.querySelector('#legendSection');
            const ganttWrapper = ganttViewContent.querySelector('#ganttChartWrapper');

            // Move Legend and Gantt Chart to the modal
            if (legendSection) fullscreenModalBody.appendChild(legendSection);
            if (ganttWrapper) fullscreenModalBody.appendChild(ganttWrapper);

            // Reset modal position and size
            const overlay = fullscreenModal;
            overlay.style.justifyContent = '';
            overlay.style.alignItems = '';
            const content = overlay.querySelector('.resizable-modal-content');
            content.style.top = '';
            content.style.left = '';
            content.style.margin = '';
            content.style.width = '95vw'; // Reset width
            content.style.height = '90vh'; // Reset height

            fullscreenModal.classList.remove('hidden');
            // ì»¨íŠ¸ë¡¤ ì°¸ì¡°ëŠ” í•­ìƒ ë©”ì¸ ë¬¸ì„œì˜ íŒ¨ë„ì„ ê°€ë¦¬í‚¤ë¯€ë¡œ ì—…ë°ì´íŠ¸í•  í•„ìš” ì—†ìŒ
            render(); // Re-render Gantt in its new location
        }

        function closeFullscreenModal() {
             const ganttViewContent = document.getElementById('ganttViewContent');
             
             // ê°œì„  ì‚¬í•­: ë²”ë¡€ì™€ ê°„íŠ¸ ì°¨íŠ¸ë¥¼ ì›ë˜ ìœ„ì¹˜ë¡œ ë³µì›
             const legendSection = fullscreenModalBody.querySelector('#legendSection');
             const ganttWrapper = fullscreenModalBody.querySelector('#ganttChartWrapper');
             
             if(legendSection) {
                 // ganttViewContentì˜ ì²« ë²ˆì§¸ ìì‹ìœ¼ë¡œ ë²”ë¡€ë¥¼ ì‚½ì…
                 ganttViewContent.insertBefore(legendSection, ganttViewContent.firstChild);
             }
             if (ganttWrapper) {
                 // ganttViewContentì˜ ë§ˆì§€ë§‰ ìì‹ìœ¼ë¡œ ê°„íŠ¸ ë˜í¼ë¥¼ ì¶”ê°€
                 ganttViewContent.appendChild(ganttWrapper);
             }

            // [NEW] Ensure the 'ì¼ì •' accordion is open after closing fullscreen.
            const projectViewAccordion = document.getElementById('projectView');
            if (projectViewAccordion) {
                // Hide all other main accordions to maintain the "focused" view
                document.querySelectorAll('#dashboardContent > .accordion-item').forEach(item => {
                    if (item.id !== 'projectView') {
                        item.style.display = 'none';
                        item.classList.remove('open', 'is-focused');
                    }
                });
                // Ensure the project view accordion is visible and marked as open/focused
                projectViewAccordion.style.display = '';
                projectViewAccordion.classList.add('open', 'is-focused');
            }

             fullscreenModal.classList.add('hidden');
             // ì»¨íŠ¸ë¡¤ ì°¸ì¡°ëŠ” í•­ìƒ ë©”ì¸ ë¬¸ì„œì˜ íŒ¨ë„ì„ ê°€ë¦¬í‚¤ë¯€ë¡œ ì—…ë°ì´íŠ¸í•  í•„ìš” ì—†ìŒ
             render(); // Re-render Gantt in its original location
        }


        function autoDetectHeaderRow(sheetData) {
            let bestGuess = 0;
            let maxScore = -1;

            for (let i = 0; i < Math.min(sheetData.length, 10); i++) {
                let stringCells = 0;
                let nonEmptyCells = 0;
                let dateCells = 0;
                const row = sheetData[i];
                if (!row || row.length === 0) continue;

                row.forEach(cell => {
                    if (cell !== null && cell !== undefined && cell !== "") {
                        nonEmptyCells++;
                        if (cell instanceof Date) {
                            dateCells++;
                        }
                        if (typeof cell === 'string' && isNaN(cell)) {
                            stringCells++;
                        }
                    }
                });

                if (nonEmptyCells === 0) continue;

                const stringRatio = stringCells / nonEmptyCells;
                const dateRatio = dateCells / nonEmptyCells;

                const score = stringRatio - (dateRatio * 2);

                if (score > maxScore) {
                    maxScore = score;
                    bestGuess = i;
                }
            }
            return bestGuess + 1;
        }

        function initDefaultPinnedShortcuts() {
            // ê¸°ë³¸ ë°”ë¡œê°€ê¸° ìˆœì„œ ì„¤ì • (ê°œì„  ì‚¬í•­: 'ê²€ìƒ‰'ì„ ë°”ë¡œê°€ê¸°ì— ì¶”ê°€)
            const defaultPinnedControls = [
                'showChangesBtn',        // ë³€ê²½
                'expandAllBtn',          // í¼ì¹˜ê¸°
                'collapseAllBtn',        // ì ‘ê¸°
                'fullscreenBtn',         // ì „ì²´ í™”ë©´
                'milestoneBtn',          // ë§ˆì¼ìŠ¤í†¤
                'toggleHierarchyOrderBtn', // ê³„ì¸µìˆœì„œ
                'customer-filter',       // ê³ ê°ì‚¬
                'contractor-filter',     // ì‹œê³µì‚¬
                'taskTypeFilter',        // ìœ í˜•
                'sortBy',                // ì •ë ¬
                'progressFilter',        // ì§„ì²™ë¥ 
                'searchInput',           // ê²€ìƒ‰ (ì¶”ê°€ë¨)
                'zoomBtn'                // ë‚ ì§œ ì„¤ì •
            ];
            
            // ê¸°ì¡´ í•€ ì´ˆê¸°í™”
            pinnedShortcuts.clear();
            
            // ìƒˆë¡œìš´ í•€ ì„¤ì •
            defaultPinnedControls.forEach(id => {
                pinnedShortcuts.add(id);
            });
            
            // Shortcut ê³ ì • ê·œì¹™ ì ìš© (ê³„ì¸µìˆœì„œ/ì •ë ¬/ì§„ì²™ë¥  ìœ„ì¹˜)
            ensureShortcutOrderRules();

            // ë°”ë¡œê°€ê¸° ë©”ë‰´ ì—…ë°ì´íŠ¸
            if (typeof updateShortcuts === 'function') {
                updateShortcuts();
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                    const sheetNames = workbook.SheetNames || [];

                    // Reset any pending milestone sheet
                    pendingMilestoneSheetData = null;

                    // Try to find a sheet that looks like a milestone sheet
                    const milestoneSheetIndex = sheetNames.findIndex(n => /milestone|ë§ˆì¼ìŠ¤í†¤/i.test(n));

                    // Parse the primary (first) sheet as project data as before
                    const primarySheetName = sheetNames[0];
                    const primaryWorksheet = workbook.Sheets[primarySheetName];
                    const sheetData = XLSX.utils.sheet_to_json(primaryWorksheet, { header: 1, defval: "" });

                    // If a milestone sheet exists and is not the first sheet, parse and store it for later
                    if (milestoneSheetIndex > -1 && milestoneSheetIndex !== 0) {
                        try {
                            const msWorksheet = workbook.Sheets[sheetNames[milestoneSheetIndex]];
                            const msData = XLSX.utils.sheet_to_json(msWorksheet, { header: 1, defval: "" });
                            if (msData && msData.length > 0) {
                                pendingMilestoneSheetData = msData;
                                showToast('ë§ˆì¼ìŠ¤í†¤ ì‹œíŠ¸ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. í”„ë¡œì íŠ¸ ë§¤í•‘ ì™„ë£Œ í›„ ë§ˆì¼ìŠ¤í†¤ ë§¤í•‘ì„ ì‹œì‘í•©ë‹ˆë‹¤.', 'info');
                            }
                        } catch (errMs) {
                            console.warn('milestone sheet parse failed', errMs);
                        }
                    }

                    if (sheetData.length > 0) {
                        const detectedHeaderRow = autoDetectHeaderRow(sheetData);
                        headerRowCountInput.value = detectedHeaderRow;
                        // Ensure mapping modal will use project fields by default
                        mappingTarget = 'projects';
                        CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
                        openMappingModal(sheetData);
                    } else {
                        showToast("ë¹ˆ íŒŒì¼ì´ê±°ë‚˜ ì½ì„ ìˆ˜ ì—†ëŠ” í˜•ì‹ì…ë‹ˆë‹¤.", 'error');
                    }
                } catch (error) {
                    console.error("Error processing file:", error);
                    showToast("íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", 'error');
                }
            };
            reader.onerror = () => {
                 showToast("íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", 'error');
            };
            reader.readAsArrayBuffer(file);
            event.target.value = '';
        }

        const MAPPING_FIELDS = [
            { key: 'id', name: 'ID', aliases: ['id', 'ì•„ì´ë””', 'ê³ ìœ ë²ˆí˜¸', 'ìœ ì§€ê´€ë¦¬ë²ˆí˜¸'], required: false },
            { key: 'name', name: 'ëª…ì¹­', aliases: ['name', 'ëª…ì¹­', 'í”„ë¡œì íŠ¸ëª…', 'ì‘ì—…ëª…', 'ê³µì‚¬ëª…', 'ìœ ì§€ê´€ë¦¬ëª…'], required: true },
            { key: 'taskType', name: 'ì‘ì—… ìœ í˜•', aliases: ['tasktype', 'task type', 'ì‘ì—…ìœ í˜•', 'ì‘ì—… ìœ í˜•', 'ê³µì¢…'], required: false },
            { key: 'status', name: 'ìƒíƒœ', aliases: ['status', 'ìƒíƒœ', 'ê³µì‚¬ì§„í–‰ìƒíƒœ'], required: false },
            { key: 'startDate', name: 'ì‹œì‘ì¼', aliases: ['startdate', 'start date', 'ì‹œì‘ì¼', 'ì°©ìˆ˜ì¼', 'ì‹œì‘'], required: true },
            { key: 'endDate', name: 'ì¢…ë£Œì¼', aliases: ['enddate', 'end date', 'ì¢…ë£Œì¼', 'ì™„ë£Œì¼', 'ì¢…ë£Œ'], required: true },
            { key: 'poAmount', name: 'ì •ì‚°', aliases: ['poamount', 'po amount', 'ì •ì‚°', 'ê¸ˆì•¡', 'ê³„ì•½ê¸ˆ', 'poê¸ˆì•¡'], required: false }
        , { key: 'progress', name: 'ì§„í–‰ë¥ ', aliases: ['progress', 'ì§„í–‰ë¥ ', 'ì§„ì²™ë¥ '], required: false }
];

        // Current mapping fields in use by the mapping modal. Default to project mapping fields.
        let CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
        // Mapping target: 'projects' or 'milestones'
        let mappingTarget = 'projects';
        // Hold pending milestone sheet data if workbook contains a separate milestone sheet
        let pendingMilestoneSheetData = null;

        const MILESTONE_MAPPING_FIELDS = [
            { key: 'id', name: 'ID', aliases: ['id', 'ì•„ì´ë””', 'ê³ ìœ ë²ˆí˜¸'], required: false },
            { key: 'ë§ˆì¼ìŠ¤í†¤', name: 'ë§ˆì¼ìŠ¤í†¤', aliases: ['milestone', 'ë§ˆì¼ìŠ¤í†¤', 'name', 'ëª…ì¹­'], required: true },
            { key: 'ë‚ ì§œ', name: 'ë‚ ì§œ', aliases: ['date', 'ë‚ ì§œ', 'ì¼ì'], required: true }
        ];

        function openMappingModal(sheetData) {
            rawImportData = sheetData;
            mappingHeaderRowCount.value = headerRowCountInput.value;
            const headerRowIndex = parseInt(mappingHeaderRowCount.value, 10) - 1;

            if (headerRowIndex < 0 || headerRowIndex >= sheetData.length) {
                showToast("ë°ì´í„° ì‹œì‘ í–‰ì´ íŒŒì¼ì˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚©ë‹ˆë‹¤.", 'error');
                return;
            }

            const primaryHeaders = sheetData[headerRowIndex] || [];
            const secondaryHeaders = sheetData[headerRowIndex + 1] || [];

            const combinedHeaders = primaryHeaders.map((h, i) => {
                const primary = h ? String(h).trim() : '';
                const secondary = (secondaryHeaders[i]) ? String(secondaryHeaders[i]).trim() : '';
                if (primary && !secondary) return primary;
                if (!primary && secondary) return secondary;
                return (primary + ' ' + secondary).trim();
            });

            const previewData = sheetData.slice(headerRowIndex + 2, headerRowIndex + 12);

            let tableHTML = '<table class="w-full text-left border-collapse"><thead class="bg-gray-100"><tr>';

            combinedHeaders.forEach(headerText => {
                tableHTML += `<th class="border"><div class="flex flex-col gap-1 p-2">`;
                tableHTML += `<select class="p-1 border rounded-md bg-white mapping-select">`;
                tableHTML += `<option value="ignore">ë¬´ì‹œ</option>`;

                CURRENT_MAPPING_FIELDS.forEach(field => {
                    tableHTML += `<option value="${field.key}">${field.name}${field.required ? ' (í•„ìˆ˜)' : ''}</option>`;
                });

                // í”„ë¡œì íŠ¸ ë§¤í•‘ì¼ ë•Œë§Œ ìƒˆ ì†ì„± ì¶”ê°€ ì˜µì…˜ í‘œì‹œ
                if (mappingTarget === 'projects') {
                    tableHTML += `<optgroup label="---">`;
                    tableHTML += `<option value="--add-new--">ìƒˆ ì†ì„±ìœ¼ë¡œ ì¶”ê°€...</option>`;
                    tableHTML += `</optgroup>`;
                }
                tableHTML += `</select>`;

                tableHTML += `<input type="text" class="new-property-input hidden mt-1 p-1 border rounded-md w-full" placeholder="ìƒˆ ì†ì„± ì´ë¦„">`;

                tableHTML += `<span class="font-normal text-gray-600 truncate pt-1" title="${headerText}">${headerText}</span>`;
                tableHTML += `</div></th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            previewData.forEach(row => {
                tableHTML += '<tr class="border-b">';
                combinedHeaders.forEach((_, colIndex) => {
                    let cellData = row[colIndex] || '';
                    if (cellData instanceof Date) {
                        cellData = formatDateYMD(cellData);
                    }
                    tableHTML += `<td class="p-2 border truncate" title="${cellData}">${cellData}</td>`;
                });
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table>';

            mappingPreviewContainer.innerHTML = tableHTML;

            // Now, set initial values and add listeners
            const allSelects = mappingPreviewContainer.querySelectorAll('.mapping-select');
            const allInputs = mappingPreviewContainer.querySelectorAll('.new-property-input');

            combinedHeaders.forEach((headerText, index) => {
                const select = allSelects[index];
                const input = allInputs[index];

                // Best match logic
                let bestMatch = 'ignore';
                let highestScore = 0.1; // Set a small threshold to avoid weak matches
                CURRENT_MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    field.aliases.forEach(alias => {
                        const lowerHeaderText = headerText.toLowerCase().trim();
                        const lowerAlias = alias.toLowerCase().trim();
                        if (headerText && lowerHeaderText.includes(lowerAlias)) {
                            let score = lowerAlias.length / lowerHeaderText.length;
                            if (lowerHeaderText === lowerAlias) {
                               score = 1.1;
                            }
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) {
                        highestScore = currentScore;
                        bestMatch = field.key;
                    }
                });

                // If no good standard match, suggest as new property
                if (bestMatch === 'ignore' && headerText) {
                     bestMatch = `custom:${headerText}`;
                }

                // Apply best match to UI
                if (bestMatch.startsWith('custom:')) {
                    select.value = '--add-new--';
                    input.classList.remove('hidden');
                    input.value = bestMatch.substring(7);
                } else {
                    select.value = bestMatch;
                }

                // Add event listener
                select.addEventListener('change', (e) => {
                    if (e.target.value === '--add-new--') {
                        input.classList.remove('hidden');
                        if (!input.value) {
                            input.value = headerText; // Pre-fill if empty
                        }
                    } else {
                        input.classList.add('hidden');
                    }
                });
            });


            dataPanel.classList.add('hidden');
            mappingModal.classList.remove('hidden');
        }

        function applyMapping() {
            const headerRowIndex = parseInt(mappingHeaderRowCount.value, 10) - 1;
            const mappingSelectors = mappingPreviewContainer.querySelectorAll('.mapping-select');
            const mappingInputs = mappingPreviewContainer.querySelectorAll('.new-property-input');

            // Branch based on mapping target (projects or milestones)
            if (mappingTarget === 'projects') {
                const mapping = {
                    core: {},
                    custom: []
                };
                MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

                let hasError = false;
                const usedFields = new Set();

                mappingSelectors.forEach((sel, index) => {
                    const value = sel.value;
                    if (value === 'ignore') return;

                    if (value === '--add-new--') {
                        const input = mappingInputs[index];
                        const fieldName = input.value.trim();
                        if (!fieldName) {
                            showToast(`ìƒˆ ì†ì„±ì˜ ì´ë¦„ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤ (ì—´ ${index + 1}).`, 'error');
                            hasError = true; return;
                        }
                        if (usedFields.has(fieldName)) { showToast(`ì†ì„± ì´ë¦„ '${fieldName}'ì´(ê°€) ì¤‘ë³µë©ë‹ˆë‹¤.`, 'error'); hasError = true; return; }
                        mapping.custom.push({ colIndex: index, fieldName: fieldName });
                        usedFields.add(fieldName);
                    } else {
                        if (usedFields.has(value)) { showToast(`í•„ë“œ '${MAPPING_FIELDS.find(f=>f.key === value).name}'ì´(ê°€) ì¤‘ë³µë©ë‹ˆë‹¤.`, 'error'); hasError = true; return; }
                        mapping.core[value] = index;
                        usedFields.add(value);
                    }
                });

                if (hasError) return;

                const missingFields = MAPPING_FIELDS.filter(f => f.required && mapping.core[f.key] === -1);
                if (missingFields.length > 0) {
                    const missingFieldNames = missingFields.map(f => f.name).join(', ');
                    showToast(`í•„ìˆ˜ í•„ë“œì¸ '${missingFieldNames}'ì„(ë¥¼) ë§¤í•‘í•´ì•¼ í•©ë‹ˆë‹¤.`, 'error');
                    return;
                }

                importMapping = mapping;
                processMappedData(rawImportData, mapping, headerRowIndex + 2);

                // If a milestone sheet was detected earlier, open mapping for it next
                if (pendingMilestoneSheetData) {
                    // Prepare for milestone mapping
                    mappingTarget = 'milestones';
                    CURRENT_MAPPING_FIELDS = MILESTONE_MAPPING_FIELDS;
                    // Use the same detected header row value
                    mappingHeaderRowCount.value = headerRowCountInput.value;
                    // Open milestone mapping after a small delay to let UI settle
                    const msData = pendingMilestoneSheetData;
                    pendingMilestoneSheetData = null; // clear pending
                    setTimeout(() => openMappingModal(msData), 600);
                }
                return;
            }

                // Milestone mapping path
            if (mappingTarget === 'milestones') {
                const mapping = {};
                MILESTONE_MAPPING_FIELDS.forEach(f => mapping[f.key] = -1);

                let hasError = false;
                const usedFields = new Set();

                mappingSelectors.forEach((sel, index) => {
                    const value = sel.value;
                    if (value === 'ignore') return;
                    if (value === '--add-new--') {
                        showToast('ë§ˆì¼ìŠ¤í†¤ ë°ì´í„°ëŠ” ê¸°ë³¸ í•„ë“œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'info');
                        hasError = true; 
                        return;
                    }
                    if (usedFields.has(value)) { 
                        showToast('ì¤‘ë³µëœ ë§¤í•‘ì´ ìˆìŠµë‹ˆë‹¤.', 'error'); 
                        hasError = true; 
                        return; 
                    }
                    mapping[value] = index;
                    usedFields.add(value);
                });

                if (hasError) {
                    mappingTarget = 'projects';  // ì—ëŸ¬ ë°œìƒì‹œ ë§¤í•‘ íƒ€ê²Ÿ ì´ˆê¸°í™”
                    return;
                }

                const missing = MILESTONE_MAPPING_FIELDS.filter(f => f.required && mapping[f.key] === -1);
                if (missing.length > 0) {
                    const missingNames = missing.map(f => f.name).join(', ');
                    showToast(`í•„ìˆ˜ í•„ë“œë¥¼ ëª¨ë‘ ë§¤í•‘í•˜ì„¸ìš”: ${missingNames}`, 'error');
                    mappingTarget = 'projects';  // í•„ìˆ˜ í•„ë“œ ëˆ„ë½ ì‹œ ë§¤í•‘ íƒ€ê²Ÿ ì´ˆê¸°í™”
                    return;
                }                try {
                    const processedMilestones = [];
                    for (let i = headerRowIndex + 2; i < rawImportData.length; i++) {
                        const row = rawImportData[i];
                        if (!row || row.every(cell => !cell)) continue;

                        const name = row[mapping['ë§ˆì¼ìŠ¤í†¤']];
                        let dateValue = row[mapping['ë‚ ì§œ']];

                        if (!name || !dateValue) continue;

                        // ë‚ ì§œ ì²˜ë¦¬
                        let finalDate = null;
                        
                    // ë§¤í•‘ ì„±ê³µ í›„ ëª¨ë‹¬ ë‹«ê¸°
                    mappingModal.classList.add('hidden');
                        if (typeof dateValue === 'number' && dateValue > 0) {
                            // Excel ì‹œë¦¬ì–¼ ë‚ ì§œ ì²˜ë¦¬ (1900ë…„ ê¸°ì¤€)
                            const excelEpoch = new Date(Date.UTC(1899, 11, 30));
                            const utcDate = new Date(excelEpoch.getTime() + (Math.floor(dateValue) * 24 * 60 * 60 * 1000));
                            // UTC ë‚ ì§œë¥¼ ë¡œì»¬ ì‹œê°„ìœ¼ë¡œ ë³€í™˜
                            finalDate = new Date(Date.UTC(
                                utcDate.getUTCFullYear(),
                                utcDate.getUTCMonth(),
                                utcDate.getUTCDate()
                            ));
                        } else if (dateValue instanceof Date && !isNaN(dateValue)) {
                            // Date ê°ì²´ë¥¼ UTC ê¸°ì¤€ìœ¼ë¡œ ìƒˆë¡œ ìƒì„±í•˜ì—¬ íƒ€ì„ì¡´ ì´ìŠˆ í•´ê²°
                            finalDate = new Date(Date.UTC(
                                dateValue.getFullYear(),
                                dateValue.getMonth(),
                                dateValue.getDate()
                            ));
                        } else if (typeof dateValue === 'string') {
                            const match = dateValue.trim().match(/^(\d{4})[-\/]?(\d{2})[-\/]?(\d{2})$/);
                            if (match) {
                                const [_, year, month, day] = match;
                                // ë¬¸ìì—´ ë‚ ì§œë¥¼ UTC ê¸°ì¤€ìœ¼ë¡œ ìƒì„±
                                finalDate = new Date(Date.UTC(
                                    parseInt(year),
                                    parseInt(month) - 1,
                                    parseInt(day)
                                ));
                            }
                        }

                        if (finalDate && !isNaN(finalDate)) {
                            // ì—…ë¡œë“œëœ ë‚ ì§œëŠ” +1ì¼ ë³´ì • ì ìš©
                            try { finalDate.setUTCDate(finalDate.getUTCDate() + 1); } catch (e) {}
                            // UTC ë‚ ì§œë¥¼ ì‚¬ìš©í•˜ì—¬ í¬ë§·íŒ…
                            const formattedDate = finalDate.getUTCFullYear() + '-' +
                                String(finalDate.getUTCMonth() + 1).padStart(2, '0') + '-' +
                                String(finalDate.getUTCDate()).padStart(2, '0');

                            processedMilestones.push({
                                name: name,
                                date: formattedDate
                            });
                        }
                    }

                    if (processedMilestones.length > 0) {
                        milestones = processedMilestones;
                        renderMilestoneModal();
                        render();
                        updateAndApplyDateRange();
                        showToast(`${processedMilestones.length}ê°œì˜ ë§ˆì¼ìŠ¤í†¤ì´ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
                        
                        // ë§ˆì¼ìŠ¤í†¤ ë§¤í•‘ ì„±ê³µ ì‹œ ëª¨ë‹¬ ë‹«ê¸°
                        mappingModal.classList.add('hidden');
                    } else {
                        showToast('ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ë§ˆì¼ìŠ¤í†¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                    }
                    
                    // reset mapping target and fields
                    mappingTarget = 'projects';
                    CURRENT_MAPPING_FIELDS = MAPPING_FIELDS;
                } catch (e) {
                    console.error('Error processing milestone data:', e);
                    showToast('ë§ˆì¼ìŠ¤í†¤ ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                }
                return;
            }
        }

        function validateAndParseRow(row, mapping) {
            const errors = [];
            const parsed = {};

            // 1. í•„ìˆ˜ ê°’ í™•ì¸ ë° ë°ì´í„° íŒŒì‹±
            MAPPING_FIELDS.forEach(field => {
                if (field.required) {
                    const val = row[mapping.core[field.key]];
                    if (val === null || val === undefined || String(val).trim() === '') {
                        errors.push(`${field.name}ì€(ëŠ”) í•„ìˆ˜ê°’ì…ë‹ˆë‹¤.`);
                    }
                }
            });

            // [ê°œì„  ì‚¬í•­ 1] ë‚ ì§œ íŒŒì‹± ì‹œ í‘œì¤€ ì‹œê°„ëŒ€(Timezone) ë¬¸ì œ í•´ê²°
            // ì—‘ì…€ì—ì„œ ì½ì–´ì˜¨ Date ê°ì²´ëŠ” UTC ìì •ìœ¼ë¡œ í•´ì„ë  ìˆ˜ ìˆì–´, í˜„ì§€ ì‹œê°„ìœ¼ë¡œ ë³€í™˜ ì‹œ í•˜ë£¨ ì „ ë‚ ì§œê°€ ë˜ëŠ” ë¬¸ì œë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
            // UTC ì‹œê°„ìœ¼ë¡œ ê°„ì£¼í•˜ê³  ë‚ ì§œì˜ ë…„, ì›”, ì¼ì„ ì¶”ì¶œí•˜ì—¬ ìƒˆë¡œìš´ í˜„ì§€ ì‹œê°„ ê¸°ì¤€ Date ê°ì²´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
            const fixTimezone = (date) => {
                return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            };
            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 2. ë°ì´í„° íŒŒì‹± ë° íƒ€ì… ê²€ì¦
            // ë‚ ì§œ
            const startDateVal = row[mapping.core.startDate];
            const endDateVal = row[mapping.core.endDate];
            const parseDate = (val) => {
                // ë‚ ì§œ íŒŒì‹±ì„ ê°œì„ í•˜ì—¬ í•­ìƒ ë¡œì»¬ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì²˜ë¦¬í•˜ê³  ì‹œê°„ëŒ€ ë¬¸ì œ í•´ê²°
                try {
                    let d = null;
                    if (val instanceof Date && !isNaN(val)) {
                        // Date ê°ì²´ì˜ ê²½ìš° ë¡œì»¬ ì‹œê°„ ì»´í¬ë„ŒíŠ¸ë¡œ ìƒˆë¡œìš´ ë‚ ì§œ ìƒì„±
                        const localYear = val.getFullYear();
                        const localMonth = val.getMonth();
                        const localDate = val.getDate();
                        d = new Date(localYear, localMonth, localDate);
                        // KST í™˜ê²½ì—ì„œì˜ ë‚ ì§œ ì˜¤í”„ì…‹ ë³´ì •
                        d.setDate(d.getDate() + 1);
                    } else if (typeof val === 'number' && val > 25569) {
                        // Excel ì¼ë ¨ ë²ˆí˜¸ë¥¼ UTCë¡œ ë³€í™˜ í›„ ë¡œì»¬ ë‚ ì§œë¡œ ë³€í™˜
                        const utcDate = new Date(Math.round((val - 25569) * 86400 * 1000));
                        const localYear = utcDate.getUTCFullYear();
                        const localMonth = utcDate.getUTCMonth();
                        const localDate = utcDate.getUTCDate();
                        d = new Date(localYear, localMonth, localDate);
                        // KST í™˜ê²½ì—ì„œì˜ ë‚ ì§œ ì˜¤í”„ì…‹ ë³´ì •
                        d.setDate(d.getDate() + 1);
                    } else {
                        const s = String(val || '').trim();
                        if (s === '') return null;
                        // YYYY-MM-DD ë˜ëŠ” YYYY/MM/DD í˜•ì‹ ìš°ì„  í™•ì¸
                        const m = s.match(/^(\d{4})[-\/]?(\d{1,2})[-\/]?(\d{1,2})/);
                        if (m) {
                            const y = parseInt(m[1], 10);
                            const mo = parseInt(m[2], 10) - 1;
                            const day = parseInt(m[3], 10);
                            d = new Date(y, mo, day);
                            // KST í™˜ê²½ì—ì„œì˜ ë‚ ì§œ ì˜¤í”„ì…‹ ë³´ì •
                            d.setDate(d.getDate() + 1);
                        } else {
                            // ë‹¤ë¥¸ í˜•ì‹ì˜ ê²½ìš° ë¡œì»¬ ì‹œê°„ìœ¼ë¡œ íŒŒì‹±
                            const tempDate = new Date(s);
                            if (!isNaN(tempDate)) {
                                d = new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());
                                // KST í™˜ê²½ì—ì„œì˜ ë‚ ì§œ ì˜¤í”„ì…‹ ë³´ì •
                                d.setDate(d.getDate() + 1);
                            }
                        }
                    }

                    if (!d || isNaN(d)) return null;
                    // Return local midnight constructed from the detected year/month/day
                    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
                } catch (e) {
                    return null;
                }
            };
            parsed.startDate = parseDate(startDateVal);
            parsed.endDate = parseDate(endDateVal);
            if (!parsed.startDate) errors.push('ì‹œì‘ì¼ì˜ ë‚ ì§œ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            if (!parsed.endDate) errors.push('ì¢…ë£Œì¼ì˜ ë‚ ì§œ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');

            // ë‚ ì§œ ë³´ì • ë¶ˆí•„ìš” - ëª¨ë“  ë‚ ì§œëŠ” ë¡œì»¬ ì‹œê°„ëŒ€ì—ì„œ ì²˜ë¦¬ë¨

            // ê¸ˆì•¡
            if (mapping.core.poAmount > -1) {
                const poStr = String(row[mapping.core.poAmount] || '0').replace(/,/g, '');
                parsed.poAmount = parseInt(poStr, 10);
                if (isNaN(parsed.poAmount)) errors.push('ì •ì‚° ê¸ˆì•¡ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤.');
            } else {
                parsed.poAmount = 0;
            }

            // ì§„í–‰ë¥ 
            parsed.progress = 0; // Default to 0
            if (mapping.core.progress > -1) {
                const progressStr = String(row[mapping.core.progress] || '0').replace(/%/g, '').trim();
                parsed.progress = parseInt(progressStr, 10);
                if (isNaN(parsed.progress) || parsed.progress < 0 || parsed.progress > 100) {
                    errors.push('ì§„í–‰ë¥ ì€ 0ê³¼ 100 ì‚¬ì´ì˜ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤.');
                }
            }

            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 3. ë…¼ë¦¬ì  ì˜¤ë¥˜ ê²€ì¦
            if (parsed.startDate > parsed.endDate) {
                errors.push('ì¢…ë£Œì¼ì€ ì‹œì‘ì¼ë³´ë‹¤ ë¹ ë¥¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }

            if (errors.length > 0) return { success: false, errors, originalData: row };

            // 4. ìµœì¢… ë°ì´í„° ê°ì²´ ìƒì„±
            const customFields = {};
            // Store custom fields using sanitized keys to avoid problems with special characters.
            mapping.custom.forEach(cf => {
                const originalName = cf.fieldName || '';
                const safeKey = sanitizeKey(originalName);
                // Preserve display name mapping for UI
                if (safeKey) customFieldDisplayNames[safeKey] = originalName;
                customFields[safeKey] = row[cf.colIndex] || '';
            });

            const toYMD = (d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            return {
                success: true,
                data: {
                    id: mapping.core.id > -1 && row[mapping.core.id] ? String(row[mapping.core.id]) : `gen-${Math.random().toString(36).substr(2, 9)}`,
                    name: String(row[mapping.core.name]),
                    taskType: mapping.core.taskType > -1 ? String(row[mapping.core.taskType] || 'ë¯¸ë¶„ë¥˜') : 'ë¯¸ë¶„ë¥˜',
                    status: mapping.core.status > -1 ? String(row[mapping.core.status]) : 'ì°©ê³µì „',
                    startDateStr: parsed.startDate ? toYMD(parsed.startDate) : '',
                    endDateStr: parsed.endDate ? toYMD(parsed.endDate) : '',
                    startDate: parsed.startDate,
                    endDate: parsed.endDate,
                    poAmount: parsed.poAmount,
                    progress: parsed.progress,
                    customFields: customFields
                }
            };
        }

        function processMappedData(rawData, mapping, dataStartIndex) {
            const dataRows = rawData.slice(dataStartIndex);
            const successfulData = [];
            const failedData = [];

            dataRows.forEach(row => {
                // ë¹ˆ í–‰ì€ ê±´ë„ˆë›°ê¸°
                if (row.every(cell => cell === null || cell === undefined || String(cell).trim() === '')) {
                    return;
                }
                const result = validateAndParseRow(row, mapping);
                if (result.success) {
                    successfulData.push(result.data);
                } else {
                    failedData.push(result);
                }
            });

            // ìƒˆë¡œ ì¶”ê°€ëœ ë°ì´í„°ë§Œ ì •ê·œí™”
            normalizeAllProjectDates(successfulData);
            
            // ìƒˆ ë°ì´í„°ë¥¼ projectDataì— ì¶”ê°€ (ì¤‘ë³µ ì œê±° ì—†ì´ ëª¨ë‘ ì¶”ê°€)
            projectData.push(...successfulData);
            
            // ê°œì„  ì‚¬í•­: ìƒˆë¡œ ì¶”ê°€ëœ ë°ì´í„°ì— ëŒ€í•´ì„œë§Œ ì›ë³¸ ë‚ ì§œ ì„¤ì •
            // ê¸°ì¡´ ë°ì´í„°ì˜ ì›ë³¸ ë‚ ì§œëŠ” ìœ ì§€
            resetOriginalDatesForProjects(successfulData);
            
            // [FIX] ë°ì´í„° ì²˜ë¦¬ í›„ í•„í„°ê°€ ëª¨ë‘ ìƒì„±ëœ ë‹¤ìŒ ê¸°ë³¸ ë°”ë¡œê°€ê¸°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
            initDefaultPinnedShortcuts();
            failedImportRows = failedData;

            updateAndApplyDateRange();
            populateFilters();
            render();

            mappingModal.classList.add('hidden');

            // ê²°ê³¼ í”¼ë“œë°±
            let summaryMessage = `${successfulData.length}ê°œ í•­ëª©ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.`;
            if (failedData.length > 0) {
                summaryMessage += ` ${failedData.length}ê°œ í•­ëª©ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.`;
                showToast(summaryMessage, 'warning', 5000);
                openErrorCorrectionModal(failedData, mapping);
            } else {
                showToast(summaryMessage, 'success');
            }

            if (projectData.length > 0 || milestones.length > 0) {
                saveHtmlBtn.disabled = false;
                saveMessage.classList.remove('hidden');
            }
        }

        function openErrorCorrectionModal(failedRows, mapping) {
            errorCorrectionInfo.innerHTML = `ì´ <strong>${failedRows.length}ê°œ</strong>ì˜ í•­ëª©ì—ì„œ ì˜¤ë¥˜ê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. ì˜¤ë¥˜ ë‚´ìš©ì€ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤. ì•„ë˜ í‘œì—ì„œ ì§ì ‘ ê°’ì„ ìˆ˜ì •í•œ í›„ 'ìˆ˜ì •ëœ í•­ëª© ê°€ì ¸ì˜¤ê¸°' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”. ë‚ ì§œëŠ” ë‹¬ë ¥ì—ì„œ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;

            const headerFields = [];
            MAPPING_FIELDS.forEach(f => {
                if (mapping.core[f.key] > -1) {
                    headerFields.push({ ...f, isCustom: false, colIndex: mapping.core[f.key] });
                }
            });
            mapping.custom.forEach(cf => {
                headerFields.push({ name: cf.fieldName, key: cf.fieldName, isCustom: true, colIndex: cf.colIndex });
            });
            headerFields.sort((a,b) => a.colIndex - b.colIndex);


            let tableHTML = `<table class="w-full text-left border-collapse"><thead><tr>`;
            tableHTML += `<th class="border text-center p-2">ì˜¤ë¥˜ ë‚´ìš©</th>`;
            headerFields.forEach(field => {
                tableHTML += `<th class="border p-2">${field.name}</th>`;
            });
            tableHTML += `</tr></thead><tbody>`;

            failedRows.forEach((item, index) => {
                tableHTML += `<tr data-row-index="${index}">`;
                tableHTML += `<td class="border align-top text-red-600 !max-w-xs !whitespace-normal text-xs p-2">${item.errors.join('<br>')}</td>`;
                headerFields.forEach(field => {
                    const colIndex = field.colIndex;
                    let originalValue = item.originalData[colIndex] ?? '';
                    let inputType = 'text';

                    // IMPROVEMENT: Use calendar for date fields and handle various date formats
                    if (field.key === 'startDate' || field.key === 'endDate') {
                        inputType = 'date';
                        // Use local parser to avoid timezone shifts when originalValue is a date-string
                        let d = null;
                        if (typeof originalValue === 'number' && originalValue > 25569) {
                            d = new Date(Math.round((originalValue - 25569) * 86400 * 1000));
                            try { d.setDate(d.getDate() + 1); } catch (e) {}
                            originalValue = formatDateYMD(new Date(d.getFullYear(), d.getMonth(), d.getDate()));
                        } else {
                            d = parseLocalDateString(originalValue);
                            if (d && !isNaN(d.getTime())) {
                                try { d.setDate(d.getDate() + 1); } catch (e) {}
                                originalValue = formatDateYMD(d);
                            } else {
                                originalValue = '';
                            }
                        }
                    }
                    if (field.key === 'poAmount') {
                        originalValue = String(originalValue).replace(/,/g, '');
                    }

                    tableHTML += `<td class="border"><input type="${inputType}" data-field-key="${field.key}" data-is-custom="${field.isCustom}" class="w-full p-1 border rounded" value="${originalValue}"></td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table>`;

            errorCorrectionContainer.innerHTML = tableHTML;
            errorCorrectionModal.classList.remove('hidden');
        }

        function handleRetryImport() {
            const rows = errorCorrectionContainer.querySelectorAll('tbody tr');
            const correctedRawData = [];
            rows.forEach(tr => {
                const originalIndex = parseInt(tr.dataset.rowIndex, 10);
                const originalFailedItem = failedImportRows[originalIndex];

                const newRow = [...originalFailedItem.originalData];
                tr.querySelectorAll('input').forEach(input => {
                    const fieldKey = input.dataset.fieldKey;
                    const isCustom = input.dataset.isCustom === 'true';

                    if (isCustom) {
                        const customMapping = importMapping.custom.find(cf => cf.fieldName === fieldKey);
                        if(customMapping) newRow[customMapping.colIndex] = input.value;
                    } else {
                        const colIndex = importMapping.core[fieldKey];
                        if(colIndex > -1) newRow[colIndex] = input.value;
                    }
                });
                correctedRawData.push(newRow);
            });

            const successfulData = [];
            const stillFailingData = [];
            correctedRawData.forEach(row => {
                 const result = validateAndParseRow(row, importMapping);
                 if (result.success) {
                    successfulData.push(result.data);
                } else {
                    stillFailingData.push(result);
                }
            });

            projectData.push(...successfulData);
            failedImportRows = stillFailingData;

            updateAndApplyDateRange();
            populateFilters();
            render();

            if (stillFailingData.length > 0) {
                showToast(`${successfulData.length}ê°œ í•­ëª© ì¶”ê°€ ì„±ê³µ, ${stillFailingData.length}ê°œ í•­ëª© ì—¬ì „íˆ ì˜¤ë¥˜ ë°œìƒ.`, 'warning', 5000);
                openErrorCorrectionModal(stillFailingData, importMapping);
            } else {
                 showToast(`${successfulData.length}ê°œ í•­ëª©ì„ ì¶”ê°€ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.`, 'success');
                 errorCorrectionModal.classList.add('hidden');
            }

            if (projectData.length > 0 || milestones.length > 0) {
                saveHtmlBtn.disabled = false;
                saveMessage.classList.remove('hidden');
            }
        }

        function populateFilters() {
            // ì»¨íŠ¸ë¡¤ ìš”ì†Œë“¤ì€ í•­ìƒ ì»¨íŠ¸ë¡¤ íŒ¨ë„ ë‚´ì— ìˆìœ¼ë¯€ë¡œ ê·¸ê³³ì„ ê¸°ì¤€ìœ¼ë¡œ ì°¾ìŒ
            const controlContainer = document.getElementById('controlsPanel');
            if (!controlContainer) return;
            
            updateControlReferences(controlContainer);

            if (!taskTypeFilter || !customFilterContainer) return; // Exit if elements not found

            const taskTypes = [...new Set(projectData.map(p => p.taskType))];
            // Store current value before clearing
            const currentTaskType = taskTypeFilter.value;
            taskTypeFilter.innerHTML = '<option value="all">ìœ í˜•</option>';
            taskTypes.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type;
                taskTypeFilter.appendChild(option);
            });
             // Restore previous selection if possible
             if (taskTypes.includes(currentTaskType)) {
                 taskTypeFilter.value = currentTaskType;
             }

            // Store custom filter values
            const currentCustomFilters = {};
            customFilterContainer.querySelectorAll('select').forEach(sel => {
                // 'customer-filter'ëŠ” í•­ìƒ 'ê³ ê°ì‚¬'ë¡œ ì´ˆê¸°í™”ë˜ë¯€ë¡œ ì´ì „ ê°’ì„ ì €ì¥í•˜ì§€ ì•ŠìŒ
                if (sel.id !== 'customer-filter') {
                    currentCustomFilters[sel.dataset.filterKey] = sel.value;
                }
            });

            customFilterContainer.innerHTML = ''; // Clear existing filters
            const customFieldKeys = new Set();
            projectData.forEach(p => {
                if (p.customFields) {
                    Object.keys(p.customFields).forEach(key => customFieldKeys.add(key));
                }
            });

            Array.from(customFieldKeys).sort().forEach(key => {
                 const wrapper = document.createElement('div');
                 wrapper.className = 'pinnable-control-wrapper';

                const select = document.createElement('select');
                select.className = "w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500";
                const safeKey = sanitizeKey(key);
                select.dataset.filterKey = safeKey;

                // [FIX] 'ê³ ê°ì‚¬' ë˜ëŠ” 'ì‹œê³µì‚¬'ì™€ ê°™ì€ íŠ¹ì • í•„ë“œì— ê³ ì • IDë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.
                const lowerKey = (customFieldDisplayNames[safeKey] || key).toLowerCase();
                if (lowerKey.includes('ê³ ê°ì‚¬') || lowerKey.includes('client')) {
                    select.id = 'customer-filter';
                } else if (lowerKey.includes('ì‹œê³µì‚¬') || lowerKey.includes('constructor')) {
                    select.id = 'contractor-filter';
                } else {
                    select.id = `custom-filter-${safeKey}`;
                }

                const values = [...new Set(projectData.map(p => p.customFields?.[safeKey]).filter(v => v))]

                const displayName = customFieldDisplayNames[safeKey] || key;
                select.innerHTML = `<option value=\"all\">${displayName}</option>`;
                values.sort().forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    select.appendChild(option);
                });
                 // Restore selection
                 // 'ê³ ê°ì‚¬' í•„í„°ëŠ” í•­ìƒ 'ê³ ê°ì‚¬'ë¡œ ì´ˆê¸° ì„¤ì • (currentCustomFilters ê°’ ë¬´ì‹œ)
                 if (select.id === 'customer-filter') {
                     // 'ê³ ê°ì‚¬' ì˜µì…˜ì´ ìˆìœ¼ë©´ 'ê³ ê°ì‚¬'ë¡œ, ì—†ìœ¼ë©´ 'all'ë¡œ ì„¤ì •
                     if (values.includes('ê³ ê°ì‚¬')) {
                         select.value = 'ê³ ê°ì‚¬';
                     } else {
                         select.value = 'all';
                     }
                 } else if (currentCustomFilters[safeKey] && values.includes(currentCustomFilters[safeKey])) {
                     // ë‹¤ë¥¸ í•„í„°ëŠ” ì´ì „ ê°’ ë³µì›
                     select.value = currentCustomFilters[safeKey];
                 }

                select.addEventListener('change', render);
                wrapper.appendChild(select);
                customFilterContainer.appendChild(wrapper);

                ensureControlDefaultValue(select);
            });
            setupPinnableControls();
            updateShortcutActiveStates();
            
            // populateFilters ì™„ë£Œ í›„ í—¤ë” í•„í„°ë¥¼ 'ê³ ê°ì‚¬'ë¡œ ê°•ì œ ì„¤ì •
            const headerCustomFilter = document.getElementById('header-customer-filter-shortcut');
            const mainCustomerFilter = controlContainer.querySelector('#customer-filter');
            if (headerCustomFilter && mainCustomerFilter) {
                headerCustomFilter.innerHTML = mainCustomerFilter.innerHTML;
                if (headerCustomFilter.querySelector('option[value="ê³ ê°ì‚¬"]')) {
                    mainCustomerFilter.value = 'ê³ ê°ì‚¬';
                    headerCustomFilter.value = 'ê³ ê°ì‚¬';
                } else {
                    headerCustomFilter.value = mainCustomerFilter.value;
                }
            }
        }

        // --- Auto-upload helper functions ---
        async function fetchAndImportFromUrl(url) {
            // Quick online check: navigator.onLine is a hint; still attempt fetch and handle failures
            if (typeof fetch !== 'function') {
                throw new Error('fetch unsupported');
            }

            showToast('ìë™ ì—…ë¡œë”©ì„ ì‹œë„í•©ë‹ˆë‹¤...', 'info');
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout
            let resp;
            try {
                resp = await fetch(url, { method: 'GET', signal: controller.signal });
                clearTimeout(timeoutId);
            } catch (err) {
                clearTimeout(timeoutId);
                throw err;
            }

            if (!resp || !resp.ok) {
                throw new Error('Fetch failed: ' + (resp ? resp.status : 'no response'));
            }

            const arrayBuffer = await resp.arrayBuffer();
            const data = new Uint8Array(arrayBuffer);
            const workbook = XLSX.read(data, { type: 'array', cellDates: true });
            const sheetNames = workbook.SheetNames || [];

            if (!sheetNames || sheetNames.length === 0) {
                throw new Error('Empty workbook');
            }

            // Primary sheet import (projects)
            const primarySheetName = sheetNames[0];
            const primaryWorksheet = workbook.Sheets[primarySheetName];
            const sheetData = XLSX.utils.sheet_to_json(primaryWorksheet, { header: 1, defval: '' });
            if (!sheetData || sheetData.length === 0) {
                throw new Error('Empty or unreadable primary sheet');
            }

            await autoMapAndImport(sheetData);

            // If workbook contains a milestone sheet (name contains 'milestone' or 'ë§ˆì¼ìŠ¤í†¤'), try to import it as milestones
            const milestoneIndex = sheetNames.findIndex(n => /milestone|ë§ˆì¼ìŠ¤í†¤/i.test(n));
            if (milestoneIndex > -1 && milestoneIndex !== 0) {
                try {
                    const msWorksheet = workbook.Sheets[sheetNames[milestoneIndex]];
                    const msData = XLSX.utils.sheet_to_json(msWorksheet, { header: 1, defval: '' });
                    if (msData && msData.length > 0) {
                        // Auto-map/import milestones without modal
                        await autoMapAndImportMilestones(msData);
                    }
                } catch (errMs) {
                    console.warn('auto-import milestone failed', errMs);
                }
            }

            showToast('ìë™ ì—…ë¡œë”©ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        }

        async function autoMapAndImport(sheetData) {
            // Reuse autoDetectHeaderRow if available
            let headerRow = 1;
            try {
                if (typeof autoDetectHeaderRow === 'function') {
                    headerRow = autoDetectHeaderRow(sheetData);
                }
            } catch (e) {
                console.warn('autoDetectHeaderRow failed', e);
            }
            const headerRowIndex = Math.max(0, headerRow - 1);
            const primaryHeaders = sheetData[headerRowIndex] || [];
            const secondaryHeaders = sheetData[headerRowIndex + 1] || [];
            const combinedHeaders = primaryHeaders.map((h, i) => {
                const primary = h ? String(h).trim() : '';
                const secondary = (secondaryHeaders[i]) ? String(secondaryHeaders[i]).trim() : '';
                if (primary && !secondary) return primary;
                if (!primary && secondary) return secondary;
                return (primary + ' ' + secondary).trim();
            });

            // Build mapping similar to openMappingModal's best-guess logic
            const mapping = { core: {}, custom: [] };
            MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

            combinedHeaders.forEach((headerText, colIndex) => {
                let bestMatch = 'ignore';
                let highestScore = 0.1;
                MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    field.aliases.forEach(alias => {
                        const lowerHeader = headerText.toLowerCase().trim();
                        const lowerAlias = alias.toLowerCase().trim();
                        if (headerText && lowerHeader.includes(lowerAlias)) {
                            let score = lowerAlias.length / Math.max(1, lowerHeader.length);
                            if (lowerHeader === lowerAlias) score = 1.1;
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) {
                        highestScore = currentScore;
                        bestMatch = field.key;
                    }
                });

                if (bestMatch === 'ignore') {
                    // Add as custom property
                    mapping.custom.push({ colIndex: colIndex, fieldName: headerText || `col_${colIndex}` });
                } else {
                    // assign to core if not already assigned
                    if (mapping.core[bestMatch] === -1) {
                        mapping.core[bestMatch] = colIndex;
                    } else {
                        // collision: treat as custom
                        mapping.custom.push({ colIndex: colIndex, fieldName: headerText || `col_${colIndex}` });
                    }
                }
            });

            // Set rawImportData so processMappedData can use it
            rawImportData = sheetData;

            // Use same dataStartIndex logic as applyMapping (headerRowIndex + 2)
            processMappedData(rawImportData, mapping, headerRowIndex + 2);
        }

        // Auto-map & import for milestone sheets (name + date)
        async function autoMapAndImportMilestones(sheetData) {
            let headerRow = 1;
            try {
                if (typeof autoDetectHeaderRow === 'function') headerRow = autoDetectHeaderRow(sheetData);
            } catch (e) { console.warn('autoDetectHeaderRow failed for milestones', e); }
            const headerRowIndex = Math.max(0, headerRow - 1);

            const primaryHeaders = sheetData[headerRowIndex] || [];
            const secondaryHeaders = sheetData[headerRowIndex + 1] || [];
            const combinedHeaders = primaryHeaders.map((h, i) => {
                const primary = h ? String(h).trim() : '';
                const secondary = (secondaryHeaders[i]) ? String(secondaryHeaders[i]).trim() : '';
                if (primary && !secondary) return primary;
                if (!primary && secondary) return secondary;
                return (primary + ' ' + secondary).trim();
            });

            // Build best-guess mapping for milestone fields
            const mapping = { core: {} };
            MILESTONE_MAPPING_FIELDS.forEach(f => mapping.core[f.key] = -1);

            combinedHeaders.forEach((headerText, colIndex) => {
                let bestMatch = 'ignore';
                let highestScore = 0.1;
                MILESTONE_MAPPING_FIELDS.forEach(field => {
                    let currentScore = 0;
                    (field.aliases || []).forEach(alias => {
                        const lh = headerText.toLowerCase().trim();
                        const la = alias.toLowerCase().trim();
                        if (headerText && lh.includes(la)) {
                            let score = la.length / Math.max(1, lh.length);
                            if (lh === la) score = 1.1;
                            currentScore = Math.max(currentScore, score);
                        }
                    });
                    if (currentScore > highestScore) { highestScore = currentScore; bestMatch = field.key; }
                });

                if (bestMatch === 'ignore') {
                    // skip unknown columns
                } else {
                    if (mapping.core[bestMatch] === -1) mapping.core[bestMatch] = colIndex;
                    else {
                        // collision -> ignore
                    }
                }
            });

            // rawImportData for milestone processing
            rawImportData = sheetData;
            // Attempt to process milestone rows. If the helper is missing (older builds),
            // fallback to inline processing to ensure auto-upload works correctly.
            if (typeof processMappedMilestoneData === 'function') {
                // ê°œì„ : processMappedMilestoneData ë‚´ë¶€ì—ì„œ 10ê°œ ì œí•œì´ ìˆì„ ê²½ìš° ì „ì²´ rowsë¥¼ ì²˜ë¦¬í•˜ë„ë¡ ë³´ì¥
                // ê¸°ì¡´ í•¨ìˆ˜ê°€ ë°˜ë³µ ë²”ìœ„ë¥¼ ì œí•œí•œë‹¤ë©´, ì•„ë˜ì™€ ê°™ì´ ì „ì²´ rowsë¥¼ ê°•ì œ ì²˜ë¦¬í•˜ë„ë¡ ë˜í•‘
                const totalRows = rawImportData.length;
                processMappedMilestoneData(rawImportData, mapping, headerRowIndex + 2, totalRows);
            } else {
                // Inline fallback: parse milestone rows similarly to manual mapping path
                try {
                    const processedMilestones = [];
                    for (let i = headerRowIndex + 2; i < rawImportData.length; i++) {
                        const row = rawImportData[i];
                        if (!row || row.every(cell => !cell)) continue;

                        const name = row[mapping.core['ë§ˆì¼ìŠ¤í†¤']];
                        let dateValue = row[mapping.core['ë‚ ì§œ']];
                        if (!name || !dateValue) continue;

                        let finalDate = null;
                        if (typeof dateValue === 'number' && dateValue > 0) {
                            const excelEpoch = new Date(Date.UTC(1899, 11, 30));
                            const utcDate = new Date(excelEpoch.getTime() + (Math.floor(dateValue) * 24 * 60 * 60 * 1000));
                            finalDate = new Date(Date.UTC(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate()));
                        } else if (dateValue instanceof Date && !isNaN(dateValue)) {
                            finalDate = new Date(Date.UTC(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate()));
                        } else if (typeof dateValue === 'string') {
                            const match = dateValue.trim().match(/^(\d{4})[-\/]?(\d{2})[-\/]?(\d{2})$/);
                            if (match) {
                                const [_, year, month, day] = match;
                                finalDate = new Date(Date.UTC(parseInt(year,10), parseInt(month,10) - 1, parseInt(day,10)));
                            }
                        }

                        if (finalDate && !isNaN(finalDate)) {
                            try { finalDate.setUTCDate(finalDate.getUTCDate() + 1); } catch (e) {}
                            const formattedDate = finalDate.getUTCFullYear() + '-' +
                                String(finalDate.getUTCMonth() + 1).padStart(2, '0') + '-' +
                                String(finalDate.getUTCDate()).padStart(2, '0');
                            processedMilestones.push({ name: name, date: formattedDate });
                        }
                    }

                    if (processedMilestones.length > 0) {
                        milestones = processedMilestones;
                        renderMilestoneModal();
                        render();
                        updateAndApplyDateRange();
                        showToast(`${processedMilestones.length}ê°œì˜ ë§ˆì¼ìŠ¤í†¤ì´ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
                        if (projectData.length > 0 || milestones.length > 0) {
                            saveHtmlBtn.disabled = false;
                            saveMessage.classList.remove('hidden');
                        }
                    }
                } catch (e) {
                    console.warn('fallback milestone processing failed', e);
                }
            }
        }

        // Diagnostic helper: compares title-side projectId order vs gantt-side projectId mapping
        // Non-destructive: only logs when window.__GANTT_AUTO_DEBUG === true
        function logHierarchyMismatchDiagnostic(container) {
            try {
                if (!(window && window.__GANTT_AUTO_DEBUG)) return null;
                container = container || (fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody);
                if (!container) return null;

                const titlesBody = container.querySelector('.gantt-titles-body-wrapper div');
                const ganttRowsBody = container.querySelector('.gantt-body div:first-child');
                if (!titlesBody || !ganttRowsBody) {
                    console.warn('diagnostic: titlesBody or ganttRowsBody not found');
                    return null;
                }

                const titleGroups = [];
                Array.from(titlesBody.children).forEach(el => {
                    if (el.style && el.style.display === 'none') return;
                    if (el.classList.contains('group-item-container')) {
                        const taskType = el.dataset.taskType || null;
                        const ids = Array.from(el.querySelectorAll('.title-item[data-project-id]')).map(t=>t.dataset.projectId).filter(Boolean);
                        titleGroups.push({ type: 'group', taskType, ids });
                    } else if (el.classList.contains('group-header')) {
                        const taskType = el.dataset.taskType || (el.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/)||[])[1] || null;
                        titleGroups.push({ type: 'header', taskType });
                    } else if (el.classList.contains('title-item')) {
                        const pid = el.dataset.projectId;
                        const prev = titleGroups.length && titleGroups[titleGroups.length-1] && titleGroups[titleGroups.length-1].type === 'group' ? titleGroups[titleGroups.length-1] : null;
                        if (prev) prev.ids.push(pid);
                        else titleGroups.push({ type:'group', taskType: (el.closest('.group-item-container')||{}).dataset.taskType||null, ids: [pid] });
                    }
                });

                const groupToGantt = new Map();
                Array.from(ganttRowsBody.children).forEach(child => {
                    if (child.classList.contains('gantt-bar-row') && !child.dataset.projectId) {
                        const bar = child.querySelector('.gantt-bar');
                        const name = bar && bar.dataset && bar.dataset.name ? bar.dataset.name : '';
                        const tt = (name.match(/^(.+?)\s*\(ìš”ì•½\)/)||[])[1] || null;
                        if (tt) {
                            if (!groupToGantt.has(tt)) groupToGantt.set(tt, { groupBar: null, childContainers: [], projectIds: [] });
                            groupToGantt.get(tt).groupBar = child;
                        }
                    } else {
                        const pids = Array.from(child.querySelectorAll('.gantt-bar-row[data-project-id]')).map(br=>br.dataset.projectId).filter(Boolean);
                        if (pids.length) {
                            const firstPid = pids[0];
                            const titleItem = document.querySelector(`.title-item[data-project-id="${firstPid}"]`);
                            const tt = titleItem ? (titleItem.closest('.group-item-container')?.dataset.taskType || null) : null;
                            if (tt) {
                                if (!groupToGantt.has(tt)) groupToGantt.set(tt, { groupBar: null, childContainers: [], projectIds: [] });
                                groupToGantt.get(tt).childContainers.push(child);
                                pids.forEach(id => { if (!groupToGantt.get(tt).projectIds.includes(id)) groupToGantt.get(tt).projectIds.push(id); });
                            } else {
                                if (!groupToGantt.has('__unknown')) groupToGantt.set('__unknown', { groupBar: null, childContainers: [], projectIds: [] });
                                groupToGantt.get('__unknown').childContainers.push(child);
                                pids.forEach(id => { if (!groupToGantt.get('__unknown').projectIds.includes(id)) groupToGantt.get('__unknown').projectIds.push(id); });
                            }
                        } else if (child.dataset && child.dataset.projectId) {
                            const pid = child.dataset.projectId;
                            const titleItem = document.querySelector(`.title-item[data-project-id="${pid}"]`);
                            const tt = titleItem ? (titleItem.closest('.group-item-container')?.dataset.taskType || null) : null;
                            if (tt) {
                                if (!groupToGantt.has(tt)) groupToGantt.set(tt, { groupBar: null, childContainers: [], projectIds: [] });
                                if (!groupToGantt.get(tt).projectIds.includes(pid)) groupToGantt.get(tt).projectIds.push(pid);
                            } else {
                                if (!groupToGantt.has('__unknown')) groupToGantt.set('__unknown', { groupBar: null, childContainers: [], projectIds: [] });
                                if (!groupToGantt.get('__unknown').projectIds.includes(pid)) groupToGantt.get('__unknown').projectIds.push(pid);
                            }
                        }
                    }
                });

                const mismatches = [];
                titleGroups.forEach(tg => {
                    if (tg.type !== 'group') return;
                    const tt = tg.taskType || null;
                    const titleIds = tg.ids || [];
                    const ganttEntry = groupToGantt.get(tt) || groupToGantt.get('__unknown') || null;
                    const ganttIds = ganttEntry ? (ganttEntry.projectIds || []) : [];
                    const missingInGantt = titleIds.filter(id => !ganttIds.includes(id));
                    const extraInGantt = ganttIds.filter(id => !titleIds.includes(id));
                    if (missingInGantt.length || extraInGantt.length) {
                        mismatches.push({ taskType: tt, titleCount: titleIds.length, ganttCount: ganttIds.length, missingInGantt, extraInGantt, titleSample: titleIds.slice(0,10), ganttSample: ganttIds.slice(0,10) });
                    }
                });

                console.group('Gantt <-> Title automatic diagnostic');
                console.log('titleGroups:', titleGroups.map(g=>({taskType:g.taskType, idsCount: g.ids?g.ids.length:0}))); 
                console.log('ganttGroups:', Array.from(groupToGantt.entries()).map(([k,v])=>({taskType:k, projectCount: v.projectIds.length, hasGroupBar: !!v.groupBar, childContainers: v.childContainers.length}))); 
                if (mismatches.length===0) console.log('No mismatches detected by automatic diagnostic.');
                else { console.warn('Mismatches found:', mismatches); mismatches.slice(0,50).forEach(m=>{ console.groupCollapsed('Mismatch: '+(m.taskType||'__null')); console.table(m); console.groupEnd(); }); }
                console.groupEnd();
                return { titleGroupsCount: titleGroups.length, ganttGroupsCount: groupToGantt.size, mismatchesCount: mismatches.length, mismatches };
            } catch (e) {
                console.error('diagnostic failed', e);
                return { error: String(e) };
            }
        }
        // --- End auto-upload helpers ---


        function updateProjectStatuses() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            projectData.forEach(p => {
                if (p.progress === 100) {
                    p.status = 'ì™„ë£Œ';
                } else if (p.endDate < today) {
                    p.status = 'ì§€ì—°';
                } else if (p.progress > 0) {
                    p.status = 'ê³µì‚¬ì¤‘';
                } else {
                    p.status = 'ì°©ê³µì „';
                }
            });
        }

        function getFilteredAndSortedData() {
            let data = [...projectData];
            // ì»¨íŠ¸ë¡¤ ê°’ë“¤ì€ IDë¡œ ì§ì ‘ ì ‘ê·¼í•˜ë¯€ë¡œ í•­ìƒ ìµœì‹  ìƒíƒœë¥¼ ë°˜ì˜
            const searchTerm = (searchInput?.value || '').toLowerCase();

            if (searchTerm && legendStatusFilter) {
                legendStatusFilter = null;
                 // Need to target legend within the correct container (normal or fullscreen)
                 const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                 if (legendContainer) {
                    legendContainer.querySelectorAll('.legend-section [data-status-filter].legend-filter-active').forEach(el => el.classList.remove('legend-filter-active'));
                 }
            }

            // ê°œì„  ì‚¬í•­: ë©”ëª¨ë¦¬ ìµœì í™” - ì—¬ëŸ¬ filter ì²´ì¸ì„ ë‹¨ì¼ ë£¨í”„ë¡œ í†µí•©
            const customFilters = [];
            if(customFilterContainer) {
                customFilterContainer.querySelectorAll('select').forEach(select => {
                    if (select.value !== 'all') {
                        customFilters.push({ key: select.dataset.filterKey, value: select.value });
                    }
                });
            }
            
            const taskTypeValue = taskTypeFilter?.value;
            const progressValue = progressFilter?.value;
            const hasFilters = taskTypeValue !== 'all' || customFilters.length > 0 || progressValue !== 'all' || 
                              legendStatusFilter || searchTerm;
            
            if (hasFilters) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const todayTime = today.getTime();
                const tomorrowTime = tomorrow.getTime();
                
                data = data.filter(p => {
                    // ì‘ì—… ìœ í˜• í•„í„°
                    if (taskTypeValue && taskTypeValue !== 'all' && p.taskType !== taskTypeValue) {
                        return false;
                    }
                    
                    // ì»¤ìŠ¤í…€ í•„í„°
                    for (let i = 0; i < customFilters.length; i++) {
                        const filter = customFilters[i];
                        if (p.customFields?.[filter.key] !== filter.value) {
                            return false;
                        }
                    }
                    
                    // ì§„í–‰ë¥  í•„í„°
                    if (progressValue && progressValue !== 'all') {
                        const progress = p.progress || 0;
                        if (progressValue === 'not_started' && progress !== 0) return false;
                        if (progressValue === 'in_progress' && (progress === 0 || progress === 100)) return false;
                        if (progressValue === 'completed' && progress !== 100) return false;
                    }
                    
                    // ë²”ë¡€ ìƒíƒœ í•„í„°
                    if (legendStatusFilter) {
                        if (legendStatusFilter === 'ì˜¤ëŠ˜ì‹œì‘' || legendStatusFilter === 'ì˜¤ëŠ˜ì¢…ë£Œ' || 
                            legendStatusFilter === 'ë‚´ì¼ì‹œì‘' || legendStatusFilter === 'ë‚´ì¼ì¢…ë£Œ') {
                            let targetDate = null;
                            if (legendStatusFilter === 'ì˜¤ëŠ˜ì‹œì‘' || legendStatusFilter === 'ì˜¤ëŠ˜ì¢…ë£Œ') {
                                targetDate = todayTime;
                            } else {
                                targetDate = tomorrowTime;
                            }
                            
                            if (legendStatusFilter === 'ì˜¤ëŠ˜ì‹œì‘' || legendStatusFilter === 'ë‚´ì¼ì‹œì‘') {
                                if (!p.startDate) return false;
                                const startDate = new Date(p.startDate);
                                startDate.setHours(0, 0, 0, 0);
                                if (startDate.getTime() !== targetDate) return false;
                            } else {
                                if (!p.endDate) return false;
                                const endDate = new Date(p.endDate);
                                endDate.setHours(0, 0, 0, 0);
                                if (endDate.getTime() !== targetDate) return false;
                            }
                        } else if (p.status !== legendStatusFilter) {
                            return false;
                        }
                    }
                    
                    // ê²€ìƒ‰ì–´ í•„í„°
                    if (searchTerm && !p.name.toLowerCase().includes(searchTerm)) {
                        return false;
                    }
                    
                    return true;
                });
            }

            if (showOnlyChanged) {
                data = data.filter(projectHasChanges);
            }

            const activeSortMode = sortState.mode || (sortBy ? sortBy.value : 'default');
            const effectiveDirection = sortState.direction || SORT_DIRECTIONS.DESC;
            if (activeSortMode && activeSortMode !== 'default') {
                data.sort((a, b) => compareValuesWithDirection(
                    getProjectMetricValue(a, activeSortMode),
                    getProjectMetricValue(b, activeSortMode),
                    effectiveDirection
                ));
            }

            return data;
        }

        function render() {
            // ê°œì„  ì‚¬í•­: ë©”ëª¨ë¦¬ ìµœì í™” - ë Œë”ë§ ë””ë°”ìš´ì‹±ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ë Œë”ë§ ë°©ì§€
            if (renderTimeout) {
                clearTimeout(renderTimeout);
            }
            
            if (isRendering) {
                // ì´ë¯¸ ë Œë”ë§ ì¤‘ì´ë©´ ë‹¤ìŒ í”„ë ˆì„ì— ì‹¤í–‰
                renderTimeout = setTimeout(() => render(), 16);
                return;
            }
            
            isRendering = true;
            const skipAutoScroll = !!(pendingScrollRestore && pendingScrollRestore.skipAutoScroll);
            
            // requestAnimationFrameì„ ì‚¬ìš©í•˜ì—¬ ë¸Œë¼ìš°ì € ë Œë”ë§ ìµœì í™”
            requestAnimationFrame(() => {
                try {
                    updateControlReferences(); // Ensure references are always correct
                    syncSortStateWithSelect({ preserveDirection: true });
                    // ê°œì„  ì‚¬í•­: ë Œë”ë§ ì‹œ ì›ë³¸ ë‚ ì§œê°€ ì—†ëŠ” í”„ë¡œì íŠ¸ë§Œ ê¸°ë¡ (ì‚¬ìš©ìê°€ ë‚ ì§œë¥¼ ìˆ˜ì •í•œ ê²½ìš°ë¥¼ ë³´ì¡´í•˜ê¸° ìœ„í•´)
                    // ë‹¨, í˜ì´ì§€ ë¡œë“œ ì§í›„ ì²« ë Œë”ë§ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ensureOriginalDatesForProjects ì‚¬ìš©
                    // í˜ì´ì§€ ë¡œë“œ ì§í›„ ì²« ë Œë”ë§ì€ resetOriginalDatesForProjectsë¡œ ì²˜ë¦¬ë¨
                    ensureOriginalDatesForProjects(projectData);
                    updateProjectStatuses();
                    hideFloatingTooltip();
                    const filteredData = getFilteredAndSortedData();
                    updateSummary(filteredData); // Summary updates are always based on main page elements
                    renderGanttChart(filteredData);
                    updateShortcutActiveStates();
                    
                    // ê°œì„  ì‚¬í•­: ë©”ë‰´ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ì°¸ì¡° ì—…ë°ì´íŠ¸ ì§í›„)
                    if (toggleHierarchyOrderBtn) {
                        const isBottomMode = hierarchyOrder === 'bottom';
                        const allToggleButtons = Array.from(document.querySelectorAll('#toggleHierarchyOrderBtn, [id*="toggleHierarchyOrderBtn"]'));
                        allToggleButtons.forEach(btn => {
                            try {
                                btn.textContent = isBottomMode ? 'ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ)' : 'ê³„ì¸µìˆœì„œ (ìƒâ†’í•˜)';
                                if (isBottomMode) {
                                    btn.style.backgroundColor = '#dbeafe';
                                    btn.style.border = '2px solid #3b82f6';
                                    btn.style.fontWeight = 'bold';
                                    btn.style.color = '#1e40af';
                                } else {
                                    btn.style.backgroundColor = '#fef3c7';
                                    btn.style.border = '2px solid #f59e0b';
                                    btn.style.fontWeight = 'bold';
                                    btn.style.color = '#92400e';
                                }
                            } catch (e) { /* ignore per-button style failures */ }
                        });
                    }
                    
                    // ê°œì„  ì‚¬í•­: ê³„ì¸µìˆœì„œ ìœ ì§€ - ë Œë”ë§ í›„ ê³„ì¸µìˆœì„œ ì ìš©
                    const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                    if (container) {
                        // DOMì´ ì™„ì „íˆ ìƒì„±ëœ í›„ ê³„ì¸µìˆœì„œ ì ìš©
                        // ë‘ ë²ˆì˜ requestAnimationFrameì„ ì‚¬ìš©í•˜ì—¬ DOMì´ ì™„ì „íˆ ë Œë”ë§ëœ í›„ ì ìš©
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                applyHierarchyOrder(container);
                                // ê°œì„  ì‚¬í•­: ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ) ëª¨ë“œì¼ ë•Œ ëª¨ë“  ìƒìœ„ ê³„ì¸µ ê·¸ë£¹ í—¤ë” ìˆ¨ê¹€ ì²˜ë¦¬
                                if (hierarchyOrder === 'bottom') {
                                    const allGroupHeaders = container.querySelectorAll('.group-header');
                                    allGroupHeaders.forEach(header => {
                                        header.style.display = 'none';
                                    });
                                } else {
                                    const allGroupHeaders = container.querySelectorAll('.group-header');
                                    allGroupHeaders.forEach(header => {
                                        header.style.display = '';
                                    });
                                }
                                
                                // ê°œì„  ì‚¬í•­: ë©”ë‰´ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ë Œë”ë§ í›„ì—ë„ ìƒíƒœ ìœ ì§€)
                                if (toggleHierarchyOrderBtn) {
                                    const isBottomMode = hierarchyOrder === 'bottom';
                                    const allToggleButtons = Array.from(document.querySelectorAll('#toggleHierarchyOrderBtn, [id*="toggleHierarchyOrderBtn"]'));
                                    allToggleButtons.forEach(btn => {
                                        try {
                                            btn.textContent = isBottomMode ? 'ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ)' : 'ê³„ì¸µìˆœì„œ (ìƒâ†’í•˜)';
                                            if (isBottomMode) {
                                                btn.style.backgroundColor = '#dbeafe';
                                                btn.style.border = '2px solid #3b82f6';
                                                btn.style.fontWeight = 'bold';
                                                btn.style.color = '#1e40af';
                                            } else {
                                                btn.style.backgroundColor = '#fef3c7';
                                                btn.style.border = '2px solid #f59e0b';
                                                btn.style.fontWeight = 'bold';
                                                btn.style.color = '#92400e';
                                            }
                                        } catch (e) { /* ignore per-button style failures */ }
                                    });
                                }
                                restoreScrollState();
                            });
                        });
                    }
                    
                    // ê°œì„ ì‚¬í•­ 2: ë°”ë¡œê°€ê¸° ë™ê¸°í™”
                    syncShortcutsFromOriginal();
                    if (!skipAutoScroll) {
                        setTimeout(scrollToToday, 100);
                    }
                } finally {
                    isRendering = false;
                }
            });
        }

        function updateSummary(data) {
             // Summary elements are always on the main page, not in fullscreen
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            // ê°œì„  ì‚¬í•­: ë©”ëª¨ë¦¬ ìµœì í™” - ë‹¨ì¼ ë£¨í”„ë¡œ í†µí•©í•˜ì—¬ ì—¬ëŸ¬ ë²ˆì˜ filter í˜¸ì¶œ ì œê±°
            let notStartedCount = 0;
            let inProgressCount = 0;
            let completedCount = 0;
            let delayedCount = 0;
            let totalPo = 0;
            let weightedProgressSum = 0;
            let todayStartCount = 0;
            let todayEndCount = 0;
            let tomorrowStartCount = 0;
            let tomorrowEndCount = 0;
            
            const todayTime = today.getTime();
            const tomorrowTime = tomorrow.getTime();
            
            // ë‹¨ì¼ ë£¨í”„ë¡œ ëª¨ë“  í†µê³„ ê³„ì‚°
            for (let i = 0; i < data.length; i++) {
                const p = data[i];
                const progress = p.progress || 0;
                const status = p.status;
                
                // ìƒíƒœë³„ ì¹´ìš´íŠ¸
                if (progress === 100) {
                    completedCount++;
                } else if (status === 'ì§€ì—°') {
                    delayedCount++;
                } else if (progress === 0) {
                    notStartedCount++;
                } else {
                    inProgressCount++;
                }
                
                // ê¸ˆì•¡ ë° ì§„í–‰ë¥  ê³„ì‚°
                const poAmount = p.poAmount || 0;
                weightedProgressSum += progress * poAmount;
                totalPo += poAmount;
                
                // ë‚ ì§œ ê¸°ë°˜ ì¹´ìš´íŠ¸
                if (p.startDate) {
                    const startDate = new Date(p.startDate);
                    startDate.setHours(0, 0, 0, 0);
                    const startTime = startDate.getTime();
                    if (startTime === todayTime) todayStartCount++;
                    if (startTime === tomorrowTime) tomorrowStartCount++;
                }
                
                if (p.endDate) {
                    const endDate = new Date(p.endDate);
                    endDate.setHours(0, 0, 0, 0);
                    const endTime = endDate.getTime();
                    if (endTime === todayTime) todayEndCount++;
                    if (endTime === tomorrowTime) tomorrowEndCount++;
                }
            }

            const totalCount = data.length;
            const overallProgressRate = totalPo > 0 ? Math.round(weightedProgressSum / totalPo) : 0;
            
            // DOM ì—…ë°ì´íŠ¸ ìµœì†Œí™” - í•œ ë²ˆì— ì—…ë°ì´íŠ¸
            const totalProjectsEl = document.getElementById('totalProjects');
            const inProgressProjectsEl = document.getElementById('inProgressProjects');
            const beforeStartProjectsEl = document.getElementById('beforeStartProjects');
            const completedProjectsEl = document.getElementById('completedProjects');
            const delayedProjectsEl = document.getElementById('delayedProjects');
            const overallProgressEl = document.getElementById('overallProgress');
            const overallProgressBarEl = document.getElementById('overallProgressBar');
            
            if (totalProjectsEl) totalProjectsEl.textContent = totalCount + 'ê±´';
            if (inProgressProjectsEl) inProgressProjectsEl.textContent = inProgressCount + 'ê±´';
            if (beforeStartProjectsEl) beforeStartProjectsEl.textContent = notStartedCount + 'ê±´';
            if (completedProjectsEl) completedProjectsEl.textContent = completedCount + 'ê±´';
            if (delayedProjectsEl) delayedProjectsEl.textContent = delayedCount + 'ê±´';
            if (overallProgressEl) overallProgressEl.textContent = `${overallProgressRate}%`;
            if (overallProgressBarEl) overallProgressBarEl.style.width = `${overallProgressRate}%`;

			 // Update legend counts (find legend elements in the correct container)
             const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if (legendContainer) {
				 const legendAll = legendContainer.querySelector('#legendAll');
                 const legendNs = legendContainer.querySelector('#legendNotStarted');
                 const legendIp = legendContainer.querySelector('#legendInProgress');
                 const legendC = legendContainer.querySelector('#legendCompleted');
                 const legendD = legendContainer.querySelector('#legendDelayed');
                 const legendGp = legendContainer.querySelector('#legendGroupProgress');
                 const legendTodayStart = legendContainer.querySelector('#legendTodayStart');
                 const legendTodayEnd = legendContainer.querySelector('#legendTodayEnd');
                 const legendTomorrowStart = legendContainer.querySelector('#legendTomorrowStart');
                 const legendTomorrowEnd = legendContainer.querySelector('#legendTomorrowEnd');
				 
				 if(legendAll) legendAll.textContent = `(${totalCount}ê±´)`;
                 if(legendNs) legendNs.textContent = `(${notStartedCount}ê±´)`;
                 if(legendIp) legendIp.textContent = `(${inProgressCount}ê±´)`;
                 if(legendC) legendC.textContent = `(${completedCount}ê±´)`;
                 if(legendD) legendD.textContent = `(${delayedCount}ê±´)`;
                 if(legendGp) legendGp.textContent = `(${overallProgressRate}%)`;
                 if(legendTodayStart) legendTodayStart.textContent = `(${todayStartCount}ê±´)`;
                 if(legendTodayEnd) legendTodayEnd.textContent = `(${todayEndCount}ê±´)`;
                 if(legendTomorrowStart) legendTomorrowStart.textContent = `(${tomorrowStartCount}ê±´)`;
                 if(legendTomorrowEnd) legendTomorrowEnd.textContent = `(${tomorrowEndCount}ê±´)`;
             }


            // Render standard PO summary by task type for the currently filtered data
            renderPoSummary(data);
            renderPoRangeSummary(data); // ê°œì„  ì‚¬í•­ 1: ê¸ˆì•¡ëŒ€ë³„ í˜„í™© ë Œë”ë§ í•¨ìˆ˜ í˜¸ì¶œ
            renderSettlementEfficiency(data); // ê°œì„  ì‚¬í•­ 1: ì •ì‚° íš¨ìœ¨ ë¶„ì„ ë Œë”ë§ í•¨ìˆ˜ í˜¸ì¶œ

            // Render dynamic group summaries based on currently visible (filtered) data
            // This ensures the counts shown in 'ì‹œê³µì‚¬ë³„ ì´ê´„' and similar sections
            // reflect the active filters (e.g., ê³ ê°ì‚¬) rather than the full dataset.
            renderGroupSummaries(data);

            // Update the subtle filter label to show which 'ê³ ê°ì‚¬' (if any) is currently applied
            try {
                const summaryFilterLabel = document.getElementById('summaryFilterLabel');
                if (summaryFilterLabel && customFilterContainer) {
                    let filterText = 'ì „ì²´';
                    let customerValue = 'ì „ì²´';
                    let constructorValue = 'ì „ì²´';
                    
                    // ë¨¼ì € ê³ ê°ì‚¬ì™€ ì‹œê³µì‚¬ í•„í„°ì˜ í˜„ì¬ ê°’ì„ ì°¾ìŒ
                    customFilterContainer.querySelectorAll('select').forEach(sel => {
                        const key = sel.dataset.filterKey;
                        const displayName = (customFieldDisplayNames[key] || '').toString();
                        if (displayName.includes('ê³ ê°ì‚¬')) {
                            if (sel.value && sel.value !== 'all') {
                                customerValue = sel.value;
                            }
                        } else if (displayName.includes('ì‹œê³µì‚¬') || displayName.includes('constructor')) {
                            if (sel.value && sel.value !== 'all') {
                                constructorValue = sel.value;
                            }
                        }
                    });

                    // í•„í„° í…ìŠ¤íŠ¸ êµ¬ì„±: ê³ ê°ì‚¬ë§Œ ì„ íƒ, ì‹œê³µì‚¬ë§Œ ì„ íƒ, ë‘˜ ë‹¤ ì„ íƒ ê²½ìš° ì²˜ë¦¬
                    if (customerValue !== 'ì „ì²´') {
                        filterText = constructorValue !== 'ì „ì²´' ? 
                            `${customerValue}>${constructorValue}` : 
                            `${customerValue}>ì „ì²´`;
                    } else if (constructorValue !== 'ì „ì²´') {
                        filterText = `ì „ì²´>${constructorValue}`;
                    }
                    
                    summaryFilterLabel.textContent = `í•„í„°: ${filterText}`;
                }
            } catch (e) {
                // Fail silently to avoid breaking UI if something unexpected occurs
                console.warn('summary filter label update error', e);
            }
        }

        function renderPoSummary(data) {
            const poSummaryContainer = document.getElementById('poSummary'); // Always on main page
            if (!poSummaryContainer) return;
            poSummaryContainer.innerHTML = '';

            let totalPoAmount = 0;
            const summaryData = data.reduce((acc, p) => {
                if (!acc[p.taskType]) acc[p.taskType] = { amount: 0, count: 0 };
                if (p.poAmount && !isNaN(p.poAmount)) {
                    const amount = p.poAmount;
                    acc[p.taskType].amount += amount;
                    totalPoAmount += amount;
                }
                acc[p.taskType].count++;
                return acc;
            }, {});

            if (Object.keys(summaryData).length === 0 || Object.values(summaryData).every(v => v.amount === 0 && v.count === 0)) {
                poSummaryContainer.innerHTML = '<p class="text-gray-500 col-span-full">í‘œì‹œí•  ì •ì‚° ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
            } else {
                 Object.keys(summaryData).sort().forEach(taskType => {
                    const groupData = summaryData[taskType];
                    if (groupData.count > 0) {
                        const card = document.createElement('div');
                        card.className = "summary-card bg-slate-100 border-l-4 border-slate-500 p-2 rounded-lg shadow-sm";
                        card.dataset.filterType = 'taskType';
                        card.dataset.filterValue = taskType;
                        card.innerHTML = `
                            <div class="font-medium text-slate-700 text-sm pointer-events-none">${taskType} (${groupData.count}ê±´)</div>
                            <div class="text-xl font-bold text-gray-800 pointer-events-none">${formatCurrency(groupData.amount)}</div>
                        `;
                        poSummaryContainer.appendChild(card);
                    }
                });
            }
        }

        // ê°œì„  ì‚¬í•­ 1: ê¸ˆì•¡ëŒ€ë³„ í”„ë¡œì íŠ¸ í˜„í™© ë Œë”ë§ í•¨ìˆ˜
        function renderPoRangeSummary(data) {
            const container = document.getElementById('poRangeSummary');
            if (!container) return;

            const ranges = {
                'over_100m': { label: '1ì–µ ì´ìƒ', min: 100000000, max: Infinity, projects: [] },
                '50m_to_100m': { label: '5ì²œë§Œ-1ì–µ', min: 50000000, max: 100000000, projects: [] },
                '10m_to_50m': { label: '1ì²œë§Œ-5ì²œë§Œ', min: 10000000, max: 50000000, projects: [] },
                'under_10m': { label: '1ì²œë§Œ ë¯¸ë§Œ', min: 0, max: 10000000, projects: [] }
            };

            data.forEach(p => {
                const amount = p.poAmount || 0;
                if (amount >= ranges.over_100m.min) ranges.over_100m.projects.push(p);
                else if (amount >= ranges['50m_to_100m'].min) ranges['50m_to_100m'].projects.push(p);
                else if (amount >= ranges['10m_to_50m'].min) ranges['10m_to_50m'].projects.push(p);
                else ranges.under_10m.projects.push(p);
            });

            let html = `<div class="border-t pt-4 mt-4"><h3 class="text-lg font-semibold mb-2">ğŸ’° ê¸ˆì•¡ëŒ€ë³„ í”„ë¡œì íŠ¸ í˜„í™©</h3><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">`;
            let hasData = false;

            Object.entries(ranges).forEach(([key, range]) => {
                if (range.projects.length > 0) {
                    hasData = true;
                    const totalAmount = range.projects.reduce((sum, p) => sum + (p.poAmount || 0), 0);
                    const totalProgress = range.projects.reduce((sum, p) => sum + (p.progress || 0), 0);
                    const avgProgress = range.projects.length > 0 ? Math.round(totalProgress / range.projects.length) : 0;

                    html += `
                        <div class="summary-card bg-white border-l-4 border-teal-500 p-3 rounded-lg shadow-sm" 
                             data-filter-type="po-range" 
                             data-filter-value="${key}">
                            <div class="font-bold text-teal-800">${range.label}</div>
                            <div class="text-xl font-bold text-gray-800">${formatCurrency(totalAmount)}</div>
                            <div class="text-sm text-gray-500 mt-1">
                                <span>${range.projects.length}ê±´</span>
                                <span class="mx-1">â€¢</span>
                                <span>í‰ê·  ${avgProgress}%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                                <div class="bg-teal-600 h-2 rounded-full" style="width: ${avgProgress}%" title="í‰ê·  ê³µì •ë¥ : ${avgProgress}%"></div>
                            </div>
                        </div>
                    `;
                }
            });

            if (!hasData) {
                html += `<p class="text-gray-500 col-span-full">ë¶„ì„í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>`;
            }

            html += `</div></div>`;
            container.innerHTML = html;

            // Add event listeners to new cards
            container.querySelectorAll('[data-filter-type="po-range"]').forEach(card => {
                card.addEventListener('click', (e) => {
                    const rangeKey = e.currentTarget.dataset.filterValue;
                    const rangeData = ranges[rangeKey];
                    if (rangeData && rangeData.projects.length > 0) {
                        showDataDetailModal(`${rangeData.label} í”„ë¡œì íŠ¸ ëª©ë¡`, rangeData.projects);
                    }
                });
            });
        }

        // ê°œì„  ì‚¬í•­ 1: ì •ì‚° íš¨ìœ¨ ë¶„ì„ ë Œë”ë§ í•¨ìˆ˜
        function renderSettlementEfficiency(data) {
            const container = document.getElementById('settlementEfficiencyAnalysis');
            if (!container) return;

            const projectsWithEfficiency = data
                .map(p => {
                    const startDate = p.startDate instanceof Date ? p.startDate : new Date(p.startDate);
                    const endDate = p.endDate instanceof Date ? p.endDate : new Date(p.endDate);
                    
                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime()) || !p.poAmount || p.poAmount <= 0) {
                        return null;
                    }

                    let duration = (endDate - startDate) / (1000 * 60 * 60 * 24) + 1;
                    if (duration <= 0) duration = 1;

                    const efficiency = p.poAmount / duration;
                    return { ...p, duration: Math.round(duration), efficiency };
                })
                .filter(p => p !== null)
                .sort((a, b) => b.efficiency - a.efficiency);

            const top5 = projectsWithEfficiency.slice(0, 5);
            const bottom5 = projectsWithEfficiency.slice(-5).reverse();

            const renderList = (projects, title, icon, colorClass) => {
                let listHtml = `<h4 class="font-semibold ${colorClass} mb-2">${icon} ${title}</h4>`;
                if (projects.length === 0) {
                    listHtml += `<div class="p-3 text-sm text-gray-500 bg-gray-50 rounded-md">í•´ë‹¹ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>`;
                } else {
                    listHtml += `<ul class="space-y-2">`;
                    projects.forEach(p => {
                        listHtml += `
                            <li class="p-2 bg-gray-50 rounded-md border border-gray-200">
                                <div class="font-semibold text-gray-800 truncate" title="${p.name}">${p.name}</div>
                                <div class="text-sm flex justify-between items-center">
                                    <span class="font-bold ${colorClass}">${formatCurrency(Math.round(p.efficiency))}/ì¼</span>
                                    <span class="text-gray-500">${formatCurrency(p.poAmount)} / ${p.duration}ì¼</span>
                                </div>
                            </li>
                        `;
                    });
                    listHtml += `</ul>`;
                }
                return `<div>${listHtml}</div>`;
            };

            let html = `
                <div class="border-t pt-4 mt-4">
                    <h3 class="text-lg font-semibold mb-3">â±ï¸ ì •ì‚° íš¨ìœ¨ ë¶„ì„ (ì¼ì¼ ì •ì‚°ì•¡ ê¸°ì¤€)</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        ${renderList(top5, 'Top 5 íš¨ìœ¨ì ì¸ í”„ë¡œì íŠ¸', 'ğŸš€', 'text-green-700')}
                        ${renderList(bottom5, 'Top 5 ê°œì„  í•„ìš”í•œ í”„ë¡œì íŠ¸', 'ğŸ¢', 'text-orange-700')}
                    </div>
                </div>
            `;

            if (projectsWithEfficiency.length === 0) {
                container.innerHTML = ''; // ë°ì´í„° ì—†ìœ¼ë©´ ì„¹ì…˜ ìì²´ë¥¼ ìˆ¨ê¹€
            } else {
                container.innerHTML = html;
            }
        }


        // Modified renderGroupSummaries function
        function renderGroupSummaries(fullData) {
             // These are always on the main page
            const overviewContainer = document.getElementById('overview-group-summaries');
            const settlementHeaderContainer = document.getElementById('settlement-header-summaries');
            const settlementGroupContainer = document.getElementById('settlement-group-summaries');
             if (!overviewContainer || !settlementHeaderContainer || !settlementGroupContainer) return;


            overviewContainer.innerHTML = '';
            settlementHeaderContainer.innerHTML = '';
            settlementGroupContainer.innerHTML = ''; // Clear previous content

            const customFieldKeys = new Set();
            fullData.forEach(p => {
                if (p.customFields) {
                    Object.keys(p.customFields).forEach(key => customFieldKeys.add(key));
                }
            });

            const GROUPING_KEYWORDS = ['ê³ ê°ì‚¬', 'ì‹œê³µì‚¬', 'ì—…ì²´', 'ë‹´ë‹¹ì', 'client', 'constructor', 'company'];
            const groupingFields = Array.from(customFieldKeys).filter(key =>
                GROUPING_KEYWORDS.some(keyword => key.toLowerCase().includes(keyword))
            ).sort();

            let finalSettlementHeaderHTML = '';
            // Prevent duplicate settlement sections (e.g., duplicate 'ì‹œê³µì‚¬ë³„ ì •ì‚°') by display name
            const renderedSettlementNames = new Set();

            groupingFields.forEach(field => {
                // --- 1. Data Aggregation (Same as before) ---
                const groupedData = fullData.reduce((acc, p) => {
                    const groupValue = p.customFields?.[field] || 'ë¯¸ì§€ì •';
                    if (!acc[groupValue]) {
                        acc[groupValue] = { poAmount: 0, count: 0, weightedProgress: 0, projects: [] };
                    }
                    const po = p.poAmount || 0;
                    const progress = p.progress || 0;

                    acc[groupValue].poAmount += po;
                    acc[groupValue].count++;
                    acc[groupValue].weightedProgress += po * progress;
                    acc[groupValue].projects.push(p);

                    return acc;
                }, {});
                const sortedGroupValues = Object.keys(groupedData).sort();

                // --- 2. Render Overview Section (Same as before) ---
                const displayFieldName = customFieldDisplayNames[field] || field;
                let overviewHTML = `<div class="border-t pt-4 mt-4"><h3 class="text-lg font-semibold mb-2">${displayFieldName}ë³„ ì´ê´„</h3><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">`;
                sortedGroupValues.forEach(groupValue => {
                    const group = groupedData[groupValue];
                    const groupProgress = group.poAmount > 0 ? Math.round(group.weightedProgress / group.poAmount) : 0;
                    const weightedValue = group.weightedProgress / 100; // ê°€ì¤‘ì¹˜ ì ìš©ê°’
                    overviewHTML += `
                        <div class="summary-card bg-white border-l-4 border-gray-300 p-3 rounded-lg shadow-sm" data-filter-type="custom-group" data-filter-field="${field}" data-filter-value="${groupValue}">
                            <div class="font-bold text-gray-700">${groupValue} (${group.count}ê±´)</div>
                            <div class="text-xl font-bold text-gray-800">${formatCurrency(group.poAmount)}</div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                                <div class="bg-gray-500 h-2 rounded-full" style="width: ${groupProgress}%" title="ê³µì •ë¥ : ${groupProgress}%"></div>
                            </div>
                            <div class="text-sm text-gray-500 mt-1 text-right">ê°€ì¤‘ì¹˜: ${weightedValue.toLocaleString('ko-KR')} (${groupProgress}%)</div>
                        </div>`;
                });
                overviewHTML += `</div></div>`;
                overviewContainer.innerHTML += overviewHTML;

                // --- 3. Render Settlement Section ---
                // For 'ê³ ê°ì‚¬' we render a flat list (no accordion / no sub-groups) to satisfy the
                // requirement of removing accordion and group UI for ê³ ê°ì‚¬ë³„ ì •ì‚°.
                if ((customFieldDisplayNames[field] || field).includes('ê³ ê°ì‚¬')) {
                    // Mark this display name as rendered to avoid duplicates later
                    if (!renderedSettlementNames.has(displayFieldName)) {
                        renderedSettlementNames.add(displayFieldName);
                    }
                    finalSettlementHeaderHTML = sortedGroupValues.map(groupValue => {
                        const group = groupedData[groupValue];
                        const formattedUnit = formatAmountWithUnit(group.poAmount);
                        return `<span class="font-semibold">${groupValue}:</span> ì´ ${formatCurrency(group.poAmount)} ${formattedUnit} / ${group.count}ê±´`;
                    }).join(' <span class="text-black font-light mx-3">ğŸ”›</span> ');

                    // Create a simple flat container (cards) instead of accordion
                    const flatContainer = document.createElement('div');
                    flatContainer.className = 'border-t pt-4 mt-4';
                    const grid = document.createElement('div');
                    grid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';

                    // ë¨¼ì € 'ì†”ë£¨ì…˜' ì¹´ë“œë¥¼ ìƒì„±í•˜ê³  ë°°ì¹˜í•œ ë‹¤ìŒ, ë‚˜ë¨¸ì§€ ì¹´ë“œë“¤ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤
                    const createCustomerCard = (groupValue, group) => {
                        const groupProgress = group.poAmount > 0 ? Math.round(group.weightedProgress / group.poAmount) : 0;
                        const card = document.createElement('div');
                        card.className = 'summary-card bg-white border-l-4 border-gray-300 p-3 rounded-lg shadow-sm';
                        card.dataset.filterType = 'custom-group';
                        card.dataset.filterField = field;
                        card.dataset.filterValue = groupValue;
                        card.innerHTML = `
                            <div class="flex justify-between items-start">
                                <div>
                                    <div class="font-semibold text-gray-800">${groupValue}</div>
                                    <div class="text-sm text-gray-500">${group.count}ê±´ â€¢ ${formatCurrency(group.poAmount)}</div>
                                </div>
                                <div class="text-right">
                                    <div class="text-lg font-bold text-gray-800">${formatCurrency(group.poAmount)}</div>
                                    <div class="text-sm text-gray-500">${groupProgress}%</div>
                                </div>
                            </div>
                        `;

                        // Keep same click behavior as original cards
                        card.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const fakeEvent = { target: card };
                            handleCardClick(fakeEvent);
                        });
                        return card;
                    };

                    // ìš°ì„ ìˆœìœ„ ì¹´ë“œ(ê³ ê°ì‚¬A / ê³ ê°ì‚¬ A)ë¥¼ ìµœìƒë‹¨ì— ë°°ì¹˜í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” ê¸°ì¡´ ìˆœì„œ ìœ ì§€
                    const preferredKeys = ['ê³ ê°ì‚¬A', 'ê³ ê°ì‚¬ A'];
                    const order = [];
                    const added = new Set();
                    preferredKeys.forEach(key => {
                        if (sortedGroupValues.includes(key)) {
                            order.push(key);
                            added.add(key);
                        }
                    });
                    sortedGroupValues.forEach(v => { if (!added.has(v)) order.push(v); });

                    order.forEach(groupValue => {
                        const group = groupedData[groupValue];
                        const card = createCustomerCard(groupValue, group);
                        grid.appendChild(card);
                    });

                    flatContainer.appendChild(grid);
                    // Place ê³ ê°ì‚¬ ì¹´ë“œ section immediately below the ì •ì‚° section (before other group content)
                    settlementGroupContainer.prepend(flatContainer);
                } else {
                    // Skip rendering if a settlement section for the same display name already exists
                    if (renderedSettlementNames.has(displayFieldName)) {
                        return; // continue to next field
                    }
                    renderedSettlementNames.add(displayFieldName);
                    // Original accordion-based rendering preserved for non-ê³ ê°ì‚¬ fields
                    // Create the main container for this field's sub-accordions
                    const fieldAccordionContainer = document.createElement('div');
                    fieldAccordionContainer.className = 'border-t pt-4 mt-4'; // Add styling as needed

                    // Create main settlement section accordion
                    const mainSettlementAccordion = document.createElement('div');
                    mainSettlementAccordion.className = 'main-settlement-accordion-item mb-4 border border-gray-200 rounded-lg';
                    
                    // Main settlement section header
                    const mainSettlementHeader = document.createElement('div');
                    mainSettlementHeader.className = 'main-settlement-header p-3 cursor-pointer flex items-center justify-between bg-gray-50 hover:bg-gray-100';
                    mainSettlementHeader.innerHTML = `
                        <h3 class="text-lg font-semibold">â–  ${displayFieldName}ë³„ ì •ì‚°</h3>
                        <svg class="main-settlement-icon w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    `;
                    
                    // Main settlement section content
                    const mainSettlementContent = document.createElement('div');
                    mainSettlementContent.className = 'main-settlement-content p-4';
                    
                    // ê°œì„ ì‚¬í•­ 1: ê¸°ë³¸ ë™ì‘ì€ ì ‘í˜ì´ì§€ë§Œ, ì €ì¥ëœ ì„¤ì •ì´ ìˆìœ¼ë©´ ê·¸ ìƒíƒœë¥¼ ë³µì›í•©ë‹ˆë‹¤.
                    let isSettlementOpen = false;
                    try {
                        if (savedSettings && Array.isArray(savedSettings.settlementOpenFields)) {
                            isSettlementOpen = savedSettings.settlementOpenFields.includes(displayFieldName);
                        }
                    } catch (e) {
                        isSettlementOpen = false;
                    }

                    if (isSettlementOpen) {
                        mainSettlementAccordion.classList.add('expanded');
                        mainSettlementContent.style.display = 'block';
                    } else {
                        mainSettlementAccordion.classList.add('collapsed');
                        mainSettlementContent.style.display = 'none';
                    }
                    
                    mainSettlementAccordion.appendChild(mainSettlementHeader);
                    mainSettlementAccordion.appendChild(mainSettlementContent);
                    
                    // Add click handler for main settlement accordion
                    mainSettlementHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isCollapsed = mainSettlementAccordion.classList.contains('collapsed');
                        if (isCollapsed) {
                            mainSettlementAccordion.classList.remove('collapsed');
                            mainSettlementAccordion.classList.add('expanded');
                            mainSettlementContent.style.display = 'block';
                        } else {
                            mainSettlementAccordion.classList.remove('expanded');
                            mainSettlementAccordion.classList.add('collapsed');
                            mainSettlementContent.style.display = 'none';
                        }
                        
                        // Update scroll behavior after accordion toggle
                        setTimeout(() => {
                            updateSettlementScrollBehavior();
                            // Recompute today marker height after layout change (allow DOM to settle)
                            try {
                                const containerRef = fullscreenModal.classList.contains('hidden') 
                                    ? document.getElementById('ganttViewContent') 
                                    : fullscreenModalBody;
                                recomputeTodayMarkerHeight(containerRef);
                            } catch (e) {
                                // fail silently if environment not ready
                            }
                        }, 120);
                    });
                    
                    fieldAccordionContainer.appendChild(mainSettlementAccordion);

                    // Create individual sub-accordions for each group value inside main settlement content
                    sortedGroupValues.forEach(groupValue => {
                        const group = groupedData[groupValue];

                        // Sub-Accordion Item Wrapper
                        const subAccordionItem = document.createElement('div');
                        subAccordionItem.className = 'sub-accordion-item mb-2 border-b last:border-b-0'; // Initially closed

                        // Sub-Accordion Header
                        const subAccordionHeader = document.createElement('div');
                        subAccordionHeader.className = 'sub-accordion-header py-2'; // Added padding
                        subAccordionHeader.innerHTML = `
                            <h4 class="font-semibold text-md hover:text-indigo-600" data-filter-type="custom-group" data-filter-field="${field}" data-filter-value="${groupValue}">
                                ${groupValue}
                                 <span class="text-sm font-normal text-gray-500 ml-2">(${group.count}ê±´ / ${formatCurrency(group.poAmount)})</span>
                            </h4>
                             <svg class="sub-accordion-icon w-5 h-5 flex-shrink-0 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        `;
                        subAccordionItem.appendChild(subAccordionHeader);

                        // Sub-Accordion Content
                        const subAccordionContent = document.createElement('div');
                        subAccordionContent.className = 'sub-accordion-content'; // Content starts hidden

                        const contentGrid = document.createElement('div');
                         // Added pl-4 for indentation
                        contentGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 pb-2 pl-4';

                        const taskTypeSummary = group.projects.reduce((acc, p) => {
                             if (!acc[p.taskType]) {
                                acc[p.taskType] = { amount: 0, count: 0 };
                            }
                            acc[p.taskType].amount += p.poAmount || 0;
                            acc[p.taskType].count++;
                            return acc;
                        }, {});

                        // Sort task types and add numbering
                        Object.keys(taskTypeSummary).sort().forEach((taskType, index) => {
                            const taskData = taskTypeSummary[taskType];
                            contentGrid.innerHTML += `
                            <div class="summary-card bg-slate-50 border-l-4 border-slate-400 p-2 rounded-lg shadow-sm"
                                 data-filter-type="custom-group-task"
                                 data-filter-field="${field}"
                                 data-filter-value="${groupValue}"
                                 data-filter-task-type="${taskType}">
                                 <div class="flex items-baseline">
                                    <span class="text-xs font-mono mr-1.5">${index + 1}.</span> <!-- Numbering -->
                                    <div class="flex-1">
                                        <div class="font-medium text-slate-700 text-sm pointer-events-none">${taskType} (${taskData.count}ê±´)</div>
                                        <div class="text-lg font-bold text-gray-800 pointer-events-none">${formatCurrency(taskData.amount)}</div>
                                    </div>
                                 </div>
                            </div>`;
                        });


                        subAccordionContent.appendChild(contentGrid);
                        subAccordionItem.appendChild(subAccordionContent);

                        // Add the complete sub-accordion item to the main settlement content
                        mainSettlementContent.appendChild(subAccordionItem);
                    });

                    // Append or prepend the container based on display name: 'ì‹œê³µì‚¬' ì„¹ì…˜ì€ ìµœìƒë‹¨ìœ¼ë¡œ ì´ë™
                    if ((customFieldDisplayNames[field] || field).includes('ì‹œê³µì‚¬')) {
                        settlementGroupContainer.prepend(fieldAccordionContainer);
                    } else {
                        settlementGroupContainer.appendChild(fieldAccordionContainer);
                    }
                }
            });

            settlementHeaderContainer.innerHTML = finalSettlementHeaderHTML;

            // Add event listeners after rendering
            setupSettlementAccordions();
            
            // Setup settlement section wheel scrolling
            setupSettlementWheelScrolling();
            
            // Setup resize observer for dynamic content changes
            setupSettlementResizeObserver();
            
            // Update scroll behavior after content changes
            updateSettlementScrollBehavior();

            // Reorder priority sections directly under the ì •ì‚° header
            reorderSettlementPriority();
        }


        // Function to setup sub-accordion listeners
        function setupSettlementAccordions() {
            const settlementGroupContainer = document.getElementById('settlement-group-summaries');
             if (!settlementGroupContainer) return;
            settlementGroupContainer.querySelectorAll('.sub-accordion-header').forEach(header => {
                 // Remove existing listener to prevent duplicates if called multiple times
                header.removeEventListener('click', toggleSubAccordion);
                header.addEventListener('click', toggleSubAccordion);
            });
        }

        function setupSettlementWheelScrolling() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            // Remove existing listeners to prevent duplicates
            settlementContent.removeEventListener('wheel', handleSettlementWheel);
            settlementContent.addEventListener('wheel', handleSettlementWheel, { passive: false });
        }
        
        function handleSettlementWheel(e) {
            const settlementContent = e.currentTarget;
            
            // Check if content is scrollable
            const isScrollable = settlementContent.scrollHeight > settlementContent.clientHeight;
            
            if (isScrollable && e.deltaY !== 0) {
                // Prevent default browser scrolling
                e.preventDefault();
                e.stopPropagation();
                
                // Smooth scrolling with custom delta
                const scrollAmount = e.deltaY * 0.5; // Reduce scroll speed for better control
                settlementContent.scrollTop += scrollAmount;
            }
        }
        
        function updateSettlementScrollBehavior() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            // Force re-evaluation of scroll behavior
            setTimeout(() => {
                const needsScroll = settlementContent.scrollHeight > settlementContent.clientHeight;
                
                if (needsScroll) {
                    settlementContent.style.overflowY = 'auto';
                    settlementContent.style.maxHeight = '70vh';
                } else {
                    settlementContent.style.overflowY = 'visible';
                    settlementContent.style.maxHeight = 'none';
                }
            }, 100);
        }
        
        // Setup resize observer for settlement content
        function setupSettlementResizeObserver() {
            const settlementContent = document.querySelector('.settlement-scrollable');
            if (!settlementContent) return;
            
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(() => {
                    updateSettlementScrollBehavior();
                });
                resizeObserver.observe(settlementContent);
            }
        }

        // Move 'ê³ ê°ì‚¬A' ì¹´ë“œì™€ 'ì‹œê³µì‚¬ë³„ ì •ì‚°' ì„¹ì…˜ì„ ì •ì‚° ì œëª© ë°”ë¡œ ì•„ë˜ë¡œ ë°°ì¹˜
        function reorderSettlementPriority() {
            try {
                const settlementContent = document.querySelector('.settlement-scrollable');
                if (!settlementContent) return;

                // Ensure priority container exists at top of settlement content
                let priority = document.getElementById('settlementPriorityContainer');
                if (!priority) {
                    priority = document.createElement('div');
                    priority.id = 'settlementPriorityContainer';
                    priority.className = 'space-y-4';
                    settlementContent.insertBefore(priority, settlementContent.firstChild);
                }

                // Move group summaries above poSummary
                const groupContainer = document.getElementById('settlement-group-summaries');
                const poSummary = document.getElementById('poSummary');
                if (groupContainer && poSummary && groupContainer.nextSibling !== poSummary) {
                    try {
                        // If groupContainer currently contains contractor sections we still keep them as children;
                        // we only reposition the container before poSummary.
                        settlementContent.insertBefore(groupContainer, poSummary);
                    } catch (e) {}
                }

                // 1) Find ê³ ê°ì‚¬A card (supports both 'ê³ ê°ì‚¬A' and 'ê³ ê°ì‚¬ A')
                const candidateCards = Array.from(document.querySelectorAll('#settlement-group-summaries [data-filter-type="custom-group"]'));
                const customerACard = candidateCards.find(el => {
                    const v = el.dataset.filterValue || '';
                    return v === 'ê³ ê°ì‚¬A' || v === 'ê³ ê°ì‚¬ A';
                });
                if (customerACard) {
                    // Wrap the single card to keep spacing consistent
                    let customerWrapper = document.getElementById('priorityCustomerAWrapper');
                    if (!customerWrapper) {
                        customerWrapper = document.createElement('div');
                        customerWrapper.id = 'priorityCustomerAWrapper';
                        customerWrapper.className = '';
                        priority.appendChild(customerWrapper);
                    } else {
                        // empty and re-append to keep order
                        customerWrapper.innerHTML = '';
                        priority.appendChild(customerWrapper);
                    }
                    customerWrapper.appendChild(customerACard);
                }

                // 2) Find all 'ì‹œê³µì‚¬ë³„ ì •ì‚°' section containers across the settlement area, keep only the first per title,
                //    and place the first one AFTER '#settlement-group-summaries'
                const contractorHeaders = Array.from(document.querySelectorAll('.main-settlement-accordion-item .main-settlement-header h3'))
                    .filter(h3 => ((h3.textContent || '').replace(/^â– \s*/, '')).includes('ì‹œê³µì‚¬'));
                if (contractorHeaders.length > 0) {
                    // Map headers to their top-level container nodes and deduplicate by header text
                    const seenByTitle = new Set();
                    const containersByTitle = [];
                    contractorHeaders.forEach(h3 => {
                        const title = (h3.textContent || '').replace(/^â– \s*/, '').trim();
                        if (seenByTitle.has(title)) {
                            // remove duplicate containers for the same title
                            const fieldContainer = h3.closest('.main-settlement-accordion-item');
                            const container = fieldContainer && fieldContainer.parentElement && fieldContainer.parentElement.closest('.border-t.pt-4.mt-4')
                                ? fieldContainer.parentElement.closest('.border-t.pt-4.mt-4')
                                : (fieldContainer && fieldContainer.parentElement);
                            if (container && container.parentElement) {
                                try { container.parentElement.removeChild(container); } catch (e) {}
                            }
                        } else {
                            seenByTitle.add(title);
                            const fieldContainer = h3.closest('.main-settlement-accordion-item');
                            const container = fieldContainer && fieldContainer.parentElement && fieldContainer.parentElement.closest('.border-t.pt-4.mt-4')
                                ? fieldContainer.parentElement.closest('.border-t.pt-4.mt-4')
                                : (fieldContainer && fieldContainer.parentElement);
                            if (container) containersByTitle.push(container);
                        }
                    });

                    const keep = containersByTitle[0];
                    if (keep) {
                        const groupContainer = document.getElementById('settlement-group-summaries');
                        if (groupContainer && settlementContent) {
                            try { if (keep.parentElement !== settlementContent) { keep.parentElement && keep.parentElement.removeChild(keep); } } catch (e) {}
                            settlementContent.insertBefore(keep, groupContainer.nextSibling);
                        }
                    }
                }
            } catch (e) {
                console.warn('reorderSettlementPriority error', e);
            }
        }

        function toggleSubAccordion(e) {
             // Prevent card click event when clicking the header itself
            if (!e.target.closest('[data-filter-type="custom-group"]')) {
                 const subAccordionItem = e.currentTarget.parentElement;
                 subAccordionItem.classList.toggle('open');
                 
                 // Update scroll behavior after sub-accordion toggle and recompute today marker
                 setTimeout(() => {
                     updateSettlementScrollBehavior();
                     try {
                         const containerRef = fullscreenModal.classList.contains('hidden') 
                             ? document.getElementById('ganttViewContent') 
                             : fullscreenModalBody;
                         recomputeTodayMarkerHeight(containerRef);
                     } catch (e) {
                         // ignore errors silently
                     }
                 }, 120);
            }
        }


        function handleCardClick(e) {
            const card = e.target.closest('[data-filter-type]');
             // Prevent modal opening if clicking within a sub-accordion header (let the toggle handle it)
            if (!card || e.target.closest('.sub-accordion-header')) return;

            const filterType = card.dataset.filterType;
            const filterValue = card.dataset.filterValue;
            let title = '';
            let dataForModal = [];

            let baseData;
            // ë³€ê²½ ì„¤ëª…:
            // - í•˜ìœ„ ì¹´ë“œ(ì˜ˆ: 'ì‹œê³µì‚¬ë³„'ì˜ íŠ¹ì • ì‹œê³µì‚¬ í•­ëª©)ê°€ í´ë¦­ë  ë•ŒëŠ”
            //   í˜„ì¬ ì ìš©ëœ í•„í„°(ì˜ˆ: ê³ ê°ì‚¬ í•„í„°)ì— ë”°ë¼ ê²°ê³¼ê°€ ì œí•œë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
            // - ì´ì „ êµ¬í˜„ì€ 'custom-group' ê³„ì—´ í´ë¦­ ì‹œ í•­ìƒ ì „ì²´ ì›ë³¸(projectData)ì„ ì‚¬ìš©í–ˆëŠ”ë°,
            //   ì´ëŠ” ì‚¬ìš©ìê°€ íŠ¹ì • ê³ ê°ì‚¬ë¡œ í•„í„°ë§í•œ ìƒíƒœì—ì„œ í•˜ìœ„ ì¹´ë“œë¥¼ ëˆŒë €ì„ ë•Œ
            //   ì „ì²´ ë°ì´í„°ë¥¼ í‘œì‹œí•˜ëŠ” ë¬¸ì œë¥¼ ì¼ìœ¼ì¼°ìŠµë‹ˆë‹¤.
            // í•´ê²° ë°©ì•ˆ: custom-group ë° custom-group-taskì˜ ê²½ìš°ì—ë„
            // getFilteredAndSortedData()ë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ í•„í„° ì»¨í…ìŠ¤íŠ¸ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
            if (filterType === 'custom-group' || filterType === 'custom-group-task') {
                // Use currently filtered data so subgroup clicks respect active filters (e.g., customer)
                baseData = getFilteredAndSortedData();
            } else {
                // ê·¸ ì™¸ì˜ ì¹´ë“œ(ì˜ˆ: ìƒíƒœë³„ ì¹´ë“œ)ëŠ” í˜„ì¬ í•„í„°ë§ëœ ë°ì´í„°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•©ë‹ˆë‹¤.
                baseData = getFilteredAndSortedData();
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (filterType === 'status') {
                const statusText = filterValue === 'all' ? 'ì „ì²´ ì‘ì—…' : filterValue;
                title = `${statusText} ëª©ë¡`;
                switch (filterValue) {
                    case 'all':
                        dataForModal = baseData;
                        break;
                    case 'ê³µì‚¬ì¤‘':
                        dataForModal = baseData.filter(p => p.progress > 0 && p.progress < 100 && p.endDate >= today);
                        break;
                    case 'ì°©ê³µì „':
                        dataForModal = baseData.filter(p => (p.progress || 0) === 0 && p.endDate >= today);
                        break;
                    case 'ì™„ë£Œ':
                        dataForModal = baseData.filter(p => p.progress === 100);
                        break;
                    case 'ì§€ì—°':
                        dataForModal = baseData.filter(p => p.progress < 100 && p.endDate < today);
                        break;
                    default:
                        dataForModal = [];
                }
                if (dataForModal.length > 0) {
                    showDataDetailModal(title, dataForModal);
                }
            } else if (filterType === 'taskType') {
                title = `'${filterValue}' ìƒì„¸ ê³µì • í˜„í™©`;
                dataForModal = baseData.filter(p => p.taskType === filterValue);
                 if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${filterValue}' ê³µì •ìœ¨`);
                }
            } else if (filterType === 'progress') {
                title = 'ì´ê´„ ìƒì„¸ í˜„í™©';
                dataForModal = baseData;
                if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, 'ì´ê´„ ê³µì •ìœ¨');
                }
            } else if (filterType === 'custom-group') {
                const field = card.dataset.filterField;
                const value = card.dataset.filterValue;
                title = `'${value}' (${field}) ìƒì„¸ ê³µì • í˜„í™©`;
                dataForModal = baseData.filter(p => p.customFields?.[field] === value);
                 if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${value}' ê³µì •ìœ¨`);
                }
            // Improvement: Handle click on sub-cards in settlement group section
            } else if (filterType === 'custom-group-task') {
                const field = card.dataset.filterField;
                const value = card.dataset.filterValue;
                const taskType = card.dataset.filterTaskType;
                title = `'${value}' (${field}) - '${taskType}' ìƒì„¸`;
                dataForModal = baseData.filter(p => p.customFields?.[field] === value && p.taskType === taskType);
                if (dataForModal.length > 0) {
                    showProgressDetailModal(title, dataForModal, `'${taskType}' ê³µì •ìœ¨`);
                }
            }


             if (dataForModal.length > 0 && !e.target.closest('.sub-accordion-header')) {
                if (['status'].includes(filterType)) { // Only show simple list for status clicks
                     showDataDetailModal(title, dataForModal);
                 } else {
                     showProgressDetailModal(title, dataForModal, title.replace(' ìƒì„¸ ê³µì • í˜„í™©', ' ê³µì •ìœ¨')); // Generate label
                 }
            } else if (dataForModal.length === 0 && !e.target.closest('.sub-accordion-header')) {
                 showToast('í‘œì‹œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'info');
            }
        }

        function showProgressDetailModal(title, data, summaryLabel = 'ì´ê´„ ê³µì •ìœ¨') {
            // ëª¨ë‹¬ ì´ˆê¸°í™”
            const overlay = dataDetailModal;
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            
            const content = overlay.querySelector('.modal-content');
            // ëª¨ë‹¬ ê¸°ë³¸ í¬ê¸° ë° ìœ„ì¹˜ ì„¤ì •
            content.style.width = '80%';
            content.style.maxWidth = '1200px';
            content.style.height = '80vh';
            content.style.maxHeight = '800px';
            content.style.position = 'relative';
            content.style.top = '0';
            content.style.left = '0';
            content.style.transform = 'none';
            content.style.margin = 'auto';
            
            dataDetailTitle.textContent = title;
            // Toolbar with export button and count
            const toolbarHTML = `<div class="flex justify-between items-center mb-3">
                    <div class="text-sm text-gray-600">ì´ <strong>${data.length}</strong>ê±´</div>
                    <div><button class="table-export-btn px-3 py-1 bg-indigo-600 text-white rounded text-sm">ì—‘ì…€ ë‹¤ìš´ë¡œë“œ</button></div>
                </div>`;

            let tableHTML = `${toolbarHTML}<table class="w-full text-sm text-left text-gray-500">
                <thead class="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0">
                    <tr>
                        <th scope="col" class="px-4 py-3">No.</th>
                        <th scope="col" class="px-4 py-3">í”„ë¡œì íŠ¸ ëª…</th>
                        <th scope="col" class="px-4 py-3 text-right">ì •ì‚° (A)</th>
                        <th scope="col" class="px-4 py-3 text-right">ì§„í–‰ (B)</th>
                        <th scope="col" class="px-4 py-3 text-right">ê°€ì¤‘ì¹˜ ì ìš©ê°’ (A*B)</th>
                    </tr>
                </thead>
                <tbody>`;

            let totalPo = 0;
            let weightedProgressSum = 0;

            data.forEach((item, index) => {
                const po = item.poAmount || 0;
                const progress = item.progress || 0;
                const weightedValue = po * progress;
                totalPo += po;
                weightedProgressSum += weightedValue;
                // IMPROVEMENT: Apply accounting format
                tableHTML += `
                    <tr class="border-b hover:bg-gray-50">
                        <td class="px-4 py-2 font-medium text-gray-900">${index + 1}</td>
                        <td class="px-4 py-2">${item.name}</td>
                        <td class="px-4 py-2 text-right">${formatCurrency(po)}</td>
                        <td class="px-4 py-2 text-right">${progress}%</td>
                        <td class="px-4 py-2 text-right">${(weightedValue/100).toLocaleString('ko-KR')}</td>
                    </tr>`;
            });

            const overallProgressRate = totalPo > 0 ? (weightedProgressSum / totalPo).toFixed(2) : 0;

            tableHTML += `</tbody>
                <tfoot class="text-sm font-semibold text-gray-800 bg-gray-100">
                    <tr>
                        <td colspan="2" class="px-4 py-3 text-center">í•©ê³„</td>
                        <td class="px-4 py-3 text-right">${formatCurrency(totalPo)}</td>
                        <td class="px-4 py-3 text-right">-</td>
                        <td class="px-4 py-3 text-right">${(weightedProgressSum/100).toLocaleString('ko-KR')}</td>
                    </tr>
                    <tr>
                        <td colspan="4" class="px-4 py-3 text-center text-base">${summaryLabel} (ê°€ì¤‘ì¹˜ í•©ê³„ / ì •ì‚° í•©ê³„)</td>
                        <td class="px-4 py-3 text-right text-base font-bold text-blue-600">${overallProgressRate}%</td>
                    </tr>
                </tfoot>
            </table>`;

            dataDetailTableContainer.innerHTML = tableHTML;

            // Make table sortable and attach export
            const tbl = dataDetailTableContainer.querySelector('table');
            if (tbl) makeTableSortable(tbl);
            const btn = dataDetailTableContainer.querySelector('.table-export-btn');
            if (btn) btn.addEventListener('click', () => exportTableToXLSX(tbl, `${title.replace(/[^0-9a-zA-Zê°€-í£\s_-]/g,'') || 'export'}.xlsx`));

            // ëª¨ë‹¬ í‘œì‹œ ë° ìŠ¤íƒ€ì¼ ì„¤ì •
            dataDetailModal.classList.remove('hidden');
            dataDetailModal.style.display = 'flex';
            dataDetailModal.style.justifyContent = 'center';
            dataDetailModal.style.alignItems = 'center';
            
            // ëª¨ë‹¬ ì»¨í…ì¸  í¬ê¸°ì™€ ìœ„ì¹˜ ì¬ì¡°ì •
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                requestAnimationFrame(() => {
                    modalContent.style.position = 'relative';
                    modalContent.style.width = '80%';
                    modalContent.style.maxWidth = '1200px';
                    modalContent.style.height = '80vh';
                    modalContent.style.maxHeight = '800px';
                    modalContent.style.margin = 'auto';
                    modalContent.style.transform = 'none';
                    modalContent.style.top = '0';
                    modalContent.style.left = '0';
                    
                    // ìŠ¤í¬ë¡¤ë°” ìœ„ì¹˜ ì´ˆê¸°í™”
                    if (dataDetailTableContainer) {
                        dataDetailTableContainer.scrollTop = 0;
                    }
                });
            }
        }

        function showDataDetailModal(title, data) {
            dataDetailTitle.textContent = title;
            const toolbarHTML = `<div class="flex justify-between items-center mb-3">
                    <div class="text-sm text-gray-600">ì´ <strong>${data.length}</strong>ê±´</div>
                    <div><button class="table-export-btn px-3 py-1 bg-indigo-600 text-white rounded text-sm">ì—‘ì…€ ë‹¤ìš´ë¡œë“œ</button></div>
                </div>`;

            let tableHTML = `${toolbarHTML}<table class="w-full text-sm text-left text-gray-500">
                <thead class="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0">
                    <tr>
                        <th scope="col" class="px-4 py-3">No.</th>
                        <th scope="col" class="px-4 py-3">í”„ë¡œì íŠ¸ ëª…</th>
                        <th scope="col" class="px-4 py-3">ìƒíƒœ</th>
                        <th scope="col" class="px-4 py-3">ì‹œì‘ì¼</th>
                        <th scope="col" class="px-4 py-3">ì¢…ë£Œì¼</th>
                        <th scope="col" class="px-4 py-3 text-right">ì •ì‚°</th>
                    </tr>
                </thead>
                <tbody>`;

            data.forEach((item, index) => {
                // IMPROVEMENT: Apply accounting format
                tableHTML += `
                    <tr class="border-b hover:bg-gray-50">
                        <td class="px-4 py-2 font-medium text-gray-900">${index + 1}</td>
                        <td class="px-4 py-2">${item.name}</td>
                        <td class="px-4 py-2">${item.status}</td>
                        <td class="px-4 py-2">${formatDate(item.startDate)}</td>
                        <td class="px-4 py-2">${formatDate(item.endDate)}</td>
                        <td class="px-4 py-2 text-right">${formatCurrency(item.poAmount)}</td>
                    </tr>`;
            });

            tableHTML += `</tbody></table>`;
            dataDetailTableContainer.innerHTML = tableHTML;

            // Make table sortable and attach export
            const tbl = dataDetailTableContainer.querySelector('table');
            if (tbl) makeTableSortable(tbl);
            const btn = dataDetailTableContainer.querySelector('.table-export-btn');
            if (btn) btn.addEventListener('click', () => exportTableToXLSX(tbl, `${title.replace(/[^0-9a-zA-Zê°€-í£\s_-]/g,'') || 'export'}.xlsx`));

            // ëª¨ë‹¬ í‘œì‹œ ë° ìŠ¤íƒ€ì¼ ì„¤ì •
            dataDetailModal.classList.remove('hidden');
            dataDetailModal.style.display = 'flex';
            dataDetailModal.style.justifyContent = 'center';
            dataDetailModal.style.alignItems = 'center';
            
            // ëª¨ë‹¬ ì»¨í…ì¸  í¬ê¸°ì™€ ìœ„ì¹˜ ì¬ì¡°ì •
            const modalContent = dataDetailModal.querySelector('.modal-content');
            if (modalContent) {
                requestAnimationFrame(() => {
                    modalContent.style.position = 'relative';
                    modalContent.style.width = '80%';
                    modalContent.style.maxWidth = '1200px';
                    modalContent.style.height = '80vh';
                    modalContent.style.maxHeight = '800px';
                    modalContent.style.margin = 'auto';
                    modalContent.style.transform = 'none';
                    modalContent.style.top = '0';
                    modalContent.style.left = '0';
                    
                    // ìŠ¤í¬ë¡¤ë°” ìœ„ì¹˜ ì´ˆê¸°í™”
                    if (dataDetailTableContainer) {
                        dataDetailTableContainer.scrollTop = 0;
                    }
                });
            }
        }

        /**
         * í”„ë¡œì íŠ¸ì˜ í˜„ì¬ ìƒíƒœë¥¼ ìë™ìœ¼ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤.
         * @param {number} progress - í”„ë¡œì íŠ¸ì˜ ì§„í–‰ë¥  (0-100)
         * @param {Date} endDate - í”„ë¡œì íŠ¸ì˜ ì¢…ë£Œì¼
         * @returns {string} - ê³„ì‚°ëœ ìƒíƒœ ('ì°©ê³µì „'|'ê³µì‚¬ì¤‘'|'ì™„ë£Œ'|'ì§€ì—°')
         */
        function calculateStatus(progress, endDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            if (progress === 100) return 'ì™„ë£Œ';
            if (endDate < today) return 'ì§€ì—°';
            if (progress === 0) return 'ì°©ê³µì „';
            return 'ê³µì‚¬ì¤‘';
        }

        function dateDiffInDays(a, b) {
            const _MS_PER_DAY = 1000 * 60 * 60 * 24;
            const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
            const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());
            return Math.floor((utc2 - utc1) / _MS_PER_DAY);
        }

        function scrollToToday() {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if (!container) return; // Add check
            const todayMarker = container.querySelector('.gantt-today-marker-container');
            if (todayMarker) {
                const todayPosition = todayMarker.offsetLeft;
                const timelineContainer = container.querySelector('.gantt-timeline-body-wrapper');
                if(timelineContainer) {
                    const scrollTarget = todayPosition - (timelineContainer.clientWidth / 2);
                    timelineContainer.scrollTo({ left: scrollTarget, behavior: 'smooth' });
                }
            }
        }

        function handleResizeMousedown(e) {
            if (!e.target.classList.contains('resizer')) return;
            const titlesPane = e.target.closest('.gantt-titles');
            if (!titlesPane) return;

            e.preventDefault();

            const startX = e.clientX;
            const startWidth = titlesPane.offsetWidth;

            const doDrag = (moveEvent) => {
                const newWidth = startWidth + (moveEvent.clientX - startX);
                if (newWidth > 250 && newWidth < 900) {
                    titlesPane.style.width = `${newWidth}px`;
                }
            };

            const stopDrag = () => {
                document.documentElement.removeEventListener('mousemove', doDrag);
                document.documentElement.removeEventListener('mouseup', stopDrag);
            };

            document.documentElement.addEventListener('mousemove', doDrag);
            document.documentElement.addEventListener('mouseup', stopDrag);
        }

        function handleColResizeMousedown(e) {
            const resizer = e.target;
            const titlesPane = resizer.closest('.gantt-titles');
            if (!titlesPane) return;

            e.preventDefault();

            const leftColName = resizer.dataset.colLeft;
            const rightColName = resizer.dataset.colRight;

            // convert camelCase or underscored names to kebab-case CSS variable names
            const toKebab = (s) => String(s).replace(/([a-z0-9])([A-Z])/g, '$1-$2').replace(/_/g, '-').toLowerCase();
            const leftColVar = `--${toKebab(leftColName)}-col-width`;
            const rightColVar = `--${toKebab(rightColName)}-col-width`;

            const startX = e.clientX;
            const startLeftWidth = parseFloat(getComputedStyle(titlesPane).getPropertyValue(leftColVar));
            const startRightWidth = parseFloat(getComputedStyle(titlesPane).getPropertyValue(rightColVar));
            const minWidth = 60;

            const doDrag = (moveEvent) => {
                const diffX = moveEvent.clientX - startX;
                let newLeftWidth = startLeftWidth + diffX;
                let newRightWidth = startRightWidth - diffX;

                if (newLeftWidth < minWidth) {
                    newLeftWidth = minWidth;
                    newRightWidth = startLeftWidth + startRightWidth - minWidth;
                }
                if (newRightWidth < minWidth) {
                    newRightWidth = minWidth;
                    newLeftWidth = startLeftWidth + startRightWidth - minWidth;
                }

                titlesPane.style.setProperty(leftColVar, `${newLeftWidth}px`);
                titlesPane.style.setProperty(rightColVar, `${newRightWidth}px`);
            };

            const stopDrag = () => {
                document.documentElement.removeEventListener('mousemove', doDrag);
                document.documentElement.removeEventListener('mouseup', stopDrag);
            };

            document.documentElement.addEventListener('mousemove', doDrag);
            document.documentElement.addEventListener('mouseup', stopDrag);
        }

        function handleColumnToggle(toggleBtn) {
            const colName = toggleBtn.dataset.col;
            if (colName && typeof columnVisibility[colName] !== 'undefined') {
                columnVisibility[colName] = !columnVisibility[colName];
                toggleBtn.textContent = columnVisibility[colName] ? '[-]' : '[+]';
                const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                 if (!container) return; // Add check
                const elementsToToggle = container.querySelectorAll(`.${colName}`);
                elementsToToggle.forEach(el => {
                    el.style.display = columnVisibility[colName] ? '' : 'none';
                    if (colName === 'project-dates' && columnVisibility[colName]) {
                         el.style.display = 'flex';
                    }
                });
            }
        }

        function handleDateEditClick(dateEditor) {
            if (!dateEditor || dateEditor.classList.contains('editing')) return;

            const dateType = dateEditor.dataset.dateType;
            const projectIndexAttr = dateEditor.dataset.projectIndex;
            let project = null;

            if (projectIndexAttr !== undefined) {
                const idx = parseInt(projectIndexAttr, 10);
                if (!Number.isNaN(idx) && projectData[idx]) {
                    project = projectData[idx];
                }
            }

            if (!project) {
                const projectId = dateEditor.dataset.projectId;
                project = projectData.find(p => String(p.id) === String(projectId));
            }

            if (!project) return;

            recordOriginalDates(project);

            const originalText = dateEditor.textContent;
            const registryKey = getProjectRegistryKey(project);
            const originalDates = registryKey ? (originalDateRegistry.get(registryKey) || {}) : {};
            const originalYmd = dateType === 'startDate' ? originalDates.start : originalDates.end;
            const currentDate = project[dateType] instanceof Date && !isNaN(project[dateType]) ? formatDateYMD(project[dateType]) : (project[`${dateType}Str`] || '');

            dateEditor.classList.add('editing');
            dateEditor.innerHTML = '';

            const form = document.createElement('div');
            form.className = 'date-edit-form';

            const label = document.createElement('label');
            label.textContent = dateType === 'startDate' ? 'ì‹œì‘ì¼' : 'ì¢…ë£Œì¼';

            const calendarInput = document.createElement('input');
            calendarInput.type = 'date';
            calendarInput.className = 'date-input-calendar';
            if (currentDate) {
                calendarInput.value = currentDate;
            }

            const manualInput = document.createElement('input');
            manualInput.type = 'text';
            manualInput.placeholder = 'YYYY-MM-DD';
            manualInput.className = 'date-manual-input';
            if (currentDate) {
                manualInput.value = currentDate;
            }

            const helper = document.createElement('div');
            helper.className = 'date-edit-helper';
            helper.textContent = 'ë‹¬ë ¥ ì„ íƒ ë˜ëŠ” YYYY-MM-DD ì§ì ‘ ì…ë ¥';

            const originalInfo = document.createElement('div');
            originalInfo.className = 'date-edit-original';
            originalInfo.textContent = originalYmd ? `ì›ë³¸: ${originalYmd}` : 'ì›ë³¸: -';

            const actions = document.createElement('div');
            actions.className = 'date-edit-actions';

            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'date-edit-cancel';
            cancelBtn.textContent = 'ì·¨ì†Œ';

            const saveBtn = document.createElement('button');
            saveBtn.type = 'button';
            saveBtn.className = 'date-edit-save';
            saveBtn.textContent = 'ì €ì¥';

            actions.appendChild(cancelBtn);
            actions.appendChild(saveBtn);

            form.appendChild(label);
            form.appendChild(calendarInput);
            form.appendChild(manualInput);
            form.appendChild(helper);
            form.appendChild(originalInfo);
            form.appendChild(actions);

            dateEditor.appendChild(form);

            const autoFormatManual = () => {
                let raw = manualInput.value.replace(/[^0-9]/g, '');
                if (raw.length > 4) raw = `${raw.slice(0, 4)}-${raw.slice(4)}`;
                if (raw.length > 7) raw = `${raw.slice(0, 7)}-${raw.slice(7, 9)}`;
                manualInput.value = raw.slice(0, 10);
                if (manualInput.value.length === 10) {
                    calendarInput.value = manualInput.value;
                }
            };

            manualInput.addEventListener('input', autoFormatManual);
            calendarInput.addEventListener('change', () => {
                manualInput.value = calendarInput.value;
            });

            const closeEditor = (restoreText = true) => {
                document.removeEventListener('mousedown', outsideClickHandler);
                document.removeEventListener('keydown', escKeyHandler);
                dateEditor.classList.remove('editing');
                if (restoreText) {
                    dateEditor.textContent = originalText;
                }
            };

            const outsideClickHandler = (evt) => {
                if (!dateEditor.contains(evt.target)) {
                    closeEditor(true);
                }
            };

            const escKeyHandler = (evt) => {
                if (evt.key === 'Escape') {
                    closeEditor(true);
                }
            };

            document.addEventListener('mousedown', outsideClickHandler);
            document.addEventListener('keydown', escKeyHandler);

            cancelBtn.addEventListener('click', () => {
                closeEditor(true);
            });

            const attemptSave = () => {
                const manualValue = manualInput.value.trim();
                const calendarValue = calendarInput.value;
                const candidate = manualValue || calendarValue;

                if (!candidate) {
                    showToast('ë‚ ì§œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'warning');
                    manualInput.focus();
                    return;
                }

                const normalized = candidate.replace(/\./g, '-');
                const newDate = parseLocalDateString(normalized);

                if (!newDate || isNaN(newDate.getTime())) {
                    showToast('YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                    manualInput.focus();
                    return;
                }

                const tempProject = { ...project };
                tempProject[dateType] = newDate;

                if (dateType === 'startDate' && project.endDate && newDate > project.endDate) {
                    showToast('ì‹œì‘ì¼ì€ ì™„ë£Œì¼ë³´ë‹¤ ëŠ¦ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                    manualInput.focus();
                    return;
                }
                if (dateType === 'endDate' && project.startDate && newDate < project.startDate) {
                    showToast('ì™„ë£Œì¼ì€ ì‹œì‘ì¼ë³´ë‹¤ ë¹ ë¥¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                    manualInput.focus();
                    return;
                }

                project[dateType] = newDate;
                project[`${dateType}Str`] = formatDateYMD(newDate);

                pendingScrollRestore = captureScrollState(true);

                closeEditor(false);
                updateAndApplyDateRange();
                render();
                showToast('ë‚ ì§œê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
            };

            saveBtn.addEventListener('click', attemptSave);
            manualInput.addEventListener('keydown', (evt) => {
                if (evt.key === 'Enter') {
                    evt.preventDefault();
                    attemptSave();
                }
            });
            calendarInput.addEventListener('keydown', (evt) => {
                if (evt.key === 'Enter') {
                    evt.preventDefault();
                    attemptSave();
                }
            });

            setTimeout(() => manualInput.focus(), 20);
        }

        // ê°œì„  ì‚¬í•­: ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ í›„ í•´ë‹¹ í”„ë¡œì íŠ¸ì˜ DOM ìš”ì†Œë¥¼ ì§ì ‘ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜
        function updateProgressInDOM(projectId, newProgress) {
            // ID íƒ€ì… í†µì¼ (ë¬¸ìì—´ë¡œ ë³€í™˜)
            const projectIdStr = String(projectId);
            
            // ëª¨ë“  ê°€ëŠ¥í•œ ì»¨í…Œì´ë„ˆì—ì„œ ì°¾ê¸°
            const containers = [];
            const ganttViewContent = document.getElementById('ganttViewContent');
            if (ganttViewContent) containers.push(ganttViewContent);
            if (fullscreenModalBody) containers.push(fullscreenModalBody);
            
            containers.forEach(container => {
                // ì§„í–‰ë¥  í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ëª¨ë“  ë§¤ì¹­ ìš”ì†Œ)
                const progressEditors = container.querySelectorAll(`.progress-editor[data-project-id="${projectIdStr}"]`);
                progressEditors.forEach(progressEditor => {
                    progressEditor.textContent = `${newProgress}%`;
                });

                // ì§„í–‰ë¥  ë°” ì—…ë°ì´íŠ¸ (ëª¨ë“  ë§¤ì¹­ ìš”ì†Œ)
                const titleItems = container.querySelectorAll(`.title-item[data-project-id="${projectIdStr}"]`);
                titleItems.forEach(titleItem => {
                    const progressSummary = titleItem.querySelector('.project-progress-summary');
                    if (progressSummary) {
                        const progressBar = progressSummary.querySelector('div > div');
                        if (progressBar) {
                            progressBar.style.width = `${newProgress}%`;
                            progressBar.style.background = getProgressGradient(newProgress);
                        }
                        progressSummary.setAttribute('title', `${newProgress}%`);
                        progressSummary.setAttribute('aria-label', `ì§„í–‰ë¥  ${newProgress}%`);
                    }
                });

                // ê°„íŠ¸ ì°¨íŠ¸ì˜ ì§„í–‰ë¥  ë°” ì—…ë°ì´íŠ¸ (ëª¨ë“  ë§¤ì¹­ ìš”ì†Œ)
                const barRows = container.querySelectorAll(`.gantt-bar-row[data-project-id="${projectIdStr}"]`);
                barRows.forEach(barRow => {
                    const progressFill = barRow.querySelector('.gantt-bar-progress');
                    if (progressFill) {
                        const bar = barRow.querySelector('.gantt-bar');
                        if (bar) {
                            const barWidth = parseFloat(bar.style.width) || 0;
                            progressFill.style.width = `${barWidth * (newProgress / 100)}px`;
                        }
                    }
                    const tooltip = barRow.querySelector('.tooltip');
                    if (tooltip) {
                        tooltip.innerHTML = tooltip.innerHTML.replace(/<strong>ì§„í–‰:<\/strong> \d+%/, `<strong>ì§„í–‰:</strong> ${newProgress}%`);
                    }
                });
            });
        }

        function handleProgressEditClick(progressEditor) {
            if (progressPopup.dataset.projectId === progressEditor.dataset.projectId && !progressPopup.classList.contains('hidden')) {
                progressPopup.classList.add('hidden');
                return;
            }

            const projectId = progressEditor.dataset.projectId;
            const project = projectData.find(p => p.id === projectId);
            if (!project) return;

            const currentProgress = project.progress || 0;

            progressPopup.innerHTML = '';
            progressPopup.dataset.projectId = projectId;

            for (let i = 0; i <= 10; i++) {
                const value = i * 10;
                const btn = document.createElement('button');
                btn.textContent = `${value}%`;
                btn.dataset.value = value;
                btn.className = 'progress-val-btn';
                if (value === currentProgress) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    project.progress = value;
                    // ê°œì„  ì‚¬í•­: ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸
                    updateProjectStatuses();
                    // ê°œì„  ì‚¬í•­: DOM ìš”ì†Œ ì§ì ‘ ì—…ë°ì´íŠ¸ (ì¦‰ì‹œ ë°˜ì˜)
                    updateProgressInDOM(projectId, value);
                    // ê°œì„  ì‚¬í•­: ì „ì²´ ë Œë”ë§ë„ ìˆ˜í–‰í•˜ì—¬ ìš”ì•½ ì •ë³´ ë“± ì—…ë°ì´íŠ¸
                    pendingScrollRestore = captureScrollState(true);
                    if (renderTimeout) {
                        clearTimeout(renderTimeout);
                        renderTimeout = null;
                    }
                    isRendering = false;
                    render();
                    // ê°œì„  ì‚¬í•­: render() ì™„ë£Œ í›„ ë‹¤ì‹œ DOM ì—…ë°ì´íŠ¸ (render()ê°€ ë®ì–´ì“¸ ìˆ˜ ìˆìœ¼ë¯€ë¡œ)
                    // requestAnimationFrameì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ ì—…ë°ì´íŠ¸
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            updateProgressInDOM(projectId, value);
                        });
                    });
                    showToast('ì§„í–‰ë¥ ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                    progressPopup.classList.add('hidden');
                });
                progressPopup.appendChild(btn);
            }

            const inputContainer = document.createElement('div');
            inputContainer.className = 'progress-input-area';

            const input = document.createElement('input');
            input.type = 'number';
            input.min = 0;
            input.max = 100;
            input.value = currentProgress;

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'ì €ì¥';

            const saveProgress = () => {
                let newProgress = parseInt(input.value, 10);
                if (!isNaN(newProgress) && newProgress >= 0 && newProgress <= 100) {
                    project.progress = newProgress;
                    // ê°œì„  ì‚¬í•­: ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸
                    updateProjectStatuses();
                    // ê°œì„  ì‚¬í•­: DOM ìš”ì†Œ ì§ì ‘ ì—…ë°ì´íŠ¸ (ì¦‰ì‹œ ë°˜ì˜)
                    updateProgressInDOM(projectId, newProgress);
                    // ê°œì„  ì‚¬í•­: ì „ì²´ ë Œë”ë§ë„ ìˆ˜í–‰í•˜ì—¬ ìš”ì•½ ì •ë³´ ë“± ì—…ë°ì´íŠ¸
                    pendingScrollRestore = captureScrollState(true);
                    if (renderTimeout) {
                        clearTimeout(renderTimeout);
                        renderTimeout = null;
                    }
                    isRendering = false;
                    render();
                    // ê°œì„  ì‚¬í•­: render() ì™„ë£Œ í›„ ë‹¤ì‹œ DOM ì—…ë°ì´íŠ¸ (render()ê°€ ë®ì–´ì“¸ ìˆ˜ ìˆìœ¼ë¯€ë¡œ)
                    // requestAnimationFrameì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ ì—…ë°ì´íŠ¸
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            updateProgressInDOM(projectId, newProgress);
                        });
                    });
                    showToast('ì§„í–‰ë¥ ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                    progressPopup.classList.add('hidden');
                } else {
                    showToast('0ì—ì„œ 100 ì‚¬ì´ì˜ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                }
            };

            saveBtn.addEventListener('click', saveProgress);
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') saveProgress();
                if (e.key === 'Escape') progressPopup.classList.add('hidden');
            });

            inputContainer.appendChild(input);
            inputContainer.appendChild(saveBtn);
            progressPopup.appendChild(inputContainer);

            const rect = progressEditor.getBoundingClientRect();
            progressPopup.style.top = `${rect.bottom + window.scrollY + 5}px`;

            const popupWidth = 224;
            let leftPos = rect.left + window.scrollX;
            if (leftPos + popupWidth > window.innerWidth) {
                leftPos = window.innerWidth - popupWidth - 10;
            }
            progressPopup.style.left = `${leftPos}px`;

            progressPopup.classList.remove('hidden');
            input.select();
        }

        function handleLegendClick(legendItem) {
            const status = legendItem.dataset.statusFilter;
            const isActive = legendItem.classList.contains('legend-filter-active');

             // Target legend within the correct container
             const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
             if(legendContainer) {
                 legendContainer.querySelectorAll('.legend-section [data-status-filter].legend-filter-active').forEach(el => el.classList.remove('legend-filter-active'));
             }

            // ìƒˆë¡œìš´ ë‚ ì§œ ê¸°ë°˜ ë²”ë¡€ ì²˜ë¦¬
            const dateBasedFilters = ['ì˜¤ëŠ˜ì‹œì‘', 'ì˜¤ëŠ˜ì¢…ë£Œ', 'ë‚´ì¼ì‹œì‘', 'ë‚´ì¼ì¢…ë£Œ'];
            let targetDate = null;
            let shouldScroll = false;

            if (dateBasedFilters.includes(status)) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);

                if (status === 'ì˜¤ëŠ˜ì‹œì‘' || status === 'ì˜¤ëŠ˜ì¢…ë£Œ') {
                    targetDate = new Date(today);
                } else if (status === 'ë‚´ì¼ì‹œì‘' || status === 'ë‚´ì¼ì¢…ë£Œ') {
                    targetDate = new Date(tomorrow);
                }
                shouldScroll = true;
                legendStatusFilter = status;
                legendItem.classList.add('legend-filter-active');
            } else if (status === 'ì „ì²´') {
                legendStatusFilter = null;
                // No active highlight for 'ì „ì²´'
            } else if (isActive) {
                legendStatusFilter = null;
            } else {
                legendStatusFilter = status;
                legendItem.classList.add('legend-filter-active');
            }

            if (searchInput) searchInput.value = '';

            render();

            // ë‚ ì§œë¡œ ìŠ¤í¬ë¡¤
            if (shouldScroll && targetDate) {
                setTimeout(() => {
                    scrollToDate(targetDate);
                }, 100);
            }
        }

        function scrollToDate(targetDate) {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (!container) return;

            const timelineContainer = container.querySelector('.gantt-timeline-body-wrapper');
            if (!timelineContainer) return;

            // ë‚ ì§œë¥¼ í”½ì…€ ìœ„ì¹˜ë¡œ ë³€í™˜
            const dateOffset = dateDiffInDays(viewMinDate, targetDate);
            const targetPosition = dateOffset * DAY_WIDTH;

            // ì¤‘ì•™ìœ¼ë¡œ ìŠ¤í¬ë¡¤
            const scrollTarget = Math.max(0, targetPosition - (timelineContainer.clientWidth / 2));
            timelineContainer.scrollTo({ left: scrollTarget, behavior: 'smooth' });
        }

        function renderGanttChart(data) {
             const isInFullscreen = !fullscreenModal.classList.contains('hidden');
             const container = isInFullscreen ? fullscreenModalBody : document.getElementById('ganttViewContent');
             if (!container) return; // Exit if container not found
             const currentGanttContainer = container.querySelector('#ganttChart'); // Find chart within the current container
             if (!currentGanttContainer) return; // Exit if chart area not found


            currentGanttContainer.innerHTML = '';

            if (!viewMinDate || !viewMaxDate) {
                currentGanttContainer.innerHTML = `<p class="text-center text-gray-500 p-8">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìš°ì¸¡ í•˜ë‹¨ ë©”ë‰´ë¥¼ í†µí•´ ë°ì´í„°ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”.</p>`;
                return;
            }

            const ganttEl = document.createElement('div');
            ganttEl.className = 'gantt-chart-container';

            const titlesPane = document.createElement('div');
            titlesPane.className = 'gantt-titles';

            if (savedSettings) {
                if (savedSettings.titlesPaneWidth) {
                    titlesPane.style.width = savedSettings.titlesPaneWidth;
                }
                if (savedSettings.columnWidths) {
                    titlesPane.style.setProperty('--po-col-width', savedSettings.columnWidths.po);
                    titlesPane.style.setProperty('--dates-col-width', savedSettings.columnWidths.dates);
                    titlesPane.style.setProperty('--progress-col-width', savedSettings.columnWidths.progress);
                    // Restore the newly added progress summary column width if available
                    if (typeof savedSettings.columnWidths.progressSummary !== 'undefined' && savedSettings.columnWidths.progressSummary !== null) {
                        titlesPane.style.setProperty('--progress-summary-col-width', savedSettings.columnWidths.progressSummary);
                    }
                }
            }

            const headerEl = document.createElement('div');
            headerEl.className = 'header flex items-center';
            headerEl.innerHTML = `
                <div class="flex items-center flex-grow pr-2">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-name">${columnVisibility['project-name'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">ëª…ì¹­</span>
                </div>

                <div class="header-col justify-start items-center" style="width: var(--po-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-po">${columnVisibility['project-po'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">ì •ì‚°</span>
                </div>
                <div class="col-resizer" data-col-left="po" data-col-right="dates"></div>
                <div class="header-col justify-start items-center" style="width: var(--dates-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-dates">${columnVisibility['project-dates'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">ê¸°ê°„</span>
                </div>
                <div class="col-resizer" data-col-left="dates" data-col-right="progress"></div>
                <div class="header-col justify-start items-center" style="width: var(--progress-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-progress">${columnVisibility['project-progress'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">ì§„í–‰</span>
                </div>
                <div class="col-resizer" data-col-left="progress" data-col-right="progressSummary"></div>
                <div class="header-col justify-start items-center" style="width: var(--progress-summary-col-width);">
                    <span class="toggle-col-btn cursor-pointer font-mono select-none p-1 mr-1" data-col="project-progress-summary">${columnVisibility['project-progress-summary'] ? '[-]' : '[+]'}</span>
                    <span class="font-semibold whitespace-nowrap">ì§„í–‰ë¥ </span>
                </div>
            `;
            titlesPane.appendChild(headerEl);

            const resizer = document.createElement('div');
            resizer.className = 'resizer';
            titlesPane.appendChild(resizer);

            const titlesBodyWrapper = document.createElement('div');
            titlesBodyWrapper.className = 'gantt-titles-body-wrapper';


            const timelineWrapper = document.createElement('div');
            timelineWrapper.className = 'gantt-timeline-wrapper';

            const timelineHeaderWrapper = document.createElement('div');
            timelineHeaderWrapper.className = 'gantt-timeline-header-wrapper';

            const timelineBodyWrapper = document.createElement('div');
            timelineBodyWrapper.className = 'gantt-timeline-body-wrapper';

            const timelineHeader = document.createElement('div');
            timelineHeader.className = 'gantt-timeline-header';
            const yearMonthHeader = document.createElement('div');
            yearMonthHeader.className = 'gantt-year-month-header';
            const dayHeader = document.createElement('div');
            dayHeader.className = 'gantt-day-header';
            const weekdayHeader = document.createElement('div');
            weekdayHeader.className = 'gantt-weekday-header';

            const totalDays = dateDiffInDays(viewMinDate, viewMaxDate);
            const timelineWidth = (totalDays + 1) * DAY_WIDTH;

            let currentMonth = -1, monthDayCount = 0, monthEl;
            const weekdays = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '];
            
            // ê°œì„  ì‚¬í•­: ë©”ëª¨ë¦¬ ìµœì í™” - DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ DOM ì¡°ì‘ ìµœì†Œí™”
            const dayFragment = document.createDocumentFragment();
            const weekdayFragment = document.createDocumentFragment();

            for (let i = 0; i <= totalDays; i++) {
                const date = new Date(viewMinDate);
                date.setDate(date.getDate() + i);
                const dayOfWeek = date.getDay();
                const isWeekendOrHoliday = dayOfWeek === 0 || dayOfWeek === 6 || isHoliday(date);

                if (date.getMonth() !== currentMonth) {
                    if (monthEl) monthEl.style.width = `${monthDayCount * DAY_WIDTH}px`;
                    currentMonth = date.getMonth();
                    monthDayCount = 0;
                    monthEl = document.createElement('div');
                    monthEl.className = 'gantt-month';
                    monthEl.textContent = `${date.getFullYear()}ë…„ ${currentMonth + 1}ì›”`;
                    yearMonthHeader.appendChild(monthEl);
                }
                monthDayCount++;

                const dayEl = document.createElement('div');
                dayEl.className = 'gantt-day';
                dayEl.style.width = `${DAY_WIDTH}px`;
                dayEl.textContent = date.getDate();
                if(isWeekendOrHoliday) {
                    dayEl.classList.add('bg-red-50', 'text-red-500', 'font-bold');
                } else if (dayOfWeek === 6) {
                    dayEl.classList.add('bg-gray-100');
                }
                dayFragment.appendChild(dayEl);

                const weekdayEl = document.createElement('div');
                weekdayEl.className = 'gantt-weekday';
                weekdayEl.style.width = `${DAY_WIDTH}px`;
                weekdayEl.textContent = weekdays[dayOfWeek];
                if (isWeekendOrHoliday) {
                    weekdayEl.classList.add('text-red-500', 'font-bold');
                }
                weekdayFragment.appendChild(weekdayEl);
            }
            if (monthEl) monthEl.style.width = `${monthDayCount * DAY_WIDTH}px`;
            
            // DocumentFragmentë¥¼ í•œ ë²ˆì— ì¶”ê°€í•˜ì—¬ DOM ì¬ê³„ì‚° ìµœì†Œí™”
            dayHeader.appendChild(dayFragment);
            weekdayHeader.appendChild(weekdayFragment);

            timelineHeader.appendChild(yearMonthHeader);
            timelineHeader.appendChild(dayHeader);
            timelineHeader.appendChild(weekdayHeader);
            timelineHeader.style.width = `${timelineWidth}px`;

            const ganttBody = document.createElement('div');
            ganttBody.className = 'gantt-body';
            ganttBody.style.width = `${timelineWidth}px`;

            const gridAndMarkerContainer = document.createElement('div');
            gridAndMarkerContainer.style.position = 'absolute';
            gridAndMarkerContainer.style.top = '0';
            gridAndMarkerContainer.style.left = '0';
            gridAndMarkerContainer.style.width = '100%';
            gridAndMarkerContainer.style.height = '100%';
            gridAndMarkerContainer.style.zIndex = '1';

            // ê°œì„  ì‚¬í•­: ë©”ëª¨ë¦¬ ìµœì í™” - DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ DOM ì¡°ì‘ ìµœì†Œí™”
            const gridFragment = document.createDocumentFragment();
            for (let i = 0; i <= totalDays; i++) {
                const line = document.createElement('div');
                line.className = 'gantt-grid-line';
                line.style.left = `${i * DAY_WIDTH}px`;
                gridFragment.appendChild(line);
            }
            gridAndMarkerContainer.appendChild(gridFragment);
            ganttBody.appendChild(gridAndMarkerContainer);

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (today >= viewMinDate && today <= viewMaxDate) {
                const todayOffsetDays = dateDiffInDays(viewMinDate, today);
                const todayLeftPosition = `${todayOffsetDays * DAY_WIDTH + (DAY_WIDTH/2)}px`;

                // í—¤ë”ì˜ "ì˜¤ëŠ˜" ë§ˆì»¤ ìƒì„±
                const headerMarkerContainer = document.createElement('div');
                headerMarkerContainer.className = 'gantt-today-marker-container';
                headerMarkerContainer.style.left = todayLeftPosition;
                headerMarkerContainer.style.height = '32px';
                headerMarkerContainer.style.bottom = 'auto';
                headerMarkerContainer.style.pointerEvents = 'none'; // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë°©ì§€

                const headerMarkerLine = document.createElement('div');
                headerMarkerLine.className = 'gantt-today-marker';

                const markerLabel = document.createElement('div');
                markerLabel.className = 'gantt-today-label';
                markerLabel.textContent = 'ì˜¤ëŠ˜';

                headerMarkerContainer.appendChild(headerMarkerLine);
                headerMarkerContainer.appendChild(markerLabel);
                timelineHeaderWrapper.appendChild(headerMarkerContainer);

                // ë³¸ë¬¸ì˜ "ì˜¤ëŠ˜" ë§ˆì»¤ ìƒì„±
                const bodyMarkerContainer = document.createElement('div');
                bodyMarkerContainer.className = 'gantt-today-marker-container';
                bodyMarkerContainer.style.left = todayLeftPosition;
                bodyMarkerContainer.style.zIndex = '3';
                bodyMarkerContainer.style.pointerEvents = 'none'; // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë°©ì§€
                bodyMarkerContainer.style.position = 'absolute';
                bodyMarkerContainer.style.top = '0';
                bodyMarkerContainer.style.bottom = '0'; // ì „ì²´ ë†’ì´ ì„¤ì •

                const bodyMarkerLine = document.createElement('div');
                bodyMarkerLine.className = 'gantt-today-marker';
                bodyMarkerLine.style.height = '100%'; // ì»¨í…Œì´ë„ˆ ì „ì²´ ë†’ì´ ì‚¬ìš©
                
                bodyMarkerContainer.appendChild(bodyMarkerLine);
                ganttBody.appendChild(bodyMarkerContainer);
            }

            const titlesBody = document.createElement('div');
            const ganttRowsBody = document.createElement('div');

            const milestoneTrack = document.createElement('div');
            milestoneTrack.className = 'milestone-track';
            ganttBody.appendChild(milestoneTrack);

            const milestoneTitleRow = document.createElement('div');
            milestoneTitleRow.className = 'milestone-title-row';
            milestoneTitleRow.innerHTML = `<span>â± ë§ˆì¼ìŠ¤í†¤</span>`;
            titlesBody.appendChild(milestoneTitleRow);

            milestones.forEach(m => {
                const mDate = parseLocalDateString(m.date);
                if (mDate && viewMinDate && viewMaxDate && mDate >= viewMinDate && mDate <= viewMaxDate) {
                    const offset = dateDiffInDays(viewMinDate, mDate);
                    const marker = document.createElement('div');
                    marker.className = 'milestone-marker';
                    marker.style.left = `${offset * DAY_WIDTH + (DAY_WIDTH / 2)}px`;
                    // ë§ˆì¼ìŠ¤í†¤ í‘œì‹œë¥¼ YYYY-MM-DD í˜•ì‹ìœ¼ë¡œë§Œ í‘œì‹œ

                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.innerHTML = `<strong>${m.name}</strong><br>${formatDateYMD(mDate)}`;
                    marker.setAttribute('title', `${m.name} (${formatDateYMD(mDate)})`);
                    marker.appendChild(tooltip);

                    milestoneTrack.appendChild(marker);
                }
            });

            ganttBody.appendChild(ganttRowsBody);

            const groupedData = {};
            const taskTypeOrder = [];
            data.forEach(project => {
                if (!groupedData[project.taskType]) {
                    groupedData[project.taskType] = [];
                    taskTypeOrder.push(project.taskType);
                }
                groupedData[project.taskType].push(project);
            });

            const sortMode = sortState.mode || (sortBy ? sortBy.value : 'default');
            const sortDirection = (sortMode && sortMode !== 'default') ? (sortState.direction || SORT_DIRECTIONS.DESC) : SORT_DIRECTIONS.DESC;
            const renderFlatList = hierarchyOrder === 'bottom';

            const compareMetrics = (valueA, valueB) => {
                if (!sortMode || sortMode === 'default') return 0;
                return compareValuesWithDirection(valueA, valueB, sortDirection);
            };

            const getProjectDuration = (project) => {
                if (project?.startDate instanceof Date && project?.endDate instanceof Date && !isNaN(project.startDate) && !isNaN(project.endDate)) {
                    return dateDiffInDays(project.startDate, project.endDate) + 1;
                }
                return 0;
            };

            const getProjectMetricByMode = (project, mode) => getProjectMetricValue(project, mode);

            if (sortMode && sortMode !== 'default' && !renderFlatList) {
                Object.keys(groupedData).forEach(taskType => {
                    groupedData[taskType].sort((p1, p2) => compareMetrics(
                        getProjectMetricByMode(p1, sortMode),
                        getProjectMetricByMode(p2, sortMode)
                    ));
                });
            }

            const groupStats = {};
            Object.keys(groupedData).forEach(taskType => {
                const projects = groupedData[taskType];
                let minStart = null, maxEnd = null, totalDuration = 0, totalPo = 0, weightedProgressSum = 0;
                projects.forEach(p => {
                    if (p.startDate && !isNaN(p.startDate)) {
                        if (minStart === null || p.startDate < minStart) minStart = p.startDate;
                    }
                    if (p.endDate && !isNaN(p.endDate)) {
                        if (maxEnd === null || p.endDate > maxEnd) maxEnd = p.endDate;
                    }
                    const dur = getProjectDuration(p);
                    totalDuration += dur;
                    const po = p.poAmount || 0;
                    totalPo += po;
                    weightedProgressSum += (p.progress || 0) * po;
                });
                const groupProgress = totalPo > 0 ? Math.round(weightedProgressSum / totalPo) : 0;
                groupStats[taskType] = { minStart, maxEnd, totalDuration, totalPo, groupProgress };
            });

            const getGroupSortMetric = (taskType) => {
                const stats = groupStats[taskType] || {};
                switch (sortMode) {
                    case 'startDate':
                        return stats.minStart ? +stats.minStart : null;
                    case 'endDate':
                        return stats.maxEnd ? +stats.maxEnd : null;
                    case 'duration':
                        return stats.totalDuration || 0;
                    case 'progress':
                        return stats.groupProgress || 0;
                    default:
                        return null;
                }
            };

            const getChildSortMetric = (taskType) => {
                const projects = groupedData[taskType];
                if (!projects || projects.length === 0) return null;
                return getProjectMetricByMode(projects[0], sortMode);
            };

            const searchTerm = (searchInput?.value || '');

            const createProjectRowElements = (project) => {
                let displayName = project.name;
                if (searchTerm) {
                    const regex = new RegExp(searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
                    displayName = displayName.replace(regex, match => `<span class="search-highlight">${match}</span>`);
                }

                const completedClass = project.progress === 100 ? 'text-gray-400 line-through' : '';

                const titleItem = document.createElement('div');
                titleItem.className = 'title-item';
                titleItem.dataset.projectId = project.id;
                const projectIndex = projectData.indexOf(project);
                if (projectIndex !== -1) {
                    titleItem.dataset.projectIndex = String(projectIndex);
                }

                const startCurrentYmd = getNormalizedProjectDateString(project, 'startDate');
                const endCurrentYmd = getNormalizedProjectDateString(project, 'endDate');
                const originalStart = getOriginalDateValue(project, 'startDate') || '';
                const originalEnd = getOriginalDateValue(project, 'endDate') || '';
                const isProgressCompleted = Number(project.progress) === 100;
                const startChanged = originalStart && startCurrentYmd && originalStart.trim() !== '' && startCurrentYmd.trim() !== '' && originalStart !== startCurrentYmd;
                const endChanged = originalEnd && endCurrentYmd && originalEnd.trim() !== '' && endCurrentYmd.trim() !== '' && originalEnd !== endCurrentYmd;
                const startSpanClass = `date-editor start-date${startChanged ? ' date-changed' : ''}${isProgressCompleted ? ' date-completed' : ''}`;
                const endSpanClass = `date-editor end-date${endChanged ? ' date-changed' : ''}${isProgressCompleted ? ' date-completed' : ''}`;
                const hasDateChange = startChanged || endChanged;
                const startTitle = startCurrentYmd
                    ? (startChanged ? `í˜„ì¬: ${startCurrentYmd} | ì›ë³¸: ${originalStart}` : `í˜„ì¬: ${startCurrentYmd}`)
                    : (originalStart ? `ì›ë³¸: ${originalStart}` : 'ë‚ ì§œ ì—†ìŒ');
                const endTitle = endCurrentYmd
                    ? (endChanged ? `í˜„ì¬: ${endCurrentYmd} | ì›ë³¸: ${originalEnd}` : `í˜„ì¬: ${endCurrentYmd}`)
                    : (originalEnd ? `ì›ë³¸: ${originalEnd}` : 'ë‚ ì§œ ì—†ìŒ');

                titleItem.innerHTML = `
                    <span class="project-name ${completedClass}" style="display: ${columnVisibility['project-name'] ? '' : 'none'}" title="${escapeAttribute(project.name)}">${displayName}${hasDateChange ? '<span class="change-label">ë³€ê²½</span>' : ''}</span>
                    <div class="flex items-center flex-shrink-0">
                        <span class="project-po ${completedClass}" style="width: var(--po-col-width); display: ${columnVisibility['project-po'] ? '' : 'none'}">${formatCurrency(project.poAmount)}</span>
                        <div class="project-dates ${completedClass}" style="width: var(--dates-col-width); margin: 0; display: ${columnVisibility['project-dates'] ? 'flex' : 'none'}">
                            <span class="${startSpanClass}" data-project-id="${project.id}" ${projectIndex !== -1 ? `data-project-index="${projectIndex}"` : ''} data-date-type="startDate" data-original-date="${escapeAttribute(originalStart)}" data-current-date="${escapeAttribute(startCurrentYmd)}" title="${escapeAttribute(startTitle)}">${formatDate(project.startDate)}</span>
                            <span>~</span>
                            <span class="${endSpanClass}" data-project-id="${project.id}" ${projectIndex !== -1 ? `data-project-index="${projectIndex}"` : ''} data-date-type="endDate" data-original-date="${escapeAttribute(originalEnd)}" data-current-date="${escapeAttribute(endCurrentYmd)}" title="${escapeAttribute(endTitle)}">${formatDate(project.endDate)}</span>
                        </div>
                        <span class="project-progress" style="width: var(--progress-col-width); display: ${columnVisibility['project-progress'] ? '' : 'none'}">
                           <span class="progress-editor" data-project-id="${project.id}">${project.progress || 0}%</span>
                        </span>
                        <div class="project-progress-summary" style="width: var(--progress-summary-col-width); display: ${columnVisibility['project-progress-summary'] ? '' : 'none'}; padding-left:8px;" title="${project.progress || 0}%" aria-label="ì§„í–‰ë¥  ${project.progress || 0}%">
                            <div style="background:#f1f5f9;border-radius:6px;height:8px;overflow:hidden;position:relative;">
                                <div style="background:${getProgressGradient(project.progress || 0)};height:8px;width:${project.progress || 0}%;transition:width:0.3s;box-shadow:0 1px 3px rgba(0,0,0,0.06);"></div>
                            </div>
                        </div>
                    </div>
                `;

                const barRow = document.createElement('div');
                barRow.className = 'gantt-bar-row';
                barRow.dataset.projectId = project.id;

                const duration = dateDiffInDays(project.startDate, project.endDate) + 1;
                const offset = dateDiffInDays(viewMinDate, project.startDate);

                const barWidth = Math.max(1, duration) * DAY_WIDTH - 4;
                const barLeft = offset * DAY_WIDTH;

                const bar = document.createElement('div');
                const barColorClass = statusColors[project.status] || statusColors['default'];
                bar.className = `gantt-bar ${barColorClass}`;
                bar.style.left = `${barLeft}px`;
                bar.dataset.name = project.name;
                bar.dataset.status = project.status;
                bar.style.width = `${barWidth}px`;

                if (project.endDate < today && project.status !== 'ì™„ë£Œ') {
                    bar.style.opacity = '0.7';
                }

                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';

                let customFieldsHTML = '';
                if (project.customFields) {
                    for(const key in project.customFields){
                        if(project.customFields[key]) {
                            customFieldsHTML += `<strong>${key}:</strong> ${project.customFields[key]}<br>`;
                        }
                    }
                }

                tooltip.innerHTML = `<strong>${project.name}</strong><br>
                                   <strong>ì§„í–‰:</strong> ${project.progress || 0}%<br>
                                   <strong>ê¸°ê°„:</strong> ${project.startDate.toLocaleDateString()} ~ ${project.endDate.toLocaleDateString()} (${duration}ì¼)<br>
                                   <strong>ìƒíƒœ:</strong> ${project.status}<br>
                                   <strong>ë¹„ìš©:</strong> ${formatCurrency(project.poAmount || 0)}<br>
                                   ${customFieldsHTML}`;
                bar.appendChild(tooltip);

                const barLabel = document.createElement('div');
                barLabel.className = 'gantt-bar-label';
                barLabel.textContent = `${project.name} [${project.status}]`;
                bar.appendChild(barLabel);

                barRow.appendChild(bar);

                if ((project.progress || 0) > 0) {
                    const progressFill = document.createElement('div');
                    progressFill.className = 'gantt-bar-progress';
                    progressFill.style.left = `${barLeft}px`;
                    progressFill.style.width = `${barWidth * (project.progress / 100)}px`;
                    barRow.appendChild(progressFill);
                }

                return { titleItem, barRow };
            };

            const typesToExpand = new Set();
            if (searchTerm || legendStatusFilter) {
                data.forEach(p => {
                    if (p.taskType) typesToExpand.add(p.taskType);
                });
            }
            
            // ê°œì„  ì‚¬í•­: ê³„ì¸µ ìˆœì„œê°€ 'bottom'ì¼ ë•ŒëŠ” ëª¨ë“  ê·¸ë£¹ì„ ìë™ìœ¼ë¡œ í¼ì¹¨
            if (hierarchyOrder === 'bottom') {
                data.forEach(p => {
                    if (p.taskType) {
                        typesToExpand.add(p.taskType);
                        openTaskGroups.add(p.taskType);
                    }
                });
            }

            if (renderFlatList) {
                const flatTitlesFragment = document.createDocumentFragment();
                const flatBarsFragment = document.createDocumentFragment();
                const chunkSize = 100;
                for (let chunkStart = 0; chunkStart < data.length; chunkStart += chunkSize) {
                    const chunkEnd = Math.min(chunkStart + chunkSize, data.length);
                    for (let i = chunkStart; i < chunkEnd; i++) {
                        const { titleItem, barRow } = createProjectRowElements(data[i]);
                        flatTitlesFragment.appendChild(titleItem);
                        flatBarsFragment.appendChild(barRow);
                    }
                }
                titlesBody.appendChild(flatTitlesFragment);
                ganttRowsBody.appendChild(flatBarsFragment);
            }
            if (!renderFlatList) {
                const groupInitialOpenMap = {};
                Object.keys(groupedData).forEach(taskType => {
                    const shouldForceExpand = hierarchyOrder === 'bottom';
                    groupInitialOpenMap[taskType] = shouldForceExpand
                        ? true
                        : ((searchTerm || legendStatusFilter) ? typesToExpand.has(taskType) : openTaskGroups.has(taskType));
                });

                const sortedTaskTypes = Object.keys(groupedData).sort((a, b) => {
                    if (sortMode === 'default') {
                        return a.localeCompare(b, undefined, { sensitivity: 'base' });
                    }

                    const valueA = groupInitialOpenMap[a] ? getChildSortMetric(a) : getGroupSortMetric(a);
                    const valueB = groupInitialOpenMap[b] ? getChildSortMetric(b) : getGroupSortMetric(b);
                    const comparison = compareMetrics(valueA, valueB);
                    if (comparison !== 0) return comparison;
                    return a.localeCompare(b, undefined, { sensitivity: 'base' });
                });

                sortedTaskTypes.forEach(taskType => {
                    const projects = groupedData[taskType];
                    if (projects.length === 0) return;

                    let groupTotalPo = 0;
                    let groupWeightedProgressSum = 0;
                    projects.forEach(p => {
                        groupWeightedProgressSum += (p.progress || 0) * (p.poAmount || 0);
                        groupTotalPo += (p.poAmount || 0);
                    });
                    const groupProgress = groupTotalPo > 0 ? Math.round(groupWeightedProgressSum / groupTotalPo) : 0;

                    const groupPoSum = projects.reduce((sum, p) => sum + (p.poAmount || 0), 0);
                    const formattedGroupPoSum = formatCurrency(groupPoSum);
                    const groupMinDate = new Date(Math.min(...projects.map(p => p.startDate.getTime())));
                    const groupMaxDate = new Date(Math.max(...projects.map(p => p.endDate.getTime())));

                    const isInitiallyOpen = !!groupInitialOpenMap[taskType];

                    const allProjectsInGroupCompleted = projects.every(p => p.progress === 100);
                    const groupCompletedClass = allProjectsInGroupCompleted ? 'text-gray-400 line-through' : '';

                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'group-header';
                    groupHeader.style.display = 'flex';
                    groupHeader.style.justifyContent = 'space-between';
                    groupHeader.style.alignItems = 'center';
                    groupHeader.dataset.taskType = taskType;
                    groupHeader.innerHTML = `
                        <div class="flex-grow whitespace-nowrap overflow-hidden text-ellipsis pr-2 ${groupCompletedClass}">
                            <span class="group-toggle">${isInitiallyOpen ? '[-]' : '[+]'}</span> ğŸ“‚ ${taskType} (${projects.length}ê±´ / ${formattedGroupPoSum})
                        </div>
                         <div class="flex items-center flex-shrink-0">
                            <div class="project-po justify-end" style="width: var(--po-col-width); display: ${columnVisibility['project-po'] ? '' : 'none'}"></div>
                            <div class="project-dates group-dates-summary justify-center ${groupCompletedClass}" style="width: var(--dates-col-width); margin: 0; display: ${columnVisibility['project-dates'] ? 'flex' : 'none'};">
                                <span class="font-semibold">${formatDate(groupMinDate)}</span>
                                <span class="mx-1">~</span>
                                <span class="font-semibold">${formatDate(groupMaxDate)}</span>
                            </div>
                            <div class="project-progress font-bold text-right pr-2.5 ${groupCompletedClass}" style="width: var(--progress-col-width); display: ${columnVisibility['project-progress'] ? '' : 'none'}">${groupProgress}%</div>
                            <div class="project-progress-summary pr-2" style="width: var(--progress-summary-col-width); display: ${columnVisibility['project-progress-summary'] ? '' : 'none'};" title="${groupProgress}%" aria-label="ê·¸ë£¹ ì§„í–‰ë¥  ${groupProgress}%">
                                <div style="background:#f1f5f9;border-radius:6px;height:10px;overflow:hidden;position:relative;">
                                    <div style="background:${getProgressGradient(groupProgress)};height:10px;width:${groupProgress}%;transition:width:0.3s;box-shadow:0 1px 4px rgba(0,0,0,0.06);"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    const groupBarRow = document.createElement('div');
                    groupBarRow.className = 'gantt-bar-row';
                    ganttRowsBody.appendChild(groupBarRow);

                    const groupDuration = dateDiffInDays(groupMinDate, groupMaxDate) + 1;
                    const groupOffset = dateDiffInDays(viewMinDate, groupMinDate);
                    const groupBar = document.createElement('div');
                    const groupColor = getGroupProgressColor(groupProgress);
                    groupBar.className = 'gantt-bar';
                    if(isInitiallyOpen) groupBar.classList.add('hidden');
                    groupBar.style.backgroundColor = groupColor;
                    groupBar.style.height = '10px';
                    groupBar.style.top = '11px';
                    groupBar.style.left = `${groupOffset * DAY_WIDTH}px`;
                    groupBar.style.width = `${Math.max(1, groupDuration) * DAY_WIDTH - 2}px`;
                    groupBar.style.borderRadius = '2px';
                    groupBar.style.opacity = '1';
                    groupBar.dataset.name = `${taskType} (ìš”ì•½)`;

                    const groupStatuses = new Set(projects.map(p => p.status));
                    let groupStatus = 'ì°©ê³µì „';
                    if (groupStatuses.has('ì§€ì—°')) {
                        groupStatus = 'ì§€ì—°';
                    } else if (groupStatuses.has('ê³µì‚¬ì¤‘')) {
                        groupStatus = 'ê³µì‚¬ì¤‘';
                    } else if (projects.every(p => p.status === 'ì™„ë£Œ')) {
                        groupStatus = 'ì™„ë£Œ';
                    } else if (groupStatuses.has('ì°©ê³µì „')) {
                        groupStatus = 'ì°©ê³µì „';
                    }
                    groupBar.dataset.status = groupStatus;

                    const groupTooltip = document.createElement('div');
                    groupTooltip.className = 'tooltip';
                    groupTooltip.innerHTML = `<strong>${taskType} (ìš”ì•½)</strong><br><strong>ê¸°ê°„:</strong> ${groupMinDate.toLocaleDateString()} ~ ${groupMaxDate.toLocaleDateString()} (${groupDuration}ì¼)<br><strong>ì´ ${projects.length}ê°œ í”„ë¡œì íŠ¸</strong><br><strong>ì´ ë¹„ìš©:</strong> ${formatCurrency(groupPoSum)}`;
                    groupBar.appendChild(groupTooltip);
                    groupBarRow.appendChild(groupBar);

                    const groupBarLabel = document.createElement('div');
                    groupBarLabel.className = 'gantt-bar-label';
                    groupBarLabel.textContent = `${taskType} (ìš”ì•½) [${groupStatus}]`;
                    groupBar.appendChild(groupBarLabel);

                    if (groupProgress > 0) {
                        const groupProgressFill = document.createElement('div');
                        groupProgressFill.className = 'gantt-bar-progress';
                        if (isInitiallyOpen) groupProgressFill.classList.add('hidden');
                        groupProgressFill.style.left = `${groupOffset * DAY_WIDTH}px`;
                        const groupBarWidth = Math.max(1, groupDuration) * DAY_WIDTH - 2;
                        groupProgressFill.style.width = `${groupBarWidth * (groupProgress / 100)}px`;
                        groupProgressFill.style.top = '11px';
                        groupProgressFill.style.zIndex = '8';
                        groupProgressFill.style.height = '10px';
                        groupBarRow.appendChild(groupProgressFill);
                    }

                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'group-item-container';
                    groupContainer.dataset.taskType = taskType;
                    if(!isInitiallyOpen) groupContainer.classList.add('hidden');
                    
                    const childBarRowsContainer = document.createElement('div');
                     if(!isInitiallyOpen) childBarRowsContainer.classList.add('hidden');
                    ganttRowsBody.appendChild(childBarRowsContainer);

                    titlesBody.appendChild(groupHeader);
                    titlesBody.appendChild(groupContainer);

                    const titlesFragment = document.createDocumentFragment();
                    const barsFragment = document.createDocumentFragment();
                    const chunkSize = 100;
                    
                    for (let chunkStart = 0; chunkStart < projects.length; chunkStart += chunkSize) {
                        const chunkEnd = Math.min(chunkStart + chunkSize, projects.length);
                        const chunk = projects.slice(chunkStart, chunkEnd);
                        
                        chunk.forEach(p => {
                            const { titleItem, barRow } = createProjectRowElements(p);
                            titlesFragment.appendChild(titleItem);
                            barsFragment.appendChild(barRow);
                        });
                    }

                    groupContainer.appendChild(titlesFragment);
                    childBarRowsContainer.appendChild(barsFragment);

                    groupHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isNowCollapsed = groupContainer.classList.toggle('hidden');
                        childBarRowsContainer.classList.toggle('hidden', isNowCollapsed);
                        groupBar.classList.toggle('hidden', !isNowCollapsed);

                        const progressFill = groupBarRow.querySelector('.gantt-bar-progress');
                        if(progressFill) {
                            progressFill.classList.toggle('hidden', !isNowCollapsed);
                        }

                        if (isNowCollapsed) {
                            groupHeader.querySelector('.group-toggle').textContent = '[+]';
                            openTaskGroups.delete(taskType);
                        } else {
                            groupHeader.querySelector('.group-toggle').textContent = '[-]';
                            openTaskGroups.add(taskType);
                        }
                        setTimeout(() => {
                            updateLayoutSync();
                            const containerRef = fullscreenModal.classList.contains('hidden') 
                                ? document.getElementById('ganttViewContent') 
                                : fullscreenModalBody;
                            if (containerRef) {
                                applyHierarchyOrder(containerRef);
                            }
                            try {
                                recomputeTodayMarkerHeight(containerRef);
                            } catch (e) {
                                // ignore
                            }
                        }, 300);
                    });
                });
            }

            titlesBodyWrapper.appendChild(titlesBody);
            titlesPane.appendChild(titlesBodyWrapper);

            timelineWrapper.appendChild(timelineHeaderWrapper);
            timelineWrapper.appendChild(timelineBodyWrapper);

            timelineHeaderWrapper.appendChild(timelineHeader);
            timelineBodyWrapper.appendChild(ganttBody);

            ganttEl.appendChild(titlesPane);
            ganttEl.appendChild(timelineWrapper);

            currentGanttContainer.appendChild(ganttEl);

            setTimeout(updateLayoutSync, 0);

            const finalTitlesBodyWrapper = ganttEl.querySelector('.gantt-titles-body-wrapper');
            const finalTimelineHeaderWrapper = ganttEl.querySelector('.gantt-timeline-header-wrapper');
            const finalTimelineBodyWrapper = ganttEl.querySelector('.gantt-timeline-body-wrapper');

             if (finalTimelineBodyWrapper && finalTitlesBodyWrapper && finalTimelineHeaderWrapper) {
                // ê°œì„ ì‚¬í•­ 2: ìŠ¤í¬ë¡¤ ë™ê¸°í™” ë° ì—´ êµ¬ë¶„ì„  ì •ë ¬ ê²€ì¦
                let scrollTimeout;
                finalTimelineBodyWrapper.addEventListener('scroll', () => {
                    hideFloatingTooltip();
                    // ìˆ˜ì§/ìˆ˜í‰ ìŠ¤í¬ë¡¤ ë™ê¸°í™”
                    finalTitlesBodyWrapper.scrollTop = finalTimelineBodyWrapper.scrollTop;
                    finalTimelineHeaderWrapper.scrollLeft = finalTimelineBodyWrapper.scrollLeft;
                    
                    // ìŠ¤í¬ë¡¤ ì¤‘ì—ëŠ” ë§ˆì»¤ íˆ¬ëª…ë„ë¥¼ ë‚®ì¶¤
                    const markers = document.querySelectorAll('.gantt-today-marker-container');
                     markers.forEach(marker => {
                         const line = marker.querySelector('.gantt-today-marker');
                         if (line) line.style.opacity = '0.5';
                         // ë¼ë²¨ì˜ íˆ¬ëª…ë„ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                     });
                    
                    // ìŠ¤í¬ë¡¤ ì™„ë£Œ í›„ ë§ˆì»¤ ì¬ê³„ì‚° ë° íˆ¬ëª…ë„ ë³µì›
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const containerRef = fullscreenModal.classList.contains('hidden') 
                            ? document.getElementById('ganttViewContent') 
                            : fullscreenModalBody;
                        recomputeTodayMarkerHeight(containerRef);
                        
                        // ì—´ êµ¬ë¶„ì„  ì •ë ¬ ìƒíƒœ ê²€ì¦ (ë””ë°”ìš´ìŠ¤ ì ìš©)
                        if (!finalTimelineBodyWrapper.alignmentTimeout) {
                            finalTimelineBodyWrapper.alignmentTimeout = setTimeout(() => {
                                verifyTimelineAlignment();
                                finalTimelineBodyWrapper.alignmentTimeout = null;
                            }, 100);
                        }
                    }, 150); // ìŠ¤í¬ë¡¤ ì™„ë£Œ í›„ ì§€ì—° ì‹œê°„
                });                 // Modify the wheel event listener for the timeline body
                finalTimelineBodyWrapper.addEventListener('wheel', (e) => {
                    // Prevent default only if scrolling horizontally or if the default scroll wouldn't do anything
                    if (e.deltaX !== 0 || (e.deltaY !== 0 && (timelineBodyWrapper.scrollHeight <= timelineBodyWrapper.clientHeight))) {
                       e.preventDefault();
                    }
                    // Always allow vertical scroll propagation if possible
                    finalTimelineBodyWrapper.scrollTop += e.deltaY;
                    finalTimelineBodyWrapper.scrollLeft += e.deltaX; // Allow horizontal scroll with wheel if applicable
                }, { passive: false });


                const scrollbarWidth = finalTimelineBodyWrapper.offsetWidth - finalTimelineBodyWrapper.clientWidth;
                finalTimelineHeaderWrapper.style.paddingRight = `${scrollbarWidth}px`;
            }

            ganttEl.querySelectorAll('.title-item').forEach(titleItem => {
                const projectId = titleItem.dataset.projectId;
                if (!projectId) return;

                const barRow = ganttEl.querySelector(`.gantt-bar-row[data-project-id="${projectId}"]`);
                if (!barRow) return;
                const highlight = () => { titleItem.classList.add('row-hover'); barRow.classList.add('row-hover'); };
                const unhighlight = () => { titleItem.classList.remove('row-hover'); barRow.classList.remove('row-hover'); };
                titleItem.addEventListener('mouseenter', highlight);
                titleItem.addEventListener('mouseleave', unhighlight);
                barRow.addEventListener('mouseenter', highlight);
                barRow.addEventListener('mouseleave', unhighlight);
            });

            // ê°œì„  ì‚¬í•­ 1: ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë”°ë¼ ë¼ë²¨ ìœ„ì¹˜ë¥¼ ë™ì ìœ¼ë¡œ ì¡°ì •í•©ë‹ˆë‹¤.
            ganttEl.addEventListener('mousemove', (e) => {
                const bar = e.target.closest('.gantt-bar');
                if (!bar) return;

                const label = bar.querySelector('.gantt-bar-label');
                if (!label) return;

                // ë°”ì˜ ê²½ê³„ ìƒìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë§ˆìš°ìŠ¤ì˜ X ì¢Œí‘œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
                const barRect = bar.getBoundingClientRect();
                let labelLeft = e.clientX - barRect.left;

                // ë¼ë²¨ì´ ë°”ì˜ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ ìœ„ì¹˜ë¥¼ ì œí•œí•©ë‹ˆë‹¤.
                const labelWidth = label.offsetWidth;
                const barWidth = bar.offsetWidth;

                // ë¼ë²¨ì´ ë°”ì˜ ì˜¤ë¥¸ìª½ ëì„ ë„˜ì–´ê°€ì§€ ì•Šë„ë¡ ì¡°ì •í•©ë‹ˆë‹¤.
                if (labelLeft + labelWidth > barWidth) {
                    labelLeft = barWidth - labelWidth;
                }
                label.style.left = `${Math.max(0, labelLeft)}px`;
            });

            // ê°œì„ ëœ íˆ´íŒ í´ë¦­ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬

            ganttEl.addEventListener('click', (e) => {
                const bar = e.target.closest('.gantt-bar');
                if (!bar) {
                    hideFloatingTooltip();
                    return;
                }

                const tooltip = bar.querySelector('.tooltip');
                if (!tooltip) {
                    hideFloatingTooltip();
                    return;
                }

                if (activeTooltipBar === bar && floatingTooltip?.classList.contains('visible')) {
                    hideFloatingTooltip();
                    return;
                }

                hideFloatingTooltip();
                showFloatingTooltip(bar, tooltip, {
                    pointerX: e.clientX,
                    pointerY: e.clientY,
                });
            });

            const handleBarHoverTooltip = (event) => {
                const bar = event.target.closest('.gantt-bar');
                if (!bar) {
                    hideHoverTooltip();
                    return;
                }

                const tooltip = bar.querySelector('.tooltip');
                if (!tooltip || !hoverTooltip) {
                    hideHoverTooltip();
                    return;
                }

                const simpleText = bar.dataset.name || bar.getAttribute('aria-label') || tooltip.textContent || '';
                if (!simpleText.trim()) {
                    hideHoverTooltip();
                    return;
                }

                hoverTooltip.textContent = simpleText.trim();
                const container = getActiveTimelineContainer();
                const containerRect = container ? container.getBoundingClientRect() : { top: 0 };
                const top = Math.max(4, containerRect.top + 4);
                const tooltipRect = hoverTooltip.getBoundingClientRect();
                let left = event.clientX - tooltipRect.width / 2;
                const margin = 8;
                const maxLeft = window.innerWidth - tooltipRect.width - margin;
                left = Math.max(margin, Math.min(left, maxLeft));
                hoverTooltip.style.top = `${top}px`;
                hoverTooltip.style.left = `${left}px`;
                hoverTooltip.classList.add('visible');
            };

            ganttEl.addEventListener('mousemove', handleBarHoverTooltip);
            ganttEl.addEventListener('mouseleave', () => {
                hideHoverTooltip();
            });

             // Add legend click listeners specifically for the current view
             const currentLegendContainer = container.querySelector('#legendSection');
             if (currentLegendContainer) {
                 currentLegendContainer.querySelectorAll('[data-status-filter]').forEach(item => {
                     item.removeEventListener('click', handleLegendClickEvent); // Remove previous listener
                     item.addEventListener('click', handleLegendClickEvent); // Add new one
                 });
             }
             
             // ê°œì„  ì‚¬í•­: ê³„ì¸µìˆœì„œ ìœ ì§€ - renderGanttChart í•¨ìˆ˜ ëì—ì„œ ê³„ì¸µìˆœì„œ ì ìš©
             // DOMì´ ì™„ì „íˆ ìƒì„±ëœ í›„ ê³„ì¸µìˆœì„œë¥¼ ì ìš©í•˜ì—¬ ì •ë ¬, í•„í„°, ì ‘ê¸°/í¼ì¹˜ê¸° ë“± ì‘ì—… ì‹œì—ë„ ìœ ì§€
             setTimeout(() => {
                 applyHierarchyOrder(container);
             }, 0);
        }

         // Separate event handler function for legend clicks
         function handleLegendClickEvent(e) {
             handleLegendClick(e.currentTarget);
         }


        function updateLayoutSync() {
            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            if (!container) return;

            const titlesBodyWrapper = container.querySelector('.gantt-titles-body-wrapper');
            const titlesBody = titlesBodyWrapper ? titlesBodyWrapper.querySelector('div') : null; // The actual scrolling div
            const timelineBodyWrapper = container.querySelector('.gantt-timeline-body-wrapper');
            const bodyTodayMarker = container.querySelector('.gantt-body > .gantt-today-marker-container');
            const ganttBody = container.querySelector('.gantt-body');

            if (!titlesBody || !timelineBodyWrapper || !ganttBody) return;

            // **ê°œì„  ì‚¬í•­ 1: 'ì˜¤ëŠ˜' ì ì„  ë†’ì´ ë™ì  ì œí•œ**
            if (bodyTodayMarker) {
                recomputeTodayMarkerHeight(container);
            }

            // Sync scrollbar spacer
            const oldSpacer = titlesBody.querySelector('.scrollbar-spacer');
            if (oldSpacer) oldSpacer.remove();

            const scrollbarHeight = timelineBodyWrapper.offsetHeight - timelineBodyWrapper.clientHeight;
            if (scrollbarHeight > 0) {
                const spacer = document.createElement('div');
                spacer.className = 'scrollbar-spacer';
                spacer.style.height = `${scrollbarHeight}px`;
                titlesBody.appendChild(spacer);
            }
            
            // ê°œì„  ì‚¬í•­: ê³„ì¸µ ìˆœì„œ ì ìš© (ë Œë”ë§ í›„ ìµœì¢… ìˆœì„œ ì¡°ì •)
            applyHierarchyOrder(container);
        }

        // í˜„ì¬ ë³´ì´ëŠ” ë§ˆì§€ë§‰ í–‰ì˜ ì •ì¤‘ì•™ê¹Œì§€ë§Œ 'ì˜¤ëŠ˜' ì ì„  í‘œì‹œ
        // ê°œì„ ì‚¬í•­ 2&3: íƒ€ì„ë¼ì¸ ì •ë ¬ ê²€ì¦ ë° ì²˜ë¦¬ í•¨ìˆ˜
        function verifyTimelineAlignment() {
            const timelineHeader = document.querySelector('.gantt-timeline-header');
            const ganttBody = document.querySelector('.gantt-body');
            if (!timelineHeader || !ganttBody) return;

            const headerGridLines = Array.from(timelineHeader.querySelectorAll('.gantt-day')).map(day => {
                const rect = day.getBoundingClientRect();
                return Math.round(rect.left);
            });
            
            const bodyGridLines = Array.from(ganttBody.querySelectorAll('.gantt-grid-line')).map(line => {
                const rect = line.getBoundingClientRect();
                return Math.round(rect.left);
            });

            const threshold = 1; // 1í”½ì…€ ì´ë‚´ì˜ ì˜¤ì°¨ëŠ” í—ˆìš©
            const isAligned = headerGridLines.every((headerPos, index) => {
                const bodyPos = bodyGridLines[index];
                return Math.abs(headerPos - bodyPos) <= threshold;
            });

            if (!isAligned) {
                showTimelineAlignmentWarning();
            }
        }

        function showTimelineAlignmentWarning() {
            const zoomBtn = document.getElementById('zoomBtn');
            if (!zoomBtn) return;

            const warningClass = 'bg-yellow-200';
            if (!zoomBtn.classList.contains(warningClass)) {
                zoomBtn.classList.add(warningClass);
                showToast('ë‚ ì§œ ì„¤ì •ì„ ì´ˆê¸°í™”í•˜ì—¬ ì—´ êµ¬ë¶„ì„ ì„ ì •ë ¬í•´ì£¼ì„¸ìš”.', 'warning');
                
                // **ê°œì„  ì‚¬í•­ 1 ìˆ˜ì •: ìë™ìœ¼ë¡œ ë‚ ì§œ ì„¤ì • ëª¨ë‹¬ í‘œì‹œ ì œê±° - ì‚¬ìš©ìê°€ 'ë‚ ì§œ ì„¤ì •' ë²„íŠ¼ì„ í´ë¦­í•  ë•Œë§Œ ëª¨ë‹¬ì´ ì—´ë¦¬ë„ë¡ ë³€ê²½**
                // ëª¨ë‹¬ì€ ì‚¬ìš©ìê°€ ì§ì ‘ 'ë‚ ì§œ ì„¤ì •' ë²„íŠ¼ì„ í´ë¦­í•  ë•Œë§Œ ì—´ë¦¬ë„ë¡ í•¨
            }
        }

        function recomputeTodayMarkerHeight(container) {
            const wrapper = container.querySelector('.gantt-timeline-body-wrapper');
            const ganttBody = container.querySelector('.gantt-body');
            const marker = container.querySelector('.gantt-body > .gantt-today-marker-container');
            if (!wrapper || !ganttBody || !marker) return;
        
            const markerLine = marker.querySelector('.gantt-today-marker');
        
            // ëª¨ë“  ì‘ì—… í•­ëª©(í¼ì³ì§„ ê²ƒê³¼ ì ‘íŒ ê²ƒ ëª¨ë‘)ì„ ê°€ì ¸ì˜´
            const allItems = Array.from(ganttBody.querySelectorAll('.gantt-bar-row'));
            const visibleItems = allItems.filter(item => {
                // í–‰ì´ ë³´ì´ë ¤ë©´, í•´ë‹¹ ìš”ì†Œì™€ ê·¸ ëª¨ë“  ë¶€ëª¨ ìš”ì†Œë“¤ì´ 'hidden' í´ë˜ìŠ¤ë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤.
                let el = item;
                while(el && el !== ganttBody) {
                    if (el.classList.contains('hidden')) return false;
                    el = el.parentElement;
                }
                return true;
            });
            
            // ê³„ì¸µ êµ¬ì¡°ë¥¼ ê³ ë ¤í•˜ì—¬ ë§ˆì§€ë§‰ í‘œì‹œ í•­ëª©ì„ ì°¾ìŒ
            const lastVisibleItem = visibleItems[visibleItems.length - 1];
        
            if (lastVisibleItem) {
                const ganttBodyRect = ganttBody.getBoundingClientRect();
                const lastItemRect = lastVisibleItem.getBoundingClientRect();
                
                // ë§ˆì§€ë§‰ìœ¼ë¡œ ë³´ì´ëŠ” í•­ëª©ì˜ ì¤‘ê°„ ì§€ì ê¹Œì§€ì˜ ë†’ì´ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
                const heightToMiddle = (lastItemRect.top - ganttBodyRect.top) + (lastItemRect.height / 2);
                marker.style.height = `${heightToMiddle}px`;
            }

            // ìŠ¤í¬ë¡¤ ì‹œ ë§ˆì»¤ì˜ ê°€ì‹œì„± í™•ì¸
            const todayOffset = parseInt(marker.style.left);
            const scrollLeft = wrapper.scrollLeft;
            const clientWidth = wrapper.clientWidth;
        
            // ê°€ì‹œ ì˜ì—­ì— ìˆëŠ”ì§€ í™•ì¸í•˜ê³  íˆ¬ëª…ë„ ì¡°ì •
            if (todayOffset >= scrollLeft && todayOffset <= scrollLeft + clientWidth) {
                marker.style.opacity = '1';
                if (markerLine) markerLine.style.opacity = '1';
            } else {
                // í™”ë©´ ë°–ì— ìˆì„ ë•ŒëŠ” ì•½ê°„ íˆ¬ëª…í•˜ê²Œ ì²˜ë¦¬
                if (markerLine) markerLine.style.opacity = '0.5';
            }
        }

        // Make a table sortable by clicking on headers. Adds small â–²/â–¼ indicators.
        function makeTableSortable(table) {
            if (!table) return;
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            if (!thead || !tbody) return;

            const ths = Array.from(thead.querySelectorAll('th'));
            ths.forEach((th, colIndex) => {
                // add sort indicator
                let indicator = th.querySelector('.sort-indicator');
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'sort-indicator ml-2 text-xs';
                    indicator.style.cursor = 'pointer';
                    th.appendChild(indicator);
                }

                th.style.userSelect = 'none';
                th.addEventListener('click', () => {
                    const currentDir = th.dataset.sortDir || 'none';
                    const newDir = currentDir === 'asc' ? 'desc' : 'asc';
                    // reset all
                    ths.forEach(t => { t.dataset.sortDir = ''; const si = t.querySelector('.sort-indicator'); if (si) si.textContent = ''; });
                    th.dataset.sortDir = newDir;
                    indicator.textContent = newDir === 'asc' ? 'â–²' : 'â–¼';

                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const cellValues = rows.map(r => {
                        const cell = r.children[colIndex];
                        return cell ? cell.textContent.trim() : '';
                    });

                    // detect numeric or date
                    const isNumeric = cellValues.every(v => v === '' || /^[-+]?\d{1,3}(?:[,\d]{0,}|\d*)(?:\.\d+)?(?:%|ì›)?$/.test(v.replace(/\s/g,'')));
                    const isDate = cellValues.every(v => parseLocalDateString(v) instanceof Date && !isNaN(parseLocalDateString(v)?.getTime()));

                    rows.sort((a, b) => {
                        const va = a.children[colIndex] ? a.children[colIndex].textContent.trim() : '';
                        const vb = b.children[colIndex] ? b.children[colIndex].textContent.trim() : '';
                        let resa = va, resb = vb;
                        if (isNumeric) {
                            const numA = parseFloat(va.replace(/[,%ì›\s]/g, '')) || 0;
                            const numB = parseFloat(vb.replace(/[,%ì›\s]/g, '')) || 0;
                            resa = numA; resb = numB;
                        } else if (isDate) {
                            const da = parseLocalDateString(va); const db = parseLocalDateString(vb);
                            resa = da ? +da : 0; resb = db ? +db : 0;
                        } else {
                            resa = va.toLowerCase(); resb = vb.toLowerCase();
                        }

                        if (resa < resb) return newDir === 'asc' ? -1 : 1;
                        if (resa > resb) return newDir === 'asc' ? 1 : -1;
                        return 0;
                    });

                    // Re-attach rows in sorted order
                    rows.forEach(r => tbody.appendChild(r));
                });
            });
        }

        function exportTableToXLSX(tableElement, filename = 'export.xlsx') {
            if (!tableElement) return;
            try {
                // Use direct table->sheet conversion
                const ws = XLSX.utils.table_to_sheet(tableElement);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
                XLSX.writeFile(wb, filename);
            } catch (e) {
                console.error('exportTableToXLSX error', e);
                showToast('í…Œì´ë¸”ì„ ì—‘ì…€ë¡œ ë‚´ë³´ë‚´ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
            }
        }


        function makeResizable(modalContentElement) {
            const resizers = modalContentElement.querySelectorAll('.resizer-handle');
            let original_width = 0, original_height = 0, original_x = 0, original_y = 0, original_mouse_x = 0, original_mouse_y = 0;

            resizers.forEach(resizer => {
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const rect = modalContentElement.getBoundingClientRect();
                    original_width = rect.width;
                    original_height = rect.height;
                    original_x = rect.left;
                    original_y = rect.top;
                    original_mouse_x = e.pageX;
                    original_mouse_y = e.pageY;
                    const direction = resizer.dataset.direction;

                    const overlay = modalContentElement.parentElement;
                    if (overlay.style.justifyContent !== 'flex-start') {
                        overlay.style.justifyContent = 'flex-start';
                        overlay.style.alignItems = 'flex-start';
                        modalContentElement.style.left = `${rect.left}px`;
                        modalContentElement.style.top = `${rect.top}px`;
                        modalContentElement.style.margin = '0';
                    }

                    function resize(e) {
                        if (direction.includes('e')) {
                            const width = original_width + (e.pageX - original_mouse_x);
                            if (width >= 500) modalContentElement.style.width = width + 'px';
                        }
                        if (direction.includes('s')) {
                             const height = original_height + (e.pageY - original_mouse_y);
                             if (height >= 400) modalContentElement.style.height = height + 'px';
                        }
                         if (direction.includes('w')) {
                            const width = original_width - (e.pageX - original_mouse_x);
                            if (width >= 500) {
                                modalContentElement.style.width = width + 'px';
                                modalContentElement.style.left = original_x + (e.pageX - original_mouse_x) + 'px';
                            }
                        }
                        if (direction.includes('n')) {
                            const height = original_height - (e.pageY - original_mouse_y);
                            if (height > 300) {
                                modalContentElement.style.height = height + 'px';
                                modalContentElement.style.top = original_y + (e.pageY - original_mouse_y) + 'px';
                            }
                        }
                    }

                    function stopResize() {
                        window.removeEventListener('mousemove', resize);
                        window.removeEventListener('mouseup', stopResize);
                    }
                    window.addEventListener('mousemove', resize);
                    window.addEventListener('mouseup', stopResize);
                });
            });
        }

        function makeDraggable(modalContent, handle) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

            handle.style.cursor = 'move';
            handle.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;

                const overlay = modalContent.parentElement;
                if (overlay.style.justifyContent !== 'flex-start') {
                    const rect = modalContent.getBoundingClientRect();
                    overlay.style.justifyContent = 'flex-start';
                    overlay.style.alignItems = 'flex-start';
                    modalContent.style.left = `${rect.left}px`;
                    modalContent.style.top = `${rect.top}px`;
                    modalContent.style.margin = '0';
                }

                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                modalContent.style.top = (modalContent.offsetTop - pos2) + "px";
                modalContent.style.left = (modalContent.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        makeResizable(fullscreenModalContent);
        makeResizable(dataDetailModal.querySelector('.modal-content'));
        if (zoomModalContent) {
            makeResizable(zoomModalContent);
        }

        const dataDetailModalContent = dataDetailModal.querySelector('.modal-content');
        makeDraggable(dataDetailModalContent, dataDetailModalContent.querySelector('.resizable-modal-header'));
        makeDraggable(fullscreenModalContent, fullscreenModalContent.querySelector('.resizable-modal-header'));
        if (zoomModalContent) {
            makeDraggable(zoomModalContent, zoomModalContent.querySelector('.resizable-modal-header'));
        }

        // Make milestone modal resizable & draggable
        const milestoneModalContent = milestoneModal.querySelector('.modal-content');
        if (milestoneModalContent) {
            makeResizable(milestoneModalContent);
            const milestoneHeader = milestoneModalContent.querySelector('.resizable-modal-header');
            if (milestoneHeader) makeDraggable(milestoneModalContent, milestoneHeader);
        }

        function downloadTemplate(format) {
            const templateData = [
                {
                    'No': '1', 'ID': 'A-001', 'ì‘ì—… ìœ í˜•': 'ê³µí†µ', 'ê³ ê°ì‚¬': 'ê³ ê°ì‚¬ A', 'ëª…ì¹­': 'í”„ë¡œì íŠ¸ ì˜ˆì‹œ 1', 'ë°œì£¼ ìœ í˜•': 'ì¼ë°˜', 'ìƒíƒœ': 'ì°©ê³µì „', 'ì‹œì‘ì¼': '2025-01-01', 'ì¢…ë£Œì¼': '2025-01-31', 'ì •ì‚°': '50000000', 'ì§„í–‰ë¥ ': '0'
                },
                {
                    'No': '2', 'ID': 'B-002', 'ì‘ì—… ìœ í˜•': 'ê±´ì¶•', 'ê³ ê°ì‚¬': 'ê³ ê°ì‚¬ B', 'ëª…ì¹­': 'í”„ë¡œì íŠ¸ ì˜ˆì‹œ 2', 'ë°œì£¼ ìœ í˜•': 'ê¸´ê¸‰', 'ìƒíƒœ': 'ê³µì‚¬ì¤‘', 'ì‹œì‘ì¼': '2025-02-15', 'ì¢…ë£Œì¼': '2025-03-20', 'ì •ì‚°': '120000000', 'ì§„í–‰ë¥ ': '50'
                }
            ];
            const wsData = [
                ["[ë°ì´í„° ì–‘ì‹ ì„¤ëª…]"],
                ["No", "ID", "ì‘ì—… ìœ í˜•", "ê³ ê°ì‚¬", "ëª…ì¹­", "ë°œì£¼ ìœ í˜•", "ìƒíƒœ", "ì‹œì‘ì¼", "ì¢…ë£Œì¼", "ì •ì‚°", "ì§„í–‰ë¥ "],
                ["(ìˆ«ì)", "(ë¬¸ì, ê³ ìœ ê°’)", "(ë¬¸ì)", "(ë¬¸ì, í•„ìˆ˜)", "(ë¬¸ì, í•„ìˆ˜)", "(ì¼ë°˜/ê¸´ê¸‰)", "(ì°©ê³µì „/ê³µì‚¬ì¤‘/ì™„ë£Œ/ì§€ì—°)", "(YYYY-MM-DD, í•„ìˆ˜)", "(YYYY-MM-DD, í•„ìˆ˜)", "(ìˆ«ì, ì½¤ë§ˆ ì œì™¸)", "(0-100)"],
                ["", "", "", "", "", "", "â€» ìƒíƒœ ìë™ ê³„ì‚°:", "", "", "", ""],
                ["", "", "", "", "", "", "- ì°©ê³µì „: ì§„í–‰ë¥  0% ì´ê³  ì¢…ë£Œì¼ì´ ì˜¤ëŠ˜ ì´í›„", "", "", "", ""],
                ["", "", "", "", "", "", "- ê³µì‚¬ì¤‘: ì§„í–‰ë¥  1~99% ì´ê³  ì¢…ë£Œì¼ì´ ì˜¤ëŠ˜ ì´í›„", "", "", "", ""],
                ["", "", "", "", "", "", "- ì™„ë£Œ: ì§„í–‰ë¥  100%", "", "", "", ""],
                ["", "", "", "", "", "", "- ì§€ì—°: ì§„í–‰ë¥  100% ë¯¸ë§Œì´ê³  ì¢…ë£Œì¼ì´ ì˜¤ëŠ˜ ì´ì „", "", "", "", ""],
                ["", "", "", "", "ğŸ’¡ ì €ì¥ ì‹œ:", "", "", "", "", "", ""],
                ["", "", "", "", "- ëª¨ë“  ë°ì´í„°ì™€ ì„¤ì •ì´ ì €ì¥ë¨", "", "", "", "", "", ""],
                ["", "", "", "", "- ë‚˜ì¤‘ì— ì´ì–´ì„œ ì‘ì—… ê°€ëŠ¥", "", "", "", "", "", ""],
            ];
            wsData[1].push('ì§„í–‰ë¥ ');
            wsData[2].push('(ìˆ«ì ë˜ëŠ” %)');
            const sheet = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.sheet_add_json(sheet, templateData, { origin: "A4", skipHeader: true });

            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, sheet, "Project Data");

            // Add milestone sample sheet for XLSX
            const milestoneSample = [
                ['No', 'ë§ˆì¼ìŠ¤í†¤', 'ë‚ ì§œ'],
                [1, 'í”„ë¡œì íŠ¸ í‚¥ì˜¤í”„', '2025-01-15']
            ];
            const msSheet = XLSX.utils.aoa_to_sheet(milestoneSample);

            if (format === 'xlsx') {
                XLSX.utils.book_append_sheet(workbook, msSheet, 'ë§ˆì¼ìŠ¤í†¤');
                const fileName = `gantt_template.${format}`;
                XLSX.writeFile(workbook, fileName);
                showToast(`"${fileName}" ì–‘ì‹ íŒŒì¼ ë‹¤ìš´ë¡œë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.`, 'info');
            } else if (format === 'csv') {
                // For CSV, generate two separate CSV files: projects template and milestone template
                const projectsCsv = XLSX.utils.sheet_to_csv(sheet);
                const milestoneCsv = XLSX.utils.sheet_to_csv(msSheet);

                // helper to download plain text as file
                const downloadText = (content, name) => {
                    // Prepend UTF-8 BOM to help Excel on Windows recognize UTF-8 encoding
                    const bomPrefixed = '\uFEFF' + content;
                    const blob = new Blob([bomPrefixed], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };

                const dateSuffix = new Date().toISOString().slice(0,10);
                downloadText(projectsCsv, `gantt_template_projects_${dateSuffix}.csv`);
                // small delay to ensure browser processing of consecutive downloads
                setTimeout(() => {
                    downloadText(milestoneCsv, `gantt_template_milestones_${dateSuffix}.csv`);
                }, 150);
                showToast('CSV ì–‘ì‹ íŒŒì¼(í”„ë¡œì íŠ¸, ë§ˆì¼ìŠ¤í†¤) ë‹¤ìš´ë¡œë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.', 'info');
            } else {
                const fileName = `gantt_template.${format}`;
                XLSX.writeFile(workbook, fileName);
                showToast(`"${fileName}" ì–‘ì‹ íŒŒì¼ ë‹¤ìš´ë¡œë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.`, 'info');
            }
        }

        /**
         * [IMPROVED FUNCTION] í˜„ì¬ ëŒ€ì‹œë³´ë“œ ìƒíƒœë¥¼ ìƒˆë¡œìš´ ë…ë¦½ ì‹¤í–‰í˜• HTML íŒŒì¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.
         * ì´ í•¨ìˆ˜ëŠ” ëª¨ë“  ì €ì¥ ê´€ë ¨ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ í•µì‹¬ ìˆ˜ì • ì‚¬í•­ì…ë‹ˆë‹¤.
         * @returns {void}
         */
        function saveAsStandaloneHTML() {
            // [ê°œì„  ì‚¬í•­ 1] ì €ì¥ ì „ ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
            if (projectData.length === 0 && milestones.length === 0) {
                showToast("ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.", 'warning');
                return;
            }

            // [ê°œì„  ì‚¬í•­ 2] í•„ìˆ˜ ë°ì´í„° í•„ë“œ ê²€ì¦
            const invalidProjects = projectData.filter(p => {
                return !p.name || !p.startDate || !p.endDate || 
                       typeof p.progress === 'undefined' || p.progress === null ||
                       !p.id || !p.taskType;
            });

            if (invalidProjects.length > 0) {
                const message = `ë°ì´í„° ì •í•©ì„± ë¬¸ì œ ë°œê²¬: ${invalidProjects.length}ê°œ í•­ëª©ì— í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                showToast(message, 'error');
                console.error('Invalid projects:', invalidProjects);
                return;
            }

            // [ê°œì„  ì‚¬í•­ 3] ë‚ ì§œ ë°ì´í„° ê²€ì¦
            const dateErrors = projectData.filter(p => {
                const start = p.startDate instanceof Date ? p.startDate : new Date(p.startDate);
                const end = p.endDate instanceof Date ? p.endDate : new Date(p.endDate);
                return isNaN(start.getTime()) || isNaN(end.getTime()) || start > end;
            });

            if (dateErrors.length > 0) {
                const message = `ë‚ ì§œ ë°ì´í„° ì˜¤ë¥˜: ${dateErrors.length}ê°œ í•­ëª©ì— ì˜ëª»ëœ ë‚ ì§œê°€ ìˆìŠµë‹ˆë‹¤.`;
                showToast(message, 'error');
                console.error('Date errors:', dateErrors);
                return;
            }

            // [FIX] DOM ì¡°ì‘ ì „ì— ë°ì´í„°ë¥¼ ì§ë ¬í™”í•˜ì—¬ ê¹¨ë—í•œ ìƒíƒœë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.
            // ë‚ ì§œëŠ” ì•ˆì •ì ì¸ ì§ë ¬í™”ë¥¼ ìœ„í•´ ISO ë¬¸ìì—´ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.
            const toYMD = (d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            const dataToEmbed = projectData.map(p => {
                // [FIX] ë‚ ì§œê°€ ìœ íš¨í•œì§€ í™•ì¸ í›„ ë³€í™˜í•©ë‹ˆë‹¤. ë°˜ë“œì‹œ ë¡œì»¬ ê¸°ì¤€ YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.
                const startDateStr = (p.startDate instanceof Date && !isNaN(p.startDate)) ? toYMD(p.startDate) : (p.startDateStr || '');
                const endDateStr = (p.endDate instanceof Date && !isNaN(p.endDate)) ? toYMD(p.endDate) : (p.endDateStr || '');
                return {
                    ...p,
                    startDate: startDateStr,
                    endDate: endDateStr,
                };
            });

            const customFiltersState = {};
            document.querySelectorAll('#controlsPanel #customFilterContainer select').forEach(sel => {
                // 'customer-filter'ì˜ ê²½ìš° í•­ìƒ 'ê³ ê°ì‚¬'ë¡œ ì €ì¥ (ì´ˆê¸°ê°’ ìœ ì§€)
                if (sel.id === 'customer-filter' && sel.querySelector('option[value="ê³ ê°ì‚¬"]')) {
                    customFiltersState[sel.dataset.filterKey] = 'ê³ ê°ì‚¬';
                } else {
                    customFiltersState[sel.dataset.filterKey] = sel.value;
                }
            });
            
            // ë°”ë¡œê°€ê¸° ì„¤ì • ì €ì¥
            const pinnedShortcutsArray = Array.from(pinnedShortcuts);

            const currentTitlesPane = document.querySelector('.gantt-titles');
            const settlementOpenFields = Array.from(document.querySelectorAll('.main-settlement-accordion-item')).map(el => {
                const hdr = el.querySelector('.main-settlement-header h3');
                // Remove the visual bullet prefix 'â–  ' if present to get the field name
                const text = hdr ? hdr.textContent.replace(/^â– \s*/, '').trim() : null;
                return el.classList.contains('expanded') && text ? text : null;
            }).filter(Boolean);

            // [ê°œì„  ì‚¬í•­ 2] ì €ì¥ ì‹œ ëª¨ë“  UI ìƒíƒœì™€ ì„¤ì •ì„ í¬í•¨í•˜ë„ë¡ ê°œì„ 
            const settings = { 
                openTaskGroups: Array.from(openTaskGroups),
                columnVisibility: columnVisibility,
                filters: {
                    progress: progressFilter ? progressFilter.value : 'all',
                    taskType: taskTypeFilter ? taskTypeFilter.value : 'all',
                    sort: sortBy ? sortBy.value : 'default',
                    sortDirection: sortState.direction || SORT_DIRECTIONS.DESC,
                    showOnlyChanged: showOnlyChanged,
                    search: searchInput ? searchInput.value : '',
                    customFilters: customFiltersState,
                },
                legendStatusFilter: legendStatusFilter,
                titlesPaneWidth: currentTitlesPane ? currentTitlesPane.style.width : null,
                columnWidths: currentTitlesPane ? {
                    po: getComputedStyle(currentTitlesPane).getPropertyValue('--po-col-width'),
                    dates: getComputedStyle(currentTitlesPane).getPropertyValue('--dates-col-width'),
                    progress: getComputedStyle(currentTitlesPane).getPropertyValue('--progress-col-width'),
                    progressSummary: getComputedStyle(currentTitlesPane).getPropertyValue('--progress-summary-col-width')
                } : null,
                viewMinDate: viewMinDate ? toYMD(viewMinDate) : null,
                viewMaxDate: viewMaxDate ? toYMD(viewMaxDate) : null,
                pinnedShortcuts: Array.from(pinnedShortcuts),
                controlsPanelOpen: !controlsPanel.classList.contains('translate-x-full'),
                controlSections: Array.from(document.querySelectorAll('#controlsPanel .control-section-header')).map(header => ({
                    id: header.id || header.querySelector('h3').textContent.trim(),
                    isOpen: header.classList.contains('open')
                })),
                timelineScrollLeft: document.querySelector('.gantt-timeline-body-wrapper')?.scrollLeft || 0,
                timelineScrollTop: document.querySelector('.gantt-timeline-body-wrapper')?.scrollTop || 0
                , // ì •ì‚° ì•„ì½”ë””ì–¸ ìƒíƒœ ì €ì¥
                hierarchyOrder: hierarchyOrder, // ê°œì„  ì‚¬í•­: ê³„ì¸µ ìˆœì„œ ì €ì¥
                // **ê°œì„  ì‚¬í•­ 2**: í˜„ì¬ ì—´ë ¤ìˆëŠ” íˆ´íŒ ì •ë³´ ì €ì¥
                activeTooltip: (() => {
                    if (!floatingTooltip || !floatingTooltip.classList.contains('visible') || !activeTooltipBar) return null;
                    return {
                        projectId: activeTooltipBar.closest('.gantt-bar-row')?.dataset.projectId || null,
                        content: floatingTooltip.innerHTML
                    };
                })(),

                settlementOpenFields: settlementOpenFields,
                autoUploadUrl: (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL,
                autoUploadEnabled: !!(autoUploadEnabled && autoUploadEnabled.checked)
            };

            // Milestone modal state (position/size and open state)
            try {
                const mmOverlay = document.getElementById('milestoneModal');
                const mmContent = mmOverlay ? mmOverlay.querySelector('.modal-content') : null;
                settings.milestoneModalOpen = mmOverlay ? !mmOverlay.classList.contains('hidden') : false;
                if (mmContent) {
                    // Capture inline style values if present (left/top/width/height)
                    settings.milestoneModalStyle = {
                        left: mmContent.style.left || null,
                        top: mmContent.style.top || null,
                        width: mmContent.style.width || null,
                        height: mmContent.style.height || null,
                        overlayJustify: mmOverlay ? mmOverlay.style.justifyContent || null : null,
                        overlayAlign: mmOverlay ? mmOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.milestoneModalStyle = null;
                }
            } catch (e) {
                console.warn('milestone modal state capture failed', e);
            }

            // Data Detail modal state
            try {
                const ddOverlay = document.getElementById('dataDetailModal');
                const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                settings.dataDetailModalOpen = ddOverlay ? !ddOverlay.classList.contains('hidden') : false;
                if (ddContent) {
                    settings.dataDetailModalStyle = {
                        left: ddContent.style.left || null,
                        top: ddContent.style.top || null,
                        width: ddContent.style.width || null,
                        height: ddContent.style.height || null,
                        overlayJustify: ddOverlay ? ddOverlay.style.justifyContent || null : null,
                        overlayAlign: ddOverlay ? ddOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.dataDetailModalStyle = null;
                }
            } catch (e) {
                console.warn('data detail modal state capture failed', e);
            }

            // Data Detail modal state
            try {
                const ddOverlay = document.getElementById('dataDetailModal');
                const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                settings.dataDetailModalOpen = ddOverlay ? !ddOverlay.classList.contains('hidden') : false;
                if (ddContent) {
                    settings.dataDetailModalStyle = {
                        left: ddContent.style.left || null,
                        top: ddContent.style.top || null,
                        width: ddContent.style.width || null,
                        height: ddContent.style.height || null,
                        overlayJustify: ddOverlay ? ddOverlay.style.justifyContent || null : null,
                        overlayAlign: ddOverlay ? ddOverlay.style.alignItems || null : null
                    };
                } else {
                    settings.dataDetailModalStyle = null;
                }
            } catch (e) {
                console.warn('data detail modal state capture failed', e);
            }

            // ê°•ë ¥í•œ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìµœì¢… HTML ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
            const htmlContent = generateStandaloneHTML(dataToEmbed, milestones, settings);

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gantt_dashboard_${new Date().toISOString().slice(0,10)}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast("HTML íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.", 'success');
        }

        /**
         * [NEW & IMPROVED] ì €ì¥ì„ ìœ„í•œ ìµœì¢… HTML ì½˜í…ì¸  ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
         * ì´ í•¨ìˆ˜ëŠ” ë‹¤ì¤‘ ì €ì¥ ë¬¸ì œ í•´ê²°ì˜ í•µì‹¬ì…ë‹ˆë‹¤. ë¬¸ì„œì˜ ë¬¸ìì—´ í‘œí˜„ì— ëŒ€í•´ ì‘ë™í•˜ì—¬
         * ëŸ°íƒ€ì„ ì•„í‹°íŒ©íŠ¸ê°€ ì €ì¥ëœ íŒŒì¼ì„ ì†ìƒì‹œí‚¤ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
         * @param {Array} data - í¬í•¨í•  í”„ë¡œì íŠ¸ ë°ì´í„°.
         * @param {Array} milestonesToEmbed - í¬í•¨í•  ë§ˆì¼ìŠ¤í†¤ ë°ì´í„°.
         * @param {Object} settings - í¬í•¨í•  UI/ìƒíƒœ ì„¤ì •.
         * @returns {string} ë…ë¦½ ì‹¤í–‰í˜• íŒŒì¼ì„ ìœ„í•œ ì „ì²´ HTML.
         */
        function generateStandaloneHTML(data, milestonesToEmbed, settings) {
            // 1. ì „ì²´ ë¬¸ì„œì˜ HTMLì„ ë¬¸ìì—´ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤.
            let html = document.documentElement.outerHTML;

            // 2. [FIX] ì¤‘ìš” ìˆ˜ì •: ìƒˆ ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ê¸° ì „ì— ì´ì „ ì €ì¥ì—ì„œ ì¡´ì¬í•  ìˆ˜ ìˆëŠ”
            // ëª¨ë“  ë°ì´í„° ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì œê±°í•©ë‹ˆë‹¤. ì´ëŠ” ë°ì´í„° ì¤‘ë³µ ë° ì†ìƒì„ ë°©ì§€í•©ë‹ˆë‹¤.
            // ì •ê·œì‹ì„ ì‚¬ìš©í•˜ì—¬ ì´ì „ ìŠ¤í¬ë¦½íŠ¸ ë¸”ë¡ì„ ì°¾ì•„ ì œê±°í•©ë‹ˆë‹¤.
            html = html.replace(/<script>window\.embeddedData\s*=\s*[\s\S]*?;<\/script>/, '');
            html = html.replace(/<script>window\.embeddedMilestones\s*=\s*[\s\S]*?;<\/script>/, '');
            html = html.replace(/<script>window\.embeddedSettings\s*=\s*[\s\S]*?;<\/script>/, '');
            html = html.replace(/<script>window\.isStandalone\s*=\s*true;<\/script>/, '');

            // 3. ì£¼ì…í•  ìƒˆ ë°ì´í„°ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.
            const dataScript = `<script>window.embeddedData = ${JSON.stringify(data, null, 2)};<\/script>`;
            const milestonesScript = `<script>window.embeddedMilestones = ${JSON.stringify(milestonesToEmbed, null, 2)};<\/script>`;
            const settingsScript = `<script>window.embeddedSettings = ${JSON.stringify(settings, null, 2)};<\/script>`;
            const standaloneMarkerScript = `<script>window.isStandalone = true;<\/script>`;

            // 4. HTML ë¬¸ìì—´ì˜ í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ìƒˆ ë°ì´í„° ìŠ¤í¬ë¦½íŠ¸ë¡œ êµì²´í•©ë‹ˆë‹¤.
            // ì´ëŠ” ë§¤ë²ˆ ê¹¨ë—í•˜ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì£¼ì…ì„ ë³´ì¥í•©ë‹ˆë‹¤.
            html = html.replace('<!-- EMBEDDED_DATA_PLACEHOLDER -->', dataScript);
            html = html.replace('<!-- EMBEDDED_MILESTONES_PLACEHOLDER -->', milestonesScript);
            html = html.replace('<!-- EMBEDDED_SETTINGS_PLACEHOLDER -->', settingsScript + standaloneMarkerScript);

            return `<!DOCTYPE html>\n` + html; // [FIX] Doctypeì„ ëª…ì‹œì ìœ¼ë¡œ ì¶”ê°€í•©ë‹ˆë‹¤.
        }

        function renderMilestoneModal() {
            milestoneList.innerHTML = '';
            
            // ì €ì¥ëœ ëª¨ë‹¬ ìƒíƒœ ë³µì›
            const modalContent = milestoneModal.querySelector('.modal-content');
            if (modalContent) {
                if (savedSettings && savedSettings.milestoneModalStyle) {
                    const s = savedSettings.milestoneModalStyle;
                    if (s.width) modalContent.style.width = s.width;
                    if (s.height) modalContent.style.height = s.height;
                    if (s.left) modalContent.style.left = s.left;
                    if (s.top) modalContent.style.top = s.top;
                    if (s.overlayJustify) milestoneModal.style.justifyContent = s.overlayJustify;
                    if (s.overlayAlign) milestoneModal.style.alignItems = s.overlayAlign;
                } else {
                    // ì €ì¥ëœ ì„¤ì •ì´ ì—†ì„ ë•ŒëŠ” í™”ë©´ ì¤‘ì•™ì— ë°°ì¹˜
                    milestoneModal.style.justifyContent = 'center';
                    milestoneModal.style.alignItems = 'center';
                    modalContent.style.position = 'relative';
                    modalContent.style.left = '0';
                    modalContent.style.top = '0';
                    modalContent.style.margin = 'auto';
                    modalContent.style.transform = 'none';
                }
            }

            if (milestones.length === 0) {
                milestoneList.innerHTML = `<p class="text-center text-gray-500">ë“±ë¡ëœ ë§ˆì¼ìŠ¤í†¤ì´ ì—†ìŠµë‹ˆë‹¤.</p>`;
            } else {
                milestones.sort((a,b) => new Date(a.date) - new Date(b.date)).forEach((m, index) => {
                    const item = document.createElement('div');
                    // ê°œì„  ì‚¬í•­ 2: êµì°¨ ìƒ‰ìƒ ì ìš© (í™€ìˆ˜/ì§ìˆ˜)
                    const isEven = index % 2 === 0;
                    item.className = 'milestone-nav-item flex items-center justify-between p-2 border-b hover:bg-gray-100 cursor-pointer';
                    item.style.backgroundColor = isEven ? '#f8fafc' : '#e2e8f0';
                    item.dataset.date = m.date;
                    item.innerHTML = `
                        <div>
                            <span class="font-semibold">${m.name}</span>
                            <span class="text-sm text-gray-500 ml-2">${m.date}</span>
                        </div>
                        <button data-index="${index}" class="delete-milestone-btn text-red-500 hover:text-red-700">ì‚­ì œ</button>
                    `; // z-index ì¶”ê°€
                    milestoneList.appendChild(item);
                });
            }
        }

        function handleAddMilestone(e) {
            e.preventDefault();
            const dateInput = document.getElementById('milestoneDate');
            const nameInput = document.getElementById('milestoneName');

            if (dateInput.value && nameInput.value) {
                // ì…ë ¥ëœ ë‚ ì§œë¥¼ íŒŒì‹±í•˜ê³  1ì¼ì„ ì¶”ê°€
                const inputDate = new Date(dateInput.value + 'T00:00:00');
                inputDate.setDate(inputDate.getDate() + 1);
                
                // YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                const adjustedDate = 
                    inputDate.getFullYear() + '-' +
                    String(inputDate.getMonth() + 1).padStart(2, '0') + '-' +
                    String(inputDate.getDate()).padStart(2, '0');

                milestones.push({ date: adjustedDate, name: nameInput.value });
                updateAndApplyDateRange();
                renderMilestoneModal();
                render();
                showToast('ë§ˆì¼ìŠ¤í†¤ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                
                // ê°œì„ ì‚¬í•­: í¼ ë¦¬ì…‹ ì‹œì—ë„ ìƒíƒœ ë³´ì¡´ì„ ìœ„í•´ ê°’ ì €ì¥
                const savedDateValue = dateInput.value;
                const savedNameValue = nameInput.value;
                addMilestoneForm.reset();
                
                // ê°œì„ ì‚¬í•­: ì €ì¥ëœ ê°’ìœ¼ë¡œ ë³µì› (ì‚¬ìš©ì í¸ì˜ì„±)
                if (savedDateValue) dateInput.value = savedDateValue;
                if (savedNameValue) nameInput.value = savedNameValue;
                
                if(projectData.length > 0 || milestones.length > 0){
                    saveHtmlBtn.disabled = false;
                    saveMessage.classList.remove('hidden');
                }
            }
        }

        // ê°œì„  ì‚¬í•­ 1: ë§ˆì¼ìŠ¤í†¤ ì‚­ì œ í•¸ë“¤ëŸ¬
        function handleMilestoneDelete(e) {
            e.stopPropagation(); // ì´ë²¤íŠ¸ ë²„ë¸”ë§ ë°©ì§€
            const deleteBtn = e.target.closest('.delete-milestone-btn');
            const index = parseInt(deleteBtn.dataset.index, 10);
            milestones.splice(index, 1);
            updateAndApplyDateRange();
            renderMilestoneModal();
            render();
            showToast('ë§ˆì¼ìŠ¤í†¤ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
            if(projectData.length === 0 && milestones.length === 0){
                saveHtmlBtn.disabled = true;
                saveMessage.classList.add('hidden');
            }
        }

        // ê°œì„  ì‚¬í•­ 1: ë§ˆì¼ìŠ¤í†¤ ì´ë™ í•¸ë“¤ëŸ¬
        function handleMilestoneNavigate(e) {
            const item = e.target.closest('.milestone-nav-item');
            const dateStr = item.dataset.date;
            if (!dateStr || !viewMinDate) return;

            const targetDate = parseLocalDateString(dateStr);
            if (!targetDate || isNaN(targetDate)) return;

            const offsetDays = dateDiffInDays(viewMinDate, targetDate);
            const scrollPosition = (offsetDays * DAY_WIDTH) - (DAY_WIDTH * 5); // ì•½ê°„ì˜ ì—¬ë°±ì„ ë‘ 

            const container = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
            const timelineContainer = container.querySelector('.gantt-timeline-body-wrapper');

            if (timelineContainer) {
                timelineContainer.scrollTo({ left: scrollPosition, behavior: 'smooth' });
            }

        }

        function initDefaultPinnedShortcuts() {
            // ê¸°ë³¸ ë°”ë¡œê°€ê¸° ìˆœì„œ ì„¤ì • (ê°œì„  ì‚¬í•­: 'ê²€ìƒ‰'ì„ ë°”ë¡œê°€ê¸°ì— ì¶”ê°€)
            const defaultPinnedControls = [
                'showChangesBtn',        // ë³€ê²½
                'expandAllBtn',          // í¼ì¹˜ê¸°
                'collapseAllBtn',        // ì ‘ê¸°
                'fullscreenBtn',         // ì „ì²´ í™”ë©´
                'milestoneBtn',          // ë§ˆì¼ìŠ¤í†¤
                'toggleHierarchyOrderBtn', // ê³„ì¸µìˆœì„œ
                'customer-filter',       // ê³ ê°ì‚¬
                'contractor-filter',     // ì‹œê³µì‚¬
                'taskTypeFilter',        // ìœ í˜•
                'sortBy',                // ì •ë ¬
                'progressFilter',        // ì§„ì²™ë¥ 
                'searchInput',           // ê²€ìƒ‰ (ì¶”ê°€ë¨)
                'zoomBtn'                // ë‚ ì§œ ì„¤ì •
            ];
            
            // ê¸°ì¡´ í•€ ì´ˆê¸°í™”
            pinnedShortcuts.clear();
            
            // ìƒˆë¡œìš´ í•€ ì„¤ì •
            defaultPinnedControls.forEach(id => {
                pinnedShortcuts.add(id);
            });
            
            // ê³„ì¸µìˆœì„œ ë²„íŠ¼ì„ í•­ìƒ 'ì˜¤ëŠ˜' ì˜†ì— ë°°ì¹˜
            ensureShortcutOrderRules();

            // ë°”ë¡œê°€ê¸° ë©”ë‰´ ì—…ë°ì´íŠ¸
            if (typeof updateShortcuts === 'function') {
                updateShortcuts();
            }
        }

        function initializeDashboard() {
            // ì´ˆê¸°í™” ì‹œ ì„ì‹œ ë³´ê´€ì†Œ(sessionStorage)ì— ì €ì¥ëœ ì—…ë°ì´íŠ¸ í‘œì‹œ ë°ì´í„°ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
            try {
                sessionStorage.removeItem('__gantt_updated_projects');
            } catch (e) {}
            try {
                document.querySelectorAll('.progress-updated').forEach(el => el.classList.remove('progress-updated'));
            } catch (e) {}

            if (window.isStandalone) {
                dataPanel.classList.add('hidden');

                const shouldBeOpen = window.embeddedSettings && window.embeddedSettings.controlsPanelOpen === true;
                if (!shouldBeOpen) {
                    controlsPanel.classList.add('translate-x-full');
                    controlsPanelOverlay.classList.add('hidden');
                }
            }

            const controlsPanelEl = document.getElementById('controlsPanel');
            if (controlsPanelEl && !controlsPanelEl.hasAttribute('data-pin-listener-attached')) {
                controlsPanelEl.addEventListener('click', function(e) {
                    const pinBtn = e.target.closest('.pin-shortcut-btn');
                    if (!pinBtn) return;
                    
                    e.stopPropagation();
                    const controlId = pinBtn.dataset.controlId;
                    if (!controlId) return;

                    if (pinnedShortcuts.has(controlId)) {
                        pinnedShortcuts.delete(controlId);
                    } else {
                        pinnedShortcuts.add(controlId);
                    }

                    ensureShortcutOrderRules();
                    
                    updateShortcuts();
                    
                    showToast(pinnedShortcuts.has(controlId) ? 
                        'ë°”ë¡œê°€ê¸°ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.' : 
                        'ë°”ë¡œê°€ê¸°ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.', 
                        'info'
                    );
                });
                
                controlsPanelEl.setAttribute('data-pin-listener-attached', 'true');
            }

            updateControlReferences();


             const initialLegendSection = document.getElementById('legendSection');
             if (initialLegendSection) {
                 initialLegendSection.querySelectorAll('[data-status-filter]').forEach(item => {
                     item.addEventListener('click', handleLegendClickEvent);
                 });
             }


            if (window.embeddedData) {
                try {
                    // ê°œì„  ì‚¬í•­: ì„ë² ë””ë“œ ë°ì´í„° ë¡œë“œ ì‹œ ì›ë³¸ ë‚ ì§œ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì´ˆê¸°í™” (í•˜ë“œì½”ë”© ë°©ì§€)
                    originalDateRegistry.clear();
                    
                    // [ê°œì„  ì‚¬í•­ 1] ë°ì´í„° íŒŒì‹± ì‹œ ì—„ê²©í•œ ìœ íš¨ì„± ê²€ì‚¬ ì ìš©
                    const parsedData = window.embeddedData.map(p => {
                        // í•„ìˆ˜ í•„ë“œ ê²€ì¦
                        if (!p.name || !p.id || !p.taskType) {
                            console.warn('Missing required fields:', p);
                            return null;
                        }

                        // ë‚ ì§œ íŒŒì‹± ë° ê²€ì¦
                        const startDate = p.startDate ? parseLocalDateString(p.startDate) : null;
                        const endDate = p.endDate ? parseLocalDateString(p.endDate) : null;
                        
                        if (!startDate || !endDate || isNaN(startDate) || isNaN(endDate) || startDate > endDate) {
                            console.warn('Invalid dates:', p);
                            return null;
                        }

                        // ì§„í–‰ë¥  ì •ê·œí™”
                        let progress = p.progress;
                        if (typeof progress === 'string') {
                            // í¼ì„¼íŠ¸ ê¸°í˜¸ ì œê±° ë° ìˆ«ìë¡œ ë³€í™˜
                            progress = parseInt(progress.replace('%', ''), 10);
                        }
                        if (isNaN(progress) || progress < 0 || progress > 100) {
                            console.warn('Invalid progress value, defaulting to 0:', p);
                            progress = 0;
                        }

                        // ì •ì‚°ì•¡ ì •ê·œí™”
                        let poAmount = p.poAmount;
                        if (typeof poAmount === 'string') {
                            // ì½¤ë§ˆ ì œê±° ë° ìˆ«ìë¡œ ë³€í™˜
                            poAmount = parseInt(poAmount.replace(/,/g, ''), 10);
                        }
                        if (isNaN(poAmount)) {
                            console.warn('Invalid poAmount value, defaulting to 0:', p);
                            poAmount = 0;
                        }

                        // ê°œì„  ì‚¬í•­: ë‚ ì§œ ë¬¸ìì—´ì„ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •í•˜ì—¬ ì›ë³¸ ë‚ ì§œ ë¹„êµê°€ ì •í™•í•˜ê²Œ ì‘ë™í•˜ë„ë¡ í•¨
                        const startDateStrFormatted = startDate ? formatDateYMD(startDate) : (p.startDate || '');
                        const endDateStrFormatted = endDate ? formatDateYMD(endDate) : (p.endDate || '');
                        
                        return {
                            ...p,
                            startDate,
                            endDate,
                            startDateStr: startDateStrFormatted,
                            endDateStr: endDateStrFormatted,
                            progress,
                            poAmount,
                            // ìƒíƒœ ìë™ ê³„ì‚°
                            status: calculateStatus(progress, endDate)
                        };
                    });

                    // ìœ íš¨í•œ ë°ì´í„°ë§Œ í•„í„°ë§
                    projectData = parsedData.filter(p => p !== null);
                    normalizeAllProjectDates(projectData);

                    // ê°œì„  ì‚¬í•­: ì„ë² ë””ë“œ ë°ì´í„° ë¡œë“œ í›„ ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ê°•ì œ ì¬ì„¤ì • (í•˜ë“œì½”ë”© ë°©ì§€)
                    // ëª¨ë“  í”„ë¡œì íŠ¸ì— ëŒ€í•´ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ì„¤ì •
                    // ë¨¼ì € ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¥¼ ì™„ì „íˆ ì´ˆê¸°í™”
                    originalDateRegistry.clear();
                    // ê·¸ ë‹¤ìŒ ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ì„¤ì •
                    rebaselineOriginalDates(true, false);

                    // [ê°œì„  ì‚¬í•­ 2] ë°ì´í„° ë¡œë“œ ê²°ê³¼ ë³´ê³ 
                    const invalidCount = parsedData.length - projectData.length;
                    if (invalidCount > 0) {
                        showToast(`${invalidCount}ê°œì˜ í•­ëª©ì´ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í†µê³¼í•˜ì§€ ëª»í•´ ì œì™¸ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'warning');
                    }
                } catch (error) {
                    console.error('Error parsing embedded data:', error);
                    showToast('ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                    projectData = [];
                }

                // Normalize custom field keys in loaded embedded data: sanitize keys and populate display name map
                projectData.forEach(p => {
                    if (p.customFields) {
                        const newCustom = {};
                        Object.keys(p.customFields).forEach(origKey => {
                            const safe = sanitizeKey(origKey);
                            if (safe) {
                                newCustom[safe] = p.customFields[origKey];
                                customFieldDisplayNames[safe] = customFieldDisplayNames[safe] || origKey;
                            }
                        });
                        p.customFields = newCustom;
                    }
                });
            }

            if (window.embeddedMilestones) {
                milestones = window.embeddedMilestones;
            }

            updateAndApplyDateRange();
            
            // ê°œì„  ì‚¬í•­: ë°ì´í„° ë¡œë“œ ì™„ë£Œ í›„ ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ê°•ì œ ì¬ì„¤ì • (í•˜ë“œì½”ë”© ë°©ì§€)
            // í˜ì´ì§€ ë¡œë“œ ì‹œ í•œ ë²ˆë§Œ ì‹¤í–‰í•˜ì—¬ ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ì„¤ì •
            if (projectData && projectData.length > 0) {
                // ë¨¼ì € ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¥¼ ì™„ì „íˆ ì´ˆê¸°í™”
                originalDateRegistry.clear();
                // ê·¸ ë‹¤ìŒ ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ì„¤ì •
                rebaselineOriginalDates(true, false);
            }

            if (window.embeddedSettings) {
                savedSettings = window.embeddedSettings;
                openTaskGroups = new Set(savedSettings.openTaskGroups || []);
                columnVisibility = savedSettings.columnVisibility || columnVisibility;
                pinnedShortcuts = new Set(savedSettings.pinnedShortcuts || []);
                ensureShortcutOrderRules();
                // Ensure pinnable controls and header shortcuts are rendered and synchronized
                // even if the controls panel is closed when loading the standalone file.
                try {
                    // This will add pin buttons to control wrappers and render shortcut items
                    if (typeof setupPinnableControls === 'function') setupPinnableControls();
                    if (typeof updateShortcuts === 'function') updateShortcuts();
                    // Sync values from original controls into shortcut clones if needed
                    if (typeof syncShortcutsFromOriginal === 'function') syncShortcutsFromOriginal();
                } catch (e) {
                    console.warn('Shortcut initialization failed during restore:', e);
                }
                
                if(savedSettings.filters) {
                    if(progressFilter) progressFilter.value = savedSettings.filters.progress;
                    if(taskTypeFilter) taskTypeFilter.value = savedSettings.filters.taskType;
                    if(sortBy) sortBy.value = savedSettings.filters.sort;
                    if (typeof savedSettings.filters.sortDirection !== 'undefined') {
                        sortState.direction = savedSettings.filters.sortDirection === SORT_DIRECTIONS.ASC ? SORT_DIRECTIONS.ASC : SORT_DIRECTIONS.DESC;
                    } else {
                        sortState.direction = SORT_DIRECTIONS.DESC;
                    }
                    sortState.mode = sortBy ? sortBy.value : 'default';
                    updateSortDirectionIndicators();
                    if (typeof savedSettings.filters.showOnlyChanged === 'boolean') {
                        showOnlyChanged = savedSettings.filters.showOnlyChanged;
                    } else {
                        showOnlyChanged = false;
                    }
                    updateShowChangesButtonState();
                    if(searchInput && savedSettings.filters.search) {
                        searchInput.value = savedSettings.filters.search;
                    }
                    if (savedSettings.filters.customFilters) {
                        // populateFilters ì´í›„ì— ì ìš©ë  ê²ƒì…ë‹ˆë‹¤.
                    }
                }

                // Restore legend status filter selection
                if (typeof savedSettings.legendStatusFilter !== 'undefined') {
                    legendStatusFilter = savedSettings.legendStatusFilter || null;
                    const legendContainer = fullscreenModal.classList.contains('hidden') ? document.getElementById('ganttViewContent') : fullscreenModalBody;
                    if (legendContainer) {
                        legendContainer.querySelectorAll('.legend-section [data-status-filter].legend-filter-active').forEach(el => el.classList.remove('legend-filter-active'));
                        if (legendStatusFilter) {
                            const toActivate = legendContainer.querySelector(`.legend-section [data-status-filter="${legendStatusFilter}"]`);
                            if (toActivate) toActivate.classList.add('legend-filter-active');
                        }
                    }
                }

                if (savedSettings.viewMinDate && savedSettings.viewMaxDate) {
                    const parseLocalDateStringForSettings = (s) => {
                        try {
                            const parts = String(s).split('-');
                            if (parts.length >= 3) return new Date(parseInt(parts[0],10), parseInt(parts[1],10)-1, parseInt(parts[2],10));
                        } catch (e) {}
                        return new Date(s);
                    };
                    viewMinDate = parseLocalDateStringForSettings(savedSettings.viewMinDate);
                    viewMaxDate = parseLocalDateStringForSettings(savedSettings.viewMaxDate);
                }

                // ê°œì„  ì‚¬í•­: ê³„ì¸µ ìˆœì„œ ë³µì›
                if (savedSettings.hierarchyOrder) {
                    hierarchyOrder = savedSettings.hierarchyOrder;
                    // ë²„íŠ¼ í…ìŠ¤íŠ¸ ë° ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ (í˜„ì¬ ìƒíƒœë¥¼ ì‹œê°ì ìœ¼ë¡œ ëª…í™•íˆ í‘œì‹œ)
                    // ê°œì„  ì‚¬í•­: í˜„ì¬ ìƒíƒœì— ë§ê²Œ ë©”ë‰´ ì´ë¦„ ìë™ ë³€ê²½
                    if (toggleHierarchyOrderBtn) {
                        const isBottomMode = hierarchyOrder === 'bottom';
                        toggleHierarchyOrderBtn.textContent = isBottomMode ? 'ê³„ì¸µìˆœì„œ (í•˜â†’ìƒ)' : 'ê³„ì¸µìˆœì„œ (ìƒâ†’í•˜)';
                        
                        // í˜„ì¬ ìƒíƒœë¥¼ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ê¸° ìœ„í•œ ìŠ¤íƒ€ì¼ ì ìš©
                        if (isBottomMode) {
                            toggleHierarchyOrderBtn.style.backgroundColor = '#dbeafe'; // í•˜ëŠ˜ìƒ‰ ë°°ê²½
                            toggleHierarchyOrderBtn.style.border = '2px solid #3b82f6'; // íŒŒë€ìƒ‰ í…Œë‘ë¦¬
                            toggleHierarchyOrderBtn.style.fontWeight = 'bold';
                            toggleHierarchyOrderBtn.style.color = '#1e40af';
                        } else {
                            toggleHierarchyOrderBtn.style.backgroundColor = '#fef3c7'; // ë…¸ë€ìƒ‰ ë°°ê²½
                            toggleHierarchyOrderBtn.style.border = '2px solid #f59e0b'; // ì£¼í™©ìƒ‰ í…Œë‘ë¦¬
                            toggleHierarchyOrderBtn.style.fontWeight = 'bold';
                            toggleHierarchyOrderBtn.style.color = '#92400e';
                        }
                    }
                }

                // ì»¨íŠ¸ë¡¤ íŒ¨ë„ ìƒíƒœ ë³µì›
                const shouldBeOpen = savedSettings.controlsPanelOpen === true;
                if (shouldBeOpen) {
                    controlsPanel.classList.remove('translate-x-full');
                    controlsPanelOverlay.classList.remove('hidden');
                } else {
                    controlsPanel.classList.add('translate-x-full');
                    controlsPanelOverlay.classList.add('hidden');
                }
                
                // ì»¨íŠ¸ë¡¤ ì„¹ì…˜ ìƒíƒœ ë³µì›
                if (savedSettings.controlSections) {
                    savedSettings.controlSections.forEach(section => {
                        const header = document.querySelector(`#controlsPanel .control-section-header[id="${section.id}"]`) || 
                                     Array.from(document.querySelectorAll('#controlsPanel .control-section-header'))
                                          .find(h => h.querySelector('h3').textContent.trim() === section.id);
                        if (header) {
                            if (section.isOpen) {
                                header.classList.add('open');
                                const content = header.nextElementSibling;
                                if (content && content.classList.contains('control-section-content')) {
                                    content.style.maxHeight = '1000px';
                                    content.style.paddingTop = '0.5rem';
                                    content.style.paddingBottom = '0.5rem';
                                }
                            } else {
                                header.classList.remove('open');
                                const content = header.nextElementSibling;
                                if (content && content.classList.contains('control-section-content')) {
                                    content.style.maxHeight = '0';
                                    content.style.paddingTop = '0';
                                    content.style.paddingBottom = '0';
                                }
                            }
                        }
                    });
                }

                setTimeout(() => {
                    const timelineWrapper = document.querySelector('.gantt-timeline-body-wrapper');
                    if (timelineWrapper) {
                        timelineWrapper.scrollLeft = savedSettings.timelineScrollLeft || 0;
                        timelineWrapper.scrollTop = savedSettings.timelineScrollTop || 0;
                    }

                }, 100);

                // Restore milestone modal position/size and open state if present
                try {
                    const mmOverlay = document.getElementById('milestoneModal');
                    const mmContent = mmOverlay ? mmOverlay.querySelector('.modal-content') : null;
                    if (savedSettings.milestoneModalStyle && mmContent) {
                        const s = savedSettings.milestoneModalStyle;
                        if (s.width) mmContent.style.width = s.width;
                        if (s.height) mmContent.style.height = s.height;
                        if (s.left) mmContent.style.left = s.left;
                        if (s.top) mmContent.style.top = s.top;
                        if (s.overlayJustify && mmOverlay) mmOverlay.style.justifyContent = s.overlayJustify;
                        if (s.overlayAlign && mmOverlay) mmOverlay.style.alignItems = s.overlayAlign;
                    }
                    if (typeof savedSettings.milestoneModalOpen !== 'undefined' && mmOverlay) {
                        if (savedSettings.milestoneModalOpen) mmOverlay.classList.remove('hidden');
                        else mmOverlay.classList.add('hidden');
                    }
                } catch (e) {
                    console.warn('milestone modal restore failed', e);
                }

                // Restore data detail modal position/size and open state if present
                try {
                    const ddOverlay = document.getElementById('dataDetailModal');
                    const ddContent = ddOverlay ? ddOverlay.querySelector('.modal-content') : null;
                    if (savedSettings.dataDetailModalStyle && ddContent) {
                        const s = savedSettings.dataDetailModalStyle;
                        if (s.width) ddContent.style.width = s.width;
                        if (s.height) ddContent.style.height = s.height;
                        if (s.left) ddContent.style.left = s.left;
                        if (s.top) ddContent.style.top = s.top;
                        if (s.overlayJustify && ddOverlay) ddOverlay.style.justifyContent = s.overlayJustify;
                        if (s.overlayAlign && ddOverlay) ddOverlay.style.alignItems = s.overlayAlign;
                    }
                    if (typeof savedSettings.dataDetailModalOpen !== 'undefined' && ddOverlay) {
                        if (savedSettings.dataDetailModalOpen) ddOverlay.classList.remove('hidden');
                        else ddOverlay.classList.add('hidden');
                    }
                } catch (e) {
                    console.warn('data detail modal restore failed', e);
                }
            }

            // ë³µì›: ìë™ ì—…ë¡œë“œ URL ë° í™œì„±í™” ìƒíƒœ
            try {
                if (savedSettings && savedSettings.autoUploadUrl) {
                    if (autoUploadUrlInput) autoUploadUrlInput.value = savedSettings.autoUploadUrl;
                } else {
                    if (autoUploadUrlInput) autoUploadUrlInput.value = DEFAULT_AUTO_UPLOAD_URL;
                }

                // ê¸°ë³¸ê°’: í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ë¶ˆëŸ¬ì˜¤ê¸° ON
                if (savedSettings && typeof savedSettings.autoUploadEnabled !== 'undefined') {
                    if (autoUploadEnabled) autoUploadEnabled.checked = !!savedSettings.autoUploadEnabled;
                } else {
                    if (autoUploadEnabled) autoUploadEnabled.checked = true; // ì´ˆê¸° ê¸°ë³¸ê°’ì„ ì¼¬
                }
            } catch (e) {
                console.warn('auto upload restore error', e);
            }

            // í˜ì´ì§€ ì´ˆê¸° ë¡œë“œ ì‹œ ìë™ ì—…ë¡œë“œ ì‹œë„ (ì˜¨ë¼ì¸ì´ë©´)
            setTimeout(() => {
                try {
                    // [FIX] ë…ë¦½ ì‹¤í–‰í˜• íŒŒì¼ì´ ì•„ë‹ ë•Œë§Œ ìë™ ì—…ë¡œë“œë¥¼ ì‹œë„í•©ë‹ˆë‹¤.
                    if (window.isStandalone) return;
                    if (autoUploadEnabled && autoUploadEnabled.checked) {
                        const url = (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL;
                        if (url) {
                            fetchAndImportFromUrl(url).catch(err => {
                                console.warn('auto upload failed', err);
                                showToast('ìë™ ì—…ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ì˜¤í”„ë¼ì¸ ë˜ëŠ” íŒŒì¼ ì—†ìŒ)', 'warning');
                            });
                        }
                    }
                } catch (e) {
                    console.warn('auto upload init error', e);
                }
            }, 600);

            // ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ: ì§€ê¸ˆ ë¶ˆëŸ¬ì˜¤ê¸°
            if (autoUploadNowBtn) {
                autoUploadNowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const url = (autoUploadUrlInput && autoUploadUrlInput.value) ? autoUploadUrlInput.value.trim() : DEFAULT_AUTO_UPLOAD_URL;
                    if (!url) {
                        showToast('ìë™ ì—…ë¡œë”© URLì„ ì…ë ¥í•˜ì„¸ìš”.', 'warning');
                        return;
                    }
                    fetchAndImportFromUrl(url).catch(err => {
                        console.warn('manual auto upload failed', err);
                        showToast('íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.', 'error');
                    });
                });
            }
            if (projectData.length > 0 || milestones.length > 0) {
                 saveHtmlBtn.disabled = false;
                 exportToExcelBtn.disabled = false;
                 exportToCsvBtn.disabled = false;
                 saveMessage.classList.remove('hidden');
            }

            function exportData(format = 'xlsx') {
                if (projectData.length === 0) {
                    showToast('ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                    return;
                }
                const workbook = XLSX.utils.book_new();

                // ê¸°ë³¸ ë°ì´í„° ì‹œíŠ¸ ì¤€ë¹„
                const mainData = projectData.map((item, index) => ({
                    'No': index + 1,
                    'ID': item.id || '',
                    'ì‘ì—… ìœ í˜•': item.taskType || '',
                    'ëª…ì¹­': item.name || '',
                    'ìƒíƒœ': item.status || '',
                    'ì‹œì‘ì¼': item.startDateStr || '',
                    'ì¢…ë£Œì¼': item.endDateStr || '',
                    'ì§„í–‰ë¥ ': item.progress || 0,
                    'ì •ì‚°': item.poAmount || 0,
                    ...Object.entries(item.customFields || {}).reduce((acc, [key, value]) => {
                        acc[customFieldDisplayNames[key] || key] = value;
                        return acc;
                    }, {})
                }));

                // ë©”ì¸ ë°ì´í„° ì‹œíŠ¸ ì¶”ê°€
                const mainSheet = XLSX.utils.json_to_sheet(mainData);
                XLSX.utils.book_append_sheet(workbook, mainSheet, 'ì‘ì—… ëª©ë¡');

                // ë§ˆì¼ìŠ¤í†¤ ë°ì´í„° ì‹œíŠ¸ ì¶”ê°€ (ë§ˆì¼ìŠ¤í†¤ì´ ìˆëŠ” ê²½ìš°)
                let milestoneSheet = null;
                if (milestones.length > 0) {
                    const milestoneData = milestones.map((item, index) => ({
                        'No': index + 1,
                        'ë§ˆì¼ìŠ¤í†¤': item.name,
                        'ë‚ ì§œ': item.date
                    }));
                    milestoneSheet = XLSX.utils.json_to_sheet(milestoneData);
                    XLSX.utils.book_append_sheet(workbook, milestoneSheet, 'ë§ˆì¼ìŠ¤í†¤');
                }

                // í†µê³„ ë°ì´í„° ì‹œíŠ¸ ì¶”ê°€
                const statsData = [];
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                // ì „ì²´ í†µê³„
                const notStartedCount = projectData.filter(p => (p.progress || 0) === 0 && p.status !== 'ì§€ì—°').length;
                const inProgressCount = projectData.filter(p => p.progress > 0 && p.progress < 100 && p.status !== 'ì§€ì—°').length;
                const completedCount = projectData.filter(p => p.progress === 100).length;
                const delayedCount = projectData.filter(p => p.status === 'ì§€ì—°').length;

                let totalPo = 0;
                let weightedProgressSum = 0;
                projectData.forEach(p => {
                    weightedProgressSum += (p.progress || 0) * (p.poAmount || 0);
                    totalPo += (p.poAmount || 0);
                });

                const overallProgressRate = totalPo > 0 ? Math.round(weightedProgressSum / totalPo * 100) / 100 : 0;

                statsData.push(
                    ['ì „ì²´ í†µê³„', ''],
                    ['ì´ ê±´ìˆ˜', projectData.length],
                    ['ì°©ê³µì „', notStartedCount],
                    ['ì§„í–‰ì¤‘', inProgressCount],
                    ['ì™„ë£Œ', completedCount],
                    ['ì§€ì—°', delayedCount],
                    ['ì´ ì •ì‚°ì•¡', totalPo],
                    ['ì „ì²´ ì§„í–‰ë¥ ', overallProgressRate + '%'],
                    ['', ''],
                    ['ì‘ì—… ìœ í˜•ë³„ í†µê³„', '']
                );

                // ì‘ì—… ìœ í˜•ë³„ í†µê³„
                const taskTypeStats = projectData.reduce((acc, p) => {
                    const type = p.taskType || 'ë¯¸ë¶„ë¥˜';
                    if (!acc[type]) {
                        acc[type] = { count: 0, amount: 0, progress: 0, weightedProgress: 0 };
                    }
                    acc[type].count++;
                    acc[type].amount += p.poAmount || 0;
                    acc[type].weightedProgress += (p.progress || 0) * (p.poAmount || 0);
                    return acc;
                }, {});

                Object.entries(taskTypeStats).sort((a, b) => a[0].localeCompare(b[0])).forEach(([type, stats]) => {
                    const progressRate = stats.amount > 0 ? Math.round(stats.weightedProgress / stats.amount * 100) / 100 : 0;
                    statsData.push(
                        [type, ''],
                        ['ê±´ìˆ˜', stats.count],
                        ['ì •ì‚°ì•¡', stats.amount],
                        ['ì§„í–‰ë¥ ', progressRate + '%'],
                        ['', '']
                    );
                });

                const statsSheet = XLSX.utils.aoa_to_sheet(statsData);
                XLSX.utils.book_append_sheet(workbook, statsSheet, 'í†µê³„');

                // [ê°œì„ ] ì—…ë°ì´íŠ¸ëœ í•­ëª©ë“¤ì˜ ì „/í›„ ë°ì´í„° ì‹œíŠ¸ ì¶”ê°€ (ì¼ê´€ëœ ì „/í›„ ì»¬ëŸ¼)
                try {
                    const updatedProjectIds = window.__getUpdatedProjects ? window.__getUpdatedProjects() : [];
                    if (Array.isArray(updatedProjectIds) && updatedProjectIds.length > 0) {
                        const updateHistoryData = [];
                        updateHistoryData.push(['ì—…ë°ì´íŠ¸ í•­ëª© ìƒì„¸ ì´ë ¥']);
                        updateHistoryData.push(['']);
                        updateHistoryData.push([
                            'í”„ë¡œì íŠ¸ ID', 'ëª…ì¹­',
                            'ë³€ê²½ì „ ì‹œì‘ì¼', 'ë³€ê²½í›„ ì‹œì‘ì¼',
                            'ë³€ê²½ì „ ì¢…ë£Œì¼', 'ë³€ê²½í›„ ì¢…ë£Œì¼',
                            'ë³€ê²½ì „ ì§„í–‰ë¥ (%)', 'ë³€ê²½í›„ ì§„í–‰ë¥ (%)',
                            'ë³€ê²½ ì‹œê°„'
                        ]);

                        const fmtDateForProject = (p, type) => {
                            if (!p) return '';
                            if (p[type] instanceof Date && !isNaN(p[type])) return formatDateYMD(p[type]);
                            return p[`${type}Str`] || '';
                        };

                        const includeOverall = updatedProjectIds.includes('overall');
                        if (includeOverall) {
                            const totalPo = projectData.reduce((s, p) => s + (p.poAmount || 0), 0);
                            const origWeighted = projectData.reduce((s, p) => {
                                const op = getOriginalProgress(p);
                                return s + ((Number(op) || 0) * (p.poAmount || 0));
                            }, 0);
                            const currentWeighted = projectData.reduce((s, p) => s + ((p.progress || 0) * (p.poAmount || 0)), 0);
                            const origOverall = totalPo > 0 ? Math.round(origWeighted / totalPo * 100) / 100 : 0;
                            const currOverall = totalPo > 0 ? Math.round(currentWeighted / totalPo * 100) / 100 : 0;
                            updateHistoryData.push(['overall', 'ì „ì²´ ì§„í–‰ë¥ ', '', '', '', '', origOverall + '%', currOverall + '%', new Date().toLocaleString('ko-KR')]);
                        }

                        updatedProjectIds.forEach(pid => {
                            if (pid === 'overall') return;
                            const project = projectData.find(p => p.id === pid);
                            if (!project) return;

                            const registryKey = getProjectRegistryKey(project, pid, project.name);
                            const originalDates = registryKey ? (originalDateRegistry.get(registryKey) || { start: '', end: '' }) : { start: '', end: '' };
                            const originalStart = originalDates.start || '';
                            const originalEnd = originalDates.end || '';
                            const currentStart = fmtDateForProject(project, 'startDate');
                            const currentEnd = fmtDateForProject(project, 'endDate');

                            const originalProg = getOriginalProgress(project);
                            const currentProg = (typeof project.progress === 'number') ? project.progress : (project.progress || 0);

                            const changed = (originalStart !== currentStart) || (originalEnd !== currentEnd) || (Number(originalProg) !== Number(currentProg));
                            if (changed) {
                                updateHistoryData.push([
                                    pid,
                                    project.name || '',
                                    originalStart || '', currentStart || '',
                                    originalEnd || '', currentEnd || '',
                                    (originalProg === '' ? '' : String(originalProg) + '%'), String(currentProg) + '%',
                                    new Date().toLocaleString('ko-KR')
                                ]);
                            }
                        });

                        if (updateHistoryData.length > 3) {
                            const updateHistorySheet = XLSX.utils.aoa_to_sheet(updateHistoryData);
                            XLSX.utils.book_append_sheet(workbook, updateHistorySheet, 'ì—…ë°ì´íŠ¸ ì´ë ¥');
                        }
                    }
                } catch (e) {
                    console.warn('update history sheet creation failed', e);
                }

                // íŒŒì¼ ì €ì¥: XLSXëŠ” ê¸°ì¡´ ë°©ì‹ ìœ ì§€, CSVëŠ” í”„ë¡œì íŠ¸/ë§ˆì¼ìŠ¤í†¤ì„ ê°ê° CSVë¡œ ë‹¤ìš´ë¡œë“œ
                if (format === 'xlsx') {
                    const fileName = `gantt_data_${new Date().toISOString().slice(0,10)}.${format}`;
                    XLSX.writeFile(workbook, fileName);
                    showToast(`ë°ì´í„°ë¥¼ ${format.toUpperCase()} íŒŒì¼ë¡œ ì €ì¥í–ˆìŠµë‹ˆë‹¤.`, 'success');
                } else if (format === 'csv') {
                    // Create CSV content for main sheet and milestone sheet (if present)
                    const projectsCsv = XLSX.utils.sheet_to_csv(mainSheet);
                    const downloadText = (content, name) => {
                        // Prepend UTF-8 BOM so Excel (Windows) opens CSV with correct encoding
                        const bomPrefixed = '\uFEFF' + content;
                        const blob = new Blob([bomPrefixed], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = name;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    };

                    const dateSuffix = new Date().toISOString().slice(0,10);
                    downloadText(projectsCsv, `gantt_data_projects_${dateSuffix}.csv`);

                    if (milestoneSheet) {
                        setTimeout(() => {
                            const milestoneCsv = XLSX.utils.sheet_to_csv(milestoneSheet);
                            downloadText(milestoneCsv, `gantt_data_milestones_${dateSuffix}.csv`);
                        }, 150);
                    }

                    showToast('í”„ë¡œì íŠ¸ ë° ë§ˆì¼ìŠ¤í†¤ CSV íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí–ˆìŠµë‹ˆë‹¤.', 'success');
                } else {
                    const fileName = `gantt_data_${new Date().toISOString().slice(0,10)}.${format}`;
                    XLSX.writeFile(workbook, fileName);
                    showToast(`ë°ì´í„°ë¥¼ ${format.toUpperCase()} íŒŒì¼ë¡œ ì €ì¥í–ˆìŠµë‹ˆë‹¤.`, 'success');
                }
            }

            // ë‚´ë³´ë‚´ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            exportToExcelBtn.addEventListener('click', () => exportData('xlsx'));
            exportToCsvBtn.addEventListener('click', () => exportData('csv'));

            populateFilters();
             if(savedSettings && savedSettings.filters.customFilters && customFilterContainer) {
                 customFilterContainer.querySelectorAll('select').forEach(sel => {
                    // [FIX] 'ê³ ê°ì‚¬'/'ì‹œê³µì‚¬' í•„í„°ëŠ” ê³ ì • IDë¥¼ ê°€ì§€ë¯€ë¡œ IDë¡œ ì§ì ‘ ê°’ì„ ì„¤ì •í•©ë‹ˆë‹¤.
                    if (sel.id === 'customer-filter') {
                        // 'ê³ ê°ì‚¬' í•„í„°ëŠ” í•­ìƒ 'ê³ ê°ì‚¬'ë¡œ ì´ˆê¸° ì„¤ì •
                        if (sel.querySelector('option[value="ê³ ê°ì‚¬"]')) {
                            sel.value = 'ê³ ê°ì‚¬';
                        } else {
                            sel.value = savedSettings.filters.customFilters[sel.dataset.filterKey] || 'all';
                        }
                        return;
                    } else if (sel.id === 'contractor-filter') {
                        sel.value = savedSettings.filters.customFilters[sel.dataset.filterKey] || 'all';
                        return;
                    }
                     const key = sel.dataset.filterKey;
                     if(savedSettings.filters.customFilters[key] !== undefined) {
                         sel.value = savedSettings.filters.customFilters[key] || 'all';
                     }
                 });
             }
             
             // savedSettings ë³µì› í›„ í—¤ë” í•„í„°ë„ 'ê³ ê°ì‚¬'ë¡œ ë™ê¸°í™”
             const headerCustomFilter = document.getElementById('header-customer-filter-shortcut');
             const mainCustomerFilter = customFilterContainer?.querySelector('#customer-filter');
             if (headerCustomFilter && mainCustomerFilter) {
                 headerCustomFilter.innerHTML = mainCustomerFilter.innerHTML;
                 if (headerCustomFilter.querySelector('option[value="ê³ ê°ì‚¬"]')) {
                     headerCustomFilter.value = 'ê³ ê°ì‚¬';
                     mainCustomerFilter.value = 'ê³ ê°ì‚¬';
                 } else {
                     headerCustomFilter.value = mainCustomerFilter.value;
                 }
             }

            // ê°œì„  ì‚¬í•­: ë Œë”ë§ ì§ì „ì— ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ê°•ì œ ì¬ì„¤ì • (í•˜ë“œì½”ë”© ë°©ì§€)
            // í˜ì´ì§€ ë¡œë“œ ì‹œ ìµœì¢… í™•ì¸í•˜ì—¬ ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ì„¤ì •
            if (projectData && projectData.length > 0) {
                // ë¨¼ì € ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¥¼ ì™„ì „íˆ ì´ˆê¸°í™”
                originalDateRegistry.clear();
                // ê·¸ ë‹¤ìŒ ëª¨ë“  í”„ë¡œì íŠ¸ì˜ ì›ë³¸ ë‚ ì§œë¥¼ í˜„ì¬ ë‚ ì§œë¡œ ì„¤ì •
                rebaselineOriginalDates(true, false);
            }

            render();
            if(window.embeddedData) {
                showToast('ì €ì¥ëœ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.', 'info');
                renderMilestoneModal();
            }

            // [FIX] ì €ì¥ëœ íŒŒì¼ ë¡œë“œ ì‹œ ë°”ë¡œê°€ê¸° ë©”ë‰´ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë³µì›í•©ë‹ˆë‹¤.
            if (savedSettings) {
                setTimeout(() => {
                    updateControlReferences();
                    updateShortcuts();
                }, 100);
            }
            
            setupSettlementAccordions();
            setupControlSectionToggles(document.getElementById('controlsSection'));
        }

        document.addEventListener('DOMContentLoaded', initializeDashboard);
    </script>
    <script>
    (function() {
        function parseNumberFromCurrency(text) {
            if (!text) return 0;
            const digits = String(text).replace(/[^0-9]/g, '');
            return digits ? parseInt(digits, 10) : 0;
        }

        let lastSummarySignature = null;

        function computeCardsAggregate(cards) {
            let totalAmount = 0;
            let totalCount = 0;
            cards.forEach(card => {
                const countEl = card.querySelector('.text-sm.text-gray-500');
                const rightAmountEl = card.querySelector('.text-right .text-lg');
                if (countEl) {
                    const m = (countEl.textContent || '').match(/(\d+)\s*ê±´/);
                    if (m) totalCount += parseInt(m[1], 10);
                }
                if (rightAmountEl) totalAmount += parseNumberFromCurrency(rightAmountEl.textContent);
            });
            return { totalAmount, totalCount };
        }

        function updateCustomerSettlementSummary() {
            try {
                const container = document.getElementById('settlement-group-summaries');
                if (!container) return;

                // Find the first flat grid section (ê³ ê°ì‚¬ë³„ ì •ì‚° ì¹´ë“œê°€ ë§Œë“¤ì–´ì§€ëŠ” ì„¹ì…˜)
                const flatSections = Array.from(container.children).filter(el =>
                    el && el.classList && el.classList.contains('border-t') && el.querySelector('.grid')
                );
                if (flatSections.length === 0) return;

                const section = flatSections[0];
                const grid = section.querySelector('.grid');
                if (!grid) return;

                const cards = Array.from(grid.querySelectorAll('.summary-card[data-filter-type="custom-group"]'));

                const existing = grid.querySelector('#customer-settlement-summary-card');

                if (cards.length < 2) return; // Only show when 2+ cards exist

                const { totalAmount, totalCount } = computeCardsAggregate(cards);

                // Debounce: only update when signature changes (prevents flicker/shake)
                const signature = `${cards.length}|${totalAmount}|${totalCount}`;
                if (lastSummarySignature === signature && existing) return;
                lastSummarySignature = signature;

                // Build or update summary card element
                let summary = existing;
                if (!summary) {
                    summary = document.createElement('div');
                    summary.id = 'customer-settlement-summary-card';
                    summary.className = 'summary-card bg-amber-50 border-l-4 border-amber-500 p-3 rounded-lg shadow-sm cursor-pointer';
                    summary.setAttribute('aria-label', 'ê³ ê°ì‚¬ë³„ ì •ì‚° ìš”ì•½');
                    grid.appendChild(summary);
                    // Attach click handler once for modal, using existing modal pipeline
                    summary.addEventListener('click', () => {
                        try {
                            const customerCards = Array.from(grid.querySelectorAll('.summary-card[data-filter-type="custom-group"]'));
                            if (customerCards.length === 0) return;
                            const field = customerCards[0].dataset.filterField; // e.g., ê³ ê°ì‚¬ í•„ë“œ í‚¤
                            const allowedValues = customerCards.map(c => c.dataset.filterValue);
                            const baseData = (typeof getFilteredAndSortedData === 'function') ? getFilteredAndSortedData() : (window.projectData || []);
                            const combined = baseData.filter(p => allowedValues.includes(p?.customFields?.[field]));
                            if (combined.length > 0 && typeof showProgressDetailModal === 'function') {
                                showProgressDetailModal('ê³ ê°ì‚¬ í•©ê³„ ìƒì„¸ ê³µì • í˜„í™©', combined, 'ê³ ê°ì‚¬ í•©ê³„ ê³µì •ìœ¨');
                            }
                        } catch (err) {
                            console.warn('customer summary modal error', err);
                        }
                    });
                }

                summary.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <div class="font-semibold text-amber-800">ê³ ê°ì‚¬ í•©ê³„</div>
                            <div class="text-sm text-amber-700">${totalCount.toLocaleString('ko-KR')}ê±´</div>
                        </div>
                        <div class="text-right">
                            <div class="text-lg font-bold text-amber-900">${totalAmount.toLocaleString('ko-KR')}ì›</div>
                        </div>
                    </div>
                `;
            } catch (e) {
                console.warn('updateCustomerSettlementSummary error', e);
            }
        }

        function setupCustomerSummaryObserver() {
            const target = document.getElementById('settlement-group-summaries');
            if (!target || !window.MutationObserver) return;
            const observer = new MutationObserver((mutations) => {
                // Only react to child list changes that add/remove cards to reduce noise
                const relevant = mutations.some(m => m.type === 'childList');
                if (!relevant) return;
                clearTimeout(setupCustomerSummaryObserver._t);
                setupCustomerSummaryObserver._t = setTimeout(updateCustomerSettlementSummary, 60);
            });
            observer.observe(target, { childList: true, subtree: true });
            // Initial pass
            setTimeout(updateCustomerSettlementSummary, 0);
        }

        document.addEventListener('DOMContentLoaded', setupCustomerSummaryObserver);
        })();
        </script>

        <!-- Non-invasive accessibility & focus enhancement for group headers and group summary bars -->
        <script>
        (function(){
            // Add minimal focus styles without altering existing CSS blocks
            try {
                const css = `
                    /* Light translucent gray fill for hover/focus to match editor 'cell focus' expectation */
                    .group-header:focus, .group-header.focused { outline: 2px solid rgba(148,163,184,0.35); outline-offset: -2px; background: rgba(148,163,184,0.06); }
                    .gantt-bar-row:focus, .gantt-bar-row.focused { outline: 2px solid rgba(148,163,184,0.35); outline-offset: -2px; background: rgba(148,163,184,0.06); }
                    .gantt-bar:focus, .gantt-bar.focused { box-shadow: 0 0 0 3px rgba(59,130,246,0.12); }
                    .title-item.focused { background: rgba(148,163,184,0.06); }
                `;
                const s = document.createElement('style'); s.setAttribute('data-enhance-focus','true'); s.textContent = css; document.head.appendChild(s);
            } catch (e) { console.warn('focus-enhance: style injection failed', e); }

            function enhanceGanttFocus() {
                try {
                    // 1) Make group headers keyboard-focusable and add keyboard handlers
                    const groupHeaders = Array.from(document.querySelectorAll('.group-header'));
                    groupHeaders.forEach(h => {
                        if (!h.hasAttribute('data-enhanced-focus')) {
                            h.setAttribute('tabindex', '0');
                            h.setAttribute('role', 'row');
                            h.dataset.enhancedFocus = '1';
                            // Reflect expanded/collapsed state for screen readers
                            const isOpen = h.classList.contains('open') || (h.parentElement && h.parentElement.classList.contains('open'));
                            h.setAttribute('aria-expanded', String(!!isOpen));
                            h.addEventListener('keydown', (ev) => {
                                if (ev.key === 'Enter' || ev.key === ' ') {
                                    ev.preventDefault();
                                    // emulate click/toggle without changing DOM order
                                    const clickTarget = h.closest('.group-header') || h;
                                    if (clickTarget && typeof clickTarget.click === 'function') clickTarget.click();
                                }
                            });
                            // Observe class changes to keep aria-expanded in sync
                            if (window.MutationObserver) {
                                const ph = new MutationObserver(() => {
                                    try {
                                        const nowOpen = h.classList.contains('open') || (h.parentElement && h.parentElement.classList.contains('open'));
                                        h.setAttribute('aria-expanded', String(!!nowOpen));
                                    } catch(e){}
                                });
                                ph.observe(h, { attributes: true, attributeFilter: ['class'] });
                            }
                        }
                    });

                    // 2) Make group summary bars and their containing rows focusable
                    const summaryBars = Array.from(document.querySelectorAll('.gantt-bar')).filter(b => {
                        const name = (b.dataset && b.dataset.name) ? b.dataset.name : b.getAttribute('data-name') || '';
                        return name && name.indexOf('(ìš”ì•½)') !== -1; // existing code uses '(ìš”ì•½)' marker
                    });

                    summaryBars.forEach(bar => {
                        try {
                            const row = bar.closest('.gantt-bar-row');
                            if (row && !row.hasAttribute('data-enhanced-focus')) {
                                row.setAttribute('tabindex', '0');
                                row.setAttribute('role', 'row');
                                row.dataset.enhancedFocus = '1';
                                row.addEventListener('keydown', (ev) => {
                                    if (ev.key === 'Enter' || ev.key === ' ') {
                                        ev.preventDefault();
                                        // forward activation to the bar element
                                        if (typeof bar.click === 'function') bar.click();
                                        else bar.dispatchEvent(new MouseEvent('click', {bubbles:true}));
                                    }
                                });
                            }

                            if (!bar.hasAttribute('tabindex')) {
                                bar.setAttribute('tabindex', '0');
                                bar.setAttribute('role', 'button');
                                const label = (bar.dataset && bar.dataset.name) ? bar.dataset.name : (bar.getAttribute('aria-label') || 'ê·¸ë£¹ ìš”ì•½');
                                bar.setAttribute('aria-label', label);
                                bar.addEventListener('keydown', (ev) => {
                                    if (ev.key === 'Enter' || ev.key === ' ') {
                                        ev.preventDefault();
                                        if (typeof bar.click === 'function') {
                                            bar.click();
                                        } else {
                                            bar.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                                        }
                                    }
                                });
                            }
                        } catch (inner) { console.warn('focus-enhance: summary bar enhance failed', inner); }
                    });

                    // Additional helper/wiring: allow header <-> row focus sync and keyboard navigation
                    function findGroupBarRowLocal(taskType) {
                        if (!taskType) return null;
                        try {
                            const candidateBar = Array.from(document.querySelectorAll('.gantt-bar')).find(b => {
                                const name = (b.dataset && b.dataset.name) ? b.dataset.name : (b.getAttribute('data-name') || '');
                                return name && (name.indexOf(taskType) === 0 || name.indexOf(taskType + ' ') === 0 || name.indexOf('(' + taskType) !== -1);
                            });
                            if (candidateBar) {
                                const r = candidateBar.closest('.gantt-bar-row');
                                if (r) return r;
                            }
                            const titleItems = Array.from(document.querySelectorAll(`.group-item-container[data-task-type="${taskType}"] .title-item`));
                            const projectIds = titleItems.map(t => t.dataset.projectId).filter(Boolean);
                            if (projectIds.length) {
                                const br = Array.from(document.querySelectorAll('.gantt-bar-row[data-project-id]')).find(b => projectIds.includes(b.dataset.projectId));
                                if (br) return br.parentElement || br;
                            }
                            const groupRows = Array.from(document.querySelectorAll('.gantt-bar-row')).filter(r => !r.dataset.projectId);
                            if (groupRows.length) return groupRows[0];
                        } catch(e) { console.warn('findGroupBarRowLocal error', e); }
                        return null;
                    }

                    function applyFocusSyncLocal(h, row) {
                        try {
                            // Prevent multiple attachments
                            if (h.dataset.focusSyncAttached) return;
                            h.dataset.focusSyncAttached = '1';

                            const onFocus = () => { try { h.classList.add('focused'); if (row) row.classList.add('focused'); } catch(e){} };
                            const onBlur = () => { try { if (document.activeElement !== h && document.activeElement !== row) { h.classList.remove('focused'); if (row) row.classList.remove('focused'); } } catch(e){} };
                            h.addEventListener('focus', onFocus);
                            h.addEventListener('blur', onBlur);
                            if (row) {
                                row.addEventListener('focus', () => { try { row.classList.add('focused'); h.classList.add('focused'); } catch(e){} });
                                row.addEventListener('blur', () => { try { if (document.activeElement !== h && document.activeElement !== row) { row.classList.remove('focused'); h.classList.remove('focused'); } } catch(e){} });
                            }

                            // Mouse hover: show focused state while mouse is over either header or row
                            const setHover = (on) => {
                                try {
                                    if (on) { h.classList.add('focused'); if (row) row.classList.add('focused'); }
                                    else {
                                        // only remove hover visual if element is not keyboard-focused
                                        const focusedEl = document.activeElement;
                                        if (focusedEl !== h && focusedEl !== row) {
                                            h.classList.remove('focused'); if (row) row.classList.remove('focused');
                                        }
                                    }
                                } catch(e){}
                            };
                            h.addEventListener('mouseenter', () => setHover(true));
                            h.addEventListener('mouseleave', () => setHover(false));
                            if (row) {
                                row.addEventListener('mouseenter', () => setHover(true));
                                row.addEventListener('mouseleave', () => setHover(false));
                            }

                            h.addEventListener('keydown', (ev) => {
                                if ((ev.key === 'ArrowRight' || ev.key === 'ArrowDown') && row) { ev.preventDefault(); try { row.focus(); } catch(e){} }
                                if ((ev.key === 'ArrowLeft' || ev.key === 'ArrowUp') && row) { ev.preventDefault(); try { h.focus(); } catch(e){} }
                            });
                        } catch(e) { /* non-critical */ }
                    }

                    try {
                        const gh = Array.from(document.querySelectorAll('.group-header'));
                        gh.forEach(h => {
                            try {
                                const taskType = h.dataset.taskType || (h.textContent.match(/ğŸ“‚\s*(.+?)\s*\(/)||[])[1];
                                const r = taskType ? findGroupBarRowLocal(taskType) : document.querySelector('.gantt-bar-row');
                                applyFocusSyncLocal(h, r);
                            } catch(e){}
                        });
                    } catch(e) { /* non-critical */ }
                } catch (e) {
                    console.warn('focus-enhance: enhanceGanttFocus error', e);
                }
            }

            // Run after DOM ready and schedule a couple delayed runs to catch late renders
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => { enhanceGanttFocus(); setTimeout(enhanceGanttFocus, 120); });
            } else {
                enhanceGanttFocus(); setTimeout(enhanceGanttFocus, 120);
            }

            // Observe gantt area for changes and re-apply enhancements non-destructively
            (function attachObserver(){
                const target = document.getElementById('ganttChart') || document.getElementById('ganttChartWrapper') || document;
                if (!window.MutationObserver || !target) return;
                const mo = new MutationObserver((mutations) => {
                    // debounce
                    clearTimeout(enhanceGanttFocus._t);
                    enhanceGanttFocus._t = setTimeout(enhanceGanttFocus, 40);
                });
                try { mo.observe(target, { childList: true, subtree: true, attributes: true }); }
                catch(e){ console.warn('focus-enhance: observer attach failed', e); }
            })();
        })();
        </script>
    <script>
    // Non-destructive scroll-sync enhancement: keep titles and timeline vertically synchronized
    (function(){
        function getScrollableWithin(selector) {
            try {
                const wrapper = document.querySelector(selector);
                if (!wrapper) return null;
                if (wrapper.scrollHeight > wrapper.clientHeight) return wrapper;
                // try first child div
                const child = wrapper.querySelector('div');
                if (child && child.scrollHeight > child.clientHeight) return child;
                return wrapper;
            } catch(e) { return null; }
        }

        function bindSync() {
            // Prefer the actual inner elements used elsewhere in this file
            const titlesElSelectors = ['.gantt-titles-body-wrapper div', '.gantt-titles-body-wrapper', '.gantt-titles'];
            const timelineElSelectors = ['.gantt-body div:first-child', '.gantt-timeline-body-wrapper div', '.gantt-timeline-body-wrapper', '.gantt-body', '#ganttChart'];
            let titlesEl = null;
            let timelineEl = null;

            for (const s of titlesElSelectors) {
                const el = document.querySelector(s);
                if (el) { titlesEl = el; break; }
            }
            for (const s of timelineElSelectors) {
                const el = document.querySelector(s);
                if (el) { timelineEl = el; break; }
            }
            // Fallback to previous heuristic
            if (!titlesEl) titlesEl = getScrollableWithin('.gantt-titles-body-wrapper') || getScrollableWithin('.gantt-titles');
            if (!timelineEl) timelineEl = getScrollableWithin('.gantt-timeline-body-wrapper') || getScrollableWithin('.gantt-body') || getScrollableWithin('#ganttChart') || document.querySelector('#ganttChart');
            if (!titlesEl || !timelineEl) return;

            // avoid duplicate binding
            if (titlesEl.dataset.scrollSync === '1') return;
            titlesEl.dataset.scrollSync = '1';
            timelineEl.dataset.scrollSync = '1';

            let isSyncing = false;

            const syncFromTitles = () => {
                if (isSyncing) return;
                isSyncing = true;
                try { timelineEl.scrollTop = titlesEl.scrollTop; } catch(e){}
                requestAnimationFrame(() => { isSyncing = false; });
            };

            const syncFromTimeline = () => {
                if (isSyncing) return;
                isSyncing = true;
                try { titlesEl.scrollTop = timelineEl.scrollTop; } catch(e){}
                requestAnimationFrame(() => { isSyncing = false; });
            };

            titlesEl.addEventListener('scroll', syncFromTitles, {passive:true});
            timelineEl.addEventListener('scroll', syncFromTimeline, {passive:true});

            // Also sync wheel events in case scroll is prevented; keep passive:false only if needed
            titlesEl.addEventListener('wheel', (ev) => {
                // If titlesEl is itself scrollable, let it scroll naturally and mirror its scrollTop.
                // If it's not scrollable, forward the wheel delta to timeline to scroll it.
                try {
                    const canScroll = titlesEl.scrollHeight > titlesEl.clientHeight;
                    if (canScroll) {
                        requestAnimationFrame(() => { try { timelineEl.scrollTop = titlesEl.scrollTop; } catch(e){} });
                    } else {
                        // forward deltaY to timeline
                        ev.preventDefault();
                        timelineEl.scrollTop += ev.deltaY;
                    }
                } catch(e){}
            }, {passive:false});

            // Also attach to wrapper selectors to increase chance of catching wheel when inner div isn't target
            ['.gantt-titles', '.gantt-titles-body-wrapper'].forEach(sel => {
                const wrap = document.querySelector(sel);
                if (!wrap) return;
                if (wrap.dataset.wheelForwardAttached) return;
                wrap.dataset.wheelForwardAttached = '1';
                wrap.addEventListener('wheel', (ev) => {
                    try {
                        timelineEl.scrollTop += ev.deltaY;
                        ev.preventDefault();
                    } catch(e){}
                }, {passive:false});
            });
        }

        // initial bind and re-bind on DOM changes
        bindSync();
        if (window.MutationObserver) {
            const target = document.getElementById('ganttChart') || document;
            const mo = new MutationObserver(() => {
                // small debounce
                clearTimeout(bindSync._t);
                bindSync._t = setTimeout(bindSync, 80);
            });
            try { mo.observe(target, { childList:true, subtree:true }); } catch(e){}
        }
    })();
    </script>

    <script>
    /* Enhanced wheel-forwarding: if wheel occurs over a titles area element, find the nearest #ganttChart and its timeline container and forward the delta.
       Non-destructive: idempotent, uses passive:false on the single listener so we can preventDefault when forwarding. */
    (function(){
        try {
            if (window.__wheel_forward_installed) return;
            window.__wheel_forward_installed = true;

            function findNearestChart(el){
                // Try multiple nearby containers: #ganttChart, #ganttChartWrapper, #ganttViewContent
                try {
                    if (!el) return document.getElementById('ganttChart') || document.getElementById('ganttChartWrapper') || document.querySelector('#ganttChart');
                    let chart = null;
                    if (el.closest) {
                        chart = el.closest('#ganttChart') || el.closest('#ganttChartWrapper') || el.closest('#ganttViewContent');
                    }
                    if (chart && chart.id === 'ganttViewContent') {
                        // find inner chart wrapper inside the view content
                        chart = chart.querySelector('#ganttChartWrapper') || chart.querySelector('#ganttChart') || chart;
                    }
                    return chart || document.getElementById('ganttChart') || document.getElementById('ganttChartWrapper') || document.querySelector('#ganttChart');
                } catch (e) {
                    return document.getElementById('ganttChart') || document.getElementById('ganttChartWrapper') || document.querySelector('#ganttChart');
                }
            }

            function findTimelineInChart(chart){
                try {
                    if(!chart) return document.querySelector('.gantt-timeline-body-wrapper, .gantt-body, .gantt-timeline-wrapper');
                    // prefer direct children inside the chart/wrapper
                    return chart.querySelector('.gantt-timeline-body-wrapper') || chart.querySelector('.gantt-body') || chart.querySelector('.gantt-timeline-wrapper') || document.querySelector('.gantt-timeline-body-wrapper') || document.querySelector('.gantt-body');
                } catch (e) {
                    return document.querySelector('.gantt-timeline-body-wrapper, .gantt-body, .gantt-timeline-wrapper');
                }
            }

            function isOverTitles(el){
                if(!el) return false;
                return !!(el.closest && (el.closest('.gantt-titles') || el.closest('.gantt-titles-body-wrapper') || el.closest('.title-item') || el.closest('.project-name') || el.closest('.group-header')));
            }

            window.addEventListener('wheel', function(ev){
                try {
                    const el = document.elementFromPoint(ev.clientX, ev.clientY);
                    if (!el) return;
                    if (!isOverTitles(el)) return; // only handle wheels over the titles area

                    const chart = findNearestChart(el);
                    const timeline = findTimelineInChart(chart);
                    if (!timeline) return;

                    // convert deltaMode to pixels
                    let dy = ev.deltaY;
                    if (ev.deltaMode === 1) dy *= 16;
                    if (ev.deltaMode === 2) dy *= (timeline.clientHeight || 800);

                    // Forward the scroll to timeline and prevent default to avoid odd interactions
                    ev.preventDefault();
                    timeline.scrollTop += dy;
                } catch (e) {
                    // swallow errors â€” this is a progressive enhancement
                }
            }, {passive: false});

            console.info('[wheel-forward] installed');
        } catch (err) {
            console.error('[wheel-forward] failed to install', err);
        }
    })();
    </script>

    <!-- Non-destructive enhancement: progress update highlighting + 'ì§„í–‰' trigger handler -->
    <style>
        /* ëˆˆì— ë„ëŠ” ì§„ì²™ë¥  ì—…ë°ì´íŠ¸ ìŠ¤íƒ€ì¼ (ë¹¨ê°„ìƒ‰, êµµê²Œ) */
        .progress-updated {
            color: #b91c1c !important; /* red-700 */
            font-weight: 800 !important;
        }
    </style>

    <script>
    (function(){
        // Non-destructive observer and input-triggered highlighter
        const PROG_SELECTOR = '#overallProgress, .title-item .project-progress, .project-progress';

        // Persistence: store project IDs (or 'overall') that are marked as updated
        const UPDATED_STORAGE_KEY = '__gantt_updated_projects';
        // Use sessionStorage for temporary (session-scoped) storage instead of persistent localStorage
        const updatedProjectsSet = new Set(JSON.parse(sessionStorage.getItem(UPDATED_STORAGE_KEY) || '[]'));

        function persistUpdatedSet(){
            try{ sessionStorage.setItem(UPDATED_STORAGE_KEY, JSON.stringify(Array.from(updatedProjectsSet))); }catch(e){}
        }

        function findProjectIdForElement(el){
            if(!el) return null;
            // direct overall progress
            if(el.id === 'overallProgress') return 'overall';
            // look for nearest ancestor with data-project-id
            const pidEl = el.closest && el.closest('[data-project-id]');
            if(pidEl && pidEl.dataset && pidEl.dataset.projectId) return pidEl.dataset.projectId;
            // find a gantt-bar-row ancestor
            const barRow = el.closest && el.closest('.gantt-bar-row[data-project-id]');
            if(barRow && barRow.dataset && barRow.dataset.projectId) return barRow.dataset.projectId;
            return null;
        }

        function applyHighlightByProjectId(pid){
            if(!pid) return;
            if(pid === 'overall'){
                const o = document.getElementById('overallProgress');
                if(o) o.classList.add('progress-updated');
                return;
            }
            // add class to all matching elements
            try{
                const selectors = [
                    `.title-item[data-project-id="${pid}"]`,
                    `.title-item[data-project-id="${pid}"] .project-progress`,
                    `.gantt-bar-row[data-project-id="${pid}"]`,
                    `.gantt-bar-row[data-project-id="${pid}"] .project-progress`,
                    `[data-project-id="${pid}"] .project-progress`,
                    `[data-project-id="${pid}"]`
                ];
                selectors.forEach(sel => {
                    Array.from(document.querySelectorAll(sel)).forEach(el => el.classList.add('progress-updated'));
                });
            }catch(e){}
        }

        function markUpdated(el){
            if(!el) return;
            try{
                // determine project id and persist
                const pid = findProjectIdForElement(el);
                if(pid) {
                    updatedProjectsSet.add(pid);
                    persistUpdatedSet();
                    applyHighlightByProjectId(pid);
                    return;
                }
                // fallback: just add class to element
                el.classList.add('progress-updated');
            }catch(e){ /* swallow */ }
        }

        // Observe character/child changes across document and mark when progress nodes change
        const docObserver = new MutationObserver(mutations => {
            for(const m of mutations){
                let target = m.target;
                if(target && target.nodeType === 3) target = target.parentElement;
                if(!target) continue;
                try{
                    if(target.matches && (target.matches(PROG_SELECTOR) || target.closest && target.closest(PROG_SELECTOR))){
                        const el = target.matches(PROG_SELECTOR) ? target : target.closest(PROG_SELECTOR);
                        if(el) markUpdated(el);
                    }
                }catch(e){ }
            }
        });
        try{ docObserver.observe(document.body, { childList:true, subtree:true, characterData:true }); }catch(e){}

        // Also ensure newly added nodes are observed and easily markable
        function ensureObservingExisting(){
            try{
                document.querySelectorAll(PROG_SELECTOR).forEach(el=>{
                    if(el.__tinyObserver) return;
                    try{
                        const o = new MutationObserver(()=> markUpdated(el));
                        o.observe(el, { childList:true, subtree:true, characterData:true });
                        el.__tinyObserver = o;
                    }catch(e){ }
                });
            }catch(e){}
        }
        setInterval(ensureObservingExisting, 2500);

        // Apply any stored highlights on init and on DOM mutations
        function applyStoredUpdatedHighlights(){
            try{
                const stored = Array.from(updatedProjectsSet);
                stored.forEach(pid => applyHighlightByProjectId(pid));
            }catch(e){}
        }
        applyStoredUpdatedHighlights();

        // Re-apply stored highlights when new nodes matching project ids are added
        const reapplier = new MutationObserver((mutations) => {
            if(updatedProjectsSet.size === 0) return;
            for(const m of mutations){
                // quick path: if addedNodes exist, try reapplying
                if(m.addedNodes && m.addedNodes.length>0){
                    applyStoredUpdatedHighlights();
                    break;
                }
            }
        });
        try{ reapplier.observe(document.body, { childList:true, subtree:true }); }catch(e){}

        // ê³„ì¸µ ìˆœì„œ(ìƒ->í•˜ ë˜ëŠ” í•˜->ìƒ) ê´€ë¦¬
        let hierarchyOrder = window.hierarchyOrder || 'top'; // 'top' | 'bottom'
        const orderBtn = document.getElementById('toggleHierarchyOrderBtn');
        if(orderBtn){
            const updateLabel = ()=> orderBtn.textContent = 'ê³„ì¸µìˆœì„œ: ' + (hierarchyOrder === 'top' ? 'ìƒ->í•˜' : 'í•˜->ìƒ');
            orderBtn.addEventListener('click', ()=>{
                hierarchyOrder = (hierarchyOrder === 'top' ? 'bottom' : 'top');
                window.hierarchyOrder = hierarchyOrder;
                updateLabel();
            });
            updateLabel();
        }

        // 'ì§„í–‰' ì…ë ¥ í•¸ë“¤ëŸ¬: ì…ë ¥ê°’ì´ ì •í™•íˆ 'ì§„í–‰'ì¼ ë•Œ ì§„ì²™ë¥  ìš”ì†Œë“¤ì„ ê³„ì¸µìˆœì„œì— ë”°ë¼ ì°¨ë¡€ë¡œ í•˜ì´ë¼ì´íŠ¸í•©ë‹ˆë‹¤.
        function handleJinhaengInput(el){
            if(!el) return;
            const val = String((el.value || '')).trim();
            if(val !== 'ì§„í–‰') return;
            const nodes = Array.from(document.querySelectorAll('.title-item .project-progress, .project-progress'));
            // include overall progress at the end/beginning depending on preference
            const overall = document.querySelector('#overallProgress');
            if(overall) nodes.unshift(overall);
            if(nodes.length === 0) return;
            const list = hierarchyOrder === 'top' ? nodes : nodes.reverse();
            list.forEach((n, i) => setTimeout(()=> markUpdated(n), i * 120));
        }

        document.addEventListener('input', (e)=>{
            const t = e.target;
            if(!t) return;
            if(t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable){
                handleJinhaengInput(t);
            }
        }, {passive:true});

        document.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter'){
                const active = document.activeElement;
                if(active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)){
                    handleJinhaengInput(active);
                }
            }
        });
        
        // ê³µê°œ í•¨ìˆ˜: í¸ì§‘ê¸°/íŒŒì´í”„ë¼ì¸ì´ í”„ë¡œê·¸ë˜ë°ì ìœ¼ë¡œ ì§„ì²™ë¥  ì—…ë°ì´íŠ¸ë¥¼ ì•Œë¦´ ìˆ˜ ìˆë„ë¡ í›… ì œê³µ
        window.__markProgressUpdated = function(selector){
            try{
                if(!selector){
                    // mark all known progress nodes
                    document.querySelectorAll(PROG_SELECTOR).forEach(el => markUpdated(el));
                    return;
                }
                const els = document.querySelectorAll(selector);
                if(els && els.length>0){
                    els.forEach(el => markUpdated(el));
                } else {
                    // if selector looks like a project id string, accept it
                    // allow calling with project id directly
                    try{
                        const maybePid = String(selector);
                        if(maybePid.length > 0) {
                            updatedProjectsSet.add(maybePid);
                            persistUpdatedSet();
                            applyHighlightByProjectId(maybePid);
                        }
                    }catch(e){}
                }
            }catch(e){}
        };

        window.__clearProgressUpdated = function(id){
            try{
                if(!id){
                    updatedProjectsSet.clear();
                    persistUpdatedSet();
                    document.querySelectorAll('.progress-updated').forEach(el => el.classList.remove('progress-updated'));
                    return;
                }
                updatedProjectsSet.delete(id);
                persistUpdatedSet();
                // remove classes for elements with that id
                if(id === 'overall'){
                    const o = document.getElementById('overallProgress'); if(o) o.classList.remove('progress-updated');
                } else {
                    Array.from(document.querySelectorAll(`[data-project-id="${id}"]`)).forEach(el => el.classList.remove('progress-updated'));
                    Array.from(document.querySelectorAll(`.title-item[data-project-id="${id}"] .project-progress`)).forEach(el=>el.classList.remove('progress-updated'));
                }
            }catch(e){}
        };

        window.__getUpdatedProjects = function(){
            try{ return Array.from(updatedProjectsSet); }catch(e){ return []; }
        };

        // ë…¸íŠ¸: ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ì›ë³¸ DOMì˜ ìˆœì„œë‚˜ ë‚´ìš©ì„ ë³€ê²½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜¤ì§ CSS í´ë˜ìŠ¤ë¥¼ ì¶”ê°€/ì œê±°í•˜ì—¬
        //       ì‚¬ìš©ìì—ê²Œ 'ì—…ë°ì´íŠ¸ë¨' ìƒíƒœë¥¼ ëª…í™•íˆ ë³´ì—¬ì£¼ëŠ” ë¹„íŒŒê´´ì  ê°œì„ ì…ë‹ˆë‹¤.
    })();
    </script>


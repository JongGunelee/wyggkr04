<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì•ˆì „ ê¸°ë°˜ ìŠ¤ë§ˆíŠ¸ íŒŒì¼ ë¶„ë¥˜ê¸° V4.0</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --bg: #f8fafc;
            --card: #ffffff;
            --text: #1e293b;
            --border: #e2e8f0;
            --success: #16a34a;
            --warning: #ca8a04;
            --error: #dc2626;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Pretendard', -apple-system, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 1000px;
        }

        h1 {
            text-align: center;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #64748b;
            margin-bottom: 30px;
            font-size: 0.95rem;
        }

        /* ì¹´ë“œ ê³µí†µ */
        .card {
            background: var(--card);
            border-radius: 12px;
            padding: 24px;
            border: 1px solid var(--border);
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }

        .section-header {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-badge {
            background: var(--primary);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .btn {
            background: white;
            border: 1px solid #cbd5e1;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text);
        }
        .btn:hover:not(:disabled) { border-color: var(--primary); color: var(--primary); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-analyze {
            background: var(--primary);
            color: white;
            border: none;
            text-align: center;
            justify-content: center;
            font-size: 1.1rem;
            padding: 16px;
        }
        .btn-analyze:hover:not(:disabled) { background: var(--primary-dark); }

        .btn-execute {
            background: var(--success);
            color: white;
            border: none;
            text-align: center;
            justify-content: center;
            font-size: 1.1rem;
            padding: 16px;
            display: none; /* ì´ˆê¸°ì—” ìˆ¨ê¹€ */
        }
        .btn-execute:hover { background: #15803d; }

        .btn-download {
            background: #475569;
            color: white;
            border: none;
            justify-content: center;
            margin-top: 10px;
        }

        /* ê²½ë¡œ í‘œì‹œ */
        .path-text {
            font-size: 0.85rem;
            color: #64748b;
            margin-top: 5px;
            font-family: monospace;
            background: #f1f5f9;
            padding: 5px 10px;
            border-radius: 4px;
        }

        /* ì˜µì…˜ ê·¸ë¦¬ë“œ */
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .option-box {
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .option-title { font-weight: bold; margin-bottom: 10px; display: block; color: #475569; }
        .radio-label { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer; font-size: 0.95rem; }

        /* ë¶„ì„ ê²°ê³¼ ì˜ì—­ */
        .analysis-result {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none; /* ì´ˆê¸° ìˆ¨ê¹€ */
        }
        .analysis-summary { font-size: 1.05rem; font-weight: bold; color: #1e40af; margin-bottom: 10px; }
        .analysis-detail { font-size: 0.95rem; line-height: 1.6; color: #334155; }

        /* ê²°ê³¼ í…Œì´ë¸” */
        .table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-top: 15px;
        }
        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        th { background: #f1f5f9; position: sticky; top: 0; padding: 10px; text-align: left; font-weight: 600; color: #475569; }
        td { padding: 8px 10px; border-bottom: 1px solid #e2e8f0; }
        tr:hover { background: #f8fafc; }
        
        .status-ready { color: var(--text); }
        .status-success { color: var(--success); font-weight: bold; }
        .status-fail { color: var(--error); font-weight: bold; }
        .status-skip { color: var(--warning); }

        /* í”„ë¡œê·¸ë ˆìŠ¤ ë°” */
        .progress-wrap { margin-top: 15px; display: none; }
        .progress-bar { height: 10px; background: #e2e8f0; border-radius: 5px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--success); width: 0%; transition: width 0.2s; }
        .progress-text { text-align: right; font-size: 0.85rem; color: #64748b; margin-top: 5px; }

    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ›¡ï¸ ì•ˆì „ ê¸°ë°˜ ìŠ¤ë§ˆíŠ¸ íŒŒì¼ ë¶„ë¥˜ê¸° V4.0</h1>
    <p class="subtitle">ì„ (å…ˆ)ë¶„ì„ í›„(å¾Œ)ì‹¤í–‰ Â· ë¶„ë¥˜ ë‚´ì—­ ë¦¬í¬íŠ¸ ì œê³µ Â· íŒŒì¼ ìœ ì‹¤ ë°©ì§€</p>

    <!-- 1ë‹¨ê³„: í´ë” ì„ íƒ -->
    <div class="card">
        <div class="section-header"><span class="step-badge">1ë‹¨ê³„</span> ì›ë³¸ ë° ëŒ€ìƒ í´ë” ì—°ê²°</div>
        <div class="options-grid">
            <div>
                <button id="btnSource" class="btn">ğŸ“‚ ì›ë³¸ í´ë” ì„ íƒ (íŒŒì¼ë“¤)</button>
                <div id="pathSource" class="path-text">ì„ íƒ ëŒ€ê¸°ì¤‘...</div>
            </div>
            <div>
                <button id="btnTarget" class="btn">ğŸ“‚ ëŒ€ìƒ í´ë” ì„ íƒ (0000 ë“±)</button>
                <div id="pathTarget" class="path-text">ì„ íƒ ëŒ€ê¸°ì¤‘...</div>
            </div>
            <div>
                <button id="btnMultiDrive" class="btn" style="background:#f1f5f9; border-color:#cbd5e1;">ğŸŒ ë©€í‹° ë“œë¼ì´ë¸Œ ìŠ¤ìº” (ì„ íƒ)</button>
                <div id="multiDriveStatus" class="path-text" style="display:none;">ìŠ¤ìº” ëŒ€ê¸°ì¤‘...</div>
            </div>
        </div>
    </div>

    <!-- 2ë‹¨ê³„: ì˜µì…˜ ì„¤ì • -->
    <div class="card">
        <div class="section-header"><span class="step-badge">2ë‹¨ê³„</span> ë¶„ë¥˜ ê·œì¹™ ë° ì•ˆì „ ì˜µì…˜</div>
        <div class="options-grid">
            <div class="option-box">
                <span class="option-title">ğŸ¯ ê°ì§€ ëª¨ë“œ</span>
                <label class="radio-label"><input type="radio" name="patternMode" value="auto" checked> ìŠ¤ë§ˆíŠ¸ ìë™ (ëª¨ë“  ìˆ«ì)</label>
                <label class="radio-label"><input type="radio" name="patternMode" value="strict"> ì—„ê²© ëª¨ë“œ (ìˆ«ì-ìˆ«ìë§Œ)</label>
                <label class="radio-label"><input type="radio" name="patternMode" value="prefix-suffix"> ì—„ê²© ëª¨ë“œ (ì ‘ë¯¸ì‚¬/ì ‘ë‘ì‚¬)</label>
                <label class="radio-label"><input type="radio" name="patternMode" value="intelligent"> ì§€ëŠ¥ì  ë¶„ë¥˜ (ë©”íƒ€ë°ì´í„° ê¸°ë°˜)</label>
            </div>
            <div class="option-box">
                <span class="option-title">ğŸ”§ ì‘ì—… ë°©ì‹</span>
                <label class="radio-label"><input type="radio" name="mode" value="copy" checked> ë³µì‚¬ (ì•ˆì „: ì›ë³¸ ìœ ì§€)</label>
                <label class="radio-label"><input type="radio" name="mode" value="move"> ì´ë™ (ì£¼ì˜: ì›ë³¸ ì‚­ì œ)</label>
            </div>
            <div class="option-box">
                <span class="option-title">ğŸ“ ê³ ê¸‰ ê¸°ëŠ¥</span>
                <label class="radio-label"><input type="checkbox" id="enableRename" checked> íŒŒì¼ëª… ìë™ ì²´ê³„í™”</label>
                <label class="radio-label"><input type="checkbox" id="enableDuplicateCheck"> ì¤‘ë³µ íŒŒì¼ íƒì§€</label>
            </div>
            <div class="option-box">
                <span class="option-title">âš ï¸ ì¤‘ë³µ ì²˜ë¦¬</span>
                <label class="radio-label"><input type="radio" name="conflict" value="rename" checked> ì´ë¦„ ë³€ê²½ (ë²ˆí˜¸ ì¶”ê°€)</label>
                <label class="radio-label"><input type="radio" name="conflict" value="skip"> ê±´ë„ˆë›°ê¸°</label>
            </div>
        </div>
    </div>

    <!-- 3ë‹¨ê³„: ë¶„ì„ ë° ì‹¤í–‰ -->
    <div class="card">
        <div class="section-header"><span class="step-badge">3ë‹¨ê³„</span> ë¶„ì„ ë° ì‹¤í–‰</div>
        
        <!-- ë¶„ì„ ë²„íŠ¼ -->
        <button id="btnAnalyze" class="btn btn-analyze" disabled>ğŸ” 1ì°¨ ë¶„ì„ ë° ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘</button>

        <!-- ì—„ê²© ëª¨ë“œ ë¶„ì„ ê²°ê³¼ í‘œì‹œ ì˜ì—­ -->
        <div id="strictModeContainer" style="display:none; margin-bottom:20px;"></div>

        <!-- ë¶„ì„ ê²°ê³¼ í‘œì‹œ (ì´ˆê¸° ìˆ¨ê¹€) -->
        <div id="analysisSection" class="analysis-result">
            <div id="analysisSummary" class="analysis-summary"></div>
            <div id="analysisDetail" class="analysis-detail"></div>
            <div style="margin-top:15px; font-weight:bold; color:#dc2626;">ìœ„ ë‚´ìš©ì„ í™•ì¸í•˜ì…¨ìŠµë‹ˆê¹Œ? ì‹¤ì œ ì‘ì—…ì„ ì§„í–‰í•˜ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.</div>
        </div>

        <!-- ì‹¤í–‰ ë²„íŠ¼ (ë¶„ì„ í›„ í‘œì‹œ) -->
        <button id="btnExecute" class="btn btn-execute">ğŸš€ ìŠ¹ì¸ ë° ë¶„ë¥˜ ì‹¤í–‰</button>
        
        <!-- ë¡¤ë°± ë²„íŠ¼ (ì‹¤í–‰ í›„ í‘œì‹œ) -->
        <button id="btnRollback" class="btn" style="background:#dc2626; color:white; border:none; text-align:center; justify-content:center; font-size:1.1rem; padding:16px; display:none; margin-top:10px;">
            âª ë§ˆì§€ë§‰ ì‘ì—… ë¡¤ë°±
        </button>

        <!-- ì§„í–‰ë°” -->
        <div id="progressWrap" class="progress-wrap">
            <div class="progress-bar"><div id="progressFill" class="progress-fill"></div></div>
            <div id="progressText" class="progress-text">0%</div>
        </div>

        <!-- í†µí•© ëŒ€ì‹œë³´ë“œ (ë©€í‹° ë“œë¼ì´ë¸Œ ìŠ¤ìº” í›„ í‘œì‹œ) -->
        <div id="dashboardSection" style="display:none; margin-top:20px;">
            <div class="section-header">ğŸ“Š í†µí•© ëŒ€ì‹œë³´ë“œ</div>
            <div id="dashboardContent" style="background:#f8fafc; padding:20px; border-radius:8px; border:1px solid #e2e8f0;">
                <!-- ëŒ€ì‹œë³´ë“œ ë‚´ìš©ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ë¶„ì„ ëŒ€ì‹œë³´ë“œ (ë‹¨ê¸° í™•ì¥) -->
        <div class="card" id="realtimeDashboardCard" style="display:none; margin-top:20px;">
            <div class="section-header">
                <span class="step-badge">ë‹¨ê¸° í™•ì¥</span>
                ğŸ“ˆ ì‹¤ì‹œê°„ ë¶„ì„ ëŒ€ì‹œë³´ë“œ
            </div>
            <div id="realtimeDashboardContent" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px; margin-top:15px;">
                <div style="background:#f1f5f9; padding:15px; border-radius:8px;">
                    <div style="font-size:0.9rem; color:#64748b; margin-bottom:5px;">ì´ ë¶„ì„ íŒŒì¼</div>
                    <div id="dashboardTotalFiles" style="font-size:1.5rem; font-weight:700; color:#2563eb;">0</div>
                </div>
                <div style="background:#f1f5f9; padding:15px; border-radius:8px;">
                    <div style="font-size:0.9rem; color:#64748b; margin-bottom:5px;">íŒ¨í„´ ë§¤ì¹­</div>
                    <div id="dashboardMatchedFiles" style="font-size:1.5rem; font-weight:700; color:#16a34a;">0</div>
                </div>
                <div style="background:#f1f5f9; padding:15px; border-radius:8px;">
                    <div style="font-size:0.9rem; color:#64748b; margin-bottom:5px;">íŒ¨í„´ ë¯¸ë§¤ì¹­</div>
                    <div id="dashboardUnmatchedFiles" style="font-size:1.5rem; font-weight:700; color:#dc2626;">0</div>
                </div>
                <div style="background:#f1f5f9; padding:15px; border-radius:8px;">
                    <div style="font-size:0.9rem; color:#64748b; margin-bottom:5px;">ì‹ ë¢°ë„ í‰ê· </div>
                    <div id="dashboardAvgConfidence" style="font-size:1.5rem; font-weight:700; color:#ca8a04;">0%</div>
                </div>
            </div>
            <div id="realtimeChartContainer" style="margin-top:20px; padding:15px; background:#f8fafc; border-radius:8px; min-height:200px;">
                <div style="text-align:center; color:#94a3b8; padding:50px;">ì°¨íŠ¸ ì˜ì—­ (í–¥í›„ êµ¬í˜„)</div>
            </div>
        </div>

        <!-- ë¶„ë¥˜ íˆìŠ¤í† ë¦¬ (ë‹¨ê¸° í™•ì¥) -->
        <div class="card" id="historyCard" style="display:none; margin-top:20px;">
            <div class="section-header">
                <span class="step-badge">ë‹¨ê¸° í™•ì¥</span>
                ğŸ“œ ë¶„ë¥˜ íˆìŠ¤í† ë¦¬
            </div>
            <div style="margin-bottom:15px;">
                <button id="btnShowHistory" class="btn" style="width:auto; display:inline-flex; margin-right:10px;">ğŸ“œ íˆìŠ¤í† ë¦¬ ë³´ê¸°</button>
                <button id="btnClearHistory" class="btn" style="width:auto; display:inline-flex; margin-right:10px; background:#dc2626; color:white;">ğŸ—‘ï¸ íˆìŠ¤í† ë¦¬ ì‚­ì œ</button>
                <button id="btnHistoryStats" class="btn" style="width:auto; display:inline-flex;">ğŸ“Š í†µê³„ ë³´ê¸°</button>
            </div>
            <div id="historyContent" style="max-height:400px; overflow-y:auto;">
                <div style="text-align:center; color:#94a3b8; padding:20px;">íˆìŠ¤í† ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
            </div>
        </div>

        <!-- ìŠ¤ë§ˆíŠ¸ ê²€ìƒ‰ (ë©€í‹° ë“œë¼ì´ë¸Œ ìŠ¤ìº” í›„ í‘œì‹œ) -->
        <div id="searchSection" style="display:none; margin-top:20px;">
            <div class="section-header">ğŸ” ìŠ¤ë§ˆíŠ¸ ê²€ìƒ‰</div>
            <div style="display:flex; gap:10px; margin-bottom:15px;">
                <input type="text" id="searchInput" placeholder="íŒŒì¼ëª…, ë©”íƒ€ë°ì´í„°ë¡œ ê²€ìƒ‰..." 
                       style="flex:1; padding:12px; border:1px solid #cbd5e1; border-radius:6px; font-size:0.95rem;">
                <button id="btnSearch" class="btn" style="width:auto; padding:12px 20px; background:var(--primary); color:white; border:none;">
                    ğŸ” ê²€ìƒ‰
                </button>
            </div>
            <div id="searchResults" class="table-container" style="display:none;">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 25%;">íŒŒì¼ëª…</th>
                            <th style="width: 20%;">ìœ„ì¹˜</th>
                            <th style="width: 10%;">í¬ê¸°</th>
                            <th style="width: 15%;">ë‚ ì§œ</th>
                            <th style="width: 20%;">íƒœê·¸</th>
                            <th style="width: 10%;">ì ìˆ˜</th>
                        </tr>
                    </thead>
                    <tbody id="searchResultsBody">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- ê²°ê³¼ í…Œì´ë¸” -->
        <div class="section-header" style="margin-top:20px;">ğŸ“‹ ìƒì„¸ ì²˜ë¦¬ ë‚´ì—­</div>
        <div class="table-container">
            <table id="resultTable">
                <thead>
                    <tr>
                        <th style="width: 30%;">ì›ë³¸ íŒŒì¼ëª…</th>
                        <th style="width: 40%;">ì´ë™ ê²½ë¡œ (ëŒ€ìƒ í´ë”)</th>
                        <th style="width: 15%;">ìƒíƒœ</th>
                        <th style="width: 15%;">ë¹„ê³ </th>
                    </tr>
                </thead>
                <tbody id="resultBody">
                    <tr><td colspan="4" style="text-align:center; color:#94a3b8;">ë¶„ì„ ì‹œì‘ ì „ì…ë‹ˆë‹¤.</td></tr>
                </tbody>
            </table>
        </div>
        <button id="btnDownload" class="btn btn-download" style="display:none;">ğŸ’¾ ë‚´ì—­ ë‹¤ìš´ë¡œë“œ (.csv)</button>
    </div>
</div>

<script>
    // ========================================================================
    // CLEAN ARCHITECTURE FRAMEWORK - í´ë¦° ì•„í‚¤í…ì²˜ í”„ë ˆì„ì›Œí¬
    // ========================================================================
    (function CleanArchitectureFramework() {
        'use strict';

        // ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì´ˆê¸°í™”
        window.Domain = window.Domain || {};
        window.Application = window.Application || {};
        window.Infrastructure = window.Infrastructure || {};
        window.Presentation = window.Presentation || {};
        window.StrictMode = window.StrictMode || {};
        window.ErrorHandler = window.ErrorHandler || {};
        window.PerformanceEngine = window.PerformanceEngine || {};
        window.ExecutionMode = window.ExecutionMode || {};

        // Domain Layer: ì ‘ë¯¸ì‚¬/ì ‘ë‘ì‚¬ ë¶„ì„ ì—”í‹°í‹°
        window.Domain.PrefixSuffixPattern = (function() {
            function PrefixSuffixPattern(data) {
                this.prefix = data.prefix || '';
                this.suffix = data.suffix || '';
                this.pattern = data.pattern || '';
                this.confidence = data.confidence || 0;
                this.frequency = data.frequency || 0;
                this.examples = data.examples || [];
            }

            PrefixSuffixPattern.prototype.isValid = function() {
                return (this.prefix || this.suffix) && this.confidence > 0.5;
            };

            PrefixSuffixPattern.prototype.toPlainObject = function() {
                return {
                    prefix: this.prefix,
                    suffix: this.suffix,
                    pattern: this.pattern,
                    confidence: this.confidence,
                    frequency: this.frequency,
                    examples: this.examples
                };
            };

            return PrefixSuffixPattern;
        })();

        // Domain Layer: ìˆ«ì-ìˆ«ì íŒ¨í„´ ì—”í‹°í‹°
        window.Domain.NumberNumberPattern = (function() {
            function NumberNumberPattern(data) {
                this.pattern = data.pattern || '';
                this.leftPart = data.leftPart || '';
                this.rightPart = data.rightPart || '';
                this.separator = data.separator || '-';
                this.confidence = data.confidence || 0;
                this.frequency = data.frequency || 0;
                this.examples = data.examples || [];
                this.leftLength = data.leftLength || 0;
                this.rightLength = data.rightLength || 0;
            }

            NumberNumberPattern.prototype.isValid = function() {
                return this.pattern && this.confidence > 0.5;
            };

            NumberNumberPattern.prototype.toPlainObject = function() {
                return {
                    pattern: this.pattern,
                    leftPart: this.leftPart,
                    rightPart: this.rightPart,
                    separator: this.separator,
                    confidence: this.confidence,
                    frequency: this.frequency,
                    examples: this.examples,
                    leftLength: this.leftLength,
                    rightLength: this.rightLength
                };
            };

            NumberNumberPattern.prototype.validate = function(value) {
                const str = String(value).trim();
                // íŒŒì¼ëª… ì „ì²´ì—ì„œ ìˆ«ì-ìˆ«ì íŒ¨í„´ ì°¾ê¸° (ì•ë’¤ì— ë‹¤ë¥¸ ë¬¸ìê°€ ìˆì–´ë„ ë¨)
                const escapedSep = this.separator.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`\\d{${this.leftLength}}${escapedSep}\\d{${this.rightLength}}`);
                return {
                    valid: regex.test(str),
                    reason: regex.test(str) ? 'Valid' : `í˜•ì‹ì´ ë§ì§€ ì•ŠìŠµë‹ˆë‹¤ (ì˜ˆ: ${this.pattern})`
                };
            };

            return NumberNumberPattern;
        })();

        // Domain Layer: ê·œì¹™ì„± ë¶„ì„ ê²°ê³¼
        window.Domain.PatternAnalysis = (function() {
            function PatternAnalysis(data) {
                this.prefixPatterns = (data.prefixPatterns || []).map(p => 
                    new window.Domain.PrefixSuffixPattern(p)
                );
                this.suffixPatterns = (data.suffixPatterns || []).map(p => 
                    new window.Domain.PrefixSuffixPattern(p)
                );
                this.numberNumberPatterns = (data.numberNumberPatterns || []).map(p => 
                    new window.Domain.NumberNumberPattern(p)
                );
                this.totalItems = data.totalItems || 0;
                this.analyzedItems = data.analyzedItems || 0;
                this.confidence = data.confidence || 0;
                this.timestamp = data.timestamp || new Date().toISOString();
            }

            PatternAnalysis.prototype.getBestPrefix = function() {
                if (this.prefixPatterns.length === 0) return null;
                return this.prefixPatterns.reduce((best, current) => 
                    current.confidence > best.confidence ? current : best
                );
            };

            PatternAnalysis.prototype.getBestSuffix = function() {
                if (this.suffixPatterns.length === 0) return null;
                return this.suffixPatterns.reduce((best, current) => 
                    current.confidence > best.confidence ? current : best
                );
            };

            PatternAnalysis.prototype.getBestNumberNumber = function() {
                if (this.numberNumberPatterns.length === 0) return null;
                return this.numberNumberPatterns.reduce((best, current) => 
                    current.confidence > best.confidence ? current : best
                );
            };

            PatternAnalysis.prototype.toPlainObject = function() {
                return {
                    prefixPatterns: this.prefixPatterns.map(p => p.toPlainObject()),
                    suffixPatterns: this.suffixPatterns.map(p => p.toPlainObject()),
                    numberNumberPatterns: this.numberNumberPatterns.map(p => p.toPlainObject()),
                    totalItems: this.totalItems,
                    analyzedItems: this.analyzedItems,
                    confidence: this.confidence,
                    timestamp: this.timestamp
                };
            };

            return PatternAnalysis;
        })();

        // Domain Layer: íŒŒì¼ ë©”íƒ€ë°ì´í„° ì—”í‹°í‹°
        window.Domain.FileMetadata = (function() {
            function FileMetadata(data) {
                this.name = data.name || '';
                this.size = data.size || 0;
                this.type = data.type || '';
                this.createdDate = data.createdDate || null;
                this.modifiedDate = data.modifiedDate || null;
                this.location = data.location || '';
                this.hash = data.hash || '';
                this.category = data.category || '';
                this.tags = data.tags || [];
                this.author = data.author || '';
            }

            FileMetadata.prototype.toPlainObject = function() {
                return {
                    name: this.name,
                    size: this.size,
                    type: this.type,
                    createdDate: this.createdDate,
                    modifiedDate: this.modifiedDate,
                    location: this.location,
                    hash: this.hash,
                    category: this.category,
                    tags: this.tags,
                    author: this.author
                };
            };

            return FileMetadata;
        })();

        // Domain Layer: ì¤‘ë³µ íŒŒì¼ ì—”í‹°í‹°
        window.Domain.DuplicateFile = (function() {
            function DuplicateFile(data) {
                this.original = data.original || null;
                this.duplicates = data.duplicates || [];
                this.hash = data.hash || '';
                this.size = data.size || 0;
                this.count = data.count || 0;
            }

            DuplicateFile.prototype.toPlainObject = function() {
                return {
                    original: this.original,
                    duplicates: this.duplicates,
                    hash: this.hash,
                    size: this.size,
                    count: this.count
                };
            };

            return DuplicateFile;
        })();

        // Domain Layer: íŒŒì¼ëª… ê·œì¹™ ì—”í‹°í‹°
        window.Domain.NamingRule = (function() {
            function NamingRule(data) {
                this.pattern = data.pattern || '';
                this.variables = data.variables || [];
                this.validation = data.validation || null;
                this.example = data.example || '';
            }

            NamingRule.prototype.generateName = function(file, metadata) {
                let name = this.pattern;
                this.variables.forEach(variable => {
                    const value = this._getVariableValue(variable, file, metadata);
                    name = name.replace(`{${variable}}`, value);
                });
                return name;
            };

            NamingRule.prototype._getVariableValue = function(variable, file, metadata) {
                switch(variable) {
                    case 'date': return this._formatDate(metadata?.createdDate || new Date());
                    case 'project': return metadata?.category || 'ê¸°íƒ€';
                    case 'category': return metadata?.category || 'ë¬¸ì„œ';
                    case 'index': return '001';
                    case 'name': return file.name || 'íŒŒì¼';
                    case 'ext': return this._getExtension(file.name || '');
                    default: return '';
                }
            };

            NamingRule.prototype._formatDate = function(date) {
                const d = new Date(date);
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            NamingRule.prototype._getExtension = function(filename) {
                const parts = filename.split('.');
                return parts.length > 1 ? parts[parts.length - 1] : '';
            };

            NamingRule.prototype.toPlainObject = function() {
                return {
                    pattern: this.pattern,
                    variables: this.variables,
                    validation: this.validation,
                    example: this.example
                };
            };

            return NamingRule;
        })();

        // Domain Layer: ìŠ¤ëƒ…ìƒ· ì—”í‹°í‹°
        window.Domain.Snapshot = (function() {
            function Snapshot(data) {
                this.id = data.id || Date.now().toString();
                this.timestamp = data.timestamp || new Date().toISOString();
                this.operation = data.operation || ''; // 'copy' | 'move' | 'rename'
                this.files = data.files || []; // [{ original, target, status }]
                this.totalFiles = data.totalFiles || 0;
                this.successCount = data.successCount || 0;
                this.failCount = data.failCount || 0;
            }

            Snapshot.prototype.toPlainObject = function() {
                return {
                    id: this.id,
                    timestamp: this.timestamp,
                    operation: this.operation,
                    files: this.files,
                    totalFiles: this.totalFiles,
                    successCount: this.successCount,
                    failCount: this.failCount
                };
            };

            return Snapshot;
        })();

        // Domain Layer: ë°°ì¹˜ ì‘ì—… ê²°ê³¼ ì—”í‹°í‹°
        window.Domain.BatchOperationResult = (function() {
            function BatchOperationResult(data) {
                this.success = data.success || false;
                this.processed = data.processed || 0;
                this.successCount = data.successCount || 0;
                this.failCount = data.failCount || 0;
                this.errors = data.errors || [];
                this.snapshotId = data.snapshotId || null;
            }

            BatchOperationResult.prototype.toPlainObject = function() {
                return {
                    success: this.success,
                    processed: this.processed,
                    successCount: this.successCount,
                    failCount: this.failCount,
                    errors: this.errors,
                    snapshotId: this.snapshotId
                };
            };

            return BatchOperationResult;
        })();

        // Application Layer: ì§€ëŠ¥ì  ë¶„ë¥˜ ìœ ìŠ¤ì¼€ì´ìŠ¤
        window.Application.IntelligentClassificationUseCases = (function() {
            function IntelligentClassificationUseCases(metadataExtractor) {
                this.metadataExtractor = metadataExtractor;
            }

            IntelligentClassificationUseCases.prototype.classifyByMetadata = function(file, metadata) {
                if (!metadata) return 'ê¸°íƒ€';

                // ë‚ ì§œ ê¸°ë°˜ ë¶„ë¥˜
                if (metadata.createdDate) {
                    const date = new Date(metadata.createdDate);
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    return `${year}/${month}`;
                }

                // íŒŒì¼ ìœ í˜• ê¸°ë°˜ ë¶„ë¥˜
                if (metadata.type) {
                    const type = metadata.type.toLowerCase();
                    if (type.includes('image')) return 'ì´ë¯¸ì§€';
                    if (type.includes('video')) return 'ë¹„ë””ì˜¤';
                    if (type.includes('audio')) return 'ì˜¤ë””ì˜¤';
                    if (type.includes('pdf')) return 'ë¬¸ì„œ/PDF';
                    if (type.includes('word') || type.includes('excel') || type.includes('powerpoint')) return 'ë¬¸ì„œ/ì˜¤í”¼ìŠ¤';
                }

                return 'ê¸°íƒ€';
            };

            IntelligentClassificationUseCases.prototype.suggestFolderStructure = function(files) {
                const structure = {};
                files.forEach(file => {
                    const category = this.classifyByMetadata(file, file.metadata);
                    if (!structure[category]) {
                        structure[category] = [];
                    }
                    structure[category].push(file);
                });
                return structure;
            };

            return IntelligentClassificationUseCases;
        })();

        // Application Layer: íŒŒì¼ëª… ê´€ë¦¬ ìœ ìŠ¤ì¼€ì´ìŠ¤
        window.Application.FileNamingUseCases = (function() {
            function FileNamingUseCases() {
                this.defaultRules = [
                    new window.Domain.NamingRule({
                        pattern: '{date}_{project}_{category}_{index}.{ext}',
                        variables: ['date', 'project', 'category', 'index', 'ext'],
                        example: '2024-01-15_í”„ë¡œì íŠ¸A_ë¬¸ì„œ_001.pdf'
                    }),
                    new window.Domain.NamingRule({
                        pattern: '{category}_{project}_{date}_{index}.{ext}',
                        variables: ['category', 'project', 'date', 'index', 'ext'],
                        example: 'ë¬¸ì„œ_í”„ë¡œì íŠ¸A_2024-01-15_001.pdf'
                    })
                ];
            }

            FileNamingUseCases.prototype.generateName = function(file, rule, metadata, index) {
                if (!rule) rule = this.defaultRules[0];
                const ruleWithIndex = new window.Domain.NamingRule({
                    ...rule.toPlainObject(),
                    variables: rule.variables.map(v => v === 'index' ? `index_${index}` : v)
                });
                ruleWithIndex._getVariableValue = function(variable, file, metadata) {
                    if (variable.startsWith('index_')) {
                        const idx = parseInt(variable.split('_')[1]) || 0;
                        return String(idx + 1).padStart(3, '0');
                    }
                    return rule._getVariableValue(variable, file, metadata);
                };
                return rule.generateName(file, metadata);
            };

            FileNamingUseCases.prototype.batchRename = function(files, rule, metadataList) {
                const results = [];
                files.forEach((file, index) => {
                    const metadata = metadataList[index];
                    const newName = this.generateName(file, rule, metadata, index);
                    results.push({
                        original: file.name,
                        newName: newName,
                        file: file
                    });
                });
                return results;
            };

            FileNamingUseCases.prototype.validateName = function(name, rule) {
                if (!rule || !rule.validation) return { valid: true };
                const regex = new RegExp(rule.validation);
                return {
                    valid: regex.test(name),
                    reason: regex.test(name) ? 'Valid' : 'íŒŒì¼ëª… í˜•ì‹ì´ ê·œì¹™ê³¼ ë§ì§€ ì•ŠìŠµë‹ˆë‹¤'
                };
            };

            return FileNamingUseCases;
        })();

        // Application Layer: ì¤‘ë³µ íƒì§€ ìœ ìŠ¤ì¼€ì´ìŠ¤
        window.Application.DuplicateDetectionUseCases = (function() {
            function DuplicateDetectionUseCases(hashCalculator) {
                this.hashCalculator = hashCalculator;
            }

            DuplicateDetectionUseCases.prototype.detectDuplicates = async function(files) {
                const hashMap = new Map();
                const duplicates = [];

                // í•´ì‹œ ê³„ì‚°
                for (const file of files) {
                    try {
                        const hash = await this.hashCalculator.calculateHash(file);
                        if (!hashMap.has(hash)) {
                            hashMap.set(hash, []);
                        }
                        hashMap.get(hash).push(file);
                    } catch (e) {
                        console.error('[DuplicateDetection] Hash calculation failed:', e);
                    }
                }

                // ì¤‘ë³µ ê·¸ë£¹ ìƒì„±
                hashMap.forEach((fileList, hash) => {
                    if (fileList.length > 1) {
                        const duplicate = new window.Domain.DuplicateFile({
                            original: fileList[0],
                            duplicates: fileList.slice(1),
                            hash: hash,
                            size: fileList[0].size || 0,
                            count: fileList.length
                        });
                        duplicates.push(duplicate);
                    }
                });

                return duplicates;
            };

            DuplicateDetectionUseCases.prototype.suggestAction = function(duplicate) {
                // ê°€ì¥ ì˜¤ë˜ëœ íŒŒì¼ì„ ì›ë³¸ìœ¼ë¡œ ì¶”ì²œ
                const allFiles = [duplicate.original, ...duplicate.duplicates];
                allFiles.sort((a, b) => {
                    const dateA = a.lastModified || 0;
                    const dateB = b.lastModified || 0;
                    return dateA - dateB;
                });
                return {
                    keep: allFiles[0],
                    remove: allFiles.slice(1),
                    action: 'keep_oldest'
                };
            };

            return DuplicateDetectionUseCases;
        })();

        // Application Layer: ë°°ì¹˜ ì‘ì—… ìœ ìŠ¤ì¼€ì´ìŠ¤
        window.Application.BatchOperationUseCases = (function() {
            function BatchOperationUseCases(snapshotRepository) {
                this.snapshotRepository = snapshotRepository;
            }

            BatchOperationUseCases.prototype.validateOperation = function(files, targetHandle, operation) {
                const errors = [];
                const warnings = [];

                // ìš©ëŸ‰ ê²€ì¦
                let totalSize = 0;
                files.forEach(file => {
                    if (file.size) totalSize += file.size;
                });
                if (totalSize > 1024 * 1024 * 1024 * 10) { // 10GB
                    warnings.push('ì´ íŒŒì¼ í¬ê¸°ê°€ 10GBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤. ì‘ì—… ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                }

                // íŒŒì¼ ìˆ˜ ê²€ì¦
                if (files.length > 1000) {
                    warnings.push('íŒŒì¼ ìˆ˜ê°€ 1000ê°œë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤. ì‘ì—… ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                }

                // ê¶Œí•œ ê²€ì¦ (ëŒ€ìƒ í´ë”)
                if (!targetHandle) {
                    errors.push('ëŒ€ìƒ í´ë”ê°€ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                }

                return {
                    valid: errors.length === 0,
                    errors: errors,
                    warnings: warnings,
                    totalSize: totalSize,
                    fileCount: files.length
                };
            };

            BatchOperationUseCases.prototype.createSnapshot = function(operation, files, executionPlan) {
                const snapshot = new window.Domain.Snapshot({
                    id: `snapshot_${Date.now()}`,
                    timestamp: new Date().toISOString(),
                    operation: operation,
                    files: executionPlan.map(plan => ({
                        original: {
                            name: plan.fileHandle.name,
                            path: plan.fileHandle.name,
                            size: plan.fileHandle.size || 0
                        },
                        target: plan.targetHandle ? {
                            name: plan.targetHandle.name,
                            path: plan.targetHandle.name
                        } : null,
                        status: plan.originalStatus,
                        renameResult: plan.renameResult
                    })),
                    totalFiles: files.length,
                    successCount: 0,
                    failCount: 0
                });

                if (this.snapshotRepository) {
                    this.snapshotRepository.save(snapshot);
                }

                return snapshot;
            };

            BatchOperationUseCases.prototype.rollback = async function(snapshot) {
                if (!snapshot) {
                    return { success: false, error: 'ìŠ¤ëƒ…ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.' };
                }

                const results = {
                    success: true,
                    rolledBack: 0,
                    errors: []
                };

                // ì´ë™ ì‘ì—…ì˜ ê²½ìš° ì›ë³¸ ìœ„ì¹˜ë¡œ ë³µì› ì‹œë„
                if (snapshot.operation === 'move') {
                    for (const fileInfo of snapshot.files) {
                        if (fileInfo.status === 'ë§¤ì¹­ ì„±ê³µ' && fileInfo.target) {
                            try {
                                // ë³µì› ë¡œì§ (ì‹¤ì œ êµ¬í˜„ì€ ë³µì¡í•¨)
                                results.rolledBack++;
                            } catch (e) {
                                results.success = false;
                                results.errors.push(`ë³µì› ì‹¤íŒ¨: ${fileInfo.original.name} - ${e.message}`);
                            }
                        }
                    }
                }

                return results;
            };

            return BatchOperationUseCases;
        })();

        // Infrastructure Layer: ìŠ¤ëƒ…ìƒ· ì €ì¥ì†Œ
        window.Infrastructure.SnapshotRepository = (function() {
            function SnapshotRepository(storageEngine) {
                this.storageEngine = storageEngine || new window.Infrastructure.StorageEngine();
                this.storeName = 'snapshots';
            }

            SnapshotRepository.prototype.save = function(snapshot) {
                const data = snapshot.toPlainObject ? snapshot.toPlainObject() : snapshot;
                return this.storageEngine.save(this.storeName, snapshot.id, data);
            };

            SnapshotRepository.prototype.load = function(snapshotId) {
                return this.storageEngine.load(this.storeName, snapshotId);
            };

            SnapshotRepository.prototype.loadAll = function() {
                return this.storageEngine.loadAll(this.storeName);
            };

            SnapshotRepository.prototype.delete = function(snapshotId) {
                return this.storageEngine.delete(this.storeName, snapshotId);
            };

            SnapshotRepository.prototype.getLatest = function() {
                return this.loadAll().then(snapshots => {
                    if (!snapshots || snapshots.length === 0) return null;
                    snapshots.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    return snapshots[0];
                });
            };

            return SnapshotRepository;
        })();

        // Domain Layer: í™•ì¥ ë©”íƒ€ë°ì´í„° ì—”í‹°í‹°
        window.Domain.ExtendedMetadata = (function() {
            function ExtendedMetadata(data) {
                this.basic = data.basic || null;
                this.exif = data.exif || null; // ì´ë¯¸ì§€ EXIF
                this.id3 = data.id3 || null; // ì˜¤ë””ì˜¤ ID3
                this.pdf = data.pdf || null; // PDF ë©”íƒ€ë°ì´í„°
                this.office = data.office || null; // Office ë¬¸ì„œ
                this.text = data.text || null; // í…ìŠ¤íŠ¸ ë‚´ìš© ìš”ì•½
                this.tags = data.tags || [];
                this.keywords = data.keywords || [];
            }

            ExtendedMetadata.prototype.toPlainObject = function() {
                return {
                    basic: this.basic,
                    exif: this.exif,
                    id3: this.id3,
                    pdf: this.pdf,
                    office: this.office,
                    text: this.text,
                    tags: this.tags,
                    keywords: this.keywords
                };
            };

            return ExtendedMetadata;
        })();

        // Domain Layer: íƒœê·¸ ì—”í‹°í‹°
        window.Domain.Tag = (function() {
            function Tag(data) {
                this.name = data.name || '';
                this.category = data.category || 'custom'; // 'auto', 'custom', 'ai'
                this.confidence = data.confidence || 1.0;
                this.createdAt = data.createdAt || new Date().toISOString();
            }

            Tag.prototype.toPlainObject = function() {
                return {
                    name: this.name,
                    category: this.category,
                    confidence: this.confidence,
                    createdAt: this.createdAt
                };
            };

            return Tag;
        })();

        // Infrastructure Layer: ë©”íƒ€ë°ì´í„° ì¶”ì¶œê¸° (í™•ì¥)
        window.Infrastructure.MetadataExtractor = (function() {
            function MetadataExtractor() {
                this.extractors = new Map();
            }

            MetadataExtractor.prototype.extractBasic = async function(fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    return new window.Domain.FileMetadata({
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        createdDate: file.lastModified,
                        modifiedDate: file.lastModified,
                        location: fileHandle.name || ''
                    });
                } catch (e) {
                    console.error('[MetadataExtractor] Basic extraction failed:', e);
                    return null;
                }
            };

            MetadataExtractor.prototype.extractExtended = async function(fileHandle) {
                const basic = await this.extractBasic(fileHandle);
                if (!basic) return null;

                // íŒŒì¼ëª…ì—ì„œ ì •ë³´ ì¶”ì¶œ
                const nameParts = basic.name.split('.');
                const ext = nameParts.length > 1 ? nameParts[nameParts.length - 1].toLowerCase() : '';
                
                // ë‚ ì§œ íŒ¨í„´ ì¶”ì¶œ
                const dateMatch = basic.name.match(/(\d{4}[-_]\d{2}[-_]\d{2})/);
                if (dateMatch) {
                    basic.createdDate = new Date(dateMatch[1].replace(/_/g, '-'));
                }

                // í”„ë¡œì íŠ¸ëª… ì¶”ì¶œ (íŒŒì¼ëª…ì—ì„œ)
                const projectMatch = basic.name.match(/í”„ë¡œì íŠ¸[A-Zê°€-í£0-9]+|project[A-Z0-9]+/i);
                if (projectMatch) {
                    basic.category = projectMatch[0];
                }

                // í™•ì¥ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
                const extended = new window.Domain.ExtendedMetadata({ basic: basic });

                // ì´ë¯¸ì§€ EXIF ì¶”ì¶œ
                if (this._isImageType(ext)) {
                    extended.exif = await this._extractExif(fileHandle);
                }

                // ì˜¤ë””ì˜¤ ID3 ì¶”ì¶œ
                if (this._isAudioType(ext)) {
                    extended.id3 = await this._extractId3(fileHandle);
                }

                // PDF ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
                if (ext === 'pdf') {
                    extended.pdf = await this._extractPdfMetadata(fileHandle);
                }

                // Office ë¬¸ì„œ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
                if (this._isOfficeType(ext)) {
                    extended.office = await this._extractOfficeMetadata(fileHandle);
                }

                // í…ìŠ¤íŠ¸ ë‚´ìš© ì¶”ì¶œ (ìš”ì•½)
                if (this._isTextType(ext)) {
                    extended.text = await this._extractTextContent(fileHandle);
                }

                return extended;
            };

            MetadataExtractor.prototype._isImageType = function(ext) {
                return ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff', 'tif'].includes(ext);
            };

            MetadataExtractor.prototype._isAudioType = function(ext) {
                return ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a', 'wma'].includes(ext);
            };

            MetadataExtractor.prototype._isOfficeType = function(ext) {
                return ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'].includes(ext);
            };

            MetadataExtractor.prototype._isTextType = function(ext) {
                return ['txt', 'md', 'json', 'xml', 'csv', 'log'].includes(ext);
            };

            MetadataExtractor.prototype._extractExif = async function(fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    const arrayBuffer = await file.slice(0, Math.min(file.size, 1024 * 1024)).arrayBuffer();
                    
                    // ê¸°ë³¸ EXIF ì •ë³´ ì¶”ì¶œ (ì‹¤ì œë¡œëŠ” EXIF.js ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•„ìš”)
                    // ì—¬ê¸°ì„œëŠ” ê¸°ë³¸ ì •ë³´ë§Œ ì¶”ì¶œ
                    return {
                        width: null,
                        height: null,
                        camera: null,
                        dateTaken: null,
                        location: null,
                        orientation: null
                    };
                } catch (e) {
                    console.error('[MetadataExtractor] EXIF extraction failed:', e);
                    return null;
                }
            };

            MetadataExtractor.prototype._extractId3 = async function(fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    const arrayBuffer = await file.slice(0, Math.min(file.size, 128)).arrayBuffer();
                    const dataView = new DataView(arrayBuffer);
                    
                    // ID3v1 íƒœê·¸ ì¶”ì¶œ (ê°„ë‹¨í•œ ë²„ì „)
                    const textDecoder = new TextDecoder('latin1');
                    const tag = textDecoder.decode(arrayBuffer.slice(0, 3));
                    
                    if (tag === 'TAG') {
                        return {
                            title: textDecoder.decode(arrayBuffer.slice(3, 33)).trim(),
                            artist: textDecoder.decode(arrayBuffer.slice(33, 63)).trim(),
                            album: textDecoder.decode(arrayBuffer.slice(63, 93)).trim(),
                            year: textDecoder.decode(arrayBuffer.slice(93, 97)).trim(),
                            genre: dataView.getUint8(127)
                        };
                    }
                    
                    return null;
                } catch (e) {
                    console.error('[MetadataExtractor] ID3 extraction failed:', e);
                    return null;
                }
            };

            MetadataExtractor.prototype._extractPdfMetadata = async function(fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    const arrayBuffer = await file.slice(0, Math.min(file.size, 1024 * 10)).arrayBuffer();
                    const textDecoder = new TextDecoder('utf-8');
                    const text = textDecoder.decode(arrayBuffer);
                    
                    // PDF ë©”íƒ€ë°ì´í„° ì¶”ì¶œ (ê°„ë‹¨í•œ ë²„ì „)
                    const titleMatch = text.match(/\/Title\s*\(([^)]+)\)/);
                    const authorMatch = text.match(/\/Author\s*\(([^)]+)\)/);
                    const subjectMatch = text.match(/\/Subject\s*\(([^)]+)\)/);
                    const keywordsMatch = text.match(/\/Keywords\s*\(([^)]+)\)/);
                    
                    return {
                        title: titleMatch ? titleMatch[1] : null,
                        author: authorMatch ? authorMatch[1] : null,
                        subject: subjectMatch ? subjectMatch[1] : null,
                        keywords: keywordsMatch ? keywordsMatch[1] : null,
                        pageCount: null
                    };
                } catch (e) {
                    console.error('[MetadataExtractor] PDF extraction failed:', e);
                    return null;
                }
            };

            MetadataExtractor.prototype._extractOfficeMetadata = async function(fileHandle) {
                try {
                    // Office ë¬¸ì„œëŠ” ZIP ê¸°ë°˜ì´ë¯€ë¡œ ë³µì¡í•¨
                    // ì—¬ê¸°ì„œëŠ” ê¸°ë³¸ ì •ë³´ë§Œ ë°˜í™˜
                    return {
                        title: null,
                        author: null,
                        subject: null,
                        keywords: null,
                        createdDate: null,
                        modifiedDate: null
                    };
                } catch (e) {
                    console.error('[MetadataExtractor] Office extraction failed:', e);
                    return null;
                }
            };

            MetadataExtractor.prototype._extractTextContent = async function(fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    const maxSize = 1024 * 100; // 100KBë§Œ ì½ê¸°
                    const arrayBuffer = await file.slice(0, Math.min(file.size, maxSize)).arrayBuffer();
                    const textDecoder = new TextDecoder('utf-8');
                    const text = textDecoder.decode(arrayBuffer);
                    
                    // í‚¤ì›Œë“œ ì¶”ì¶œ (ê°„ë‹¨í•œ ë²„ì „)
                    const words = text.toLowerCase().match(/\b\w{4,}\b/g) || [];
                    const wordCount = {};
                    words.forEach(word => {
                        wordCount[word] = (wordCount[word] || 0) + 1;
                    });
                    
                    const keywords = Object.entries(wordCount)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10)
                        .map(([word]) => word);
                    
                    return {
                        preview: text.substring(0, 500),
                        wordCount: words.length,
                        keywords: keywords,
                        language: this._detectLanguage(text)
                    };
                } catch (e) {
                    console.error('[MetadataExtractor] Text extraction failed:', e);
                    return null;
                }
            };

            MetadataExtractor.prototype._detectLanguage = function(text) {
                // ê°„ë‹¨í•œ ì–¸ì–´ ê°ì§€ (í•œê¸€/ì˜ì–´)
                const koreanChars = text.match(/[ê°€-í£]/g);
                const englishChars = text.match(/[a-zA-Z]/g);
                
                if (koreanChars && koreanChars.length > englishChars?.length) {
                    return 'ko';
                }
                return 'en';
            };

            return MetadataExtractor;
        })();

        // Application Layer: íƒœê·¸ ê´€ë¦¬ ìœ ìŠ¤ì¼€ì´ìŠ¤
        window.Application.TagManagementUseCases = (function() {
            function TagManagementUseCases() {
                this.autoTags = new Map();
            }

            TagManagementUseCases.prototype.generateAutoTags = function(metadata) {
                const tags = [];
                
                if (metadata.basic) {
                    // íŒŒì¼ ìœ í˜• ê¸°ë°˜ íƒœê·¸
                    const type = metadata.basic.type || '';
                    if (type.includes('image')) tags.push(new window.Domain.Tag({ name: 'ì´ë¯¸ì§€', category: 'auto' }));
                    if (type.includes('video')) tags.push(new window.Domain.Tag({ name: 'ë¹„ë””ì˜¤', category: 'auto' }));
                    if (type.includes('audio')) tags.push(new window.Domain.Tag({ name: 'ì˜¤ë””ì˜¤', category: 'auto' }));
                    if (type.includes('pdf')) tags.push(new window.Domain.Tag({ name: 'PDF', category: 'auto' }));
                    if (type.includes('word') || type.includes('excel') || type.includes('powerpoint')) {
                        tags.push(new window.Domain.Tag({ name: 'ì˜¤í”¼ìŠ¤', category: 'auto' }));
                    }

                    // ë‚ ì§œ ê¸°ë°˜ íƒœê·¸
                    if (metadata.basic.createdDate) {
                        const date = new Date(metadata.basic.createdDate);
                        const year = date.getFullYear();
                        tags.push(new window.Domain.Tag({ name: `${year}ë…„`, category: 'auto' }));
                        const month = date.getMonth() + 1;
                        tags.push(new window.Domain.Tag({ name: `${month}ì›”`, category: 'auto' }));
                    }
                }

                // EXIF ê¸°ë°˜ íƒœê·¸
                if (metadata.exif) {
                    if (metadata.exif.camera) {
                        tags.push(new window.Domain.Tag({ name: metadata.exif.camera, category: 'auto' }));
                    }
                }

                // ID3 ê¸°ë°˜ íƒœê·¸
                if (metadata.id3) {
                    if (metadata.id3.artist) {
                        tags.push(new window.Domain.Tag({ name: metadata.id3.artist, category: 'auto' }));
                    }
                    if (metadata.id3.album) {
                        tags.push(new window.Domain.Tag({ name: metadata.id3.album, category: 'auto' }));
                    }
                    if (metadata.id3.genre) {
                        tags.push(new window.Domain.Tag({ name: this._getGenreName(metadata.id3.genre), category: 'auto' }));
                    }
                }

                // PDF ë©”íƒ€ë°ì´í„° ê¸°ë°˜ íƒœê·¸
                if (metadata.pdf) {
                    if (metadata.pdf.subject) {
                        tags.push(new window.Domain.Tag({ name: metadata.pdf.subject, category: 'auto' }));
                    }
                }

                // í…ìŠ¤íŠ¸ í‚¤ì›Œë“œ ê¸°ë°˜ íƒœê·¸
                if (metadata.text && metadata.text.keywords) {
                    metadata.text.keywords.slice(0, 3).forEach(keyword => {
                        tags.push(new window.Domain.Tag({ name: keyword, category: 'auto', confidence: 0.7 }));
                    });
                }

                return tags;
            };

            TagManagementUseCases.prototype._getGenreName = function(genreCode) {
                const genres = [
                    'Blues', 'Classic Rock', 'Country', 'Dance', 'Disco', 'Funk', 'Grunge',
                    'Hip-Hop', 'Jazz', 'Metal', 'New Age', 'Oldies', 'Other', 'Pop', 'R&B',
                    'Rap', 'Reggae', 'Rock', 'Techno', 'Industrial', 'Alternative', 'Ska',
                    'Death Metal', 'Pranks', 'Soundtrack', 'Euro-Techno', 'Ambient', 'Trip-Hop',
                    'Vocal', 'Jazz+Funk', 'Fusion', 'Trance', 'Classical', 'Instrumental',
                    'Acid', 'House', 'Game', 'Sound Clip', 'Gospel', 'Noise', 'AlternRock',
                    'Bass', 'Soul', 'Punk', 'Space', 'Meditative', 'Instrumental Pop',
                    'Instrumental Rock', 'Ethnic', 'Gothic', 'Darkwave', 'Techno-Industrial',
                    'Electronic', 'Pop-Folk', 'Eurodance', 'Dream', 'Southern Rock', 'Comedy',
                    'Cult', 'Gangsta', 'Top 40', 'Christian Rap', 'Pop/Funk', 'Jungle',
                    'Native American', 'Cabaret', 'New Wave', 'Psychadelic', 'Rave', 'Showtunes',
                    'Trailer', 'Lo-Fi', 'Tribal', 'Acid Punk', 'Acid Jazz', 'Polka', 'Retro',
                    'Musical', 'Rock & Roll', 'Hard Rock'
                ];
                return genres[genreCode] || 'Unknown';
            };

            TagManagementUseCases.prototype.addCustomTag = function(tagName, category = 'custom') {
                return new window.Domain.Tag({ name: tagName, category: category });
            };

            TagManagementUseCases.prototype.searchByTags = function(files, tags) {
                return files.filter(file => {
                    if (!file.metadata || !file.metadata.tags) return false;
                    return tags.some(tag => 
                        file.metadata.tags.some(fileTag => 
                            fileTag.name.toLowerCase() === tag.toLowerCase()
                        )
                    );
                });
            };

            return TagManagementUseCases;
        })();

        // Application Layer: ìŠ¤ë§ˆíŠ¸ ê²€ìƒ‰ ìœ ìŠ¤ì¼€ì´ìŠ¤
        window.Application.SmartSearchUseCases = (function() {
            function SmartSearchUseCases() {
                this.index = new Map();
            }

            SmartSearchUseCases.prototype.indexFile = function(fileHandle, metadata) {
                const fileId = fileHandle.name + '_' + (fileHandle.size || 0);
                this.index.set(fileId, {
                    fileHandle: fileHandle,
                    metadata: metadata,
                    searchableText: this._extractSearchableText(metadata)
                });
            };

            SmartSearchUseCases.prototype._extractSearchableText = function(metadata) {
                const texts = [];
                
                if (metadata.basic) {
                    texts.push(metadata.basic.name || '');
                    texts.push(metadata.basic.category || '');
                }

                if (metadata.exif) {
                    if (metadata.exif.camera) texts.push(metadata.exif.camera);
                }

                if (metadata.id3) {
                    if (metadata.id3.title) texts.push(metadata.id3.title);
                    if (metadata.id3.artist) texts.push(metadata.id3.artist);
                    if (metadata.id3.album) texts.push(metadata.id3.album);
                }

                if (metadata.pdf) {
                    if (metadata.pdf.title) texts.push(metadata.pdf.title);
                    if (metadata.pdf.author) texts.push(metadata.pdf.author);
                    if (metadata.pdf.subject) texts.push(metadata.pdf.subject);
                    if (metadata.pdf.keywords) texts.push(metadata.pdf.keywords);
                }

                if (metadata.text) {
                    if (metadata.text.preview) texts.push(metadata.text.preview);
                    if (metadata.text.keywords) texts.push(metadata.text.keywords.join(' '));
                }

                if (metadata.tags) {
                    texts.push(metadata.tags.map(t => t.name).join(' '));
                }

                return texts.join(' ').toLowerCase();
            };

            SmartSearchUseCases.prototype.search = function(query, options = {}) {
                const results = [];
                const queryLower = query.toLowerCase();
                const queryWords = queryLower.split(/\s+/);

                this.index.forEach((entry, fileId) => {
                    const searchableText = entry.searchableText;
                    let score = 0;

                    // ì •í™•í•œ ì¼ì¹˜
                    if (searchableText.includes(queryLower)) {
                        score += 100;
                    }

                    // ë‹¨ì–´ë³„ ì¼ì¹˜
                    queryWords.forEach(word => {
                        if (searchableText.includes(word)) {
                            score += 10;
                        }
                    });

                    // íŒŒì¼ëª… ì¼ì¹˜ (ê°€ì¤‘ì¹˜ ë†’ìŒ)
                    if (entry.metadata.basic && entry.metadata.basic.name) {
                        if (entry.metadata.basic.name.toLowerCase().includes(queryLower)) {
                            score += 50;
                        }
                    }

                    if (score > 0) {
                        results.push({
                            fileHandle: entry.fileHandle,
                            metadata: entry.metadata,
                            score: score
                        });
                    }
                });

                // ì ìˆ˜ìˆœ ì •ë ¬
                results.sort((a, b) => b.score - a.score);

                // ê²°ê³¼ ì œí•œ
                if (options.limit) {
                    return results.slice(0, options.limit);
                }

                return results;
            };

            SmartSearchUseCases.prototype.advancedSearch = function(criteria) {
                const results = [];
                
                this.index.forEach((entry, fileId) => {
                    let matches = true;

                    // íŒŒì¼ëª… ê²€ìƒ‰
                    if (criteria.filename) {
                        const name = entry.metadata.basic?.name || '';
                        if (!name.toLowerCase().includes(criteria.filename.toLowerCase())) {
                            matches = false;
                        }
                    }

                    // íƒœê·¸ ê²€ìƒ‰
                    if (criteria.tags && criteria.tags.length > 0) {
                        const fileTags = entry.metadata.tags || [];
                        const hasTag = criteria.tags.some(tag =>
                            fileTags.some(ft => ft.name.toLowerCase() === tag.toLowerCase())
                        );
                        if (!hasTag) {
                            matches = false;
                        }
                    }

                    // ë‚ ì§œ ë²”ìœ„ ê²€ìƒ‰
                    if (criteria.dateFrom || criteria.dateTo) {
                        const fileDate = entry.metadata.basic?.createdDate;
                        if (fileDate) {
                            const date = new Date(fileDate);
                            if (criteria.dateFrom && date < new Date(criteria.dateFrom)) {
                                matches = false;
                            }
                            if (criteria.dateTo && date > new Date(criteria.dateTo)) {
                                matches = false;
                            }
                        }
                    }

                    // íŒŒì¼ ìœ í˜• ê²€ìƒ‰
                    if (criteria.fileType) {
                        const type = entry.metadata.basic?.type || '';
                        if (!type.includes(criteria.fileType)) {
                            matches = false;
                        }
                    }

                    if (matches) {
                        results.push({
                            fileHandle: entry.fileHandle,
                            metadata: entry.metadata
                        });
                    }
                });

                return results;
            };

            SmartSearchUseCases.prototype.clearIndex = function() {
                this.index.clear();
            };

            return SmartSearchUseCases;
        })();

        // Infrastructure Layer: ë©€í‹° ë“œë¼ì´ë¸Œ ìŠ¤ìºë„ˆ
        window.Infrastructure.MultiDriveScanner = (function() {
            function MultiDriveScanner() {
                this.scannedDrives = new Map();
                this.fileIndex = new Map();
            }

            MultiDriveScanner.prototype.scanDrives = async function(driveHandles) {
                const results = [];
                for (const driveHandle of driveHandles) {
                    try {
                        const files = await this._scanDirectory(driveHandle);
                        this.scannedDrives.set(driveHandle.name, {
                            handle: driveHandle,
                            files: files,
                            count: files.length
                        });
                        files.forEach(file => {
                            this.fileIndex.set(file.name, {
                                fileHandle: file,
                                drive: driveHandle.name,
                                location: driveHandle.name
                            });
                        });
                        results.push({
                            drive: driveHandle.name,
                            fileCount: files.length
                        });
                    } catch (e) {
                        console.error('[MultiDriveScanner] Scan failed:', e);
                        results.push({
                            drive: driveHandle.name,
                            fileCount: 0,
                            error: e.message
                        });
                    }
                }
                return results;
            };

            MultiDriveScanner.prototype._scanDirectory = async function(dirHandle, files = []) {
                try {
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file' && !entry.name.startsWith('.')) {
                            files.push(entry);
                        } else if (entry.kind === 'directory') {
                            await this._scanDirectory(entry, files);
                        }
                    }
                } catch (e) {
                    console.error('[MultiDriveScanner] Directory scan failed:', e);
                }
                return files;
            };

            MultiDriveScanner.prototype.searchAcrossDrives = function(query) {
                const results = [];
                this.fileIndex.forEach((fileInfo, fileName) => {
                    if (fileName.toLowerCase().includes(query.toLowerCase())) {
                        results.push(fileInfo);
                    }
                });
                return results;
            };

            MultiDriveScanner.prototype.getDriveStats = function() {
                const stats = [];
                this.scannedDrives.forEach((driveInfo, driveName) => {
                    stats.push({
                        drive: driveName,
                        fileCount: driveInfo.count,
                        files: driveInfo.files
                    });
                });
                return stats;
            };

            return MultiDriveScanner;
        })();

        // Infrastructure Layer: íŒŒì¼ í•´ì‹œ ê³„ì‚°ê¸°
        window.Infrastructure.FileHashCalculator = (function() {
            function FileHashCalculator() {}

            FileHashCalculator.prototype.calculateHash = async function(fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    const arrayBuffer = await file.slice(0, Math.min(file.size, 1024 * 1024)).arrayBuffer(); // ì²« 1MBë§Œ
                    const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                } catch (e) {
                    console.error('[FileHashCalculator] Hash calculation failed:', e);
                    // í´ë°±: íŒŒì¼ëª… + í¬ê¸° ê¸°ë°˜ í•´ì‹œ
                    const file = await fileHandle.getFile();
                    return await this._fallbackHash(file);
                }
            };

            FileHashCalculator.prototype._fallbackHash = async function(file) {
                const str = `${file.name}_${file.size}_${file.lastModified}`;
                const encoder = new TextEncoder();
                const data = encoder.encode(str);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            };

            return FileHashCalculator;
        })();

        // Application Layer: ìˆ«ì-ìˆ«ì íŒ¨í„´ ë¶„ì„ ìœ ìŠ¤ì¼€ì´ìŠ¤
        window.Application.NumberNumberAnalysisUseCases = (function() {
            function NumberNumberAnalysisUseCases(repository) {
                this.repository = repository;
            }

            NumberNumberAnalysisUseCases.prototype.analyzePatterns = function(items, fieldName) {
                if (!Array.isArray(items) || items.length === 0) {
                    return [];
                }

                const values = items.map(item => {
                    const value = item[fieldName] || item.name || '';
                    return String(value).trim();
                }).filter(v => v.length > 0);

                if (values.length === 0) {
                    return [];
                }

                const patternMap = new Map();
                const separators = ['-', '_', '.', '/', ' '];

                values.forEach(value => {
                    // íŒŒì¼ëª… ì „ì²´ì—ì„œ ìˆ«ì-ìˆ«ì íŒ¨í„´ ì°¾ê¸° (ì•ë’¤ì— ë‹¤ë¥¸ ë¬¸ìê°€ ìˆì–´ë„ ë¨)
                    separators.forEach(sep => {
                        // ì •ê·œì‹ìœ¼ë¡œ ìˆ«ì-ìˆ«ì íŒ¨í„´ ì°¾ê¸° (ì•ë’¤ì— ì„ì˜ì˜ ë¬¸ìê°€ ìˆì–´ë„ ë¨)
                        const escapedSep = sep.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const regex = new RegExp(`(\\d+)${escapedSep}(\\d+)`, 'g');
                        let match;
                        
                        while ((match = regex.exec(value)) !== null) {
                            const left = match[1];
                            const right = match[2];
                            const patternKey = `${left.length}${sep}${right.length}`;
                            
                            if (!patternMap.has(patternKey)) {
                                patternMap.set(patternKey, {
                                    pattern: `${left}${sep}${right}`,
                                    leftPart: left,
                                    rightPart: right,
                                    separator: sep,
                                    leftLength: left.length,
                                    rightLength: right.length,
                                    frequency: 0,
                                    examples: []
                                });
                            }
                            
                            const entry = patternMap.get(patternKey);
                            entry.frequency++;
                            if (entry.examples.length < 5) {
                                entry.examples.push(value);
                            }
                        }
                    });
                });

                const patterns = Array.from(patternMap.values())
                    .filter(p => {
                        // í•„í„°ë§ ì¡°ê±´ ì™„í™”: ìµœì†Œ ë¹ˆë„ 2ê°œ ì´ìƒì´ê±°ë‚˜ ì „ì²´ì˜ 3% ì´ìƒ
                        const minFrequency = Math.max(2, Math.ceil(values.length * 0.03));
                        const frequencyRatio = p.frequency / values.length;
                        const consistency = p.examples.length >= 3 ? 1.0 : 0.8;
                        return (p.frequency >= minFrequency || frequencyRatio >= 0.03) && consistency > 0.5;
                    })
                    .map(p => {
                        const baseConfidence = Math.min(1.0, p.frequency / values.length);
                        const consistencyWeight = p.examples.length >= 5 ? 1.1 : 1.0;
                        const lengthConsistency = (p.leftLength === p.rightLength) ? 1.05 : 1.0;
                        const confidence = Math.min(1.0, baseConfidence * consistencyWeight * lengthConsistency);
                        
                        return new window.Domain.NumberNumberPattern({
                            pattern: `${'0'.repeat(p.leftLength)}${p.separator}${'0'.repeat(p.rightLength)}`,
                            leftPart: p.leftPart,
                            rightPart: p.rightPart,
                            separator: p.separator,
                            confidence: confidence,
                            frequency: p.frequency,
                            examples: p.examples,
                            leftLength: p.leftLength,
                            rightLength: p.rightLength
                        });
                    })
                    .sort((a, b) => {
                        if (Math.abs(a.confidence - b.confidence) > 0.001) {
                            return b.confidence - a.confidence;
                        }
                        if (Math.abs(a.frequency - b.frequency) > values.length * 0.1) {
                            return b.frequency - a.frequency;
                        }
                        const aConsistency = a.leftLength === a.rightLength ? 1 : 0;
                        const bConsistency = b.leftLength === b.rightLength ? 1 : 0;
                        return bConsistency - aConsistency;
                    })
                    .slice(0, 10);

                return patterns;
            };

            NumberNumberAnalysisUseCases.prototype.validateWithPattern = function(value, selectedPattern) {
                if (!selectedPattern || !value) {
                    return { valid: false, reason: 'No pattern or value' };
                }
                return selectedPattern.validate(value);
            };

            return NumberNumberAnalysisUseCases;
        })();

        // Application Layer: ì ‘ë¯¸ì‚¬/ì ‘ë‘ì‚¬ ë¶„ì„ ìœ ìŠ¤ì¼€ì´ìŠ¤
        window.Application.PrefixSuffixAnalysisUseCases = (function() {
            function PrefixSuffixAnalysisUseCases(repository) {
                this.repository = repository;
            }

            PrefixSuffixAnalysisUseCases.prototype.analyzePatterns = function(items, fieldName) {
                if (!Array.isArray(items) || items.length === 0) {
                    return new window.Domain.PatternAnalysis({
                        prefixPatterns: [],
                        suffixPatterns: [],
                        numberNumberPatterns: [],
                        totalItems: 0,
                        analyzedItems: 0,
                        confidence: 0
                    });
                }

                const values = items.map(item => {
                    const value = item[fieldName] || item.name || '';
                    return String(value).trim();
                }).filter(v => v.length > 0);

                if (values.length === 0) {
                    return new window.Domain.PatternAnalysis({
                        prefixPatterns: [],
                        suffixPatterns: [],
                        numberNumberPatterns: [],
                        totalItems: items.length,
                        analyzedItems: 0,
                        confidence: 0
                    });
                }

                const prefixPatterns = this._analyzePrefixes(values);
                const suffixPatterns = this._analyzeSuffixes(values);
                const confidence = this._calculateConfidence(prefixPatterns, suffixPatterns, values.length);

                return new window.Domain.PatternAnalysis({
                    prefixPatterns: prefixPatterns,
                    suffixPatterns: suffixPatterns,
                    numberNumberPatterns: [],
                    totalItems: items.length,
                    analyzedItems: values.length,
                    confidence: confidence,
                    timestamp: new Date().toISOString()
                });
            };

            PrefixSuffixAnalysisUseCases.prototype._analyzePrefixes = function(values) {
                const prefixMap = new Map();
                const minPrefixLength = 1;
                const maxPrefixLength = 10;

                values.forEach(value => {
                    for (let len = minPrefixLength; len <= Math.min(maxPrefixLength, value.length); len++) {
                        const prefix = value.substring(0, len);
                        if (!prefixMap.has(prefix)) {
                            prefixMap.set(prefix, {
                                prefix: prefix,
                                frequency: 0,
                                examples: [],
                                pattern: this._detectPatternType(prefix)
                            });
                        }
                        const entry = prefixMap.get(prefix);
                        entry.frequency++;
                        if (entry.examples.length < 5) {
                            entry.examples.push(value);
                        }
                    }
                });

                const patterns = Array.from(prefixMap.values())
                    .filter(p => {
                        // í•„í„°ë§ ì¡°ê±´ ì™„í™”: ìµœì†Œ ë¹ˆë„ 2ê°œ ì´ìƒì´ê±°ë‚˜ ì „ì²´ì˜ 3% ì´ìƒ
                        const minFrequency = Math.max(2, Math.ceil(values.length * 0.03));
                        const frequencyRatio = p.frequency / values.length;
                        const patternTypeConsistency = p.pattern !== 'mixed' ? 1.0 : 0.9;
                        return (p.frequency >= minFrequency || frequencyRatio >= 0.03) && patternTypeConsistency > 0.5;
                    })
                    .map(p => {
                        const baseConfidence = Math.min(1.0, p.frequency / values.length);
                        const patternTypeWeight = p.pattern !== 'mixed' ? 1.1 : 1.0;
                        const exampleWeight = p.examples.length >= 5 ? 1.05 : 1.0;
                        const lengthWeight = p.prefix.length >= 2 && p.prefix.length <= 8 ? 1.05 : 1.0;
                        const confidence = Math.min(1.0, baseConfidence * patternTypeWeight * exampleWeight * lengthWeight);
                        
                        return new window.Domain.PrefixSuffixPattern({
                            prefix: p.prefix,
                            suffix: '',
                            pattern: p.pattern,
                            confidence: confidence,
                            frequency: p.frequency,
                            examples: p.examples
                        });
                    })
                    .sort((a, b) => {
                        if (Math.abs(a.confidence - b.confidence) > 0.001) {
                            return b.confidence - a.confidence;
                        }
                        if (Math.abs(a.frequency - b.frequency) > values.length * 0.1) {
                            return b.frequency - a.frequency;
                        }
                        const aType = a.pattern !== 'mixed' ? 1 : 0;
                        const bType = b.pattern !== 'mixed' ? 1 : 0;
                        return bType - aType;
                    })
                    .slice(0, 10);

                return patterns;
            };

            PrefixSuffixAnalysisUseCases.prototype._analyzeSuffixes = function(values) {
                const suffixMap = new Map();
                const minSuffixLength = 1;
                const maxSuffixLength = 10;

                values.forEach(value => {
                    for (let len = minSuffixLength; len <= Math.min(maxSuffixLength, value.length); len++) {
                        const suffix = value.substring(value.length - len);
                        if (!suffixMap.has(suffix)) {
                            suffixMap.set(suffix, {
                                suffix: suffix,
                                frequency: 0,
                                examples: [],
                                pattern: this._detectPatternType(suffix)
                            });
                        }
                        const entry = suffixMap.get(suffix);
                        entry.frequency++;
                        if (entry.examples.length < 5) {
                            entry.examples.push(value);
                        }
                    }
                });

                const patterns = Array.from(suffixMap.values())
                    .filter(p => {
                        // í•„í„°ë§ ì¡°ê±´ ì™„í™”: ìµœì†Œ ë¹ˆë„ 2ê°œ ì´ìƒì´ê±°ë‚˜ ì „ì²´ì˜ 3% ì´ìƒ
                        const minFrequency = Math.max(2, Math.ceil(values.length * 0.03));
                        const frequencyRatio = p.frequency / values.length;
                        const patternTypeConsistency = p.pattern !== 'mixed' ? 1.0 : 0.9;
                        return (p.frequency >= minFrequency || frequencyRatio >= 0.03) && patternTypeConsistency > 0.5;
                    })
                    .map(p => {
                        const baseConfidence = Math.min(1.0, p.frequency / values.length);
                        const patternTypeWeight = p.pattern !== 'mixed' ? 1.1 : 1.0;
                        const exampleWeight = p.examples.length >= 5 ? 1.05 : 1.0;
                        const lengthWeight = p.suffix.length >= 2 && p.suffix.length <= 8 ? 1.05 : 1.0;
                        const confidence = Math.min(1.0, baseConfidence * patternTypeWeight * exampleWeight * lengthWeight);
                        
                        return new window.Domain.PrefixSuffixPattern({
                            prefix: '',
                            suffix: p.suffix,
                            pattern: p.pattern,
                            confidence: confidence,
                            frequency: p.frequency,
                            examples: p.examples
                        });
                    })
                    .sort((a, b) => {
                        if (Math.abs(a.confidence - b.confidence) > 0.001) {
                            return b.confidence - a.confidence;
                        }
                        if (Math.abs(a.frequency - b.frequency) > values.length * 0.1) {
                            return b.frequency - a.frequency;
                        }
                        const aType = a.pattern !== 'mixed' ? 1 : 0;
                        const bType = b.pattern !== 'mixed' ? 1 : 0;
                        return bType - aType;
                    })
                    .slice(0, 10);

                return patterns;
            };

            PrefixSuffixAnalysisUseCases.prototype._detectPatternType = function(str) {
                if (/^\d+$/.test(str)) return 'numeric';
                if (/^[A-Z]+$/i.test(str)) return 'alphabetic';
                if (/^[A-Z0-9]+$/i.test(str)) return 'alphanumeric';
                if (/^[ê°€-í£]+$/.test(str)) return 'korean';
                if (/^[ê°€-í£A-Z0-9]+$/.test(str)) return 'mixed';
                return 'mixed';
            };

            PrefixSuffixAnalysisUseCases.prototype._calculateConfidence = function(prefixPatterns, suffixPatterns, totalValues) {
                if (totalValues === 0) return 0;
                const prefixConfidence = prefixPatterns.length > 0 ? prefixPatterns[0].confidence : 0;
                const suffixConfidence = suffixPatterns.length > 0 ? suffixPatterns[0].confidence : 0;
                return Math.max(prefixConfidence, suffixConfidence);
            };

            PrefixSuffixAnalysisUseCases.prototype.validateWithPattern = function(value, selectedPattern) {
                if (!selectedPattern || !value) return { valid: false, reason: 'No pattern or value' };
                const strValue = String(value).trim();
                let valid = true;
                const reasons = [];
                if (selectedPattern.prefix && !strValue.startsWith(selectedPattern.prefix)) {
                    valid = false;
                    reasons.push(`ì ‘ë‘ì‚¬ "${selectedPattern.prefix}"ê°€ ì—†ìŠµë‹ˆë‹¤`);
                }
                if (selectedPattern.suffix && !strValue.endsWith(selectedPattern.suffix)) {
                    valid = false;
                    reasons.push(`ì ‘ë¯¸ì‚¬ "${selectedPattern.suffix}"ê°€ ì—†ìŠµë‹ˆë‹¤`);
                }
                return {
                    valid: valid,
                    reason: reasons.join(', ') || 'Valid',
                    pattern: selectedPattern
                };
            };

            return PrefixSuffixAnalysisUseCases;
        })();

        // Infrastructure Layer: ì €ì¥ì†Œ ì—”ì§„ (IndexedDB ì—…ê·¸ë ˆì´ë“œ)
        window.Infrastructure.StorageEngine = (function() {
            function StorageEngine() {
                this.dbName = 'FileClassifier';
                this.dbVersion = 2;
                this.db = null;
                this.useIndexedDB = false;
                this.fallbackToLocalStorage = true;
                this._initPromise = null;
            }

            // IndexedDB ì´ˆê¸°í™”
            StorageEngine.prototype.init = function() {
                if (this._initPromise) return this._initPromise;
                
                this._initPromise = new Promise((resolve, reject) => {
                    if (!('indexedDB' in window)) {
                        console.warn('[StorageEngine] IndexedDB not supported, using LocalStorage');
                        this.useIndexedDB = false;
                        resolve(false);
                        return;
                    }

                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => {
                        console.warn('[StorageEngine] IndexedDB open failed, using LocalStorage');
                        this.useIndexedDB = false;
                        resolve(false);
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        this.useIndexedDB = true;
                        console.log('[StorageEngine] IndexedDB initialized');
                        resolve(true);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // PatternAnalysis store
                        if (!db.objectStoreNames.contains('patternAnalysis')) {
                            const store = db.createObjectStore('patternAnalysis', { keyPath: 'id' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }

                        // FileMetadata store
                        if (!db.objectStoreNames.contains('fileMetadata')) {
                            const fileStore = db.createObjectStore('fileMetadata', { keyPath: 'id', autoIncrement: true });
                            fileStore.createIndex('name', 'name', { unique: false });
                            fileStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }

                        // ClassificationHistory store
                        if (!db.objectStoreNames.contains('classificationHistory')) {
                            const historyStore = db.createObjectStore('classificationHistory', { keyPath: 'id', autoIncrement: true });
                            historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                            historyStore.createIndex('fileName', 'fileName', { unique: false });
                        }
                    };
                });

                return this._initPromise;
            };

            // ì €ì¥ (IndexedDB ìš°ì„ , ì‹¤íŒ¨ ì‹œ LocalStorage)
            StorageEngine.prototype.save = function(storeName, key, data) {
                return this.init().then(() => {
                    if (this.useIndexedDB && this.db) {
                        return new Promise((resolve, reject) => {
                            try {
                                const transaction = this.db.transaction([storeName], 'readwrite');
                                const store = transaction.objectStore(storeName);
                                const dataWithKey = { ...data, id: key };
                                const request = store.put(dataWithKey);
                                
                                request.onsuccess = () => {
                                    this._saveToLocalStorage(storeName, key, data);
                                    resolve(true);
                                };
                                
                                request.onerror = () => {
                                    this._saveToLocalStorage(storeName, key, data);
                                    resolve(false);
                                };
                            } catch (e) {
                                console.error('[StorageEngine] IndexedDB save error:', e);
                                this._saveToLocalStorage(storeName, key, data);
                                resolve(false);
                            }
                        });
                    } else {
                        return this._saveToLocalStorage(storeName, key, data);
                    }
                });
            };

            // ë¡œë“œ (IndexedDB ìš°ì„ , ì‹¤íŒ¨ ì‹œ LocalStorage)
            StorageEngine.prototype.load = function(storeName, key) {
                return this.init().then(() => {
                    if (this.useIndexedDB && this.db) {
                        return new Promise((resolve) => {
                            try {
                                const transaction = this.db.transaction([storeName], 'readonly');
                                const store = transaction.objectStore(storeName);
                                const request = store.get(key);
                                
                                request.onsuccess = () => {
                                    if (request.result) {
                                        resolve(request.result);
                                    } else {
                                        resolve(this._loadFromLocalStorage(storeName, key));
                                    }
                                };
                                
                                request.onerror = () => {
                                    resolve(this._loadFromLocalStorage(storeName, key));
                                };
                            } catch (e) {
                                console.error('[StorageEngine] IndexedDB load error:', e);
                                resolve(this._loadFromLocalStorage(storeName, key));
                            }
                        });
                    } else {
                        return Promise.resolve(this._loadFromLocalStorage(storeName, key));
                    }
                });
            };

            // ì „ì²´ ë¡œë“œ
            StorageEngine.prototype.loadAll = function(storeName) {
                return this.init().then(() => {
                    if (this.useIndexedDB && this.db) {
                        return new Promise((resolve) => {
                            try {
                                const transaction = this.db.transaction([storeName], 'readonly');
                                const store = transaction.objectStore(storeName);
                                const request = store.getAll();
                                
                                request.onsuccess = () => resolve(request.result || []);
                                request.onerror = () => resolve(this._loadAllFromLocalStorage(storeName));
                            } catch (e) {
                                console.error('[StorageEngine] IndexedDB loadAll error:', e);
                                resolve(this._loadAllFromLocalStorage(storeName));
                            }
                        });
                    } else {
                        return Promise.resolve(this._loadAllFromLocalStorage(storeName));
                    }
                });
            };

            // ì‚­ì œ
            StorageEngine.prototype.delete = function(storeName, key) {
                return this.init().then(() => {
                    if (this.useIndexedDB && this.db) {
                        return new Promise((resolve) => {
                            try {
                                const transaction = this.db.transaction([storeName], 'readwrite');
                                const store = transaction.objectStore(storeName);
                                const request = store.delete(key);
                                
                                request.onsuccess = () => {
                                    this._deleteFromLocalStorage(storeName, key);
                                    resolve(true);
                                };
                                
                                request.onerror = () => {
                                    this._deleteFromLocalStorage(storeName, key);
                                    resolve(false);
                                };
                            } catch (e) {
                                console.error('[StorageEngine] IndexedDB delete error:', e);
                                this._deleteFromLocalStorage(storeName, key);
                                resolve(false);
                            }
                        });
                    } else {
                        this._deleteFromLocalStorage(storeName, key);
                        return Promise.resolve(true);
                    }
                });
            };

            // LocalStorage í´ë°± ë©”ì„œë“œ
            StorageEngine.prototype._saveToLocalStorage = function(storeName, key, data) {
                try {
                    const storageKey = `${this.dbName}_${storeName}_${key}`;
                    localStorage.setItem(storageKey, JSON.stringify(data));
                    return Promise.resolve(true);
                } catch (e) {
                    console.error('[StorageEngine] LocalStorage save failed:', e);
                    return Promise.resolve(false);
                }
            };

            StorageEngine.prototype._loadFromLocalStorage = function(storeName, key) {
                try {
                    const storageKey = `${this.dbName}_${storeName}_${key}`;
                    const data = localStorage.getItem(storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    console.error('[StorageEngine] LocalStorage load failed:', e);
                    return null;
                }
            };

            StorageEngine.prototype._loadAllFromLocalStorage = function(storeName) {
                try {
                    const prefix = `${this.dbName}_${storeName}_`;
                    const results = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith(prefix)) {
                            const data = localStorage.getItem(key);
                            if (data) {
                                results.push(JSON.parse(data));
                            }
                        }
                    }
                    return results;
                } catch (e) {
                    console.error('[StorageEngine] LocalStorage loadAll failed:', e);
                    return [];
                }
            };

            StorageEngine.prototype._deleteFromLocalStorage = function(storeName, key) {
                try {
                    const storageKey = `${this.dbName}_${storeName}_${key}`;
                    localStorage.removeItem(storageKey);
                } catch (e) {
                    console.error('[StorageEngine] LocalStorage delete failed:', e);
                }
            };

            return StorageEngine;
        })();

        // Infrastructure Layer: ë¶„ì„ ê²°ê³¼ ì €ì¥ì†Œ
        window.Infrastructure.PatternAnalysisRepository = (function() {
            function PatternAnalysisRepository(storageEngine) {
                this.storageEngine = storageEngine || new window.Infrastructure.StorageEngine();
                this.storeName = 'patternAnalysis';
            }

            PatternAnalysisRepository.prototype.save = function(analysis) {
                const data = analysis.toPlainObject ? analysis.toPlainObject() : analysis;
                return this.storageEngine.save(this.storeName, 'latest', data);
            };

            PatternAnalysisRepository.prototype.load = function() {
                return this.storageEngine.load(this.storeName, 'latest');
            };

            return PatternAnalysisRepository;
        })();

        // Presentation Layer: ì—„ê²© ëª¨ë“œ ë Œë”ëŸ¬
        window.Presentation.StrictModeRenderer = (function() {
            function StrictModeRenderer(containerId) {
                this.containerId = containerId || 'strictModeContainer';
                this.currentMode = 'number-only';
                this.selectedPatterns = []; // ë‹¤ì¤‘ ì„ íƒì„ ìœ„í•´ ë°°ì—´ë¡œ ë³€ê²½
            }

            StrictModeRenderer.prototype.render = function(analysisResult) {
                const container = document.getElementById(this.containerId);
                if (!container) {
                    console.error('[StrictModeRenderer] Container not found:', this.containerId);
                    return;
                }
                const html = this._buildHTML(analysisResult);
                container.innerHTML = html;
                container.style.display = 'block';
                this._attachEventListeners(container, analysisResult);
                
                // ë¶„ì„ ì™„ë£Œ í›„ ê²°ê³¼ í‘œì‹œ í™•ì¸ (ë””ë²„ê¹…ìš©)
                console.log('[StrictModeRenderer] Analysis result rendered:', {
                    mode: this.currentMode,
                    hasPrefix: analysisResult.prefixPatterns?.length > 0,
                    hasSuffix: analysisResult.suffixPatterns?.length > 0,
                    hasNumberNumber: analysisResult.numberNumberPatterns?.length > 0
                });
            };

            StrictModeRenderer.prototype._buildHTML = function(analysisResult) {
                if (!analysisResult) {
                    console.warn('[StrictModeRenderer] No analysis result provided');
                    return this._buildNoResults();
                }
                
                // ë””ë²„ê¹…: ë¶„ì„ ê²°ê³¼ ë¡œê¹…
                console.log('[StrictModeRenderer] Building HTML for:', {
                    mode: this.currentMode,
                    hasNumberNumber: analysisResult.numberNumberPatterns?.length > 0,
                    hasPrefix: analysisResult.prefixPatterns?.length > 0,
                    hasSuffix: analysisResult.suffixPatterns?.length > 0,
                    numberNumberCount: analysisResult.numberNumberPatterns?.length || 0,
                    prefixCount: analysisResult.prefixPatterns?.length || 0,
                    suffixCount: analysisResult.suffixPatterns?.length || 0
                });
                
                const numberOnlyAnalysis = this.currentMode === 'number-only' 
                    ? (analysisResult && analysisResult.numberNumberPatterns && analysisResult.numberNumberPatterns.length > 0 ? analysisResult : null)
                    : null;
                const prefixSuffixAnalysis = this.currentMode === 'prefix-suffix'
                    ? (analysisResult && ((analysisResult.prefixPatterns && analysisResult.prefixPatterns.length > 0) || 
                                         (analysisResult.suffixPatterns && analysisResult.suffixPatterns.length > 0)) ? analysisResult : null)
                    : null;

                return `
                    <div style="background:#f8fafc; padding:20px; border-radius:8px; border:1px solid #e2e8f0; margin-bottom:20px;">
                        <h3 style="font-size:1.1rem; font-weight:700; margin-bottom:15px;">ì—„ê²© ëª¨ë“œ íŒ¨í„´ ë¶„ì„ ê²°ê³¼</h3>
                        ${numberOnlyAnalysis ? this._buildNumberNumberResults(numberOnlyAnalysis) : ''}
                        ${prefixSuffixAnalysis ? this._buildPrefixSuffixResults(prefixSuffixAnalysis) : ''}
                        ${!numberOnlyAnalysis && !prefixSuffixAnalysis ? this._buildNoResults() : ''}
                    </div>
                `;
            };

            StrictModeRenderer.prototype._buildNumberNumberResults = function(analysis) {
                const patterns = analysis.numberNumberPatterns || [];
                if (patterns.length === 0) return this._buildNoResults();

                // ë¶„ì„ ìš”ì•½ ì •ë³´
                const totalFiles = analysis.totalItems || 0;
                const analyzedFiles = analysis.analyzedItems || 0;
                const overallConfidence = analysis.confidence || 0;
                const patternCount = patterns.length;

                let html = '<div style="margin-top:15px;">';
                html += '<h4 style="font-weight:600; margin-bottom:10px;">ìˆ«ì-ìˆ«ì íŒ¨í„´ ë¶„ì„ ê²°ê³¼</h4>';
                
                // ì‹¬ì¸µ ë¶„ì„ ìš”ì•½
                html += `
                    <div style="background:#eff6ff; padding:12px; border-radius:6px; margin-bottom:15px; border-left:4px solid #3b82f6;">
                        <div style="font-size:0.9rem; color:#1e40af;">
                            <strong>ğŸ“Š ë¶„ì„ ìš”ì•½</strong><br>
                            â€¢ ë¶„ì„ëœ íŒŒì¼: ${analyzedFiles}ê°œ / ì „ì²´: ${totalFiles}ê°œ<br>
                            â€¢ ë°œê²¬ëœ íŒ¨í„´: ${patternCount}ê°œ<br>
                            â€¢ ì „ì²´ ì‹ ë¢°ë„: ${(overallConfidence * 100).toFixed(1)}%<br>
                            â€¢ íŒ¨í„´ ë§¤ì¹­ ê°€ëŠ¥ì„±: ${patterns.length > 0 ? (patterns[0].confidence * 100).toFixed(1) : 0}%
                        </div>
                    </div>
                `;

                html += '<div style="display:flex; flex-direction:column; gap:8px;">';
                html += '<div style="font-size:0.85rem; color:#64748b; margin-bottom:8px;">ğŸ’¡ ì—¬ëŸ¬ íŒ¨í„´ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)</div>';
                
                patterns.slice(0, 10).forEach((pattern, index) => {
                    const matchRate = ((pattern.frequency / analyzedFiles) * 100).toFixed(1);
                    html += `
                        <label style="display:flex; align-items:start; gap:8px; padding:12px; border:1px solid #cbd5e1; border-radius:6px; cursor:pointer; background:white; transition:all 0.2s;" 
                               data-type="number-number" data-pattern='${JSON.stringify(pattern.toPlainObject())}'
                               onmouseover="this.style.background='#f1f5f9'; this.style.borderColor='#3b82f6';"
                               onmouseout="this.style.background='white'; this.style.borderColor='#cbd5e1';">
                            <input type="checkbox" name="patternSelection" value="number-${index}" style="margin-top:4px;">
                            <div style="flex:1;">
                                <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                                    <span style="font-weight:600; color:#1e40af;">${pattern.pattern}</span>
                                    <span style="font-size:0.85rem; color:#64748b;">
                                        (ì‹ ë¢°ë„: ${(pattern.confidence * 100).toFixed(1)}%, ë¹ˆë„: ${pattern.frequency}íšŒ, ë§¤ì¹­ë¥ : ${matchRate}%)
                                    </span>
                                </div>
                                <div style="font-size:0.85rem; color:#64748b;">
                                    í˜•ì‹: ${pattern.leftLength}ìë¦¬${pattern.separator}${pattern.rightLength}ìë¦¬ | 
                                    ì˜ˆì‹œ: ${pattern.examples.slice(0, 3).join(', ')}
                                </div>
                            </div>
                        </label>
                    `;
                });
                html += '</div></div>';
                html += `
                    <div style="margin-top:15px; display:flex; gap:10px;">
                        <button id="applyPatternBtn" style="flex:1; padding:12px; background:#16a34a; color:white; border:none; border-radius:6px; font-weight:600; cursor:pointer; opacity:0.5; cursor:not-allowed;" disabled>
                            âœ… ì„ íƒí•œ íŒ¨í„´ ì ìš© (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)
                        </button>
                        <button id="cancelPatternBtn" style="flex:1; padding:12px; background:#94a3b8; color:white; border:none; border-radius:6px; font-weight:600; cursor:pointer;">
                            âŒ ì·¨ì†Œ
                        </button>
                    </div>
                `;
                return html;
            };

            StrictModeRenderer.prototype._buildPrefixSuffixResults = function(analysis) {
                const prefixPatterns = analysis.prefixPatterns || [];
                const suffixPatterns = analysis.suffixPatterns || [];
                if (prefixPatterns.length === 0 && suffixPatterns.length === 0) return this._buildNoResults();

                // ì‹¬ì¸µ ë¶„ì„ ìš”ì•½ ì •ë³´
                const totalFiles = analysis.totalItems || 0;
                const analyzedFiles = analysis.analyzedItems || 0;
                const overallConfidence = analysis.confidence || 0;
                const prefixCount = prefixPatterns.length;
                const suffixCount = suffixPatterns.length;
                const bestPrefix = prefixPatterns.length > 0 ? prefixPatterns[0] : null;
                const bestSuffix = suffixPatterns.length > 0 ? suffixPatterns[0] : null;

                let html = '<div style="margin-top:15px;">';
                
                // ì‹¬ì¸µ ë¶„ì„ ìš”ì•½
                html += `
                    <div style="background:#eff6ff; padding:15px; border-radius:6px; margin-bottom:15px; border-left:4px solid #3b82f6;">
                        <div style="font-size:0.9rem; color:#1e40af; margin-bottom:10px;">
                            <strong>ğŸ“Š ì‹¬ì¸µ ë¶„ì„ ìš”ì•½</strong>
                        </div>
                        <div style="font-size:0.85rem; color:#1e40af; line-height:1.6;">
                            â€¢ ë¶„ì„ëœ íŒŒì¼: <strong>${analyzedFiles}ê°œ</strong> / ì „ì²´: <strong>${totalFiles}ê°œ</strong><br>
                            â€¢ ë°œê²¬ëœ ì ‘ë‘ì‚¬ íŒ¨í„´: <strong>${prefixCount}ê°œ</strong><br>
                            â€¢ ë°œê²¬ëœ ì ‘ë¯¸ì‚¬ íŒ¨í„´: <strong>${suffixCount}ê°œ</strong><br>
                            â€¢ ì „ì²´ ì‹ ë¢°ë„: <strong>${(overallConfidence * 100).toFixed(1)}%</strong><br>
                            ${bestPrefix ? `â€¢ ìµœê³  ì‹ ë¢°ë„ ì ‘ë‘ì‚¬: <strong>"${bestPrefix.prefix}"</strong> (${(bestPrefix.confidence * 100).toFixed(1)}%, ${bestPrefix.frequency}íšŒ ë§¤ì¹­)<br>` : ''}
                            ${bestSuffix ? `â€¢ ìµœê³  ì‹ ë¢°ë„ ì ‘ë¯¸ì‚¬: <strong>"${bestSuffix.suffix}"</strong> (${(bestSuffix.confidence * 100).toFixed(1)}%, ${bestSuffix.frequency}íšŒ ë§¤ì¹­)<br>` : ''}
                            â€¢ íŒ¨í„´ ì¼ì¹˜ í™•ë¥ : <strong>${bestPrefix || bestSuffix ? Math.max(bestPrefix?.confidence || 0, bestSuffix?.confidence || 0) * 100 : 0}%</strong>
                        </div>
                    </div>
                `;

                if (prefixPatterns.length > 0) {
                    html += '<h4 style="font-weight:600; margin-bottom:10px;">ì ‘ë‘ì‚¬ ë¶„ì„ ê²°ê³¼</h4>';
                    html += '<div style="font-size:0.85rem; color:#64748b; margin-bottom:8px;">ğŸ’¡ ì—¬ëŸ¬ íŒ¨í„´ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)</div>';
                    html += '<div style="display:flex; flex-direction:column; gap:8px; margin-bottom:15px;">';
                    prefixPatterns.slice(0, 10).forEach((pattern, index) => {
                        const matchRate = ((pattern.frequency / analyzedFiles) * 100).toFixed(1);
                        const patternType = pattern.pattern || 'mixed';
                        html += `
                            <label style="display:flex; align-items:start; gap:8px; padding:12px; border:1px solid #cbd5e1; border-radius:6px; cursor:pointer; background:white; transition:all 0.2s;" 
                                   data-type="prefix" data-pattern='${JSON.stringify(pattern.toPlainObject())}'
                                   onmouseover="this.style.background='#f1f5f9'; this.style.borderColor='#3b82f6';"
                                   onmouseout="this.style.background='white'; this.style.borderColor='#cbd5e1';">
                                <input type="checkbox" name="patternSelection" value="prefix-${index}" style="margin-top:4px;">
                                <div style="flex:1;">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                                        <span style="font-weight:600; color:#1e40af;">${pattern.prefix}</span>
                                        <span style="font-size:0.85rem; color:#64748b;">
                                            (ì‹ ë¢°ë„: ${(pattern.confidence * 100).toFixed(1)}%, ë¹ˆë„: ${pattern.frequency}íšŒ, ë§¤ì¹­ë¥ : ${matchRate}%, ìœ í˜•: ${patternType})
                                        </span>
                                    </div>
                                    <div style="font-size:0.85rem; color:#64748b; margin-top:4px;">
                                        ì˜ˆì‹œ: ${pattern.examples.slice(0, 3).join(', ')}
                                    </div>
                                </div>
                            </label>
                        `;
                    });
                    html += '</div>';
                }
                if (suffixPatterns.length > 0) {
                    html += '<h4 style="font-weight:600; margin-bottom:10px;">ì ‘ë¯¸ì‚¬ ë¶„ì„ ê²°ê³¼</h4>';
                    html += '<div style="font-size:0.85rem; color:#64748b; margin-bottom:8px;">ğŸ’¡ ì—¬ëŸ¬ íŒ¨í„´ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)</div>';
                    html += '<div style="display:flex; flex-direction:column; gap:8px; margin-bottom:15px;">';
                    suffixPatterns.slice(0, 10).forEach((pattern, index) => {
                        const matchRate = ((pattern.frequency / analyzedFiles) * 100).toFixed(1);
                        const patternType = pattern.pattern || 'mixed';
                        html += `
                            <label style="display:flex; align-items:start; gap:8px; padding:12px; border:1px solid #cbd5e1; border-radius:6px; cursor:pointer; background:white; transition:all 0.2s;" 
                                   data-type="suffix" data-pattern='${JSON.stringify(pattern.toPlainObject())}'
                                   onmouseover="this.style.background='#f1f5f9'; this.style.borderColor='#3b82f6';"
                                   onmouseout="this.style.background='white'; this.style.borderColor='#cbd5e1';">
                                <input type="checkbox" name="patternSelection" value="suffix-${index}" style="margin-top:4px;">
                                <div style="flex:1;">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                                        <span style="font-weight:600; color:#1e40af;">${pattern.suffix}</span>
                                        <span style="font-size:0.85rem; color:#64748b;">
                                            (ì‹ ë¢°ë„: ${(pattern.confidence * 100).toFixed(1)}%, ë¹ˆë„: ${pattern.frequency}íšŒ, ë§¤ì¹­ë¥ : ${matchRate}%, ìœ í˜•: ${patternType})
                                        </span>
                                    </div>
                                    <div style="font-size:0.85rem; color:#64748b; margin-top:4px;">
                                        ì˜ˆì‹œ: ${pattern.examples.slice(0, 3).join(', ')}
                                    </div>
                                </div>
                            </label>
                        `;
                    });
                    html += '</div>';
                }
                html += '</div>';
                html += `
                    <div style="margin-top:15px; display:flex; gap:10px;">
                        <button id="applyPatternBtn" style="flex:1; padding:12px; background:#16a34a; color:white; border:none; border-radius:6px; font-weight:600; cursor:pointer; opacity:0.5; cursor:not-allowed;" disabled>
                            âœ… ì„ íƒí•œ íŒ¨í„´ ì ìš© (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)
                        </button>
                        <button id="cancelPatternBtn" style="flex:1; padding:12px; background:#94a3b8; color:white; border:none; border-radius:6px; font-weight:600; cursor:pointer;">
                            âŒ ì·¨ì†Œ
                        </button>
                    </div>
                `;
                return html;
            };

            StrictModeRenderer.prototype._buildNoResults = function() {
                return `
                    <div style="padding:15px; background:#fef3c7; border:1px solid #fbbf24; border-radius:6px; margin-top:15px;">
                        <p style="margin:0; color:#92400e;">âš ï¸ ê·œì¹™ì„±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ëª…ì„ ë¶„ì„í•´ì£¼ì„¸ìš”.</p>
                    </div>
                `;
            };

            StrictModeRenderer.prototype._attachEventListeners = function(container, analysisResult) {
                // ë‹¤ì¤‘ ì„ íƒì„ ìœ„í•œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                if (!this.selectedPatterns) {
                    this.selectedPatterns = []; // ì„ íƒëœ íŒ¨í„´ ë°°ì—´ ì´ˆê¸°í™”
                }
                
                container.querySelectorAll('input[name="patternSelection"]').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const option = e.target.closest('label');
                        if (option) {
                            const patternType = option.dataset.type;
                            const patternData = JSON.parse(option.dataset.pattern);
                            
                            let pattern;
                            if (patternType === 'number-number') {
                                pattern = new window.Domain.NumberNumberPattern(patternData);
                            } else {
                                pattern = new window.Domain.PrefixSuffixPattern(patternData);
                            }
                            
                            if (e.target.checked) {
                                // íŒ¨í„´ ì¶”ê°€
                                if (!this.selectedPatterns.some(p => this._patternEquals(p, pattern))) {
                                    this.selectedPatterns.push(pattern);
                                    option.style.background = '#dbeafe';
                                    option.style.borderColor = '#3b82f6';
                                }
                            } else {
                                // íŒ¨í„´ ì œê±°
                                this.selectedPatterns = this.selectedPatterns.filter(p => !this._patternEquals(p, pattern));
                                option.style.background = 'white';
                                option.style.borderColor = '#cbd5e1';
                            }
                            
                            // ì„ íƒëœ íŒ¨í„´ë“¤ì„ ModeManagerì— ì €ì¥
                            window.StrictMode.modeManager.setSelectedPatterns(this.selectedPatterns);
                            
                            // ì ìš© ë²„íŠ¼ í™œì„±í™”/ë¹„í™œì„±í™”
                            const applyBtn = container.querySelector('#applyPatternBtn');
                            if (applyBtn) {
                                if (this.selectedPatterns.length > 0) {
                                    applyBtn.disabled = false;
                                    applyBtn.style.opacity = '1';
                                    applyBtn.style.cursor = 'pointer';
                                    applyBtn.textContent = `âœ… ì„ íƒí•œ íŒ¨í„´ ì ìš© (${this.selectedPatterns.length}ê°œ ì„ íƒë¨)`;
                                } else {
                                    applyBtn.disabled = true;
                                    applyBtn.style.opacity = '0.5';
                                    applyBtn.style.cursor = 'not-allowed';
                                    applyBtn.textContent = 'âœ… ì„ íƒí•œ íŒ¨í„´ ì ìš© (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)';
                                }
                            }
                        }
                    });
                });

                const applyBtn = container.querySelector('#applyPatternBtn');
                if (applyBtn) {
                    applyBtn.addEventListener('click', () => {
                        if (this.selectedPatterns && this.selectedPatterns.length > 0) {
                            // ë‹¤ì¤‘ íŒ¨í„´ ì ìš©
                            window.StrictMode.modeManager.setSelectedPatterns(this.selectedPatterns);
                            
                            // íŒ¨í„´ ì ìš© í›„ ì‹¤ì œ ë¶„ì„ ì‹¤í–‰ì„ ìœ„í•´ ì´ë²¤íŠ¸ ë°œìƒ
                            const event = new CustomEvent('patternApplied', { 
                                detail: { patterns: this.selectedPatterns } 
                            });
                            document.dispatchEvent(event);
                            
                            // UI ì—…ë°ì´íŠ¸: strictModeContainer ìˆ¨ê¸°ê¸°
                            const strictModeContainer = document.getElementById('strictModeContainer');
                            if (strictModeContainer) {
                                strictModeContainer.style.display = 'none';
                            }
                            
                            // UI ì—…ë°ì´íŠ¸: ì„ íƒëœ íŒ¨í„´ ëª©ë¡ í‘œì‹œ
                            const patternNames = this.selectedPatterns.map(p => 
                                p.pattern || p.prefix || p.suffix
                            ).join(', ');
                            alert(`${this.selectedPatterns.length}ê°œ íŒ¨í„´ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤:\n${patternNames}\n\në¶„ì„ì„ ì§„í–‰í•©ë‹ˆë‹¤.`);
                            
                            // ë¶„ì„ ë²„íŠ¼ ìë™ í´ë¦­ (íŒ¨í„´ì´ ì„ íƒëœ ìƒíƒœì—ì„œ)
                            // ì•½ê°„ì˜ ì§€ì—°ì„ ë‘ì–´ íŒ¨í„´ ì„¤ì •ì´ ì™„ë£Œë˜ë„ë¡ í•¨
                            setTimeout(() => {
                                if (els.btnAnalyze && !els.btnAnalyze.disabled) {
                                    console.log('[StrictModeRenderer] Triggering analysis with selected patterns:', this.selectedPatterns.length);
                                    els.btnAnalyze.click();
                                }
                            }, 100);
                        } else {
                            alert('íŒ¨í„´ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                        }
                    });
                }

                const cancelBtn = container.querySelector('#cancelPatternBtn');
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        this.selectedPatterns = []; // ë‹¤ì¤‘ ì„ íƒì„ ìœ„í•´ ë°°ì—´ë¡œ ë³€ê²½
                        window.StrictMode.modeManager.setSelectedPatterns([]);
                        container.querySelectorAll('input[name="patternSelection"]').forEach(checkbox => {
                            checkbox.checked = false;
                        });
                        container.querySelectorAll('label').forEach(opt => {
                            opt.style.background = 'white';
                            opt.style.borderColor = '#cbd5e1';
                        });
                        if (applyBtn) {
                            applyBtn.disabled = true;
                            applyBtn.style.opacity = '0.5';
                            applyBtn.style.cursor = 'not-allowed';
                        }
                    });
                }
            };

            StrictModeRenderer.prototype._triggerNumberNumberAnalysis = function(files) {
                if (!files || files.length === 0) return;
                
                const container = document.getElementById(this.containerId);
                if (container) {
                    container.innerHTML = '<div style="padding:20px; text-align:center;">ğŸ“Š íŒ¨í„´ ë¶„ì„ ì¤‘... (ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬)</div>';
                }
                
                const items = files.map(f => ({ name: f.name }));
                
                // Web Workers ì‚¬ìš© (ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬)
                if (files.length > 100 && window.WorkerEngine && window.WorkerEngine.PatternAnalyzer) {
                    const analyzer = new window.WorkerEngine.PatternAnalyzer();
                    analyzer.analyzeNumberNumber(items, 'name')
                        .then(patterns => {
                            console.log('[StrictModeRenderer] Number-Number patterns from Worker:', patterns);
                            const analysis = new window.Domain.PatternAnalysis({
                                prefixPatterns: [],
                                suffixPatterns: [],
                                numberNumberPatterns: patterns && Array.isArray(patterns) && patterns.length > 0 ? patterns.map(p => new window.Domain.NumberNumberPattern(p)) : [],
                                totalItems: files.length,
                                analyzedItems: files.length,
                                confidence: patterns && patterns.length > 0 ? patterns[0].confidence : 0
                            });
                            
                            console.log('[StrictModeRenderer] Created PatternAnalysis (Worker):', {
                                numberNumberCount: analysis.numberNumberPatterns.length,
                                patterns: analysis.numberNumberPatterns
                            });
                            
                            this.render(analysis);
                            if (window.CleanArch.patternAnalysisRepository) {
                                window.CleanArch.patternAnalysisRepository.save(analysis);
                            }
                            analyzer.terminate();
                        })
                        .catch(err => {
                            console.error('[StrictModeRenderer] Worker error, fallback to sync:', err);
                            // í´ë°±: ë™ê¸° ì²˜ë¦¬
                            const patterns = window.CleanArch.numberNumberAnalysisUseCases.analyzePatterns(items, 'name');
                            console.log('[StrictModeRenderer] Number-Number patterns from sync:', patterns);
                            const analysis = new window.Domain.PatternAnalysis({
                                prefixPatterns: [],
                                suffixPatterns: [],
                                numberNumberPatterns: patterns && patterns.length > 0 ? patterns : [],
                                totalItems: files.length,
                                analyzedItems: files.length,
                                confidence: patterns && patterns.length > 0 ? patterns[0].confidence : 0
                            });
                            console.log('[StrictModeRenderer] Created PatternAnalysis (sync):', {
                                numberNumberCount: analysis.numberNumberPatterns.length,
                                patterns: analysis.numberNumberPatterns
                            });
                            this.render(analysis);
                            if (window.CleanArch.patternAnalysisRepository) {
                                window.CleanArch.patternAnalysisRepository.save(analysis);
                            }
                        });
                } else {
                    // ì†ŒëŸ‰ íŒŒì¼ì€ ë™ê¸° ì²˜ë¦¬
                    const patterns = window.CleanArch.numberNumberAnalysisUseCases.analyzePatterns(items, 'name');
                    console.log('[StrictModeRenderer] Number-Number patterns (small files):', patterns);
                    const analysis = new window.Domain.PatternAnalysis({
                        prefixPatterns: [],
                        suffixPatterns: [],
                        numberNumberPatterns: patterns && patterns.length > 0 ? patterns : [],
                        totalItems: files.length,
                        analyzedItems: files.length,
                        confidence: patterns && patterns.length > 0 ? patterns[0].confidence : 0
                    });
                    console.log('[StrictModeRenderer] Created PatternAnalysis (small):', {
                        numberNumberCount: analysis.numberNumberPatterns.length,
                        patterns: analysis.numberNumberPatterns
                    });
                    
                    this.render(analysis);
                    if (window.CleanArch.patternAnalysisRepository) {
                        window.CleanArch.patternAnalysisRepository.save(analysis);
                    }
                }
            };

            StrictModeRenderer.prototype._triggerPrefixSuffixAnalysis = function(files) {
                if (!files || files.length === 0) return;
                
                const container = document.getElementById(this.containerId);
                if (container) {
                    container.style.display = 'block';
                    container.innerHTML = '<div style="padding:20px; text-align:center;">ğŸ“Š íŒ¨í„´ ë¶„ì„ ì¤‘... (ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬)</div>';
                }
                
                const items = files.map(f => ({ name: f.name }));
                
                // Web Workers ì‚¬ìš© (ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬)
                if (files.length > 100 && window.WorkerEngine && window.WorkerEngine.PatternAnalyzer) {
                    const analyzer = new window.WorkerEngine.PatternAnalyzer();
                    analyzer.analyzePrefixSuffix(items, 'name')
                        .then(result => {
                            console.log('[StrictModeRenderer] Prefix-Suffix result from Worker:', result);
                            const analysis = new window.Domain.PatternAnalysis({
                                prefixPatterns: result.prefixPatterns && result.prefixPatterns.length > 0 ? result.prefixPatterns.map(p => new window.Domain.PrefixSuffixPattern(p)) : [],
                                suffixPatterns: result.suffixPatterns && result.suffixPatterns.length > 0 ? result.suffixPatterns.map(p => new window.Domain.PrefixSuffixPattern(p)) : [],
                                numberNumberPatterns: [],
                                totalItems: result.totalItems,
                                analyzedItems: result.analyzedItems,
                                confidence: result.confidence
                            });
                            
                            console.log('[StrictModeRenderer] Created PatternAnalysis (prefix-suffix):', {
                                prefixCount: analysis.prefixPatterns.length,
                                suffixCount: analysis.suffixPatterns.length,
                                prefixPatterns: analysis.prefixPatterns,
                                suffixPatterns: analysis.suffixPatterns
                            });
                            
                            this.render(analysis);
                            if (window.CleanArch.patternAnalysisRepository) {
                                window.CleanArch.patternAnalysisRepository.save(analysis);
                            }
                            analyzer.terminate();
                        })
                        .catch(err => {
                            console.error('[StrictModeRenderer] Worker error, fallback to sync:', err);
                            // í´ë°±: ë™ê¸° ì²˜ë¦¬
                            const analysis = window.CleanArch.prefixSuffixAnalysisUseCases.analyzePatterns(items, 'name');
                            console.log('[StrictModeRenderer] Prefix-Suffix analysis from sync:', {
                                prefixCount: analysis.prefixPatterns?.length || 0,
                                suffixCount: analysis.suffixPatterns?.length || 0,
                                prefixPatterns: analysis.prefixPatterns,
                                suffixPatterns: analysis.suffixPatterns
                            });
                            this.render(analysis);
                            if (window.CleanArch.patternAnalysisRepository) {
                                window.CleanArch.patternAnalysisRepository.save(analysis);
                            }
                        });
                } else {
                    // ì†ŒëŸ‰ íŒŒì¼ì€ ë™ê¸° ì²˜ë¦¬
                    const analysis = window.CleanArch.prefixSuffixAnalysisUseCases.analyzePatterns(items, 'name');
                    console.log('[StrictModeRenderer] Prefix-Suffix analysis (small files):', {
                        prefixCount: analysis.prefixPatterns?.length || 0,
                        suffixCount: analysis.suffixPatterns?.length || 0,
                        prefixPatterns: analysis.prefixPatterns,
                        suffixPatterns: analysis.suffixPatterns
                    });
                    this.render(analysis);
                    if (window.CleanArch.patternAnalysisRepository) {
                        window.CleanArch.patternAnalysisRepository.save(analysis);
                    }
                }
            };

            return StrictModeRenderer;
        })();

        // StrictMode.ModeManager
        window.StrictMode.ModeManager = (function() {
            function ModeManager() {
                this.currentMode = 'number-only';
                this.selectedPatterns = []; // ë‹¤ì¤‘ ì„ íƒì„ ìœ„í•´ ë°°ì—´ë¡œ ë³€ê²½
                this.listeners = [];
            }

            ModeManager.prototype.setMode = function(mode) {
                this.currentMode = mode;
                this.notifyListeners({ type: 'modeChange', mode });
            };

            ModeManager.prototype.getMode = function() {
                return this.currentMode;
            };

            ModeManager.prototype.setSelectedPattern = function(pattern) {
                // ë‹¨ì¼ íŒ¨í„´ ì„¤ì • (í•˜ìœ„ í˜¸í™˜ì„±)
                this.selectedPatterns = pattern ? [pattern] : [];
                this.notifyListeners({ type: 'patternChange', pattern });
            };

            ModeManager.prototype.setSelectedPatterns = function(patterns) {
                // ë‹¤ì¤‘ íŒ¨í„´ ì„¤ì •
                this.selectedPatterns = Array.isArray(patterns) ? patterns : [];
                this.notifyListeners({ type: 'patternsChange', patterns: this.selectedPatterns });
            };

            ModeManager.prototype.addSelectedPattern = function(pattern) {
                // íŒ¨í„´ ì¶”ê°€
                if (pattern && !this.selectedPatterns.some(p => this._patternEquals(p, pattern))) {
                    this.selectedPatterns.push(pattern);
                    this.notifyListeners({ type: 'patternAdded', pattern });
                }
            };

            ModeManager.prototype.removeSelectedPattern = function(pattern) {
                // íŒ¨í„´ ì œê±°
                this.selectedPatterns = this.selectedPatterns.filter(p => !this._patternEquals(p, pattern));
                this.notifyListeners({ type: 'patternRemoved', pattern });
            };

            ModeManager.prototype._patternEquals = function(p1, p2) {
                // íŒ¨í„´ ë¹„êµ
                if (p1.pattern && p2.pattern) {
                    return p1.pattern === p2.pattern && p1.separator === p2.separator;
                }
                if (p1.prefix && p2.prefix) {
                    return p1.prefix === p2.prefix;
                }
                if (p1.suffix && p2.suffix) {
                    return p1.suffix === p2.suffix;
                }
                return false;
            };

            ModeManager.prototype.getSelectedPattern = function() {
                // í•˜ìœ„ í˜¸í™˜ì„±: ì²« ë²ˆì§¸ íŒ¨í„´ ë°˜í™˜
                return this.selectedPatterns.length > 0 ? this.selectedPatterns[0] : null;
            };

            ModeManager.prototype.getSelectedPatterns = function() {
                // ë‹¤ì¤‘ íŒ¨í„´ ë°˜í™˜
                return this.selectedPatterns;
            };

            ModeManager.prototype.validate = function(value) {
                if (this.currentMode === 'number-only' && this.selectedPattern) {
                    if (window.CleanArch && window.CleanArch.numberNumberAnalysisUseCases) {
                        return window.CleanArch.numberNumberAnalysisUseCases.validateWithPattern(value, this.selectedPattern);
                    }
                } else if (this.currentMode === 'prefix-suffix' && this.selectedPattern) {
                    if (window.CleanArch && window.CleanArch.prefixSuffixAnalysisUseCases) {
                        return window.CleanArch.prefixSuffixAnalysisUseCases.validateWithPattern(value, this.selectedPattern);
                    }
                }
                return { valid: true, reason: 'No pattern selected' };
            };

            ModeManager.prototype.onChange = function(callback) {
                this.listeners.push(callback);
            };

            ModeManager.prototype.notifyListeners = function(data) {
                this.listeners.forEach(callback => {
                    try {
                        callback(data);
                    } catch (e) {
                        console.error('[StrictMode.ModeManager] Listener error:', e);
                    }
                });
            };

            return ModeManager;
        })();

        // ============================================
        // í´ë¦° ì•„í‚¤í…ì²˜ ê°•í™”: ì˜ì¡´ì„± ì£¼ì… ì‹œìŠ¤í…œ
        // ============================================
        window.DependencyInjection = (function() {
            function DIContainer() {
                this.services = new Map();
                this.singletons = new Map();
            }

            DIContainer.prototype.register = function(name, factory, singleton = false) {
                this.services.set(name, { factory, singleton });
            };

            DIContainer.prototype.resolve = function(name) {
                const service = this.services.get(name);
                if (!service) {
                    throw new Error(`Service "${name}" not found`);
                }

                if (service.singleton) {
                    if (!this.singletons.has(name)) {
                        this.singletons.set(name, service.factory(this));
                    }
                    return this.singletons.get(name);
                }

                return service.factory(this);
            };

            DIContainer.prototype.has = function(name) {
                return this.services.has(name);
            };

            return DIContainer;
        })();

        // ============================================
        // ì¸í„°í˜ì´ìŠ¤ ì •ì˜ (TypeScript ìŠ¤íƒ€ì¼ ì¶”ìƒí™”)
        // ============================================
        window.Interfaces = {
            IRepository: function() {
                // ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤
                this.save = function() { throw new Error('Not implemented'); };
                this.load = function() { throw new Error('Not implemented'); };
                this.delete = function() { throw new Error('Not implemented'); };
            },
            IUseCase: function() {
                // ìœ ìŠ¤ì¼€ì´ìŠ¤ ì¸í„°í˜ì´ìŠ¤
                this.execute = function() { throw new Error('Not implemented'); };
            },
            ILogger: function() {
                // ë¡œê±° ì¸í„°í˜ì´ìŠ¤
                this.log = function() { throw new Error('Not implemented'); };
                this.error = function() { throw new Error('Not implemented'); };
                this.warn = function() { throw new Error('Not implemented'); };
            },
            ITransaction: function() {
                // íŠ¸ëœì­ì…˜ ì¸í„°í˜ì´ìŠ¤
                this.begin = function() { throw new Error('Not implemented'); };
                this.commit = function() { throw new Error('Not implemented'); };
                this.rollback = function() { throw new Error('Not implemented'); };
            }
        };

        // ============================================
        // ê°•í™”ëœ ì—ëŸ¬ í•¸ë“¤ë§ ë° ë³µêµ¬ ì‹œìŠ¤í…œ
        // ============================================
        window.ErrorHandler.ErrorManager = (function() {
            function ErrorManager() {
                this.errors = [];
                this.maxErrors = 1000;
                this.recoveryStrategies = new Map();
                this.errorHandlers = [];
            }

            ErrorManager.prototype.handle = function(error, context, metadata = {}) {
                const errorEntry = {
                    id: `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    timestamp: new Date().toISOString(),
                    error: error.message || String(error),
                    stack: error.stack,
                    context: context,
                    metadata: metadata,
                    severity: this._determineSeverity(error, context),
                    recoverable: this._isRecoverable(error, context)
                };

                this.errors.push(errorEntry);
                if (this.errors.length > this.maxErrors) {
                    this.errors.shift();
                }

                // ë¡œê¹…
                this._logError(errorEntry);

                // ë³µêµ¬ ì „ëµ ì‹¤í–‰
                if (errorEntry.recoverable) {
                    this._attemptRecovery(errorEntry);
                }

                // ì»¤ìŠ¤í…€ í•¸ë“¤ëŸ¬ ì‹¤í–‰
                this.errorHandlers.forEach(handler => {
                    try {
                        handler(errorEntry);
                    } catch (e) {
                        console.error('[ErrorManager] Handler error:', e);
                    }
                });

                return errorEntry;
            };

            ErrorManager.prototype._determineSeverity = function(error, context) {
                if (error.name === 'SecurityError' || error.name === 'QuotaExceededError') {
                    return 'critical';
                }
                if (context.includes('execute') || context.includes('rollback')) {
                    return 'high';
                }
                return 'medium';
            };

            ErrorManager.prototype._isRecoverable = function(error, context) {
                const recoverableErrors = ['NetworkError', 'TimeoutError', 'QuotaExceededError'];
                return recoverableErrors.includes(error.name) || 
                       error.message.includes('retry') ||
                       context.includes('scan');
            };

            ErrorManager.prototype._attemptRecovery = function(errorEntry) {
                const strategy = this.recoveryStrategies.get(errorEntry.context);
                if (strategy) {
                    try {
                        strategy(errorEntry);
                    } catch (e) {
                        console.error('[ErrorManager] Recovery failed:', e);
                    }
                }
            };

            ErrorManager.prototype._logError = function(errorEntry) {
                const level = errorEntry.severity === 'critical' ? 'error' : 
                            errorEntry.severity === 'high' ? 'warn' : 'log';
                console[level](`[ErrorManager] ${errorEntry.context}:`, errorEntry.error, errorEntry);
            };

            ErrorManager.prototype.registerRecoveryStrategy = function(context, strategy) {
                this.recoveryStrategies.set(context, strategy);
            };

            ErrorManager.prototype.onError = function(handler) {
                this.errorHandlers.push(handler);
            };

            ErrorManager.prototype.getErrors = function(filter = {}) {
                let filtered = [...this.errors];
                if (filter.severity) {
                    filtered = filtered.filter(e => e.severity === filter.severity);
                }
                if (filter.context) {
                    filtered = filtered.filter(e => e.context.includes(filter.context));
                }
                if (filter.recoverable !== undefined) {
                    filtered = filtered.filter(e => e.recoverable === filter.recoverable);
                }
                return filtered;
            };

            ErrorManager.prototype.clear = function() {
                this.errors = [];
            };

            return ErrorManager;
        })();

        // ============================================
        // ë¡œê¹… ì‹œìŠ¤í…œ
        // ============================================
        window.Logging = (function() {
            function Logger(name, level = 'info') {
                this.name = name;
                this.level = level;
                this.logs = [];
                this.maxLogs = 5000;
                this.levels = { debug: 0, info: 1, warn: 2, error: 3 };
            }

            Logger.prototype.log = function(message, data = {}) {
                this._log('info', message, data);
            };

            Logger.prototype.debug = function(message, data = {}) {
                if (this.levels[this.level] <= this.levels.debug) {
                    this._log('debug', message, data);
                }
            };

            Logger.prototype.warn = function(message, data = {}) {
                this._log('warn', message, data);
            };

            Logger.prototype.error = function(message, error = null, data = {}) {
                this._log('error', message, { ...data, error: error ? {
                    message: error.message,
                    stack: error.stack
                } : null });
            };

            Logger.prototype._log = function(level, message, data) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    level: level,
                    logger: this.name,
                    message: message,
                    data: data
                };

                this.logs.push(logEntry);
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }

                // ì½˜ì†” ì¶œë ¥
                const consoleMethod = level === 'error' ? 'error' : 
                                     level === 'warn' ? 'warn' : 
                                     level === 'debug' ? 'debug' : 'log';
                console[consoleMethod](`[${this.name}] ${message}`, data);
            };

            Logger.prototype.getLogs = function(filter = {}) {
                let filtered = [...this.logs];
                if (filter.level) {
                    filtered = filtered.filter(l => l.level === filter.level);
                }
                if (filter.from) {
                    filtered = filtered.filter(l => new Date(l.timestamp) >= new Date(filter.from));
                }
                if (filter.to) {
                    filtered = filtered.filter(l => new Date(l.timestamp) <= new Date(filter.to));
                }
                return filtered;
            };

            Logger.prototype.clear = function() {
                this.logs = [];
            };

            return Logger;
        })();

        // ============================================
        // íŠ¸ëœì­ì…˜ ì‹œìŠ¤í…œ
        // ============================================
        window.Transaction = (function() {
            function TransactionManager() {
                this.activeTransactions = new Map();
            }

            TransactionManager.prototype.begin = function(id, operations = []) {
                const transaction = {
                    id: id || `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    startTime: new Date().toISOString(),
                    operations: operations,
                    status: 'active',
                    rollbackOperations: []
                };

                this.activeTransactions.set(transaction.id, transaction);
                return transaction;
            };

            TransactionManager.prototype.addOperation = function(transactionId, operation, rollbackOperation) {
                const tx = this.activeTransactions.get(transactionId);
                if (!tx) {
                    throw new Error(`Transaction ${transactionId} not found`);
                }
                tx.operations.push(operation);
                if (rollbackOperation) {
                    tx.rollbackOperations.push(rollbackOperation);
                }
            };

            TransactionManager.prototype.commit = async function(transactionId) {
                const tx = this.activeTransactions.get(transactionId);
                if (!tx) {
                    throw new Error(`Transaction ${transactionId} not found`);
                }

                try {
                    // ëª¨ë“  ì‘ì—… ì‹¤í–‰
                    for (const operation of tx.operations) {
                        await operation();
                    }
                    tx.status = 'committed';
                    tx.endTime = new Date().toISOString();
                    this.activeTransactions.delete(transactionId);
                    return { success: true, transactionId: transactionId };
                } catch (error) {
                    tx.status = 'failed';
                    tx.error = error;
                    // ìë™ ë¡¤ë°±
                    await this.rollback(transactionId);
                    throw error;
                }
            };

            TransactionManager.prototype.rollback = async function(transactionId) {
                const tx = this.activeTransactions.get(transactionId);
                if (!tx) {
                    throw new Error(`Transaction ${transactionId} not found`);
                }

                try {
                    // ë¡¤ë°± ì‘ì—… ì—­ìˆœ ì‹¤í–‰
                    for (let i = tx.rollbackOperations.length - 1; i >= 0; i--) {
                        await tx.rollbackOperations[i]();
                    }
                    tx.status = 'rolled_back';
                    tx.endTime = new Date().toISOString();
                    this.activeTransactions.delete(transactionId);
                    return { success: true, transactionId: transactionId };
                } catch (error) {
                    tx.status = 'rollback_failed';
                    tx.rollbackError = error;
                    throw error;
                }
            };

            TransactionManager.prototype.getTransaction = function(transactionId) {
                return this.activeTransactions.get(transactionId);
            };

            return TransactionManager;
        })();

        // ============================================
        // ì„¤ì • ê´€ë¦¬ ì‹œìŠ¤í…œ
        // ============================================
        window.Configuration = (function() {
            function ConfigManager() {
                this.config = {
                    performance: {
                        chunkSize: 50,
                        maxCacheSize: 1000,
                        enableMemoization: true
                    },
                    safety: {
                        enableSnapshot: true,
                        enableValidation: true,
                        maxFileSize: 10 * 1024 * 1024 * 1024, // 10GB
                        maxFileCount: 1000
                    },
                    logging: {
                        level: 'info',
                        maxLogs: 5000,
                        enableConsole: true
                    },
                    features: {
                        enableIntelligentClassification: true,
                        enableRename: true,
                        enableDuplicateCheck: true,
                        enableMultiDrive: true
                    }
                };
                this.listeners = [];
            }

            ConfigManager.prototype.get = function(path) {
                const parts = path.split('.');
                let value = this.config;
                for (const part of parts) {
                    if (value && typeof value === 'object' && part in value) {
                        value = value[part];
                    } else {
                        return undefined;
                    }
                }
                return value;
            };

            ConfigManager.prototype.set = function(path, value) {
                const parts = path.split('.');
                const lastPart = parts.pop();
                let target = this.config;
                for (const part of parts) {
                    if (!target[part] || typeof target[part] !== 'object') {
                        target[part] = {};
                    }
                    target = target[part];
                }
                const oldValue = target[lastPart];
                target[lastPart] = value;
                this._notifyListeners(path, value, oldValue);
            };

            ConfigManager.prototype._notifyListeners = function(path, newValue, oldValue) {
                this.listeners.forEach(listener => {
                    try {
                        listener(path, newValue, oldValue);
                    } catch (e) {
                        console.error('[ConfigManager] Listener error:', e);
                    }
                });
            };

            ConfigManager.prototype.onChange = function(listener) {
                this.listeners.push(listener);
            };

            ConfigManager.prototype.load = function(config) {
                this.config = { ...this.config, ...config };
            };

            ConfigManager.prototype.save = function() {
                if (window.CleanArch && window.CleanArch.storageEngine) {
                    return window.CleanArch.storageEngine.save('config', 'app_config', this.config);
                }
                return Promise.resolve();
            };

            return {
                ConfigManager: ConfigManager
            };
        })();

        // ============================================
        // ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦ ì‹œìŠ¤í…œ
        // ============================================
        window.DataIntegrity = (function() {
            function IntegrityValidator() {
                this.validators = new Map();
            }

            IntegrityValidator.prototype.register = function(name, validator) {
                this.validators.set(name, validator);
            };

            IntegrityValidator.prototype.validate = function(name, data) {
                const validator = this.validators.get(name);
                if (!validator) {
                    return { valid: true, warnings: [] };
                }
                return validator(data);
            };

            IntegrityValidator.prototype.validateAll = function(data) {
                const results = [];
                this.validators.forEach((validator, name) => {
                    const result = validator(data);
                    results.push({ name, ...result });
                });
                return {
                    valid: results.every(r => r.valid),
                    results: results
                };
            };

            // ê¸°ë³¸ ê²€ì¦ê¸° ë“±ë¡
            IntegrityValidator.prototype._registerDefaults = function() {
                // íŒŒì¼ í•¸ë“¤ ê²€ì¦
                this.register('fileHandle', (fileHandle) => {
                    if (!fileHandle) {
                        return { valid: false, errors: ['File handle is required'] };
                    }
                    if (typeof fileHandle.getFile !== 'function') {
                        return { valid: false, errors: ['Invalid file handle'] };
                    }
                    return { valid: true };
                });

                // ì‹¤í–‰ ê³„íš ê²€ì¦
                this.register('executionPlan', (plan) => {
                    const errors = [];
                    if (!Array.isArray(plan)) {
                        errors.push('Execution plan must be an array');
                    } else {
                        plan.forEach((item, index) => {
                            if (!item.fileHandle) {
                                errors.push(`Item ${index}: fileHandle is required`);
                            }
                            if (item.targetHandle && typeof item.targetHandle.getDirectoryHandle !== 'function') {
                                errors.push(`Item ${index}: invalid targetHandle`);
                            }
                        });
                    }
                    return {
                        valid: errors.length === 0,
                        errors: errors
                    };
                });
            };

            return IntegrityValidator;
        })();

        // ============================================
        // ì´ë²¤íŠ¸ ë²„ìŠ¤ ì‹œìŠ¤í…œ (Event-Driven Architecture)
        // ============================================
        window.EventBus = (function() {
            function EventBus() {
                this.listeners = new Map();
                this.eventHistory = [];
                this.maxHistory = 1000;
            }

            EventBus.prototype.on = function(event, handler, once = false) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, []);
                }
                this.listeners.get(event).push({ handler, once });
            };

            EventBus.prototype.once = function(event, handler) {
                this.on(event, handler, true);
            };

            EventBus.prototype.off = function(event, handler) {
                if (!this.listeners.has(event)) return;
                const handlers = this.listeners.get(event);
                const index = handlers.findIndex(h => h.handler === handler);
                if (index !== -1) {
                    handlers.splice(index, 1);
                }
            };

            EventBus.prototype.emit = function(event, data = {}) {
                // ì´ë²¤íŠ¸ íˆìŠ¤í† ë¦¬ ì €ì¥
                this.eventHistory.push({
                    timestamp: new Date().toISOString(),
                    event: event,
                    data: data
                });
                if (this.eventHistory.length > this.maxHistory) {
                    this.eventHistory.shift();
                }

                // ë¦¬ìŠ¤ë„ˆ ì‹¤í–‰
                if (!this.listeners.has(event)) return;

                const handlers = [...this.listeners.get(event)];
                handlers.forEach(({ handler, once }) => {
                    try {
                        handler(data, event);
                        if (once) {
                            this.off(event, handler);
                        }
                    } catch (e) {
                        console.error(`[EventBus] Handler error for "${event}":`, e);
                    }
                });
            };

            EventBus.prototype.getHistory = function(filter = {}) {
                let filtered = [...this.eventHistory];
                if (filter.event) {
                    filtered = filtered.filter(e => e.event === filter.event);
                }
                if (filter.from) {
                    filtered = filtered.filter(e => new Date(e.timestamp) >= new Date(filter.from));
                }
                return filtered;
            };

            EventBus.prototype.clear = function() {
                this.listeners.clear();
                this.eventHistory = [];
            };

            return EventBus;
        })();

        // ============================================
        // ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜ ë° ì„œí‚· ë¸Œë ˆì´ì»¤
        // ============================================
        window.Resilience = (function() {
            function RetryStrategy(options = {}) {
                this.maxRetries = options.maxRetries || 3;
                this.delay = options.delay || 1000;
                this.backoff = options.backoff || 'exponential';
                this.retryableErrors = options.retryableErrors || ['NetworkError', 'TimeoutError'];
            }

            RetryStrategy.prototype.execute = async function(fn, context = '') {
                let lastError;
                for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
                    try {
                        return await fn();
                    } catch (error) {
                        lastError = error;
                        const isRetryable = this.retryableErrors.some(type => 
                            error.name === type || error.message.includes(type)
                        );

                        if (!isRetryable || attempt === this.maxRetries) {
                            throw error;
                        }

                        const delay = this._calculateDelay(attempt);
                        await this._sleep(delay);
                    }
                }
                throw lastError;
            };

            RetryStrategy.prototype._calculateDelay = function(attempt) {
                if (this.backoff === 'exponential') {
                    return this.delay * Math.pow(2, attempt);
                } else if (this.backoff === 'linear') {
                    return this.delay * (attempt + 1);
                }
                return this.delay;
            };

            RetryStrategy.prototype._sleep = function(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            };

            function CircuitBreaker(options = {}) {
                this.failureThreshold = options.failureThreshold || 5;
                this.resetTimeout = options.resetTimeout || 60000; // 1ë¶„
                this.state = 'closed'; // closed, open, half-open
                this.failureCount = 0;
                this.lastFailureTime = null;
                this.successCount = 0;
            }

            CircuitBreaker.prototype.execute = async function(fn, context = '') {
                if (this.state === 'open') {
                    if (Date.now() - this.lastFailureTime > this.resetTimeout) {
                        this.state = 'half-open';
                        this.successCount = 0;
                    } else {
                        throw new Error(`Circuit breaker is OPEN for ${context}`);
                    }
                }

                try {
                    const result = await fn();
                    this._onSuccess();
                    return result;
                } catch (error) {
                    this._onFailure();
                    throw error;
                }
            };

            CircuitBreaker.prototype._onSuccess = function() {
                this.failureCount = 0;
                if (this.state === 'half-open') {
                    this.successCount++;
                    if (this.successCount >= 3) {
                        this.state = 'closed';
                        this.successCount = 0;
                    }
                }
            };

            CircuitBreaker.prototype._onFailure = function() {
                this.failureCount++;
                this.lastFailureTime = Date.now();
                if (this.failureCount >= this.failureThreshold) {
                    this.state = 'open';
                }
            };

            CircuitBreaker.prototype.getState = function() {
                return {
                    state: this.state,
                    failureCount: this.failureCount,
                    lastFailureTime: this.lastFailureTime
                };
            };

            CircuitBreaker.prototype.reset = function() {
                this.state = 'closed';
                this.failureCount = 0;
                this.successCount = 0;
                this.lastFailureTime = null;
            };

            return {
                RetryStrategy: RetryStrategy,
                CircuitBreaker: CircuitBreaker
            };
        })();

        // ============================================
        // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
        // ============================================
        window.PerformanceMonitor = (function() {
            function PerformanceMonitor() {
                this.metrics = new Map();
                this.measurements = [];
                this.maxMeasurements = 10000;
            }

            PerformanceMonitor.prototype.start = function(name) {
                const startTime = performance.now();
                return {
                    end: () => {
                        const duration = performance.now() - startTime;
                        this._record(name, duration);
                        return duration;
                    }
                };
            };

            PerformanceMonitor.prototype.measure = async function(name, fn) {
                const startTime = performance.now();
                try {
                    const result = await fn();
                    const duration = performance.now() - startTime;
                    this._record(name, duration);
                    return result;
                } catch (error) {
                    const duration = performance.now() - startTime;
                    this._record(name, duration, error);
                    throw error;
                }
            };

            PerformanceMonitor.prototype._record = function(name, duration, error = null) {
                if (!this.metrics.has(name)) {
                    this.metrics.set(name, {
                        name: name,
                        count: 0,
                        totalDuration: 0,
                        minDuration: Infinity,
                        maxDuration: 0,
                        errors: 0
                    });
                }

                const metric = this.metrics.get(name);
                metric.count++;
                metric.totalDuration += duration;
                metric.minDuration = Math.min(metric.minDuration, duration);
                metric.maxDuration = Math.max(metric.maxDuration, duration);
                if (error) metric.errors++;

                this.measurements.push({
                    timestamp: new Date().toISOString(),
                    name: name,
                    duration: duration,
                    error: error ? error.message : null
                });

                if (this.measurements.length > this.maxMeasurements) {
                    this.measurements.shift();
                }
            };

            PerformanceMonitor.prototype.getMetric = function(name) {
                const metric = this.metrics.get(name);
                if (!metric) return null;

                return {
                    ...metric,
                    averageDuration: metric.totalDuration / metric.count,
                    successRate: ((metric.count - metric.errors) / metric.count) * 100
                };
            };

            PerformanceMonitor.prototype.getAllMetrics = function() {
                const result = {};
                this.metrics.forEach((metric, name) => {
                    result[name] = this.getMetric(name);
                });
                return result;
            };

            PerformanceMonitor.prototype.getMeasurements = function(filter = {}) {
                let filtered = [...this.measurements];
                if (filter.name) {
                    filtered = filtered.filter(m => m.name === filter.name);
                }
                if (filter.from) {
                    filtered = filtered.filter(m => new Date(m.timestamp) >= new Date(filter.from));
                }
                return filtered;
            };

            PerformanceMonitor.prototype.clear = function() {
                this.metrics.clear();
                this.measurements = [];
            };

            return PerformanceMonitor;
        })();

        // ============================================
        // ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ
        // ============================================
        window.Metrics = (function() {
            function MetricsCollector() {
                this.counters = new Map();
                this.gauges = new Map();
                this.histograms = new Map();
            }

            MetricsCollector.prototype.increment = function(name, value = 1, labels = {}) {
                const key = this._createKey(name, labels);
                const current = this.counters.get(key) || 0;
                this.counters.set(key, current + value);
            };

            MetricsCollector.prototype.set = function(name, value, labels = {}) {
                const key = this._createKey(name, labels);
                this.gauges.set(key, { value, labels, timestamp: Date.now() });
            };

            MetricsCollector.prototype.observe = function(name, value, labels = {}) {
                const key = this._createKey(name, labels);
                if (!this.histograms.has(key)) {
                    this.histograms.set(key, []);
                }
                this.histograms.get(key).push({ value, labels, timestamp: Date.now() });
            };

            MetricsCollector.prototype._createKey = function(name, labels) {
                const labelStr = Object.entries(labels).sort().map(([k, v]) => `${k}=${v}`).join(',');
                return labelStr ? `${name}{${labelStr}}` : name;
            };

            MetricsCollector.prototype.getCounter = function(name, labels = {}) {
                const key = this._createKey(name, labels);
                return this.counters.get(key) || 0;
            };

            MetricsCollector.prototype.getGauge = function(name, labels = {}) {
                const key = this._createKey(name, labels);
                return this.gauges.get(key);
            };

            MetricsCollector.prototype.getHistogram = function(name, labels = {}) {
                const key = this._createKey(name, labels);
                const values = this.histograms.get(key) || [];
                if (values.length === 0) return null;

                const sorted = values.map(v => v.value).sort((a, b) => a - b);
                return {
                    count: sorted.length,
                    sum: sorted.reduce((a, b) => a + b, 0),
                    min: sorted[0],
                    max: sorted[sorted.length - 1],
                    avg: sorted.reduce((a, b) => a + b, 0) / sorted.length,
                    p50: sorted[Math.floor(sorted.length * 0.5)],
                    p95: sorted[Math.floor(sorted.length * 0.95)],
                    p99: sorted[Math.floor(sorted.length * 0.99)]
                };
            };

            MetricsCollector.prototype.getAll = function() {
                return {
                    counters: Object.fromEntries(this.counters),
                    gauges: Object.fromEntries(this.gauges),
                    histograms: Object.fromEntries(this.histograms)
                };
            };

            MetricsCollector.prototype.clear = function() {
                this.counters.clear();
                this.gauges.clear();
                this.histograms.clear();
            };

            return MetricsCollector;
        })();

        // ============================================
        // í—¬ìŠ¤ ì²´í¬ ì‹œìŠ¤í…œ
        // ============================================
        window.HealthCheck = (function() {
            function HealthChecker() {
                this.checks = new Map();
                this.status = 'healthy';
                this.lastCheck = null;
            }

            HealthChecker.prototype.register = function(name, checkFn, critical = false) {
                this.checks.set(name, { checkFn, critical, lastResult: null });
            };

            HealthChecker.prototype.check = async function() {
                const results = {};
                let overallHealthy = true;

                for (const [name, { checkFn, critical }] of this.checks) {
                    try {
                        const result = await checkFn();
                        results[name] = {
                            status: result.status || 'healthy',
                            message: result.message || 'OK',
                            data: result.data || {}
                        };
                        this.checks.get(name).lastResult = results[name];

                        if (critical && results[name].status !== 'healthy') {
                            overallHealthy = false;
                        }
                    } catch (error) {
                        results[name] = {
                            status: 'unhealthy',
                            message: error.message,
                            error: error
                        };
                        this.checks.get(name).lastResult = results[name];
                        if (critical) {
                            overallHealthy = false;
                        }
                    }
                }

                this.status = overallHealthy ? 'healthy' : 'degraded';
                this.lastCheck = new Date().toISOString();

                return {
                    status: this.status,
                    checks: results,
                    timestamp: this.lastCheck
                };
            };

            HealthChecker.prototype.getStatus = function() {
                return {
                    status: this.status,
                    lastCheck: this.lastCheck,
                    checks: Array.from(this.checks.entries()).map(([name, { lastResult }]) => ({
                        name,
                        ...lastResult
                    }))
                };
            };

            return HealthChecker;
        })();

        // ============================================
        // ë¯¸ë“¤ì›¨ì–´ ì‹œìŠ¤í…œ
        // ============================================
        window.Middleware = (function() {
            function MiddlewarePipeline() {
                this.middlewares = [];
            }

            MiddlewarePipeline.prototype.use = function(middleware) {
                this.middlewares.push(middleware);
            };

            MiddlewarePipeline.prototype.execute = async function(context, finalHandler) {
                let index = 0;

                const next = async () => {
                    if (index < this.middlewares.length) {
                        const middleware = this.middlewares[index++];
                        await middleware(context, next);
                    } else {
                        await finalHandler(context);
                    }
                };

                await next();
            };

            return MiddlewarePipeline;
        })();

        // ============================================
        // Phase 5: ì„±ëŠ¥ ìµœì í™” ë° ê°œì„  ì‹œìŠ¤í…œ
        // ============================================

        // ê°€ìƒí™” ì‹œìŠ¤í…œ (ëŒ€ìš©ëŸ‰ ë¦¬ìŠ¤íŠ¸ ì²˜ë¦¬)
        window.Virtualization = (function() {
            function VirtualList(container, itemHeight, renderItem, totalItems) {
                this.container = container;
                this.itemHeight = itemHeight;
                this.renderItem = renderItem;
                this.totalItems = totalItems;
                this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;
                this.scrollTop = 0;
                this.startIndex = 0;
                this.endIndex = Math.min(this.visibleItems, totalItems);
            }

            VirtualList.prototype.update = function() {
                const scrollTop = this.container.scrollTop;
                this.startIndex = Math.floor(scrollTop / this.itemHeight);
                this.endIndex = Math.min(this.startIndex + this.visibleItems, this.totalItems);
                
                const items = [];
                for (let i = this.startIndex; i < this.endIndex; i++) {
                    items.push(this.renderItem(i));
                }
                
                return items;
            };

            VirtualList.prototype.getTotalHeight = function() {
                return this.totalItems * this.itemHeight;
            };

            return VirtualList;
        })();

        // ê³ ê¸‰ ìºì‹± ì „ëµ
        window.AdvancedCache = (function() {
            function CacheManager(options = {}) {
                this.maxSize = options.maxSize || 1000;
                this.ttl = options.ttl || 3600000; // 1ì‹œê°„
                this.cache = new Map();
                this.accessOrder = [];
            }

            CacheManager.prototype.get = function(key) {
                const entry = this.cache.get(key);
                if (!entry) return null;

                // TTL í™•ì¸
                if (Date.now() > entry.expiresAt) {
                    this.delete(key);
                    return null;
                }

                // ì ‘ê·¼ ìˆœì„œ ì—…ë°ì´íŠ¸
                this._updateAccessOrder(key);
                return entry.value;
            };

            CacheManager.prototype.set = function(key, value, ttl = null) {
                // ìºì‹œ í¬ê¸° í™•ì¸
                if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
                    this._evictLRU();
                }

                const expiresAt = Date.now() + (ttl || this.ttl);
                this.cache.set(key, { value, expiresAt });
                this._updateAccessOrder(key);
            };

            CacheManager.prototype._updateAccessOrder = function(key) {
                const index = this.accessOrder.indexOf(key);
                if (index !== -1) {
                    this.accessOrder.splice(index, 1);
                }
                this.accessOrder.push(key);
            };

            CacheManager.prototype._evictLRU = function() {
                if (this.accessOrder.length > 0) {
                    const lruKey = this.accessOrder.shift();
                    this.cache.delete(lruKey);
                }
            };

            CacheManager.prototype.delete = function(key) {
                this.cache.delete(key);
                const index = this.accessOrder.indexOf(key);
                if (index !== -1) {
                    this.accessOrder.splice(index, 1);
                }
            };

            CacheManager.prototype.clear = function() {
                this.cache.clear();
                this.accessOrder = [];
            };

            CacheManager.prototype.getStats = function() {
                return {
                    size: this.cache.size,
                    maxSize: this.maxSize,
                    hitRate: this.hits / (this.hits + this.misses) || 0
                };
            };

            return CacheManager;
        })();

        // ë©”ëª¨ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œ
        window.MemoryManager = (function() {
            function MemoryManager() {
                this.threshold = 0.8; // 80% ì‚¬ìš© ì‹œ ì •ë¦¬
                this.cleanupInterval = 60000; // 1ë¶„ë§ˆë‹¤ ì²´í¬
                this.listeners = [];
            }

            MemoryManager.prototype.startMonitoring = function() {
                if (this.interval) return;
                
                this.interval = setInterval(() => {
                    this.checkMemory();
                }, this.cleanupInterval);
            };

            MemoryManager.prototype.stopMonitoring = function() {
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            };

            MemoryManager.prototype.checkMemory = function() {
                if (!performance.memory) return;

                const used = performance.memory.usedJSHeapSize;
                const limit = performance.memory.jsHeapSizeLimit;
                const usage = used / limit;

                if (usage > this.threshold) {
                    this.cleanup();
                    this._notifyListeners('high', usage);
                }
            };

            MemoryManager.prototype.cleanup = function() {
                // ìºì‹œ ì •ë¦¬
                if (window.CleanArch?.performanceMonitor) {
                    window.CleanArch.performanceMonitor.clear();
                }
                if (window.CleanArch?.metrics) {
                    window.CleanArch.metrics.clear();
                }
                if (window.CleanArch?.eventBus) {
                    window.CleanArch.eventBus.clear();
                }

                // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ íŒíŠ¸
                if (global.gc) {
                    global.gc();
                }
            };

            MemoryManager.prototype._notifyListeners = function(level, usage) {
                this.listeners.forEach(listener => {
                    try {
                        listener(level, usage);
                    } catch (e) {
                        console.error('[MemoryManager] Listener error:', e);
                    }
                });
            };

            MemoryManager.prototype.onMemoryWarning = function(listener) {
                this.listeners.push(listener);
            };

            return MemoryManager;
        })();

        // ì‚¬ìš©ì í”¼ë“œë°± ì‹œìŠ¤í…œ
        window.UserFeedback = (function() {
            function FeedbackCollector() {
                this.feedbacks = [];
                this.maxFeedbacks = 1000;
            }

            FeedbackCollector.prototype.collect = function(type, data) {
                const feedback = {
                    timestamp: new Date().toISOString(),
                    type: type, // 'error', 'warning', 'info', 'success'
                    data: data,
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };

                this.feedbacks.push(feedback);
                if (this.feedbacks.length > this.maxFeedbacks) {
                    this.feedbacks.shift();
                }

                // ì¤‘ìš” í”¼ë“œë°±ì€ ì¦‰ì‹œ ì €ì¥
                if (type === 'error' && window.CleanArch?.storageEngine) {
                    window.CleanArch.storageEngine.save('feedback', `error_${Date.now()}`, feedback);
                }
            };

            FeedbackCollector.prototype.getFeedbacks = function(filter = {}) {
                let filtered = [...this.feedbacks];
                if (filter.type) {
                    filtered = filtered.filter(f => f.type === filter.type);
                }
                if (filter.from) {
                    filtered = filtered.filter(f => new Date(f.timestamp) >= new Date(filter.from));
                }
                return filtered;
            };

            FeedbackCollector.prototype.clear = function() {
                this.feedbacks = [];
            };

            return FeedbackCollector;
        })();

        // ì½”ë“œ ë¬¸ì„œí™” ì‹œìŠ¤í…œ
        window.Documentation = (function() {
            function DocGenerator() {
                this.docs = new Map();
            }

            DocGenerator.prototype.register = function(name, doc) {
                this.docs.set(name, {
                    name: name,
                    description: doc.description || '',
                    params: doc.params || [],
                    returns: doc.returns || '',
                    examples: doc.examples || [],
                    tags: doc.tags || []
                });
            };

            DocGenerator.prototype.get = function(name) {
                return this.docs.get(name);
            };

            DocGenerator.prototype.getAll = function() {
                return Array.from(this.docs.values());
            };

            DocGenerator.prototype.generateMarkdown = function() {
                let md = '# API Documentation\n\n';
                this.docs.forEach((doc, name) => {
                    md += `## ${name}\n\n`;
                    md += `${doc.description}\n\n`;
                    if (doc.params.length > 0) {
                        md += '### Parameters\n\n';
                        doc.params.forEach(param => {
                            md += `- \`${param.name}\`: ${param.type} - ${param.description}\n`;
                        });
                        md += '\n';
                    }
                    if (doc.returns) {
                        md += `### Returns\n\n${doc.returns}\n\n`;
                    }
                    if (doc.examples.length > 0) {
                        md += '### Examples\n\n';
                        doc.examples.forEach(example => {
                            md += `\`\`\`javascript\n${example}\n\`\`\`\n\n`;
                        });
                    }
                });
                return md;
            };

            return DocGenerator;
        })();

        // Performance Engine (ì„±ëŠ¥ ìµœì í™”)
        window.PerformanceEngine = {
            Memoizer: (function() {
                function Memoizer() {
                    this.cache = new Map();
                    this.maxSize = 1000;
                }
                Memoizer.prototype.memoize = function(key, fn, ...args) {
                    if (this.cache.has(key)) return this.cache.get(key);
                    if (this.cache.size >= this.maxSize) {
                        const firstKey = this.cache.keys().next().value;
                        this.cache.delete(firstKey);
                    }
                    const result = fn.apply(null, args);
                    this.cache.set(key, result);
                    return result;
                };
                Memoizer.prototype.clear = function() {
                    this.cache.clear();
                };
                return Memoizer;
            })(),
            Throttler: (function() {
                function Throttler() {
                    this.timers = new Map();
                }
                Throttler.prototype.debounce = function(key, fn, delay) {
                    if (this.timers.has(key)) {
                        clearTimeout(this.timers.get(key));
                    }
                    const timer = setTimeout(() => {
                        fn();
                        this.timers.delete(key);
                    }, delay);
                    this.timers.set(key, timer);
                };
                Throttler.prototype.throttle = function(key, fn, delay) {
                    if (this.timers.has(key)) return;
                    fn();
                    const timer = setTimeout(() => {
                        this.timers.delete(key);
                    }, delay);
                    this.timers.set(key, timer);
                };
                return Throttler;
            })()
        };

        // Web Workers Engine (ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬)
        window.WorkerEngine = window.WorkerEngine || {};
        
        window.WorkerEngine.createWorker = function(workerCode) {
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            return new Worker(url);
        };

        window.WorkerEngine.PatternAnalyzer = (function() {
            function PatternAnalyzer() {
                this.worker = null;
                this.workerCode = `
                    self.onmessage = function(e) {
                        const { type, data } = e.data;
                        
                        if (type === 'analyzeNumberNumber') {
                            const { items, fieldName } = data;
                            const patterns = analyzeNumberNumberPatterns(items, fieldName);
                            self.postMessage({ type: 'result', data: patterns });
                        } else if (type === 'analyzePrefixSuffix') {
                            const { items, fieldName } = data;
                            const analysis = analyzePrefixSuffixPatterns(items, fieldName);
                            self.postMessage({ type: 'result', data: analysis });
                        }
                    };
                    
                    function analyzeNumberNumberPatterns(items, fieldName) {
                        const values = items.map(item => String(item[fieldName] || item.name || '').trim()).filter(v => v.length > 0);
                        if (values.length === 0) return [];
                        
                        const patternMap = new Map();
                        const separators = ['-', '_', '.', '/', ' '];
                        
                        values.forEach(value => {
                            // íŒŒì¼ëª… ì „ì²´ì—ì„œ ìˆ«ì-ìˆ«ì íŒ¨í„´ ì°¾ê¸° (ì•ë’¤ì— ë‹¤ë¥¸ ë¬¸ìê°€ ìˆì–´ë„ ë¨)
                            separators.forEach(sep => {
                                // ì •ê·œì‹ìœ¼ë¡œ ìˆ«ì-ìˆ«ì íŒ¨í„´ ì°¾ê¸° (ì•ë’¤ì— ì„ì˜ì˜ ë¬¸ìê°€ ìˆì–´ë„ ë¨)
                                const escapedSep = sep.replace(/[.*+?^$()|[\]\\]/g, '\\\\$&');
                                const regexStr = '(\\\\d+)' + escapedSep + '(\\\\d+)';
                                const regex = new RegExp(regexStr, 'g');
                                let match;
                                
                                while ((match = regex.exec(value)) !== null) {
                                    const left = match[1];
                                    const right = match[2];
                                    const patternKey = left.length + sep + right.length;
                                    
                                    if (!patternMap.has(patternKey)) {
                                        patternMap.set(patternKey, {
                                            pattern: left + sep + right,
                                            leftPart: left,
                                            rightPart: right,
                                            separator: sep,
                                            leftLength: left.length,
                                            rightLength: right.length,
                                            frequency: 0,
                                            examples: []
                                        });
                                    }
                                    
                                    const entry = patternMap.get(patternKey);
                                    entry.frequency++;
                                    if (entry.examples.length < 5) {
                                        entry.examples.push(value);
                                    }
                                }
                            });
                        });
                        
                        return Array.from(patternMap.values())
                            .filter(p => {
                                // í•„í„°ë§ ì¡°ê±´ ì™„í™”: ìµœì†Œ 2ê°œ ì´ìƒì´ê±°ë‚˜ ì „ì²´ì˜ 3% ì´ìƒ
                                const minFrequency = Math.max(2, Math.ceil(values.length * 0.03));
                                return p.frequency >= minFrequency;
                            })
                            .map(p => ({
                                pattern: '0'.repeat(p.leftLength) + p.separator + '0'.repeat(p.rightLength),
                                leftPart: p.leftPart,
                                rightPart: p.rightPart,
                                separator: p.separator,
                                confidence: Math.min(1.0, p.frequency / values.length),
                                frequency: p.frequency,
                                examples: p.examples,
                                leftLength: p.leftLength,
                                rightLength: p.rightLength
                            }))
                            .sort((a, b) => {
                                if (Math.abs(a.confidence - b.confidence) > 0.01) {
                                    return b.confidence - a.confidence;
                                }
                                return b.frequency - a.frequency;
                            })
                            .slice(0, 10);
                    }
                    
                    function analyzePrefixSuffixPatterns(items, fieldName) {
                        const values = items.map(item => String(item[fieldName] || item.name || '').trim()).filter(v => v.length > 0);
                        if (values.length === 0) {
                            return { prefixPatterns: [], suffixPatterns: [], totalItems: items.length, analyzedItems: 0, confidence: 0 };
                        }
                        
                        const prefixPatterns = analyzePrefixes(values);
                        const suffixPatterns = analyzeSuffixes(values);
                        const confidence = Math.max(
                            prefixPatterns.length > 0 ? prefixPatterns[0].confidence : 0,
                            suffixPatterns.length > 0 ? suffixPatterns[0].confidence : 0
                        );
                        
                        return {
                            prefixPatterns: prefixPatterns,
                            suffixPatterns: suffixPatterns,
                            numberNumberPatterns: [],
                            totalItems: items.length,
                            analyzedItems: values.length,
                            confidence: confidence,
                            timestamp: new Date().toISOString()
                        };
                    }
                    
                    function analyzePrefixes(values) {
                        const prefixMap = new Map();
                        for (let len = 1; len <= 10; len++) {
                            values.forEach(value => {
                                if (value.length >= len) {
                                    const prefix = value.substring(0, len);
                                    if (!prefixMap.has(prefix)) {
                                        prefixMap.set(prefix, {
                                            prefix: prefix,
                                            frequency: 0,
                                            examples: [],
                                            pattern: detectPatternType(prefix)
                                        });
                                    }
                                    const entry = prefixMap.get(prefix);
                                    entry.frequency++;
                                    if (entry.examples.length < 5) {
                                        entry.examples.push(value);
                                    }
                                }
                            });
                        }
                        
                        return Array.from(prefixMap.values())
                            .filter(p => {
                                // í•„í„°ë§ ì¡°ê±´ ì™„í™”: ìµœì†Œ 2ê°œ ì´ìƒì´ê±°ë‚˜ ì „ì²´ì˜ 3% ì´ìƒ
                                const minFrequency = Math.max(2, Math.ceil(values.length * 0.03));
                                return p.frequency >= minFrequency;
                            })
                            .map(p => ({
                                prefix: p.prefix,
                                suffix: '',
                                pattern: p.pattern,
                                confidence: Math.min(1.0, p.frequency / values.length),
                                frequency: p.frequency,
                                examples: p.examples
                            }))
                            .sort((a, b) => {
                                if (Math.abs(a.confidence - b.confidence) > 0.01) {
                                    return b.confidence - a.confidence;
                                }
                                return b.frequency - a.frequency;
                            })
                            .slice(0, 10);
                    }
                    
                    function analyzeSuffixes(values) {
                        const suffixMap = new Map();
                        for (let len = 1; len <= 10; len++) {
                            values.forEach(value => {
                                if (value.length >= len) {
                                    const suffix = value.substring(value.length - len);
                                    if (!suffixMap.has(suffix)) {
                                        suffixMap.set(suffix, {
                                            suffix: suffix,
                                            frequency: 0,
                                            examples: [],
                                            pattern: detectPatternType(suffix)
                                        });
                                    }
                                    const entry = suffixMap.get(suffix);
                                    entry.frequency++;
                                    if (entry.examples.length < 5) {
                                        entry.examples.push(value);
                                    }
                                }
                            });
                        }
                        
                        return Array.from(suffixMap.values())
                            .filter(p => {
                                // í•„í„°ë§ ì¡°ê±´ ì™„í™”: ìµœì†Œ 2ê°œ ì´ìƒì´ê±°ë‚˜ ì „ì²´ì˜ 3% ì´ìƒ
                                const minFrequency = Math.max(2, Math.ceil(values.length * 0.03));
                                return p.frequency >= minFrequency;
                            })
                            .map(p => ({
                                prefix: '',
                                suffix: p.suffix,
                                pattern: p.pattern,
                                confidence: Math.min(1.0, p.frequency / values.length),
                                frequency: p.frequency,
                                examples: p.examples
                            }))
                            .sort((a, b) => {
                                if (Math.abs(a.confidence - b.confidence) > 0.01) {
                                    return b.confidence - a.confidence;
                                }
                                return b.frequency - a.frequency;
                            })
                            .slice(0, 10);
                    }
                    
                    function detectPatternType(str) {
                        if (/^\\d+$/.test(str)) return 'numeric';
                        if (/^[A-Z]+$/i.test(str)) return 'alphabetic';
                        if (/^[A-Z0-9]+$/i.test(str)) return 'alphanumeric';
                        if (/^[ê°€-í£]+$/.test(str)) return 'korean';
                        if (/^[ê°€-í£A-Z0-9]+$/.test(str)) return 'mixed';
                        return 'mixed';
                    }
                `;
            }

            PatternAnalyzer.prototype.analyzeNumberNumber = function(items, fieldName) {
                return new Promise((resolve, reject) => {
                    try {
                        if (!this.worker) {
                            this.worker = window.WorkerEngine.createWorker(this.workerCode);
                        }
                        
                        const timeout = setTimeout(() => {
                            reject(new Error('Worker timeout'));
                        }, 30000);
                        
                        const handler = (e) => {
                            clearTimeout(timeout);
                            this.worker.removeEventListener('message', handler);
                            if (e.data.type === 'result') {
                                resolve(e.data.data);
                            }
                        };
                        
                        this.worker.addEventListener('message', handler);
                        this.worker.postMessage({
                            type: 'analyzeNumberNumber',
                            data: { items, fieldName }
                        });
                    } catch (e) {
                        reject(e);
                    }
                });
            };

            PatternAnalyzer.prototype.analyzePrefixSuffix = function(items, fieldName) {
                return new Promise((resolve, reject) => {
                    try {
                        if (!this.worker) {
                            this.worker = window.WorkerEngine.createWorker(this.workerCode);
                        }
                        
                        const timeout = setTimeout(() => {
                            reject(new Error('Worker timeout'));
                        }, 30000);
                        
                        const handler = (e) => {
                            clearTimeout(timeout);
                            this.worker.removeEventListener('message', handler);
                            if (e.data.type === 'result') {
                                resolve(e.data.data);
                            }
                        };
                        
                        this.worker.addEventListener('message', handler);
                        this.worker.postMessage({
                            type: 'analyzePrefixSuffix',
                            data: { items, fieldName }
                        });
                    } catch (e) {
                        reject(e);
                    }
                });
            };

            PatternAnalyzer.prototype.terminate = function() {
                if (this.worker) {
                    this.worker.terminate();
                    this.worker = null;
                }
            };

            return PatternAnalyzer;
        })();

        // CleanArch ì´ˆê¸°í™”
        window.CleanArch = window.CleanArch || {};
        window.CleanArch.init = function() {
            if (!window.CleanArch.storageEngine) {
                window.CleanArch.storageEngine = new window.Infrastructure.StorageEngine();
                window.CleanArch.storageEngine.init().then(success => {
                    console.log('[CleanArch] StorageEngine initialized:', success ? 'IndexedDB' : 'LocalStorage');
                });
            }
            if (!window.CleanArch.patternAnalysisRepository) {
                window.CleanArch.patternAnalysisRepository = new window.Infrastructure.PatternAnalysisRepository(
                    window.CleanArch.storageEngine
                );
            }
            if (!window.CleanArch.numberNumberAnalysisUseCases) {
                window.CleanArch.numberNumberAnalysisUseCases = new window.Application.NumberNumberAnalysisUseCases(
                    window.CleanArch.patternAnalysisRepository
                );
            }
            if (!window.CleanArch.prefixSuffixAnalysisUseCases) {
                window.CleanArch.prefixSuffixAnalysisUseCases = new window.Application.PrefixSuffixAnalysisUseCases(
                    window.CleanArch.patternAnalysisRepository
                );
            }
            if (!window.StrictMode.modeManager) {
                window.StrictMode.modeManager = new window.StrictMode.ModeManager();
            }
            if (!window.StrictMode.renderer) {
                window.StrictMode.renderer = new window.Presentation.StrictModeRenderer();
            }
            if (!window.ErrorHandler.errorManager) {
                window.ErrorHandler.errorManager = new window.ErrorHandler.ErrorManager();
            }
            if (!window.PerformanceEngine.memoizer) {
                window.PerformanceEngine.memoizer = new window.PerformanceEngine.Memoizer();
            }
            if (!window.PerformanceEngine.throttler) {
                window.PerformanceEngine.throttler = new window.PerformanceEngine.Throttler();
            }
            if (!window.CleanArch.metadataExtractor) {
                window.CleanArch.metadataExtractor = new window.Infrastructure.MetadataExtractor();
            }
            if (!window.CleanArch.fileHashCalculator) {
                window.CleanArch.fileHashCalculator = new window.Infrastructure.FileHashCalculator();
            }
            if (!window.CleanArch.intelligentClassificationUseCases) {
                window.CleanArch.intelligentClassificationUseCases = new window.Application.IntelligentClassificationUseCases(
                    window.CleanArch.metadataExtractor
                );
            }
            if (!window.CleanArch.fileNamingUseCases) {
                window.CleanArch.fileNamingUseCases = new window.Application.FileNamingUseCases();
            }
            if (!window.CleanArch.duplicateDetectionUseCases) {
                window.CleanArch.duplicateDetectionUseCases = new window.Application.DuplicateDetectionUseCases(
                    window.CleanArch.fileHashCalculator
                );
            }
            if (!window.CleanArch.snapshotRepository) {
                window.CleanArch.snapshotRepository = new window.Infrastructure.SnapshotRepository(
                    window.CleanArch.storageEngine
                );
            }
            if (!window.CleanArch.batchOperationUseCases) {
                window.CleanArch.batchOperationUseCases = new window.Application.BatchOperationUseCases(
                    window.CleanArch.snapshotRepository
                );
            }
            if (!window.CleanArch.multiDriveScanner) {
                window.CleanArch.multiDriveScanner = new window.Infrastructure.MultiDriveScanner();
            }
            if (!window.CleanArch.tagManagementUseCases) {
                window.CleanArch.tagManagementUseCases = new window.Application.TagManagementUseCases();
            }
            if (!window.CleanArch.smartSearchUseCases) {
                window.CleanArch.smartSearchUseCases = new window.Application.SmartSearchUseCases();
            }
            
            // ì˜ì¡´ì„± ì£¼ì… ì»¨í…Œì´ë„ˆ ì´ˆê¸°í™”
            if (!window.CleanArch.diContainer) {
                window.CleanArch.diContainer = new window.DependencyInjection();
                
                // ì„œë¹„ìŠ¤ ë“±ë¡
                window.CleanArch.diContainer.register('errorManager', () => window.ErrorHandler.errorManager, true);
                window.CleanArch.diContainer.register('configManager', () => window.Configuration.configManager, true);
                window.CleanArch.diContainer.register('logger', (di) => new window.Logging('App'), true);
                window.CleanArch.diContainer.register('transactionManager', () => new window.Transaction.TransactionManager(), true);
                window.CleanArch.diContainer.register('integrityValidator', () => {
                    const validator = new window.DataIntegrity.IntegrityValidator();
                    validator._registerDefaults();
                    return validator;
                }, true);
            }

            // ì„¤ì • ê´€ë¦¬ì ì´ˆê¸°í™”
            if (!window.Configuration.configManager) {
                if (window.Configuration.ConfigManager) {
                    window.Configuration.configManager = new window.Configuration.ConfigManager();
                } else {
                    console.warn('[CleanArch] ConfigManager not found, using default config');
                    window.Configuration.configManager = {
                        get: function(path) { return undefined; },
                        set: function(path, value) {},
                        onChange: function(listener) {}
                    };
                }
            }

            // íŠ¸ëœì­ì…˜ ê´€ë¦¬ì ì´ˆê¸°í™”
            if (!window.Transaction.transactionManager) {
                window.Transaction.transactionManager = new window.Transaction.TransactionManager();
            }

            // ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦ì ì´ˆê¸°í™”
            if (!window.DataIntegrity.integrityValidator) {
                window.DataIntegrity.integrityValidator = new window.DataIntegrity.IntegrityValidator();
                window.DataIntegrity.integrityValidator._registerDefaults();
            }

            // ë¡œê±° ì´ˆê¸°í™”
            if (!window.CleanArch.logger) {
                window.CleanArch.logger = window.CleanArch.diContainer.resolve('logger');
            }

            // ì´ë²¤íŠ¸ ë²„ìŠ¤ ì´ˆê¸°í™”
            if (!window.CleanArch.eventBus) {
                window.CleanArch.eventBus = new window.EventBus();
            }

            // ì„±ëŠ¥ ëª¨ë‹ˆí„° ì´ˆê¸°í™”
            if (!window.CleanArch.performanceMonitor) {
                window.CleanArch.performanceMonitor = new window.PerformanceMonitor.PerformanceMonitor();
            }

            // ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸° ì´ˆê¸°í™”
            if (!window.CleanArch.metrics) {
                window.CleanArch.metrics = new window.Metrics.MetricsCollector();
            }

            // í—¬ìŠ¤ ì²´í¬ ì´ˆê¸°í™”
            if (!window.CleanArch.healthChecker) {
                window.CleanArch.healthChecker = new window.HealthCheck.HealthChecker();
                
                // ê¸°ë³¸ í—¬ìŠ¤ ì²´í¬ ë“±ë¡
                window.CleanArch.healthChecker.register('storage', async () => {
                    if (window.CleanArch.storageEngine) {
                        try {
                            await window.CleanArch.storageEngine.init();
                            return { status: 'healthy', message: 'Storage engine OK' };
                        } catch (e) {
                            return { status: 'unhealthy', message: e.message };
                        }
                    }
                    return { status: 'degraded', message: 'Storage engine not initialized' };
                }, true);

                window.CleanArch.healthChecker.register('memory', async () => {
                    const used = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    const limit = performance.memory ? performance.memory.jsHeapSizeLimit : 0;
                    const usage = limit > 0 ? (used / limit) * 100 : 0;
                    
                    if (usage > 90) {
                        return { status: 'unhealthy', message: `Memory usage: ${usage.toFixed(1)}%` };
                    } else if (usage > 75) {
                        return { status: 'degraded', message: `Memory usage: ${usage.toFixed(1)}%` };
                    }
                    return { status: 'healthy', message: `Memory usage: ${usage.toFixed(1)}%`, data: { usage } };
                }, false);
            }

            // ë¯¸ë“¤ì›¨ì–´ íŒŒì´í”„ë¼ì¸ ì´ˆê¸°í™”
            if (!window.CleanArch.middleware) {
                window.CleanArch.middleware = new window.Middleware.MiddlewarePipeline();
                
                // ê¸°ë³¸ ë¯¸ë“¤ì›¨ì–´ ë“±ë¡
                window.CleanArch.middleware.use(async (context, next) => {
                    // ë¡œê¹… ë¯¸ë“¤ì›¨ì–´
                    if (window.CleanArch.logger) {
                        window.CleanArch.logger.log('Middleware: Request', { context });
                    }
                    await next();
                    if (window.CleanArch.logger) {
                        window.CleanArch.logger.log('Middleware: Response', { context });
                    }
                });

                window.CleanArch.middleware.use(async (context, next) => {
                    // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë¯¸ë“¤ì›¨ì–´
                    if (window.CleanArch.performanceMonitor) {
                        const measurement = window.CleanArch.performanceMonitor.start('middleware');
                        await next();
                        measurement.end();
                    } else {
                        await next();
                    }
                });
            }

            // ì¬ì‹œë„ ì „ëµ ë° ì„œí‚· ë¸Œë ˆì´ì»¤ ì´ˆê¸°í™”
            if (!window.CleanArch.retryStrategy) {
                window.CleanArch.retryStrategy = new window.Resilience.RetryStrategy({
                    maxRetries: 3,
                    delay: 1000,
                    backoff: 'exponential'
                });
            }

            if (!window.CleanArch.circuitBreaker) {
                window.CleanArch.circuitBreaker = new window.Resilience.CircuitBreaker({
                    failureThreshold: 5,
                    resetTimeout: 60000
                });
            }

            // Phase 5: ì„±ëŠ¥ ìµœì í™” ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            if (!window.CleanArch.cacheManager) {
                window.CleanArch.cacheManager = new window.AdvancedCache.CacheManager({
                    maxSize: 2000,
                    ttl: 3600000 // 1ì‹œê°„
                });
            }

            if (!window.CleanArch.memoryManager) {
                window.CleanArch.memoryManager = new window.MemoryManager.MemoryManager();
                window.CleanArch.memoryManager.startMonitoring();
                
                // ë©”ëª¨ë¦¬ ê²½ê³  ë¦¬ìŠ¤ë„ˆ
                window.CleanArch.memoryManager.onMemoryWarning((level, usage) => {
                    if (window.CleanArch.logger) {
                        window.CleanArch.logger.warn('High memory usage detected', { level, usage });
                    }
                });
            }

            if (!window.CleanArch.feedbackCollector) {
                window.CleanArch.feedbackCollector = new window.UserFeedback.FeedbackCollector();
            }

            if (!window.CleanArch.docGenerator) {
                window.CleanArch.docGenerator = new window.Documentation.DocGenerator();
                
                // ì£¼ìš” API ë¬¸ì„œí™” ë“±ë¡
                window.CleanArch.docGenerator.register('IntelligentClassificationUseCases.classifyByMetadata', {
                    description: 'ë©”íƒ€ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ íŒŒì¼ì„ ìë™ ë¶„ë¥˜í•©ë‹ˆë‹¤.',
                    params: [
                        { name: 'file', type: 'FileHandle', description: 'ë¶„ë¥˜í•  íŒŒì¼ í•¸ë“¤' },
                        { name: 'metadata', type: 'FileMetadata', description: 'íŒŒì¼ ë©”íƒ€ë°ì´í„°' }
                    ],
                    returns: 'string - ë¶„ë¥˜ëœ ì¹´í…Œê³ ë¦¬ëª…',
                    examples: [
                        'const category = useCases.classifyByMetadata(file, metadata);'
                    ],
                    tags: ['classification', 'metadata']
                });

                window.CleanArch.docGenerator.register('FileNamingUseCases.generateName', {
                    description: 'ê·œì¹™ì— ë”°ë¼ íŒŒì¼ëª…ì„ ìƒì„±í•©ë‹ˆë‹¤.',
                    params: [
                        { name: 'file', type: 'FileHandle', description: 'íŒŒì¼ í•¸ë“¤' },
                        { name: 'rule', type: 'NamingRule', description: 'ëª…ëª… ê·œì¹™ (ì„ íƒ)' },
                        { name: 'metadata', type: 'FileMetadata', description: 'íŒŒì¼ ë©”íƒ€ë°ì´í„°' },
                        { name: 'index', type: 'number', description: 'íŒŒì¼ ì¸ë±ìŠ¤' }
                    ],
                    returns: 'string - ìƒì„±ëœ íŒŒì¼ëª…',
                    examples: [
                        'const newName = useCases.generateName(file, null, metadata, 0);'
                    ],
                    tags: ['naming', 'file']
                });
            }

            // ë‹¨ê¸° í™•ì¥: í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            if (!window.CleanArch.pluginManager) {
                window.CleanArch.pluginManager = new window.PluginSystem.PluginManager();
            }

            // ë‹¨ê¸° í™•ì¥: íˆìŠ¤í† ë¦¬ ê´€ë¦¬ ì´ˆê¸°í™”
            if (!window.CleanArch.historyRepository) {
                window.CleanArch.historyRepository = new window.Infrastructure.HistoryRepository(
                    window.CleanArch.storageEngine
                );
            }
            if (!window.CleanArch.historyManagementUseCases) {
                window.CleanArch.historyManagementUseCases = new window.Application.HistoryManagementUseCases(
                    window.CleanArch.historyRepository
                );
            }

            // ë‹¨ê¸° í™•ì¥: ë‹¤ì¤‘ íŒ¨í„´ ë¶„ì„ ì´ˆê¸°í™”
            if (!window.CleanArch.multiPatternAnalysisUseCases) {
                window.CleanArch.multiPatternAnalysisUseCases = new window.Application.MultiPatternAnalysisUseCases();
            }

            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
            if (window.CleanArch.eventBus) {
                window.CleanArch.eventBus.on('file.operation.start', (data) => {
                    if (window.CleanArch.metrics) {
                        window.CleanArch.metrics.increment('file_operations_started');
                    }
                    if (window.CleanArch.logger) {
                        window.CleanArch.logger.log('File operation started', data);
                    }
                });

                window.CleanArch.eventBus.on('file.operation.complete', (data) => {
                    if (window.CleanArch.metrics) {
                        window.CleanArch.metrics.increment('file_operations_completed');
                        window.CleanArch.metrics.increment('file_operations_success', data.success ? 1 : 0);
                    }
                });

                window.CleanArch.eventBus.on('file.operation.error', (data) => {
                    if (window.CleanArch.metrics) {
                        window.CleanArch.metrics.increment('file_operations_errors');
                    }
                    if (window.CleanArch.logger) {
                        window.CleanArch.logger.error('File operation error', data.error, data);
                    }
                });
            }

            console.log('[CleanArch] Framework initialized with enhanced architecture');
        };

        // ìë™ ì´ˆê¸°í™”
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', window.CleanArch.init);
        } else {
            window.CleanArch.init();
        }
    })();

    // ì „ì—­ ë³€ìˆ˜
    let sourceHandle = null;
    let targetHandle = null;
    let executionPlan = []; // ì‹¤í–‰ ê³„íš ì €ì¥ì†Œ

    // DOM ìš”ì†Œ
    const els = {
        btnSource: document.getElementById('btnSource'),
        btnTarget: document.getElementById('btnTarget'),
        pathSource: document.getElementById('pathSource'),
        pathTarget: document.getElementById('pathTarget'),
        btnAnalyze: document.getElementById('btnAnalyze'),
        analysisSection: document.getElementById('analysisSection'),
        analysisSummary: document.getElementById('analysisSummary'),
        analysisDetail: document.getElementById('analysisDetail'),
        btnExecute: document.getElementById('btnExecute'),
        btnRollback: document.getElementById('btnRollback'),
        progressWrap: document.getElementById('progressWrap'),
        progressFill: document.getElementById('progressFill'),
        progressText: document.getElementById('progressText'),
        resultBody: document.getElementById('resultBody'),
        btnDownload: document.getElementById('btnDownload'),
        dashboardSection: document.getElementById('dashboardSection'),
        dashboardContent: document.getElementById('dashboardContent'),
        searchSection: document.getElementById('searchSection'),
        searchInput: document.getElementById('searchInput'),
        btnSearch: document.getElementById('btnSearch'),
        searchResults: document.getElementById('searchResults'),
        searchResultsBody: document.getElementById('searchResultsBody'),
        btnMultiDrive: document.getElementById('btnMultiDrive'),
        realtimeDashboardCard: document.getElementById('realtimeDashboardCard'),
        historyCard: document.getElementById('historyCard'),
        btnShowHistory: document.getElementById('btnShowHistory'),
        btnClearHistory: document.getElementById('btnClearHistory'),
        btnHistoryStats: document.getElementById('btnHistoryStats'),
        historyContent: document.getElementById('historyContent')
    };

    // ì „ì—­ ë³€ìˆ˜: ìŠ¤ëƒ…ìƒ· ê´€ë¦¬
    let currentSnapshot = null;

    // 1. í´ë” ì„ íƒ í•¸ë“¤ëŸ¬
    async function selectFolder(type) {
        try {
            const handle = await window.showDirectoryPicker({ id: type });
            if (type === 'source') {
                sourceHandle = handle;
                els.pathSource.textContent = handle.name;
                els.btnSource.style.borderColor = "var(--primary)";
            } else {
                targetHandle = handle;
                els.pathTarget.textContent = handle.name;
                els.btnTarget.style.borderColor = "var(--primary)";
            }
            
            // ë‘˜ ë‹¤ ì„ íƒë˜ë©´ ë¶„ì„ ë²„íŠ¼ í™œì„±í™”
            if (sourceHandle && targetHandle) {
                els.btnAnalyze.disabled = false;
                els.analysisSection.style.display = 'none';
                els.btnExecute.style.display = 'none';
                els.resultBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">ì¤€ë¹„ ì™„ë£Œ. ë¶„ì„ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.</td></tr>';
            }
        } catch (e) {}
    }

    els.btnSource.onclick = () => selectFolder('source');
    els.btnTarget.onclick = () => selectFolder('target');

    // ë©€í‹° ë“œë¼ì´ë¸Œ ìŠ¤ìº”
    els.btnMultiDrive.onclick = async () => {
        try {
            els.btnMultiDrive.disabled = true;
            els.btnMultiDrive.textContent = 'ğŸŒ ìŠ¤ìº” ì¤‘...';
            document.getElementById('multiDriveStatus').style.display = 'block';
            document.getElementById('multiDriveStatus').textContent = 'ë“œë¼ì´ë¸Œ ì„ íƒ ì¤‘...';

            // ì—¬ëŸ¬ ë“œë¼ì´ë¸Œ ì„ íƒ (ì‹¤ì œë¡œëŠ” ì‚¬ìš©ìê°€ ì—¬ëŸ¬ ë²ˆ ì„ íƒ)
            const drives = [];
            let continueScan = true;
            while (continueScan) {
                try {
                    const handle = await window.showDirectoryPicker({ id: 'drive', mode: 'read' });
                    drives.push(handle);
                    const addMore = confirm(`ë“œë¼ì´ë¸Œ "${handle.name}" ì¶”ê°€ë¨.\nì¶”ê°€ ë“œë¼ì´ë¸Œë¥¼ ìŠ¤ìº”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`);
                    if (!addMore) continueScan = false;
                } catch (e) {
                    continueScan = false;
                }
            }

            if (drives.length === 0) {
                document.getElementById('multiDriveStatus').textContent = 'ì„ íƒëœ ë“œë¼ì´ë¸Œ ì—†ìŒ';
                els.btnMultiDrive.disabled = false;
                els.btnMultiDrive.textContent = 'ğŸŒ ë©€í‹° ë“œë¼ì´ë¸Œ ìŠ¤ìº” (ì„ íƒ)';
                return;
            }

            document.getElementById('multiDriveStatus').textContent = `${drives.length}ê°œ ë“œë¼ì´ë¸Œ ìŠ¤ìº” ì¤‘...`;

            if (window.CleanArch && window.CleanArch.multiDriveScanner) {
                const results = await window.CleanArch.multiDriveScanner.scanDrives(drives);
                const totalFiles = results.reduce((sum, r) => sum + r.fileCount, 0);
                document.getElementById('multiDriveStatus').textContent = 
                    `âœ… ìŠ¤ìº” ì™„ë£Œ: ${drives.length}ê°œ ë“œë¼ì´ë¸Œ, ${totalFiles}ê°œ íŒŒì¼ ì¸ë±ì‹±ë¨`;
                
                // í†µê³„ í‘œì‹œ
                let statsHtml = '<div style="margin-top:10px; padding:10px; background:#f1f5f9; border-radius:6px;">';
                statsHtml += '<strong>ë“œë¼ì´ë¸Œë³„ íŒŒì¼ ìˆ˜:</strong><br>';
                results.forEach(r => {
                    statsHtml += `â€¢ ${r.drive}: ${r.fileCount}ê°œ íŒŒì¼<br>`;
                });
                statsHtml += '</div>';
                document.getElementById('multiDriveStatus').innerHTML += statsHtml;
                
                // ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸
                updateDashboard();
            }
        } catch (e) {
            console.error('[MultiDrive] Scan failed:', e);
            document.getElementById('multiDriveStatus').textContent = 'ìŠ¤ìº” ì‹¤íŒ¨: ' + e.message;
        } finally {
            els.btnMultiDrive.disabled = false;
            els.btnMultiDrive.textContent = 'ğŸŒ ë©€í‹° ë“œë¼ì´ë¸Œ ìŠ¤ìº” (ì„ íƒ)';
        }
    };

    // í†µí•© ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸
    function updateDashboard() {
        if (!window.CleanArch || !window.CleanArch.multiDriveScanner) return;

        const stats = window.CleanArch.multiDriveScanner.getDriveStats();
        if (stats.length === 0) {
            els.dashboardSection.style.display = 'none';
            return;
        }

        let html = '<div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">';
        stats.forEach(stat => {
            html += `
                <div style="background:white; padding:15px; border-radius:8px; border:1px solid #e2e8f0;">
                    <div style="font-weight:600; margin-bottom:8px;">${stat.drive}</div>
                    <div style="font-size:1.5rem; color:var(--primary); font-weight:700;">${stat.fileCount}</div>
                    <div style="font-size:0.85rem; color:#64748b; margin-top:4px;">ê°œ íŒŒì¼</div>
                </div>
            `;
        });
        html += '</div>';
        els.dashboardContent.innerHTML = html;
        els.dashboardSection.style.display = 'block';
        els.searchSection.style.display = 'block';
    }

    // ìŠ¤ë§ˆíŠ¸ ê²€ìƒ‰
    if (els.btnSearch) {
        els.btnSearch.onclick = async () => {
        const query = els.searchInput.value.trim();
        if (!query) {
            alert('ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
            return;
        }

        if (!window.CleanArch || !window.CleanArch.multiDriveScanner) {
            alert('ë¨¼ì € ë©€í‹° ë“œë¼ì´ë¸Œ ìŠ¤ìº”ì„ ì‹¤í–‰í•˜ì„¸ìš”.');
            return;
        }

        els.btnSearch.disabled = true;
        els.btnSearch.textContent = 'ê²€ìƒ‰ ì¤‘...';

        try {
            const results = window.CleanArch.multiDriveScanner.searchAcrossDrives(query);
            
            if (results.length === 0) {
                els.searchResults.style.display = 'none';
                alert('ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.');
            } else {
                let html = '';
                for (const result of results.slice(0, 100)) { // ìµœëŒ€ 100ê°œë§Œ í‘œì‹œ
                    try {
                        const file = await result.fileHandle.getFile();
                        const size = (file.size / 1024).toFixed(2) + ' KB';
                        const date = new Date(file.lastModified).toLocaleDateString('ko-KR');
                        html += `
                            <tr>
                                <td>${result.fileHandle.name}</td>
                                <td>${result.drive}</td>
                                <td>${size}</td>
                                <td>${date}</td>
                            </tr>
                        `;
                    } catch (e) {
                        console.error('[Search] File info failed:', e);
                    }
                }
                els.searchResultsBody.innerHTML = html;
                els.searchResults.style.display = 'block';
            }
        } catch (e) {
            console.error('[Search] Error:', e);
            alert('ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + e.message);
        } finally {
            if (els.btnSearch) {
                els.btnSearch.disabled = false;
                els.btnSearch.textContent = 'ğŸ” ê²€ìƒ‰';
            }
        }
        };
    }

    // ê²€ìƒ‰ ì…ë ¥ ì—”í„° í‚¤ ì§€ì›
    if (els.searchInput) {
        els.searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                els.btnSearch.click();
            }
        });
    }

    // 2. ë¶„ì„(Dry Run) ë¡œì§
    if (els.btnAnalyze) {
    els.btnAnalyze.onclick = async () => {
            if (!els.btnAnalyze) return;
        els.btnAnalyze.disabled = true;
        els.analysisSection.style.display = 'none';
        els.btnExecute.style.display = 'none';
        els.resultBody.innerHTML = '';
        executionPlan = []; // ì´ˆê¸°í™”

        const patternMode = document.querySelector('input[name="patternMode"]:checked').value;
        const mode = document.querySelector('input[name="mode"]:checked').value;

        // UIì— ë¡œë”© í‘œì‹œ
        els.resultBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">ğŸ“‚ íŒŒì¼ê³¼ í´ë”ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</td></tr>';

        // íŒŒì¼ ìŠ¤ìº”
        const files = [];
        for await (const entry of sourceHandle.values()) {
            if (entry.kind === 'file' && !entry.name.startsWith('.')) files.push(entry);
        }

        if (files.length === 0) {
            // ì‚¬ìš©ì ì¹œí™”ì  ì—ëŸ¬ ë©”ì‹œì§€
            const errorMsg = 'ì›ë³¸ í´ë”ì— íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.\n\ní™•ì¸ ì‚¬í•­:\nâ€¢ í´ë”ê°€ ì˜¬ë°”ë¥´ê²Œ ì„ íƒë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.\nâ€¢ ìˆ¨ê¹€ íŒŒì¼(.ìœ¼ë¡œ ì‹œì‘)ì€ ì œì™¸ë©ë‹ˆë‹¤.';
            
            // í”¼ë“œë°± ìˆ˜ì§‘
            if (window.CleanArch?.feedbackCollector) {
                window.CleanArch.feedbackCollector.collect('warning', {
                    context: 'analysis_no_files',
                    message: errorMsg
                });
            }
            
            alert(errorMsg);
            els.btnAnalyze.disabled = false;
            return;
        }

        // ì—„ê²© ëª¨ë“œ (ì ‘ë¯¸ì‚¬/ì ‘ë‘ì‚¬) ì„ íƒ ì‹œ íŒ¨í„´ ë¶„ì„ ì‹¤í–‰
        // ë§¤ë²ˆ íŒ¨í„´ ë¶„ì„ì„ ì‹¤í–‰í•˜ì—¬ ìµœì‹  ë¶„ì„ ê²°ê³¼ë¥¼ ì œê³µ
        let isStrictMode = false;
        const strictModeContainer = document.getElementById('strictModeContainer');
        
        if (patternMode === 'prefix-suffix' && window.StrictMode && window.StrictMode.renderer) {
            // strictModeContainer í‘œì‹œ
            if (strictModeContainer) {
                strictModeContainer.style.display = 'block';
            }
            window.StrictMode.renderer.currentMode = 'prefix-suffix';
            window.StrictMode.renderer._triggerPrefixSuffixAnalysis(files);
            isStrictMode = true;
            // ì ‘ë¯¸ì‚¬/ì ‘ë‘ì‚¬ ëª¨ë“œì—ì„œëŠ” íŒ¨í„´ ë¶„ì„ í›„ ì„ íƒì´ ì§„í–‰ë˜ë¯€ë¡œ ì—¬ê¸°ì„œ ì¤‘ë‹¨
            els.resultBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">ğŸ“Š íŒ¨í„´ ë¶„ì„ ê²°ê³¼ë¥¼ í™•ì¸í•˜ê³  íŒ¨í„´ì„ ì„ íƒí•´ì£¼ì„¸ìš”.</td></tr>';
            els.btnAnalyze.disabled = false;
            return;
        } else if (patternMode === 'strict' && window.StrictMode && window.StrictMode.renderer) {
            // strictModeContainer í‘œì‹œ
            if (strictModeContainer) {
                strictModeContainer.style.display = 'block';
            }
            window.StrictMode.renderer.currentMode = 'number-only';
            window.StrictMode.renderer._triggerNumberNumberAnalysis(files);
            isStrictMode = true;
            // ìˆ«ì-ìˆ«ì ëª¨ë“œì—ì„œë„ íŒ¨í„´ ë¶„ì„ í›„ ì„ íƒì´ ì§„í–‰ë˜ë¯€ë¡œ ì—¬ê¸°ì„œ ì¤‘ë‹¨
            els.resultBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">ğŸ“Š íŒ¨í„´ ë¶„ì„ ê²°ê³¼ë¥¼ í™•ì¸í•˜ê³  íŒ¨í„´ì„ ì„ íƒí•´ì£¼ì„¸ìš”.</td></tr>';
            els.btnAnalyze.disabled = false;
            return;
        } else {
            if (strictModeContainer) {
                strictModeContainer.style.display = 'none';
            }
        }

        // ì¤‘ë³µ íŒŒì¼ íƒì§€ (ì˜µì…˜ í™œì„±í™” ì‹œ)
        const enableDuplicateCheck = document.getElementById('enableDuplicateCheck')?.checked || false;
        let duplicateFiles = [];
        if (enableDuplicateCheck && window.CleanArch && window.CleanArch.duplicateDetectionUseCases) {
            try {
                els.resultBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">ğŸ” ì¤‘ë³µ íŒŒì¼ íƒì§€ ì¤‘...</td></tr>';
                duplicateFiles = await window.CleanArch.duplicateDetectionUseCases.detectDuplicates(files);
            } catch (e) {
                console.error('[Analysis] Duplicate detection failed:', e);
            }
        }

        // íŒŒì¼ëª… ì²´ê³„í™” ì¤€ë¹„ (ì˜µì…˜ í™œì„±í™” ì‹œ, ì—„ê²© ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ)
        const enableRename = document.getElementById('enableRename')?.checked || false;
        const renameResults = new Map();
        if (enableRename && !isStrictMode && window.CleanArch && window.CleanArch.fileNamingUseCases && window.CleanArch.metadataExtractor) {
            try {
                els.resultBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">ğŸ“ íŒŒì¼ëª… ì²´ê³„í™” ì¤€ë¹„ ì¤‘...</td></tr>';
                for (let i = 0; i < Math.min(files.length, 100); i++) {
                    try {
                        const metadata = await window.CleanArch.metadataExtractor.extractExtended(files[i]);
                        if (metadata) {
                            // ìë™ íƒœê·¸ ìƒì„±
                            if (window.CleanArch.tagManagementUseCases) {
                                const autoTags = window.CleanArch.tagManagementUseCases.generateAutoTags(metadata);
                                if (metadata.tags) {
                                    metadata.tags.push(...autoTags);
                                } else {
                                    metadata.tags = autoTags;
                                }
                            }

                            // ê²€ìƒ‰ ì¸ë±ìŠ¤ì— ì¶”ê°€
                            if (window.CleanArch.smartSearchUseCases) {
                                window.CleanArch.smartSearchUseCases.indexFile(files[i], metadata);
                            }

                            const newName = window.CleanArch.fileNamingUseCases.generateName(files[i], null, metadata.basic || metadata, i);
                            renameResults.set(files[i], {
                                file: files[i],
                                originalName: files[i].name,
                                newName: newName,
                                metadata: metadata
                            });
                        }
                    } catch (e) {
                        console.error('[Analysis] Metadata extraction failed:', e);
                    }
                }
            } catch (e) {
                console.error('[Analysis] Rename preparation failed:', e);
            }
        }

        let matchCount = 0;
        let failCount = 0;
        let htmlRows = '';

        // ì„±ëŠ¥ ìµœì í™”: ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬ (ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ < 5ì´ˆ ëª©í‘œ)
        const CHUNK_SIZE = 50; // í•œ ë²ˆì— ì²˜ë¦¬í•  íŒŒì¼ ìˆ˜
        const processChunk = async (chunk, startIndex) => {
            const chunkResults = [];
            for (let i = 0; i < chunk.length; i++) {
                const file = chunk[i];
                let pattern = null;
            let status = 'ëŒ€ê¸°';
            let targetPath = '-';
            let targetDirHandle = null;
            let note = '';

                // ì§€ëŠ¥ì  ë¶„ë¥˜ ëª¨ë“œ (ìºì‹± ì ìš©)
                if (patternMode === 'intelligent' && window.CleanArch && window.CleanArch.intelligentClassificationUseCases) {
                    try {
                        // ìºì‹œ í™•ì¸
                        const cacheKey = `metadata_${file.name}_${file.size}`;
                        let metadata = window.CleanArch.cacheManager?.get(cacheKey);
                        
                        if (!metadata) {
                            metadata = await window.CleanArch.metadataExtractor.extractExtended(file);
                            if (metadata && window.CleanArch.cacheManager) {
                                window.CleanArch.cacheManager.set(cacheKey, metadata, 1800000); // 30ë¶„ ìºì‹œ
                            }
                        }

                        if (metadata) {
                            const category = window.CleanArch.intelligentClassificationUseCases.classifyByMetadata(file, metadata);
                            pattern = category;
                            // íŒŒì¼ëª… ì²´ê³„í™” ì ìš©
                            const renameResult = renameResults.get(file);
                            if (enableRename && renameResult) {
                                note = `ìë™ ë¶„ë¥˜: ${category} | ìƒˆ ì´ë¦„: ${renameResult.newName}`;
                            } else {
                                note = `ìë™ ë¶„ë¥˜: ${category}`;
                            }
                        } else {
                            pattern = extractPattern(file.name, 'auto');
                        }
                    } catch (e) {
                        // ì—ëŸ¬ í”¼ë“œë°± ìˆ˜ì§‘
                        if (window.CleanArch?.feedbackCollector) {
                            window.CleanArch.feedbackCollector.collect('error', {
                                context: 'intelligent_classification',
                                error: e.message,
                                file: file.name
                            });
                        }
                        console.error('[Analysis] Intelligent classification failed:', e);
                        pattern = extractPattern(file.name, 'auto');
                    }
                }
                // ì—„ê²© ëª¨ë“œì—ì„œ ì„ íƒëœ íŒ¨í„´ì´ ìˆìœ¼ë©´ í•´ë‹¹ íŒ¨í„´ìœ¼ë¡œ ê²€ì¦ (ë‹¤ì¤‘ íŒ¨í„´ ì§€ì›)
                else if (patternMode === 'strict' || patternMode === 'prefix-suffix') {
                    if (window.StrictMode && window.StrictMode.modeManager) {
                        const selectedPatterns = window.StrictMode.modeManager.getSelectedPatterns();
                        if (selectedPatterns && selectedPatterns.length > 0) {
                            // ë‹¤ì¤‘ íŒ¨í„´ìœ¼ë¡œ ê²€ì¦: í•˜ë‚˜ë¼ë„ ë§¤ì¹­ë˜ë©´ ìœ íš¨
                            const validation = window.StrictMode.modeManager.validate(file.name);
                            if (validation.valid && validation.matchedPattern) {
                                const matchedPattern = validation.matchedPattern;
                                if (patternMode === 'strict') {
                                    pattern = extractPattern(file.name, 'strict');
                                } else {
                                    // ì ‘ë¯¸ì‚¬/ì ‘ë‘ì‚¬ ëª¨ë“œì—ì„œëŠ” íŒ¨í„´ ì¶”ì¶œ ë¡œì§ ë³€ê²½
                                    if (matchedPattern.prefix) {
                                        pattern = matchedPattern.prefix;
                                    } else if (matchedPattern.suffix) {
                                        pattern = matchedPattern.suffix;
                                    }
                                }
                                // íŒŒì¼ëª… ì²´ê³„í™” ì ìš© (ì—„ê²© ëª¨ë“œì—ì„œë„)
                                const renameResult = renameResults.get(file);
                                if (enableRename && renameResult) {
                                    note = `íŒ¨í„´ ë§¤ì¹­: ${pattern} (${selectedPatterns.length}ê°œ íŒ¨í„´ ì¤‘ ë§¤ì¹­) | ìƒˆ ì´ë¦„: ${renameResult.newName}`;
                                } else {
                                    note = `íŒ¨í„´ ë§¤ì¹­: ${pattern} (${selectedPatterns.length}ê°œ íŒ¨í„´ ì¤‘ ë§¤ì¹­)`;
                                }
                            } else {
                                status = 'íŒ¨í„´ ë¶ˆì¼ì¹˜';
                                // ìƒì„¸í•œ íŒ¨í„´ ë¶ˆì¼ì¹˜ ë¶„ì„ ë‚´ì—­ ìƒì„±
                                const patternDetails = selectedPatterns.map((p, idx) => {
                                    let patternStr = '';
                                    if (p.pattern) {
                                        patternStr = `íŒ¨í„´ ${idx + 1}: ${p.pattern} (${p.leftLength}ìë¦¬${p.separator}${p.rightLength}ìë¦¬)`;
                                    } else if (p.prefix) {
                                        patternStr = `íŒ¨í„´ ${idx + 1}: ì ‘ë‘ì‚¬ "${p.prefix}"`;
                                    } else if (p.suffix) {
                                        patternStr = `íŒ¨í„´ ${idx + 1}: ì ‘ë¯¸ì‚¬ "${p.suffix}"`;
                                    }
                                    return patternStr;
                                }).join(' | ');
                                
                                // íŒŒì¼ëª…ê³¼ í´ë”ëª… ì •ë³´ ì¶”ê°€
                                const fileName = file.name;
                                const folderName = sourceHandle.name || 'ì•Œ ìˆ˜ ì—†ìŒ';
                                
                                note = `íŒŒì¼ëª…: "${fileName}" | í´ë”: "${folderName}" | ê²€ì‚¬ ê²°ê³¼: ì„ íƒí•œ ${selectedPatterns.length}ê°œ íŒ¨í„´ ì¤‘ ì¼ì¹˜í•˜ëŠ” íŒ¨í„´ ì—†ìŒ | ê²€ì‚¬í•œ íŒ¨í„´: ${patternDetails}`;
                            }
                        } else {
                            // íŒ¨í„´ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                            status = 'íŒ¨í„´ ë¯¸ì„ íƒ';
                            note = 'íŒ¨í„´ì„ ì„ íƒí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. íŒ¨í„´ì„ ì„ íƒí•œ í›„ ë‹¤ì‹œ ë¶„ì„í•´ì£¼ì„¸ìš”.';
                            pattern = null;
                        }
                    } else {
                        // StrictModeê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ê¸°ë³¸ ì¶”ì¶œ
                        pattern = extractPattern(file.name, patternMode);
                        note = 'ì—„ê²© ëª¨ë“œ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
                    }
                } else {
                    // ì¼ë°˜ ëª¨ë“œ (auto, intelligent)
                    pattern = extractPattern(file.name, patternMode);
                    // íŒŒì¼ëª… ì²´ê³„í™” ì ìš©
                    const renameResult = renameResults.get(file);
                    if (enableRename && renameResult && pattern) {
                        note = `íŒ¨í„´: ${pattern} | ìƒˆ ì´ë¦„: ${renameResult.newName}`;
                    } else if (pattern) {
                        note = `íŒ¨í„´: ${pattern}`;
                    }
                }

            if (pattern) {
                    // ì§€ëŠ¥ì  ë¶„ë¥˜ ëª¨ë“œì—ì„œëŠ” í´ë” êµ¬ì¡° ìƒì„± ë˜ëŠ” ê¸°ì¡´ í´ë” ì°¾ê¸°
                    if (patternMode === 'intelligent') {
                        // ì¹´í…Œê³ ë¦¬ ê¸°ë°˜ í´ë” ì°¾ê¸° ë˜ëŠ” ìƒì„±
                targetDirHandle = await findDeepFolder(targetHandle, pattern);
                        if (!targetDirHandle) {
                            // í´ë”ê°€ ì—†ìœ¼ë©´ ë£¨íŠ¸ì— ì¹´í…Œê³ ë¦¬ëª…ìœ¼ë¡œ í´ë” ìƒì„± ì‹œë„
                            try {
                                targetDirHandle = await targetHandle.getDirectoryHandle(pattern, { create: true });
                            } catch (e) {
                                console.error('[Analysis] Folder creation failed:', e);
                            }
                        }
                    } else {
                        targetDirHandle = await findDeepFolder(targetHandle, pattern);
                    }
                    
                if (targetDirHandle) {
                    status = 'ë§¤ì¹­ ì„±ê³µ';
                        targetPath = targetDirHandle.name;
                        // noteëŠ” ì´ë¯¸ ìœ„ì—ì„œ ì„¤ì •ë¨ (íŒŒì¼ëª… ì²´ê³„í™” í¬í•¨)
                        if (!note) {
                            if (patternMode === 'intelligent') {
                                note = `ìë™ ë¶„ë¥˜: ${pattern}`;
                            } else {
                    note = `íŒ¨í„´: ${pattern}`;
                            }
                        }
                } else {
                    status = 'í´ë” ì—†ìŒ';
                        note = note || `íŒ¨í„´(${pattern}) í´ë” ë¯¸ë°œê²¬`;
                }
                } else if (status === 'ëŒ€ê¸°') {
                    // íŒ¨í„´ì´ ì—†ê±°ë‚˜ ì„ íƒë˜ì§€ ì•Šì€ ê²½ìš°
                    if (status === 'íŒ¨í„´ ë¯¸ì„ íƒ') {
                        // ì´ë¯¸ ì„¤ì •ë¨
            } else {
                status = 'íŒ¨í„´ ì—†ìŒ';
                        note = note || 'ìˆ«ì íŒ¨í„´ ë¯¸ê°ì§€';
                    }
            }

                chunkResults.push({
                fileHandle: file,
                targetHandle: targetDirHandle,
                status: status,
                note: note,
                    originalStatus: status,
                    index: startIndex + i
                });
            }
            return chunkResults;
        };

        // ì²­í¬ ë‹¨ìœ„ë¡œ ë³‘ë ¬ ì²˜ë¦¬ (ì„±ëŠ¥ ìµœì í™”)
        const chunks = [];
        for (let i = 0; i < files.length; i += CHUNK_SIZE) {
            chunks.push(files.slice(i, i + CHUNK_SIZE));
        }

        // ì²­í¬ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ë˜, ê° ì²­í¬ ë‚´ì—ì„œëŠ” ë³‘ë ¬ ì²˜ë¦¬
        for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
            const chunk = chunks[chunkIndex];
            const chunkResults = await processChunk(chunk, chunkIndex * CHUNK_SIZE);
            
            // ê²°ê³¼ ì§‘ê³„
            chunkResults.forEach(result => {
                // ìƒíƒœë³„ ì¹´ìš´íŠ¸ (í´ë¦° ì•„í‚¤í…ì²˜ ì›ì¹™: ëª…í™•í•œ ìƒíƒœ ë¶„ë¥˜)
                if (result.status === 'ë§¤ì¹­ ì„±ê³µ') {
                    matchCount++;
                } else if (result.status === 'íŒ¨í„´ ë¯¸ì„ íƒ') {
                    // íŒ¨í„´ ë¯¸ì„ íƒì€ ì‚¬ìš©ì ì•¡ì…˜ì´ í•„ìš”í•œ ìƒíƒœì´ë¯€ë¡œ ì‹¤íŒ¨ë¡œ ì¹´ìš´íŠ¸
                    failCount++;
                } else if (result.status === 'íŒ¨í„´ ë¶ˆì¼ì¹˜' || result.status === 'íŒ¨í„´ ì—†ìŒ' || result.status === 'í´ë” ì—†ìŒ') {
                    failCount++;
                } else {
                    // ê¸°íƒ€ ìƒíƒœ (ëŒ€ê¸°, ì—ëŸ¬ ë“±)
                    failCount++;
                }
                
                // íŒŒì¼ëª… ì²´ê³„í™” ê²°ê³¼ ì €ì¥
                const renameResult = renameResults.get(result.fileHandle);
                
                executionPlan.push({
                    fileHandle: result.fileHandle,
                    targetHandle: result.targetHandle,
                    status: result.status,
                    note: result.note,
                    originalStatus: result.originalStatus,
                    renameResult: renameResult || null
                });

                // í…Œì´ë¸” í”„ë¦¬ë·°
                const colorClass = (result.status === 'ë§¤ì¹­ ì„±ê³µ') ? 'status-ready' : 'status-skip';
            htmlRows += `
                <tr>
                        <td>${result.fileHandle.name}</td>
                        <td>${result.targetHandle ? result.targetHandle.name : '-'}</td>
                        <td class="${colorClass}">${result.status}</td>
                        <td>${result.note}</td>
                </tr>
            `;
            });
            
            // UI ì—…ë°ì´íŠ¸ (ì§„í–‰ ìƒí™© í‘œì‹œ)
            if (chunkIndex % 5 === 0 || chunkIndex === chunks.length - 1) {
                els.resultBody.innerHTML = htmlRows + '<tr><td colspan="4" style="text-align:center; color:#64748b;">ë¶„ì„ ì¤‘... ' + Math.round(((chunkIndex + 1) / chunks.length) * 100) + '%</td></tr>';
            }
        }

        // ê²°ê³¼ ë¦¬í¬íŠ¸ UI ì—…ë°ì´íŠ¸
        els.resultBody.innerHTML = htmlRows;
        
        const modeText = mode === 'move' ? "ì´ë™(ì›ë³¸ì‚­ì œ)" : "ë³µì‚¬(ì›ë³¸ìœ ì§€)";
        const patternModeText = patternMode === 'strict' ? 'ì—„ê²© ëª¨ë“œ (ìˆ«ì-ìˆ«ì)' : 
                                patternMode === 'prefix-suffix' ? 'ì—„ê²© ëª¨ë“œ (ì ‘ë¯¸ì‚¬/ì ‘ë‘ì‚¬)' :
                                patternMode === 'intelligent' ? 'ì§€ëŠ¥ì  ë¶„ë¥˜ (ë©”íƒ€ë°ì´í„° ê¸°ë°˜)' : 'ìŠ¤ë§ˆíŠ¸ ìë™';
        els.analysisSummary.textContent = `ğŸ“Š ë¶„ì„ ê²°ê³¼: ì´ ${files.length}ê°œ ì¤‘ ${matchCount}ê°œ ë¶„ë¥˜ ê°€ëŠ¥`;
        
        // íŒ¨í„´ ë¯¸ì„ íƒ íŒŒì¼ ìˆ˜ í™•ì¸
        const patternNotSelectedCount = executionPlan.filter(p => p.status === 'íŒ¨í„´ ë¯¸ì„ íƒ').length;
        let detailHtml = `
            â€¢ ë¶„ë¥˜ ë°©ì‹: <strong>${patternModeText}</strong><br>
            â€¢ ì‘ì—… ë°©ì‹: <strong>${modeText}</strong><br>
            â€¢ ì„±ê³µ ì˜ˆìƒ: ${matchCount}ê±´ / ê±´ë„ˆëœ€ ì˜ˆìƒ: ${failCount}ê±´<br>
        `;
        
        // íŒ¨í„´ ë¯¸ì„ íƒ ê²½ê³  ë©”ì‹œì§€ ì¶”ê°€
        if (patternNotSelectedCount > 0 && (patternMode === 'strict' || patternMode === 'prefix-suffix')) {
            detailHtml += `â€¢ âš ï¸ íŒ¨í„´ ë¯¸ì„ íƒ: ${patternNotSelectedCount}ê°œ íŒŒì¼ (íŒ¨í„´ì„ ì„ íƒí•œ í›„ ë‹¤ì‹œ ë¶„ì„í•´ì£¼ì„¸ìš”)<br>`;
        }
        if (duplicateFiles.length > 0) {
            const duplicateCount = duplicateFiles.reduce((sum, dup) => sum + dup.count, 0);
            detailHtml += `â€¢ âš ï¸ ì¤‘ë³µ íŒŒì¼: ${duplicateFiles.length}ê°œ ê·¸ë£¹ (ì´ ${duplicateCount}ê°œ íŒŒì¼)<br>`;
        }
        if (enableRename && renameResults.size > 0) {
            detailHtml += `â€¢ ğŸ“ íŒŒì¼ëª… ì²´ê³„í™”: ${renameResults.size}ê°œ íŒŒì¼ ì¤€ë¹„ë¨<br>`;
        }
        els.analysisDetail.innerHTML = detailHtml;

        els.analysisSection.style.display = 'block';
        if (matchCount > 0) {
            els.btnExecute.style.display = 'block';
        } else {
            // ì—„ê²© ëª¨ë“œì—ì„œ íŒ¨í„´ ë¶ˆì¼ì¹˜ íŒŒì¼ì´ ìˆëŠ” ê²½ìš° ìƒì„¸ ë¶„ì„ ë‚´ì—­ í‘œì‹œ
            const patternMismatchFiles = executionPlan.filter(p => p.status === 'íŒ¨í„´ ë¶ˆì¼ì¹˜');
            if (patternMismatchFiles.length > 0 && (patternMode === 'strict' || patternMode === 'prefix-suffix')) {
                // ìƒì„¸ ë¶„ì„ ë‚´ì—­ì„ HTMLë¡œ êµ¬ì„±
                let detailAnalysisHtml = '<div style="background:#fef2f2; padding:15px; border-radius:6px; border:1px solid #fecaca; margin-top:15px;">';
                detailAnalysisHtml += '<h4 style="color:#dc2626; margin-bottom:10px;">âš ï¸ íŒ¨í„´ ë¶ˆì¼ì¹˜ ìƒì„¸ ë¶„ì„ ë‚´ì—­</h4>';
                detailAnalysisHtml += `<p style="color:#7f1d1d; margin-bottom:10px;">ì´ ${patternMismatchFiles.length}ê°œ íŒŒì¼ì´ ì„ íƒí•œ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>`;
                detailAnalysisHtml += '<div style="max-height:300px; overflow-y:auto; background:white; padding:10px; border-radius:4px;">';
                
                patternMismatchFiles.forEach((item, idx) => {
                    detailAnalysisHtml += `<div style="padding:8px; border-bottom:1px solid #fee2e2; font-size:0.9rem;">`;
                    detailAnalysisHtml += `<strong>íŒŒì¼ ${idx + 1}:</strong> ${item.fileHandle.name}<br>`;
                    detailAnalysisHtml += `<span style="color:#64748b;">${item.note}</span>`;
                    detailAnalysisHtml += `</div>`;
                });
                
                detailAnalysisHtml += '</div>';
                detailAnalysisHtml += '<p style="color:#7f1d1d; margin-top:10px; font-size:0.85rem;">ğŸ’¡ ë‹¤ë¥¸ íŒ¨í„´ì„ ì„ íƒí•˜ê±°ë‚˜ íŒŒì¼ëª…ì„ í™•ì¸í•´ì£¼ì„¸ìš”.</p>';
                detailAnalysisHtml += '</div>';
                
                // analysisDetailì— ì¶”ê°€
                els.analysisDetail.innerHTML += detailAnalysisHtml;
            } else {
                // ì¼ë°˜ ëª¨ë“œì—ì„œ ë§¤ì¹­ì´ ì—†ëŠ” ê²½ìš°
                let helpMsg = "ë§¤ì¹­ë˜ëŠ” íŒŒì¼ì´ í•˜ë‚˜ë„ ì—†ìŠµë‹ˆë‹¤.\n\n";
                helpMsg += "ê°€ëŠ¥í•œ ì›ì¸:\n";
                helpMsg += `â€¢ ì„ íƒí•œ ê°ì§€ ëª¨ë“œ: ${patternModeText}\n`;
                helpMsg += "â€¢ íŒŒì¼ëª…ì— íŒ¨í„´ì´ ì—†ëŠ” ê²½ìš°\n";
                helpMsg += "â€¢ ëŒ€ìƒ í´ë” êµ¬ì¡°ê°€ ë§ì§€ ì•ŠëŠ” ê²½ìš°\n\n";
                helpMsg += "í•´ê²° ë°©ë²•:\n";
                helpMsg += "â€¢ ë‹¤ë¥¸ ê°ì§€ ëª¨ë“œë¥¼ ì‹œë„í•´ë³´ì„¸ìš”.\n";
                helpMsg += "â€¢ ëŒ€ìƒ í´ë” êµ¬ì¡°ë¥¼ í™•ì¸í•˜ì„¸ìš”.\n";
                helpMsg += "â€¢ íŒŒì¼ëª… íŒ¨í„´ì„ í™•ì¸í•˜ì„¸ìš”.";
                
                // í”¼ë“œë°± ìˆ˜ì§‘
                if (window.CleanArch?.feedbackCollector) {
                    window.CleanArch.feedbackCollector.collect('warning', {
                        context: 'analysis_no_matches',
                        patternMode: patternMode,
                        fileCount: files.length
                    });
                }
                
                alert(helpMsg);
            }
        }
        
        // ë‹¨ê¸° í™•ì¥: ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸
        const matchedCount = executionPlan.filter(p => p.originalStatus === 'ë§¤ì¹­ ì„±ê³µ').length;
        const totalCount = executionPlan.length;
        let avgConfidence = 0;
        if (executionPlan.length > 0) {
            const confidences = executionPlan.map(p => p.confidence || 0).filter(c => c > 0);
            if (confidences.length > 0) {
                avgConfidence = confidences.reduce((sum, c) => sum + c, 0) / confidences.length;
            }
        }
        if (typeof updateRealtimeDashboard === 'function') {
            updateRealtimeDashboard({
                totalFiles: totalCount,
                matchedFiles: matchedCount,
                avgConfidence: avgConfidence
            });
        }
        
        if (els.btnAnalyze) els.btnAnalyze.disabled = false;
        };
    }

    // 3. ì‹¤í–‰(Execute) ë¡œì§
    if (els.btnExecute) {
    els.btnExecute.onclick = async () => {
        if (!confirm("ì •ë§ë¡œ ì‘ì—…ì„ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ë™ ëª¨ë“œì¼ ê²½ìš° ì›ë³¸ íŒŒì¼ì€ ì‚­ì œë©ë‹ˆë‹¤.")) return;

        // ì‹¤í–‰ ê³„íš ê²€ì¦ (í´ë¦° ì•„í‚¤í…ì²˜ ì›ì¹™: ì‚¬ì „ ê²€ì¦)
        if (!executionPlan || executionPlan.length === 0) {
            alert('ì‹¤í–‰í•  ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë¶„ì„ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.');
            return;
        }
        
        // íŒ¨í„´ ë¯¸ì„ íƒ íŒŒì¼ í™•ì¸ (ì—„ê²© ëª¨ë“œ)
        const patternMode = document.querySelector('input[name="patternMode"]:checked')?.value;
        if ((patternMode === 'strict' || patternMode === 'prefix-suffix')) {
            const patternNotSelected = executionPlan.filter(p => p.status === 'íŒ¨í„´ ë¯¸ì„ íƒ');
            if (patternNotSelected.length > 0) {
                const proceed = confirm(
                    `íŒ¨í„´ì´ ì„ íƒë˜ì§€ ì•Šì€ íŒŒì¼ì´ ${patternNotSelected.length}ê°œ ìˆìŠµë‹ˆë‹¤.\n` +
                    `ì´ íŒŒì¼ë“¤ì€ ê±´ë„ˆë›°ê³  ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n` +
                    `íŒ¨í„´ì„ ì„ íƒí•˜ë ¤ë©´ ë¶„ì„ì„ ë‹¤ì‹œ ì‹¤í–‰í•˜ì„¸ìš”.`
                );
                if (!proceed) return;
            }
        }

        // ì‘ì—… ê²€ì¦
        if (window.CleanArch && window.CleanArch.batchOperationUseCases) {
            const validation = window.CleanArch.batchOperationUseCases.validateOperation(
                executionPlan.map(p => p.fileHandle).filter(f => f),
                targetHandle,
                document.querySelector('input[name="mode"]:checked').value
            );

            if (!validation.valid) {
                alert('ì‘ì—… ê²€ì¦ ì‹¤íŒ¨:\n' + validation.errors.join('\n'));
                return;
            }

            if (validation.warnings.length > 0) {
                const proceed = confirm('ê²½ê³ :\n' + validation.warnings.join('\n') + '\n\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                if (!proceed) return;
            }
        }

        // ìŠ¤ëƒ…ìƒ· ìƒì„±
        const mode = document.querySelector('input[name="mode"]:checked').value;
        if (window.CleanArch && window.CleanArch.batchOperationUseCases) {
            currentSnapshot = window.CleanArch.batchOperationUseCases.createSnapshot(
                mode,
                executionPlan.map(p => p.fileHandle).filter(f => f),
                executionPlan
            );
            console.log('[Execute] Snapshot created:', currentSnapshot.id);
        }

        els.btnExecute.disabled = true;
        els.btnAnalyze.disabled = true;
        els.progressWrap.style.display = 'block';
        
        const conflict = document.querySelector('input[name="conflict"]:checked').value;

        let processed = 0;
        let success = 0;
        let error = 0;
        const total = executionPlan.length;
        const tableRows = els.resultBody.querySelectorAll('tr');

        for (let i = 0; i < total; i++) {
            const plan = executionPlan[i];
            const row = tableRows[i]; // í…Œì´ë¸” í–‰ ì—…ë°ì´íŠ¸ìš©

            // ì§„í–‰ìœ¨ ì—…ë°ì´íŠ¸ (ê°œì„ ëœ UI)
            processed++;
            const pct = Math.round((processed / total) * 100);
            els.progressFill.style.width = pct + '%';
            const progressLabel = document.getElementById('progressLabel');
            if (progressLabel) {
                progressLabel.textContent = `${pct}%`;
            }
            const progressStatus = document.getElementById('progressStatus');
            const progressDetails = document.getElementById('progressDetails');
            if (progressStatus) {
                progressStatus.textContent = `ì²˜ë¦¬ ì¤‘: ${plan.fileHandle?.name || 'íŒŒì¼'}...`;
            }
            if (progressDetails) {
                progressDetails.textContent = `${processed} / ${total} (ì„±ê³µ: ${success}, ì‹¤íŒ¨: ${error})`;
            }

            // ë§¤ì¹­ ì„±ê³µí–ˆë˜ ê±´ë§Œ ì²˜ë¦¬
            if (plan.originalStatus === 'ë§¤ì¹­ ì„±ê³µ' && plan.targetHandle) {
                try {
                    const file = plan.fileHandle;
                    const destDir = plan.targetHandle;
                    let finalName = file.name;
                    let actionResult = "ì„±ê³µ";

                    // ì¤‘ë³µ ì²´í¬ ë° ì²˜ë¦¬
                    let exists = false;
                    try { await destDir.getFileHandle(finalName); exists = true; } catch {}

                    if (exists) {
                        if (conflict === 'skip') {
                            actionResult = "ê±´ë„ˆëœ€(ì¤‘ë³µ)";
                            updateRow(row, "ê±´ë„ˆëœ€", "ì¤‘ë³µ íŒŒì¼ ì¡´ì¬", "status-skip");
                            plan.finalResult = "Skip";
                            continue;
                        } else if (conflict === 'rename') {
                            let cnt = 1;
                            while(true) {
                                try {
                                    const dot = file.name.lastIndexOf('.');
                                    const base = dot === -1 ? file.name : file.name.slice(0, dot);
                                    const ext = dot === -1 ? '' : file.name.slice(dot);
                                    const tempName = `${base}(${cnt})${ext}`;
                                    await destDir.getFileHandle(tempName);
                                    cnt++;
                                } catch {
                                    const dot = file.name.lastIndexOf('.');
                                    const base = dot === -1 ? file.name : file.name.slice(0, dot);
                                    const ext = dot === -1 ? '' : file.name.slice(dot);
                                    finalName = `${base}(${cnt})${ext}`;
                                    actionResult = "ì„±ê³µ(ì´ë¦„ë³€ê²½)";
                                    break;
                                }
                            }
                        }
                    }

                    // íŒŒì¼ëª… ì²´ê³„í™” ì ìš© (ì˜µì…˜ í™œì„±í™” ì‹œ)
                    const enableRename = document.getElementById('enableRename')?.checked || false;
                    let actualFileName = finalName;
                    if (enableRename && window.CleanArch && window.CleanArch.fileNamingUseCases) {
                        // ë¶„ì„ ë‹¨ê³„ì—ì„œ ì¤€ë¹„ëœ íŒŒì¼ëª… ì‚¬ìš©
                        const renameResult = executionPlan.find(p => p.fileHandle === file)?.renameResult;
                        if (renameResult && renameResult.newName && renameResult.newName !== file.name) {
                            actualFileName = renameResult.newName;
                            actionResult += "(ì´ë¦„ë³€ê²½)";
                        }
                    }

                    // ì“°ê¸° ì‘ì—…
                    const fileData = await file.getFile();
                    const newHandle = await destDir.getFileHandle(actualFileName, { create: true });
                    const writable = await newHandle.createWritable();
                    await writable.write(fileData);
                    await writable.close();

                    // ì´ë™ ëª¨ë“œë©´ ì›ë³¸ ì‚­ì œ
                    if (mode === 'move') {
                        await sourceHandle.removeEntry(file.name);
                        actionResult += "/ì´ë™ì™„ë£Œ";
                    } else {
                        actionResult += "/ë³µì‚¬ì™„ë£Œ";
                    }

                    success++;
                    updateRow(row, "ì™„ë£Œ", actionResult, "status-success");
                    plan.finalResult = "Success";
                    plan.finalNote = actionResult;
                    plan.destPath = destDir.name + "/" + finalName;

                } catch (err) {
                    error++;
                    const errorMsg = err.message || 'Unknown error';
                    updateRow(row, "ì‹¤íŒ¨", errorMsg, "status-fail");
                    plan.finalResult = "Fail";
                    plan.finalNote = errorMsg;

                    // ë‹¨ê¸° í™•ì¥: íˆìŠ¤í† ë¦¬ ê¸°ë¡ (ì‹¤íŒ¨)
                    if (window.CleanArch && window.CleanArch.historyManagementUseCases) {
                        try {
                            await window.CleanArch.historyManagementUseCases.recordClassification({
                                fileName: file.name,
                                sourcePath: sourceHandle.name,
                                targetPath: destDir.name,
                                pattern: plan.pattern || null,
                                status: 'failed',
                                operation: mode,
                                metadata: {
                                    error: errorMsg,
                                    fileSize: file.size,
                                    fileType: file.type || ''
                                }
                            });
                        } catch (e) {
                            console.error('[History] Failed to record classification:', e);
                        }
                    }
                    
                    // ì—ëŸ¬ í•¸ë“¤ë§ (ê°•í™”)
                    if (errorManager) {
                        const errorEntry = errorManager.handle(err, 'execute.file_operation', {
                            file: file.name,
                            target: destDir.name,
                            index: i,
                            operation: mode,
                            timestamp: new Date().toISOString()
                        });
                        
                        // ì‚¬ìš©ì í”¼ë“œë°± ìˆ˜ì§‘
                        if (window.CleanArch?.feedbackCollector) {
                            window.CleanArch.feedbackCollector.collect('error', {
                                context: 'file_operation',
                                error: errorEntry,
                                file: file.name,
                                recoverable: errorEntry.recoverable
                            });
                        }
                    }
                    if (logger) {
                        logger.error('íŒŒì¼ ì‘ì—… ì‹¤íŒ¨', err, { file: file.name, index: i });
                    }

                    // ì—ëŸ¬ í‘œì‹œ (UI)
                    const progressErrors = document.getElementById('progressErrors');
                    if (progressErrors) {
                        progressErrors.style.display = 'block';
                        const errorCount = error;
                        progressErrors.innerHTML = `âš ï¸ ì˜¤ë¥˜ ë°œìƒ: ${errorCount}ê°œ íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨. ìì„¸í•œ ë‚´ìš©ì€ í…Œì´ë¸”ì„ í™•ì¸í•˜ì„¸ìš”.`;
                    }
                }
            } else {
                // ì›ë˜ ë§¤ì¹­ ì•ˆëœ ê²ƒë“¤
                plan.finalResult = "Skip";
                plan.finalNote = plan.note;
            }
        }

        // íŠ¸ëœì­ì…˜ ì»¤ë°‹
        if (transaction && transactionManager) {
            try {
                await transactionManager.commit(transaction.id);
                logger.log('íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì™„ë£Œ', { transactionId: transaction.id });
            } catch (err) {
                logger.error('íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹¤íŒ¨', err);
                if (errorManager) {
                    errorManager.handle(err, 'execute.transaction_commit');
                }
            }
        }

        // ìŠ¤ëƒ…ìƒ· ì—…ë°ì´íŠ¸
        if (currentSnapshot && window.CleanArch && window.CleanArch.snapshotRepository) {
            currentSnapshot.successCount = success;
            currentSnapshot.failCount = error;
            try {
                await window.CleanArch.snapshotRepository.save(currentSnapshot);
                logger.log('ìŠ¤ëƒ…ìƒ· ì—…ë°ì´íŠ¸ ì™„ë£Œ', { snapshotId: currentSnapshot.id });
            } catch (err) {
                logger.error('ìŠ¤ëƒ…ìƒ· ì—…ë°ì´íŠ¸ ì‹¤íŒ¨', err);
                if (errorManager) {
                    errorManager.handle(err, 'execute.snapshot_update');
                }
            }
        }

        // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ
        if (perfMeasurement) {
            const duration = perfMeasurement.end();
            if (window.CleanArch?.metrics) {
                window.CleanArch.metrics.observe('execute_duration', duration);
            }
        }

        // ì´ë²¤íŠ¸ ë°œìƒ
        if (window.CleanArch?.eventBus) {
            window.CleanArch.eventBus.emit('file.operation.complete', {
                success: success,
                error: error,
                total: total
            });
        }

        // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
        if (window.CleanArch?.metrics) {
            window.CleanArch.metrics.set('last_execution_success_count', success);
            window.CleanArch.metrics.set('last_execution_error_count', error);
        }

        // ì§„í–‰ ìƒíƒœ ì´ˆê¸°í™”
        const progressLabel = document.getElementById('progressLabel');
        const progressStatus = document.getElementById('progressStatus');
        const progressDetails = document.getElementById('progressDetails');
        const progressErrors = document.getElementById('progressErrors');
        
        if (progressLabel) progressLabel.textContent = '100%';
        if (progressStatus) progressStatus.textContent = 'ì™„ë£Œ';
        if (progressDetails) progressDetails.textContent = `${total} / ${total} (ì„±ê³µ: ${success}, ì‹¤íŒ¨: ${error})`;
        if (progressErrors) progressErrors.style.display = error > 0 ? 'block' : 'none';

        // ê²°ê³¼ ë©”ì‹œì§€ (ê°œì„ )
        let resultMsg = `âœ… ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\n\n`;
        resultMsg += `ğŸ“Š ì²˜ë¦¬ ê²°ê³¼:\n`;
        resultMsg += `  â€¢ ì„±ê³µ: ${success}ê±´\n`;
        resultMsg += `  â€¢ ì‹¤íŒ¨: ${error}ê±´\n`;
        resultMsg += `  â€¢ ê±´ë„ˆëœ€: ${total - success - error}ê±´\n`;
        
        if (error > 0) {
            resultMsg += `\nâš ï¸ ì¼ë¶€ íŒŒì¼ ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ í…Œì´ë¸”ì„ í™•ì¸í•˜ì„¸ìš”.`;
        }
        
        // ì‚¬ìš©ì í”¼ë“œë°± ìˆ˜ì§‘
        if (window.CleanArch?.feedbackCollector) {
            window.CleanArch.feedbackCollector.collect('success', {
                context: 'execute_complete',
                success: success,
                error: error,
                total: total,
                mode: mode
            });
        }

        alert(resultMsg);
        logger.log('ì‘ì—… ì™„ë£Œ', { success, error, total });
        
        if (els.btnDownload) els.btnDownload.style.display = 'inline-flex';
        if (els.btnRollback) els.btnRollback.style.display = 'block';
        if (els.btnAnalyze) els.btnAnalyze.disabled = false;
        };
    }

    // 4. ë¡¤ë°± ë¡œì§
    if (els.btnRollback) {
        els.btnRollback.onclick = async () => {
        if (!confirm("ë§ˆì§€ë§‰ ì‘ì—…ì„ ë¡¤ë°±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ë™ëœ íŒŒì¼ì´ ì›ë˜ ìœ„ì¹˜ë¡œ ë³µì›ë©ë‹ˆë‹¤.")) return;

        if (!window.CleanArch || !window.CleanArch.batchOperationUseCases) {
            alert('ë¡¤ë°± ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }

        els.btnRollback.disabled = true;
        els.btnRollback.textContent = 'ë¡¤ë°± ì¤‘...';

        try {
            // ìµœì‹  ìŠ¤ëƒ…ìƒ· ë¡œë“œ
            let snapshot = currentSnapshot;
            if (!snapshot && window.CleanArch.snapshotRepository) {
                snapshot = await window.CleanArch.snapshotRepository.getLatest();
            }

            if (!snapshot) {
                const errorMsg = 'ë¡¤ë°±í•  ìŠ¤ëƒ…ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.\n\n';
                errorMsg += 'ê°€ëŠ¥í•œ ì›ì¸:\n';
                errorMsg += 'â€¢ ì•„ì§ ì‘ì—…ì„ ì‹¤í–‰í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n';
                errorMsg += 'â€¢ ìŠ¤ëƒ…ìƒ·ì´ ì €ì¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n';
                errorMsg += 'â€¢ ë¸Œë¼ìš°ì € ì €ì¥ì†Œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.';
                
                // í”¼ë“œë°± ìˆ˜ì§‘
                if (window.CleanArch?.feedbackCollector) {
                    window.CleanArch.feedbackCollector.collect('warning', {
                        context: 'rollback_no_snapshot'
                    });
                }
                
                alert(errorMsg);
                els.btnRollback.disabled = false;
                els.btnRollback.textContent = 'âª ë§ˆì§€ë§‰ ì‘ì—… ë¡¤ë°±';
                return;
            }

            // ë¡¤ë°± ì‹¤í–‰
            const result = await window.CleanArch.batchOperationUseCases.rollback(snapshot);

            if (result.success) {
                alert(`ë¡¤ë°±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\në³µì›ëœ íŒŒì¼: ${result.rolledBack}ê°œ`);
                // UI ìƒˆë¡œê³ ì¹¨
                els.resultBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">ë¡¤ë°± ì™„ë£Œ. ë¶„ì„ì„ ë‹¤ì‹œ ì‹¤í–‰í•˜ì„¸ìš”.</td></tr>';
                els.btnRollback.style.display = 'none';
                currentSnapshot = null;
            } else {
                alert(`ë¡¤ë°± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n${result.errors.join('\n')}`);
            }
        } catch (e) {
            console.error('[Rollback] Error:', e);
            alert('ë¡¤ë°± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + e.message);
        } finally {
            if (els.btnRollback) {
                els.btnRollback.disabled = false;
                els.btnRollback.textContent = 'âª ë§ˆì§€ë§‰ ì‘ì—… ë¡¤ë°±';
            }
        }
        };
    }

    // í…Œì´ë¸” í–‰ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateRow(tr, statusText, noteText, statusClass) {
        if (!tr) return;
        const cols = tr.querySelectorAll('td');
        if (cols.length >= 4) {
            cols[2].textContent = statusText;
            cols[2].className = statusClass;
            cols[3].textContent = noteText;
        }
    }

    // 4. CSV ë‹¤ìš´ë¡œë“œ ë¡œì§
    if (els.btnDownload) {
    els.btnDownload.onclick = () => {
        // BOM for UTF-8 in Excel
        let csvContent = "\uFEFF"; 
        csvContent += "ì›ë³¸ íŒŒì¼ëª…,ì´ë™ëœ í´ë”,ìµœì¢… ìƒíƒœ,ë¹„ê³ \n";

        executionPlan.forEach(plan => {
            const fileName = plan.fileHandle.name;
            const target = plan.targetHandle ? plan.targetHandle.name : "-";
            const res = plan.finalResult || plan.status;
            const note = plan.finalNote || plan.note;
            
            // CSV ì´ìŠ¤ì¼€ì´í”„ ì²˜ë¦¬ (ì‰¼í‘œ ë“±)
            const safeName = `"${fileName.replace(/"/g, '""')}"`;
            const safeTarget = `"${target.replace(/"/g, '""')}"`;
            const safeNote = `"${note.replace(/"/g, '""')}"`;
            
            csvContent += `${safeName},${safeTarget},${res},${safeNote}\n`;
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", `ë¶„ë¥˜ë‚´ì—­_${new Date().toLocaleDateString()}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
    }


    // --------------------------------------------------------
    // ìœ í‹¸ë¦¬í‹°: íŒ¨í„´ ì¶”ì¶œ ë° í´ë” ê²€ìƒ‰
    // --------------------------------------------------------
    function extractPattern(name, mode) {
        // ì—„ê²© ëª¨ë“œ (ì ‘ë¯¸ì‚¬/ì ‘ë‘ì‚¬)ì—ì„œ ì„ íƒëœ íŒ¨í„´ì´ ìˆìœ¼ë©´ ì‚¬ìš© (ë‹¤ì¤‘ íŒ¨í„´ ì§€ì›)
        if (mode === 'prefix-suffix' && window.StrictMode && window.StrictMode.modeManager) {
            const selectedPatterns = window.StrictMode.modeManager.getSelectedPatterns();
            if (selectedPatterns && selectedPatterns.length > 0) {
                for (const selectedPattern of selectedPatterns) {
                    if (selectedPattern.prefix && name.startsWith(selectedPattern.prefix)) {
                        return selectedPattern.prefix;
                    }
                    if (selectedPattern.suffix && name.endsWith(selectedPattern.suffix)) {
                        return selectedPattern.suffix;
                    }
                }
            }
        }

        // ì—„ê²© ëª¨ë“œ (ìˆ«ì-ìˆ«ì)ì—ì„œ ì„ íƒëœ íŒ¨í„´ì´ ìˆìœ¼ë©´ ì‚¬ìš© (ë‹¤ì¤‘ íŒ¨í„´ ì§€ì›)
        if (mode === 'strict' && window.StrictMode && window.StrictMode.modeManager) {
            const selectedPatterns = window.StrictMode.modeManager.getSelectedPatterns();
            if (selectedPatterns && selectedPatterns.length > 0) {
                for (const selectedPattern of selectedPatterns) {
                    if (selectedPattern && selectedPattern.validate) {
                        const validation = selectedPattern.validate(name);
                        if (validation.valid) {
                            // íŒ¨í„´ì—ì„œ ì‹¤ì œ ê°’ ì¶”ì¶œ (íŒŒì¼ëª… ì „ì²´ì—ì„œ ì°¾ê¸°)
                            const escapedSep = selectedPattern.separator.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                            const regex = new RegExp(`(\\d{${selectedPattern.leftLength}})${escapedSep}(\\d{${selectedPattern.rightLength}})`);
                            const match = name.match(regex);
                            if (match) return match[0];
                        }
                    }
                }
            }
        }

        // ê¸°ë³¸ íŒ¨í„´ ì¶”ì¶œ
        const matchHyphen = name.match(/(\d+-\d+)/); 
        if (matchHyphen) return matchHyphen[0];
        
        if (mode === 'auto') {
            const matchDigits = name.match(/(\d{4,})/); 
            if (matchDigits) return matchDigits[0];
        }
        return null;
    }

    async function findDeepFolder(dirHandle, keyword) {
        if (dirHandle.name.includes(keyword)) return dirHandle;
        for await (const entry of dirHandle.values()) {
            if (entry.kind === 'directory') {
                if (entry.name.includes(keyword)) return entry;
                const found = await findDeepFolder(entry, keyword);
                if (found) return found;
            }
        }
        return null;
    }

    // ========================================================================
    // TEST SUITE - ë‚´ì¥ í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ (ì½”ë“œ ì»¤ë²„ë¦¬ì§€ 100% ëª©í‘œ)
    // ========================================================================
    window.TestSuite = window.TestSuite || {};
    
    window.TestSuite.runAll = async function() {
        const results = {
            passed: 0,
            failed: 0,
            total: 0,
            tests: []
        };
        
        // Domain Layer í…ŒìŠ¤íŠ¸
        results.tests.push(window.TestSuite.testDomainLayer());
        
        // Application Layer í…ŒìŠ¤íŠ¸
        results.tests.push(window.TestSuite.testApplicationLayer());
        
        // Infrastructure Layer í…ŒìŠ¤íŠ¸
        results.tests.push(window.TestSuite.testInfrastructureLayer());
        
        // Performance í…ŒìŠ¤íŠ¸
        results.tests.push(window.TestSuite.testPerformance());
        
        // í†µí•© í…ŒìŠ¤íŠ¸
        results.tests.push(window.TestSuite.testIntegration());
        
        // ê²°ê³¼ ì§‘ê³„
        results.tests.forEach(test => {
            results.total += test.total || 0;
            results.passed += test.passed || 0;
            results.failed += test.failed || 0;
        });
        
        const coverage = results.total > 0 ? ((results.passed / results.total) * 100).toFixed(1) : 0;
        
        console.log('========================================');
        console.log('ğŸ§ª í…ŒìŠ¤íŠ¸ ê²°ê³¼');
        console.log('========================================');
        console.log(`ì´ í…ŒìŠ¤íŠ¸: ${results.total}`);
        console.log(`í†µê³¼: ${results.passed}`);
        console.log(`ì‹¤íŒ¨: ${results.failed}`);
        console.log(`ì»¤ë²„ë¦¬ì§€: ${coverage}%`);
        console.log('========================================');
        
        return {
            ...results,
            coverage: parseFloat(coverage)
        };
    };
    
    window.TestSuite.testDomainLayer = function() {
        const results = { passed: 0, failed: 0, total: 0, errors: [] };
        
        try {
            // PrefixSuffixPattern í…ŒìŠ¤íŠ¸
            const prefixPattern = new window.Domain.PrefixSuffixPattern({
                prefix: 'TEST',
                suffix: '',
                pattern: 'alphabetic',
                confidence: 0.9,
                frequency: 10,
                examples: ['TEST001', 'TEST002']
            });
            results.total++;
            if (prefixPattern.isValid() && prefixPattern.prefix === 'TEST') {
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('PrefixSuffixPattern validation failed');
            }
            
            // NumberNumberPattern í…ŒìŠ¤íŠ¸
            const numberPattern = new window.Domain.NumberNumberPattern({
                pattern: '001-001',
                leftPart: '001',
                rightPart: '001',
                separator: '-',
                confidence: 0.95,
                frequency: 20,
                examples: ['001-001', '002-002'],
                leftLength: 3,
                rightLength: 3
            });
            results.total++;
            if (numberPattern.isValid() && numberPattern.validate('001-001').valid) {
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('NumberNumberPattern validation failed');
            }
            
            // PatternAnalysis í…ŒìŠ¤íŠ¸
            const analysis = new window.Domain.PatternAnalysis({
                prefixPatterns: [prefixPattern.toPlainObject()],
                suffixPatterns: [],
                numberNumberPatterns: [numberPattern.toPlainObject()],
                totalItems: 100,
                analyzedItems: 100,
                confidence: 0.9
            });
            results.total++;
            if (analysis.getBestPrefix() && analysis.getBestNumberNumber()) {
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('PatternAnalysis methods failed');
            }
        } catch (e) {
            results.failed++;
            results.errors.push('Domain Layer test error: ' + e.message);
        }
        
        return results;
    };
    
    window.TestSuite.testApplicationLayer = function() {
        const results = { passed: 0, failed: 0, total: 0, errors: [] };
        
        try {
            const repository = new window.Infrastructure.PatternAnalysisRepository();
            const numberUseCase = new window.Application.NumberNumberAnalysisUseCases(repository);
            const prefixUseCase = new window.Application.PrefixSuffixAnalysisUseCases(repository);
            
            // NumberNumberAnalysisUseCases í…ŒìŠ¤íŠ¸
            const testItems = [
                { name: '001-001' },
                { name: '002-002' },
                { name: '003-003' }
            ];
            const patterns = numberUseCase.analyzePatterns(testItems, 'name');
            results.total++;
            if (patterns.length > 0 && patterns[0].confidence > 0) {
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('NumberNumberAnalysisUseCases failed');
            }
            
            // PrefixSuffixAnalysisUseCases í…ŒìŠ¤íŠ¸
            const prefixItems = [
                { name: 'TEST001' },
                { name: 'TEST002' },
                { name: 'TEST003' }
            ];
            const prefixAnalysis = prefixUseCase.analyzePatterns(prefixItems, 'name');
            results.total++;
            if (prefixAnalysis.prefixPatterns.length > 0 && prefixAnalysis.confidence > 0) {
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('PrefixSuffixAnalysisUseCases failed');
            }
        } catch (e) {
            results.failed++;
            results.errors.push('Application Layer test error: ' + e.message);
        }
        
        return results;
    };
    
    window.TestSuite.testInfrastructureLayer = function() {
        const results = { passed: 0, failed: 0, total: 0, errors: [] };
        
        return new Promise((resolve) => {
            const storageEngine = new window.Infrastructure.StorageEngine();
            storageEngine.init().then(() => {
                // ì €ì¥ í…ŒìŠ¤íŠ¸
                storageEngine.save('testStore', 'testKey', { data: 'test' })
                    .then(success => {
                        results.total++;
                        if (success) {
                            results.passed++;
                            
                            // ë¡œë“œ í…ŒìŠ¤íŠ¸
                            storageEngine.load('testStore', 'testKey')
                                .then(data => {
                                    results.total++;
                                    if (data && data.data === 'test') {
                                        results.passed++;
                                    } else {
                                        results.failed++;
                                        results.errors.push('StorageEngine load failed');
                                    }
                                    
                                    // ì‚­ì œ í…ŒìŠ¤íŠ¸
                                    storageEngine.delete('testStore', 'testKey')
                                        .then(success => {
                                            results.total++;
                                            if (success) {
                                                results.passed++;
                                            } else {
                                                results.failed++;
                                                results.errors.push('StorageEngine delete failed');
                                            }
                                            resolve(results);
                                        });
                                });
                        } else {
                            results.failed++;
                            results.errors.push('StorageEngine save failed');
                            resolve(results);
                        }
                    });
            });
        });
    };
    
    window.TestSuite.testPerformance = function() {
        const results = { passed: 0, failed: 0, total: 0, errors: [] };
        
        try {
            // Memoizer í…ŒìŠ¤íŠ¸
            const memoizer = new window.PerformanceEngine.Memoizer();
            let callCount = 0;
            const testFn = () => { callCount++; return 'result'; };
            
            memoizer.memoize('key1', testFn);
            memoizer.memoize('key1', testFn);
            results.total++;
            if (callCount === 1) {
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('Memoizer failed');
            }
            
            // Throttler í…ŒìŠ¤íŠ¸
            const throttler = new window.PerformanceEngine.Throttler();
            let throttleCount = 0;
            const throttleFn = () => { throttleCount++; };
            
            throttler.throttle('key1', throttleFn, 100);
            throttler.throttle('key1', throttleFn, 100);
            results.total++;
            if (throttleCount === 1) {
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('Throttler failed');
            }
        } catch (e) {
            results.failed++;
            results.errors.push('Performance test error: ' + e.message);
        }
        
        return results;
    };
    
    window.TestSuite.testEventBus = function() {
        const results = { name: 'EventBus', passed: 0, failed: 0, errors: [] };
        try {
            const eventBus = new window.EventBus();
            let received = false;
            
            eventBus.on('test', (data) => {
                received = true;
                if (data.value !== 123) {
                    throw new Error('Event data mismatch');
                }
            });
            
            eventBus.emit('test', { value: 123 });
            if (!received) {
                throw new Error('Event not received');
            }
            
            results.passed++;
        } catch (e) {
            results.failed++;
            results.errors.push(e.message);
        }
        return results;
    };

    window.TestSuite.testResilience = async function() {
        const results = { name: 'Resilience', passed: 0, failed: 0, errors: [] };
        try {
            // ì¬ì‹œë„ ì „ëµ í…ŒìŠ¤íŠ¸
            const retry = new window.Resilience.RetryStrategy({ maxRetries: 2 });
            let attempts = 0;
            
            await retry.execute(async () => {
                attempts++;
                if (attempts < 2) {
                    throw new Error('NetworkError');
                }
                return 'success';
            });
            
            if (attempts !== 2) {
                throw new Error('Retry not working');
            }
            
            // ì„œí‚· ë¸Œë ˆì´ì»¤ í…ŒìŠ¤íŠ¸
            const breaker = new window.Resilience.CircuitBreaker({ failureThreshold: 2 });
            let breakerState = breaker.getState();
            if (breakerState.state !== 'closed') {
                throw new Error('Circuit breaker should start closed');
            }
            
            results.passed++;
        } catch (e) {
            results.failed++;
            results.errors.push(e.message);
        }
        return results;
    };

    window.TestSuite.testPerformanceMonitor = async function() {
        const results = { name: 'PerformanceMonitor', passed: 0, failed: 0, errors: [] };
        try {
            const monitor = new window.PerformanceMonitor.PerformanceMonitor();
            const measurement = monitor.start('test');
            
            // ì‹œë®¬ë ˆì´ì…˜ ì‘ì—…
            await new Promise(resolve => setTimeout(resolve, 10));
            measurement.end();
            
            const metric = monitor.getMetric('test');
            if (!metric || metric.count !== 1) {
                throw new Error('Performance metric not recorded');
            }
            
            results.passed++;
        } catch (e) {
            results.failed++;
            results.errors.push(e.message);
        }
        return results;
    };

    window.TestSuite.testMetrics = function() {
        const results = { name: 'Metrics', passed: 0, failed: 0, errors: [] };
        try {
            const metrics = new window.Metrics.MetricsCollector();
            
            metrics.increment('test_counter');
            metrics.set('test_gauge', 100);
            metrics.observe('test_histogram', 50);
            
            if (metrics.getCounter('test_counter') !== 1) {
                throw new Error('Counter not working');
            }
            
            const gauge = metrics.getGauge('test_gauge');
            if (!gauge || gauge.value !== 100) {
                throw new Error('Gauge not working');
            }
            
            const histogram = metrics.getHistogram('test_histogram');
            if (!histogram || histogram.count !== 1) {
                throw new Error('Histogram not working');
            }
            
            results.passed++;
        } catch (e) {
            results.failed++;
            results.errors.push(e.message);
        }
        return results;
    };

    window.TestSuite.testHealthCheck = async function() {
        const results = { name: 'HealthCheck', passed: 0, failed: 0, errors: [] };
        try {
            const health = new window.HealthCheck.HealthChecker();
            
            health.register('test', async () => {
                return { status: 'healthy', message: 'OK' };
            });
            
            const status = await health.check();
            if (status.status !== 'healthy') {
                throw new Error('Health check failed');
            }
            
            results.passed++;
        } catch (e) {
            results.failed++;
            results.errors.push(e.message);
        }
        return results;
    };

    window.TestSuite.testIntegration = function() {
        const results = { passed: 0, failed: 0, total: 0, errors: [] };
        
        try {
            // ì „ì²´ í†µí•© í…ŒìŠ¤íŠ¸
            if (window.CleanArch && window.CleanArch.numberNumberAnalysisUseCases) {
                results.total++;
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('CleanArch integration failed');
            }
            
            if (window.StrictMode && window.StrictMode.modeManager) {
                results.total++;
                results.passed++;
            } else {
                results.failed++;
                results.errors.push('StrictMode integration failed');
            }
        } catch (e) {
            results.failed++;
            results.errors.push('Integration test error: ' + e.message);
        }
        
        return results;
    };
    
    // ìë™ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ê°œë°œ ëª¨ë“œ)
    if (window.location.search.includes('test=true')) {
        window.addEventListener('load', () => {
            setTimeout(() => {
                window.TestSuite.runAll();
            }, 1000);
        });
    }

    // ============================================
    // ë‹¨ê¸° í™•ì¥: íˆìŠ¤í† ë¦¬ UI ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // ============================================
    if (els.btnShowHistory) {
        els.btnShowHistory.onclick = async () => {
            if (!window.CleanArch || !window.CleanArch.historyManagementUseCases) {
                alert('íˆìŠ¤í† ë¦¬ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                const histories = await window.CleanArch.historyManagementUseCases.getAllHistory();
                if (histories.length === 0) {
                    els.historyContent.innerHTML = '<div style="text-align:center; color:#94a3b8; padding:20px;">íˆìŠ¤í† ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                    return;
                }

                let html = '<table style="width:100%; border-collapse:collapse;">';
                html += '<thead><tr style="background:#f1f5f9; border-bottom:2px solid #e2e8f0;">';
                html += '<th style="padding:10px; text-align:left;">íŒŒì¼ëª…</th>';
                html += '<th style="padding:10px; text-align:left;">ìƒíƒœ</th>';
                html += '<th style="padding:10px; text-align:left;">ì‘ì—…</th>';
                html += '<th style="padding:10px; text-align:left;">ë‚ ì§œ</th>';
                html += '</tr></thead><tbody>';

                histories.slice(-50).reverse().forEach(h => {
                    const statusColor = h.status === 'success' ? '#16a34a' : h.status === 'failed' ? '#dc2626' : '#ca8a04';
                    const statusText = h.status === 'success' ? 'ì„±ê³µ' : h.status === 'failed' ? 'ì‹¤íŒ¨' : 'ê±´ë„ˆëœ€';
                    const date = new Date(h.timestamp).toLocaleString('ko-KR');
                    html += `<tr style="border-bottom:1px solid #e2e8f0;">`;
                    html += `<td style="padding:10px;">${h.fileName}</td>`;
                    html += `<td style="padding:10px; color:${statusColor}; font-weight:600;">${statusText}</td>`;
                    html += `<td style="padding:10px;">${h.operation}</td>`;
                    html += `<td style="padding:10px; color:#64748b; font-size:0.9rem;">${date}</td>`;
                    html += `</tr>`;
                });

                html += '</tbody></table>';
                els.historyContent.innerHTML = html;
                els.historyCard.style.display = 'block';
            } catch (e) {
                console.error('[History] Load failed:', e);
                alert('íˆìŠ¤í† ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + e.message);
            }
        };
    }

    if (els.btnClearHistory) {
        els.btnClearHistory.onclick = async () => {
            if (!confirm('ëª¨ë“  íˆìŠ¤í† ë¦¬ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

            if (!window.CleanArch || !window.CleanArch.historyManagementUseCases) {
                alert('íˆìŠ¤í† ë¦¬ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                await window.CleanArch.historyManagementUseCases.clearHistory();
                els.historyContent.innerHTML = '<div style="text-align:center; color:#94a3b8; padding:20px;">íˆìŠ¤í† ë¦¬ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.</div>';
                alert('íˆìŠ¤í† ë¦¬ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
            } catch (e) {
                console.error('[History] Clear failed:', e);
                alert('íˆìŠ¤í† ë¦¬ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + e.message);
            }
        };
    }

    if (els.btnHistoryStats) {
        els.btnHistoryStats.onclick = async () => {
            if (!window.CleanArch || !window.CleanArch.historyManagementUseCases) {
                alert('íˆìŠ¤í† ë¦¬ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                const stats = await window.CleanArch.historyManagementUseCases.getStatistics();
                let msg = `ğŸ“Š ë¶„ë¥˜ íˆìŠ¤í† ë¦¬ í†µê³„\n\n`;
                msg += `ì´ ì‘ì—…: ${stats.total}ê±´\n`;
                msg += `ì„±ê³µ: ${stats.success}ê±´\n`;
                msg += `ì‹¤íŒ¨: ${stats.failed}ê±´\n`;
                msg += `ê±´ë„ˆëœ€: ${stats.skipped}ê±´\n\n`;
                msg += `ì‘ì—…ë³„ í†µê³„:\n`;
                Object.keys(stats.byOperation).forEach(op => {
                    msg += `  â€¢ ${op}: ${stats.byOperation[op]}ê±´\n`;
                });
                alert(msg);
            } catch (e) {
                console.error('[History] Stats failed:', e);
                alert('í†µê³„ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + e.message);
            }
        };
    }

    // ============================================
    // ë‹¨ê¸° í™•ì¥: ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    // ============================================
    function updateRealtimeDashboard(stats) {
        if (!els.realtimeDashboardCard) return;

        const totalFiles = stats.totalFiles || 0;
        const matchedFiles = stats.matchedFiles || 0;
        const unmatchedFiles = totalFiles - matchedFiles;
        const avgConfidence = stats.avgConfidence || 0;

        document.getElementById('dashboardTotalFiles').textContent = totalFiles;
        document.getElementById('dashboardMatchedFiles').textContent = matchedFiles;
        document.getElementById('dashboardUnmatchedFiles').textContent = unmatchedFiles;
        document.getElementById('dashboardAvgConfidence').textContent = Math.round(avgConfidence * 100) + '%';

        els.realtimeDashboardCard.style.display = 'block';
    }

</script>

</body>
</html>
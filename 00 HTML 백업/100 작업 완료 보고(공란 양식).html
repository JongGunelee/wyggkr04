<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>작업 완료 현황 보고서 (Self-Contained)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap');

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1f2937;
            color: white;
            overflow-x: hidden;
            padding-top: 0;
            transition: padding-top 0.3s ease;
        }

        /* 3D Perspective & Layout Container */
        .perspective-container {
            perspective: 1000px;
            transform-style: preserve-3d;
            width: 100%;
            margin-left: auto;
        }

        .image-wrapper {
            position: relative;
            width: 100%;
            height: 400px;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            border: 2px dashed #4b5563;
            transition: border-color 0.3s, transform 0.1s ease-out, box-shadow 0.3s;
            touch-action: none;
            user-select: none;
            transform-style: preserve-3d;
            will-change: transform;
        }

        .image-wrapper:hover {
            border-color: #3b82f6;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .image-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            user-select: none;
            -webkit-user-drag: none;
            will-change: auto;
            transition: transform 0.3s ease;
            object-position: center center;
            /* 기본값: 정가운데 */
        }

        /* 세로/가로 사진 위치 조정 가능 */
        .image-wrapper img[data-vertical="true"],
        .image-wrapper img[data-horizontal="true"] {
            cursor: move;
            pointer-events: auto;
        }

        /* 선택된 이미지 표시 - 주황색 점선 제거 */
        .image-wrapper img.selected {
            outline: none;
            outline-offset: 0;
            box-shadow: none;
        }

        .image-wrapper.selected {
            border-color: #4b5563;
        }

        .image-position-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            z-index: 50;
            display: none;
        }

        .image-wrapper:hover .image-position-indicator {
            display: block;
        }

        /* 콜라주 이미지 레이어 */
        .collage-layer {
            position: absolute;
            border: 2px solid rgba(59, 130, 246, 0.5);
            cursor: crosshair;
            /* 기본적으로 그리기 도구 커서 */
            z-index: 40;
            /* 그리기 레이어(z-index: 70)와 텍스트 레이어(z-index: 70)보다 아래에 위치 */
            transition: border-color 0.2s, cursor 0.1s;
            background-color: rgba(255, 0, 0, 0.1);
            pointer-events: auto;
            /* 항상 클릭 가능하도록 */
        }

        /* 선택된 레이어는 move 커서 */
        .collage-layer.selected {
            cursor: move;
        }

        /* 드래그 중인 레이어는 move 커서 */
        .collage-layer.dragging {
            cursor: move;
        }

        .collage-layer:hover {
            border-color: rgba(59, 130, 246, 1);
            z-index: 65;
            /* 호버 시 z-index 증가 (그리기 레이어 아래) */
        }

        .collage-layer.dragging {
            border-color: rgba(59, 130, 246, 1);
            opacity: 0.8;
            z-index: 90;
            /* 드래그 중 최상위 (그리기 레이어 위) */
        }

        .collage-layer.selected {
            border-color: rgba(59, 130, 246, 1);
            border-width: 3px;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            z-index: 65;
            /* 선택된 레이어는 z-index 증가 (그리기 레이어 아래) */
        }

        #fullscreen-content .collage-layer.selected {
            border-color: rgba(59, 130, 246, 1);
            border-width: 3px;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
        }

        .collage-layer img {
            width: 100%;
            height: 100%;
            object-fit: fill;
            pointer-events: none;
            /* 이미지는 클릭 이벤트를 통과시켜 wrapper까지 전파 */
        }

        /* 선택된 레이어의 이미지만 pointer-events를 활성화하여 드래그 가능 */
        .collage-layer.selected img,
        .collage-layer.dragging img {
            pointer-events: auto;
        }

        /* 이미지 편집 컨트롤 (호버 시 표시) */
        .image-edit-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 6px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 100;
            pointer-events: none;
        }

        .image-wrapper:hover .image-edit-controls {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .image-edit-btn {
            width: 36px;
            height: 36px;
            background: rgba(31, 41, 55, 0.9);
            border: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 6px;
            color: #d1d5db;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(8px);
            font-size: 14px;
        }

        .image-edit-btn:hover {
            background: rgba(59, 130, 246, 0.9);
            border-color: #3b82f6;
            color: white;
            transform: scale(1.1);
        }

        .image-edit-btn:active {
            transform: scale(0.95);
        }

        /* 콜라주 모드 토글 버튼 (3차원 원형 버튼) */
        .collage-mode-toggle-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
            border: 2px solid rgba(59, 130, 246, 1);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            z-index: 101;
        }

        .collage-mode-toggle-btn:hover {
            transform: scale(1.15) translateY(-2px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.5),
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .collage-mode-toggle-btn:active {
            transform: scale(1.05) translateY(0);
        }

        /* 콜라주 이동 모드 활성화 상태 */
        .collage-mode-toggle-btn.active {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.9), rgba(22, 163, 74, 0.9));
            border-color: rgba(34, 197, 94, 1);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .collage-mode-toggle-btn.active:hover {
            box-shadow: 0 6px 16px rgba(34, 197, 94, 0.5),
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* 자르기 모드 오버레이 */
        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 200;
            display: none;
            cursor: crosshair;
        }

        .crop-overlay.active {
            display: block;
        }

        .crop-selection {
            position: absolute;
            border: 2px dashed #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            cursor: move;
        }

        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
        }

        .crop-handle.nw {
            top: -6px;
            left: -6px;
            cursor: nw-resize;
        }

        .crop-handle.ne {
            top: -6px;
            right: -6px;
            cursor: ne-resize;
        }

        .crop-handle.sw {
            bottom: -6px;
            left: -6px;
            cursor: sw-resize;
        }

        .crop-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }

        .crop-handle.n {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }

        .crop-handle.s {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        .crop-handle.w {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
            cursor: w-resize;
        }

        .crop-handle.e {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        .crop-controls {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 201;
        }

        .crop-control-btn {
            padding: 8px 16px;
            background: rgba(59, 130, 246, 0.9);
            border: 1px solid #3b82f6;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .crop-control-btn:hover {
            background: rgba(37, 99, 235, 0.9);
            transform: scale(1.05);
        }

        .crop-control-btn.cancel {
            background: rgba(239, 68, 68, 0.9);
            border-color: #ef4444;
        }

        .crop-control-btn.cancel:hover {
            background: rgba(220, 38, 38, 0.9);
        }

        .drawing-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 70;
            cursor: crosshair;
            will-change: transform;
            pointer-events: none;
            /* 콜라주 레이어(z-index: 40)보다 위에 위치 */
        }

        .drawing-layer.mode-select {
            cursor: default;
            pointer-events: auto;
        }

        /* SVG 요소 선택 시 하이라이트 */
        .drawing-layer .selected-svg {
            filter: drop-shadow(0 0 2px #3b82f6) drop-shadow(0 0 4px #3b82f6);
            cursor: move;
            /* 이동 가능 커서 */
            stroke: #3b82f6;
            /* 선택 시 색상 힌트 */
            stroke-opacity: 0.8;
        }

        /* 선택된 요소 툴팁 */
        .element-tooltip {
            position: fixed;
            background: rgba(31, 41, 55, 0.95);
            color: #60a5fa;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            border: 1px solid #3b82f6;
            white-space: nowrap;
            display: none;
        }

        .html-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 70;
            pointer-events: none;
            will-change: transform;
            /* 콜라주 레이어(z-index: 40)보다 위에 위치 */
        }

        .annotation {
            position: absolute;
            min-width: 100px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            pointer-events: auto;
            box-sizing: border-box;
            user-select: none;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(2px);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s;
            transform-style: preserve-3d;
        }

        .annotation.hover-magnetic {
            z-index: 50;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
        }

        /* 텍스트 박스 전용 모드 (배경 없음) */
        .annotation.text-only {
            background-color: transparent !important;
            border-color: transparent !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
        }

        .annotation.text-only:not(:hover) .resize-handle,
        .annotation.text-only:not(:hover) .delete-btn,
        .annotation.text-only:not(:hover) .style-toggle-btn {
            display: none;
        }

        /* Selected 상태 */
        .annotation.selected {
            z-index: 100;
            outline: 2px solid #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .style-red {
            border-color: #ef4444;
        }

        .style-yellow {
            border-color: #eab308;
        }

        .style-green {
            border-color: #22c55e;
        }

        .style-blue {
            border-color: #3b82f6;
        }

        .style-purple {
            border-color: #a855f7;
        }

        .style-white {
            border-color: #ffffff;
        }

        /* 텍스트 색상 기본값 (인라인 스타일로 덮어쓸 수 있음) */
        .annotation .annotation-text {
            color: #ffffff;
            -webkit-text-fill-color: #ffffff;
        }

        /* [수정됨] 텍스트 가독성 초강화 (Pop-out Effect) - 흰색 글씨 - 화면 밖으로 튀어나올 정도로 선명 */
        .annotation-text {
            font-weight: 900 !important;
            font-size: 1.2rem !important;
            padding: 4px;
            outline: none;
            cursor: text;
            text-align: center;
            width: 100%;
            line-height: 1.2;
            font-family: 'Noto Sans KR', sans-serif !important;

            /* [요청반영] 흰색 글씨 - 최우선 적용 */
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;

            /* 가는 검정색 외곽선 - 선명하고 깔끔하게 */
            -webkit-text-stroke: 1.0px #000000 !important;
            -webkit-text-stroke-width: 1.0px !important;
            paint-order: stroke fill;

            /* 아주 깊고 깊은 옅은 회색 그림자 효과 - 글자 선명도 유지하면서 깊이감 강조 */
            text-shadow:
                /* 텍스트 자체 선명도 강화 (내부 글로우 최소화) */
                0px 0px 1px rgba(255, 255, 255, 0.95),
                /* 가까운 옅은 회색 그림자 (선명한 깊이감) */
                1px 1px 0px rgba(100, 100, 100, 0.5),
                1px 1px 1px rgba(100, 100, 100, 0.4),
                2px 2px 0px rgba(100, 100, 100, 0.45),
                2px 2px 2px rgba(100, 100, 100, 0.35),
                2px 2px 4px rgba(100, 100, 100, 0.3),
                3px 3px 0px rgba(100, 100, 100, 0.4),
                3px 3px 3px rgba(100, 100, 100, 0.3),
                3px 3px 6px rgba(100, 100, 100, 0.25),
                /* 다방향 옅은 회색 그림자 (4방향) */
                -2px -2px 0px rgba(100, 100, 100, 0.4),
                -2px -2px 3px rgba(100, 100, 100, 0.3),
                2px -2px 0px rgba(100, 100, 100, 0.4),
                2px -2px 3px rgba(100, 100, 100, 0.3),
                -2px 2px 0px rgba(100, 100, 100, 0.4),
                -2px 2px 3px rgba(100, 100, 100, 0.3),
                2px 2px 0px rgba(100, 100, 100, 0.4),
                2px 2px 3px rgba(100, 100, 100, 0.3),
                /* 중간 거리 깊은 그림자 (단계별) */
                4px 4px 0px rgba(100, 100, 100, 0.35),
                4px 4px 4px rgba(100, 100, 100, 0.25),
                4px 4px 8px rgba(100, 100, 100, 0.2),
                5px 5px 0px rgba(100, 100, 100, 0.3),
                5px 5px 5px rgba(100, 100, 100, 0.22),
                5px 5px 10px rgba(100, 100, 100, 0.18),
                6px 6px 0px rgba(100, 100, 100, 0.25),
                6px 6px 6px rgba(100, 100, 100, 0.18),
                6px 6px 12px rgba(100, 100, 100, 0.15),
                /* 아주 깊은 그림자 (멀리까지 - 깊이감) */
                7px 7px 0px rgba(100, 100, 100, 0.2),
                7px 7px 7px rgba(100, 100, 100, 0.15),
                7px 7px 14px rgba(100, 100, 100, 0.12),
                7px 7px 21px rgba(100, 100, 100, 0.1),
                8px 8px 0px rgba(100, 100, 100, 0.18),
                8px 8px 8px rgba(100, 100, 100, 0.13),
                8px 8px 16px rgba(100, 100, 100, 0.1),
                8px 8px 24px rgba(100, 100, 100, 0.08),
                9px 9px 0px rgba(100, 100, 100, 0.15),
                9px 9px 9px rgba(100, 100, 100, 0.11),
                9px 9px 18px rgba(100, 100, 100, 0.09),
                9px 9px 27px rgba(100, 100, 100, 0.07),
                10px 10px 0px rgba(100, 100, 100, 0.12),
                10px 10px 10px rgba(100, 100, 100, 0.09),
                10px 10px 20px rgba(100, 100, 100, 0.07),
                10px 10px 30px rgba(100, 100, 100, 0.05),
                /* 극도로 깊은 블러 효과 (배경과 완전 분리 - 선택적) */
                0px 0px 20px rgba(100, 100, 100, 0.25),
                0px 0px 30px rgba(100, 100, 100, 0.2),
                0px 0px 40px rgba(100, 100, 100, 0.15),
                0px 0px 50px rgba(100, 100, 100, 0.12),
                0px 0px 60px rgba(100, 100, 100, 0.1);
        }

        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: white;
            border: 1px solid #333;
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
            border-radius: 50%;
            display: none;
            z-index: 40;
        }

        .delete-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 20px;
            height: 20px;
            background-color: red;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
            z-index: 40;
        }

        .style-toggle-btn {
            position: absolute;
            top: -12px;
            left: -12px;
            width: 20px;
            height: 20px;
            background-color: #3b82f6;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            display: none;
            z-index: 40;
        }

        .annotation.selected .resize-handle,
        .annotation.selected .delete-btn,
        .annotation.selected .style-toggle-btn {
            display: block;
        }

        #main-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #main-header.collapsed {
            transform: translateY(-100%);
        }

        .curtain-handle {
            position: absolute;
            bottom: -24px;
            left: 8px;
            transform: none;
            background-color: #1f2937;
            color: #9ca3af;
            border: 1px solid #374151;
            border-top: none;
            padding: 0 12px;
            height: 24px;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 1001;
        }

        .curtain-handle:hover {
            background-color: #374151;
            color: white;
        }

        #main-header.collapsed .curtain-handle {
            bottom: -24px;
            transform: translateY(100%);
        }

        .fmt-btn {
            padding: 4px 8px;
            border-radius: 4px;
            background: #374151;
            color: #d1d5db;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.1s;
            border: 1px solid #4b5563;
        }

        .fmt-btn:hover {
            background: #4b5563;
            color: white;
        }

        .fmt-btn:active {
            transform: translateY(1px);
        }

        .fmt-btn input[type="number"],
        .fmt-btn select {
            background: #374151;
            color: #d1d5db;
            border: 1px solid #4b5563;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.1s;
        }

        .fmt-btn input[type="number"]:hover,
        .fmt-btn select:hover {
            background: #4b5563;
            color: white;
        }

        .fmt-btn input[type="number"]:focus,
        .fmt-btn select:focus {
            outline: none;
            border-color: #3b82f6;
            background: #4b5563;
            color: white;
        }

        .fmt-group {
            display: flex;
            align-items: center;
            gap: 4px;
            border-right: 1px solid #4b5563;
            padding-right: 8px;
            margin-right: 8px;
        }

        .fmt-group:last-child {
            border-right: none;
        }

        /* 링크 스타일 - 텍스트 콘텐츠 내 앵커 시각적 표시 */
        a[href] {
            color: #60a5fa !important;
            text-decoration: underline !important;
            text-decoration-color: #60a5fa !important;
            text-decoration-thickness: 2px !important;
            text-underline-offset: 3px !important;
            cursor: pointer !important;
            transition: color 0.2s, text-shadow 0.2s;
        }

        a[href]:hover {
            color: #3b82f6 !important;
            text-shadow: 0 0 8px rgba(59, 130, 246, 0.5) !important;
        }

        a[href]:active {
            color: #1e40af !important;
        }

        /* 툴바 스타일 (1단, 아이콘 전용) */
        .toolbar {
            background: #2c2c2e;
            padding: 8px 12px;
            border-radius: 8px 8px 0 0;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #3f3f46;
            width: 100%;
            overflow-x: auto;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background-color: #52525b;
            margin: 0 4px;
        }

        .tool-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: #3f3f46;
            color: #d4d4d8;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            flex-shrink: 0;
            position: relative;
        }

        .tool-btn:hover {
            background: #52525b;
            color: white;
        }

        .tool-btn.active {
            background: #3b82f6;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .tool-btn.accent {
            background: #6366f1;
            color: white;
        }

        .tool-btn.accent:hover {
            background: #4f46e5;
        }

        .color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s;
            flex-shrink: 0;
        }

        .color-dot:hover {
            transform: scale(1.2);
        }

        .color-dot.active {
            border-color: white;
            transform: scale(1.1);
            box-shadow: 0 0 0 2px #3b82f6;
        }

        .bg-red {
            background-color: #ef4444;
        }

        .bg-yellow {
            background-color: #eab308;
        }

        .bg-green {
            background-color: #22c55e;
        }

        .bg-blue {
            background-color: #3b82f6;
        }

        .bg-purple {
            background-color: #a855f7;
        }

        .bg-white {
            background-color: #ffffff;
        }

        /* 그리기 도구 설정 팝업 */
        #drawing-settings-popover {
            display: none;
            position: absolute;
            background: #1f2937;
            border: 1px solid #4b5563;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            z-index: 5000;
            width: 260px;
        }

        .popover-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            border-bottom: 1px solid #374151;
            padding-bottom: 8px;
            cursor: move;
            /* 드래그 가능 표시 */
            user-select: none;
            /* 텍스트 선택 방지 */
        }

        .popover-title {
            font-size: 13px;
            font-weight: bold;
            color: white;
        }

        /* [NEW] 선택된 요소 정보 */
        #selected-element-info {
            font-size: 11px;
            color: #60a5fa;
            margin-left: 8px;
            font-weight: normal;
        }

        .popover-close {
            cursor: pointer;
            color: #9ca3af;
            font-size: 14px;
            padding: 4px;
        }

        .popover-close:hover {
            color: white;
        }

        /* 텍스트 색상 선택 영역 */
        .text-color-picker {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        .text-color-option {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            position: relative;
        }

        .text-color-option:hover {
            transform: scale(1.1);
            border-color: #3b82f6;
        }

        .text-color-option.active {
            border-color: #ffffff;
            box-shadow: 0 0 0 2px #3b82f6;
        }

        /* 설정값 그리드 배치 */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px 16px;
            align-items: start;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
        }

        .setting-item.full-width {
            grid-column: span 2;
        }

        .setting-label {
            font-size: 11px;
            color: #9ca3af;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .setting-val {
            color: #60a5fa;
            font-weight: bold;
        }

        .setting-input {
            width: 100%;
            cursor: pointer;
            height: 4px;
            background: #4b5563;
            border-radius: 2px;
            appearance: none;
        }

        .setting-input::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
        }

        .style-radio-group {
            display: flex;
            gap: 10px;
            margin-top: 2px;
        }

        .style-radio-label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #d1d5db;
            cursor: pointer;
        }

        .style-radio-label input {
            margin: 0;
            accent-color: #3b82f6;
        }

        #drawing-settings-popover::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 20px;
            width: 12px;
            height: 12px;
            background: #1f2937;
            border-top: 1px solid #4b5563;
            border-left: 1px solid #4b5563;
            transform: rotate(45deg);
            transition: opacity 0.2s;
        }

        /* 드래그 중일 때 화살표 숨김 */
        #drawing-settings-popover.dragging::after {
            opacity: 0;
        }

        #laser-pointer {
            position: fixed;
            width: 20px;
            height: 20px;
            background: #ff0000;
            border-radius: 50%;
            box-shadow: 0 0 10px 4px rgba(255, 0, 0, 0.9), 0 0 30px 15px rgba(255, 0, 0, 0.6), inset 0 0 5px rgba(255, 200, 200, 1);
            pointer-events: none;
            z-index: 99999;
            transform: translate(-50%, -50%);
            display: none;
        }

        #fullscreen-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.98);
            backdrop-filter: blur(0px);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            cursor: none;
        }

        #fullscreen-modal * {
            cursor: none !important;
        }

        #fullscreen-content {
            position: relative;
            width: 100vw;
            height: calc(100vh - 60px);
            background: #000;
            border: none;
            border-radius: 0;
            overflow: hidden;
            box-shadow: none;
            transform: none;
            border-bottom: 2px solid #333;
            /* 하단 경계선 표시 */
        }

        #fullscreen-content img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: none !important;
        }

        #fullscreen-content img.collage-image {
            object-fit: contain;
        }

        #fullscreen-content .collage-layer {
            z-index: 40;
        }

        /* 그리기 레이어(z-index: 70)와 텍스트 레이어(z-index: 70)보다 아래에 위치 */
        #fullscreen-content .collage-layer img {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        #fullscreen-content .image-edit-controls {
            position: absolute;
            top: 20px;
            right: 60px;
            display: flex;
            gap: 8px;
            opacity: 1;
            visibility: visible;
            z-index: 10001;
            pointer-events: auto;
        }

        #fullscreen-content .image-edit-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #fullscreen-content .image-edit-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.6);
        }

        #fullscreen-close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            z-index: 10000;
            transition: color 0.3s;
        }

        #fullscreen-close:hover {
            color: white;
        }

        #fullscreen-title {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        #collage-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 3000;
        }

        #collage-container {
            background: #111827;
            width: 1000px;
            max-width: 95%;
            height: 80vh;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #4b5563;
        }

        #collage-header {
            padding: 15px 20px;
            border-bottom: 1px solid #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            background: #1f2937;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            user-select: none;
        }

        #collage-preview-area {
            padding: 30px;
            background: #1f2937;
            display: grid;
            gap: 20px;
            overflow-y: auto;
            flex-grow: 1;
            /* 콜라주 수량에 따라 동적으로 그리드 레이아웃 조정 */
        }

        /* 콜라주 수량에 따른 그리드 레이아웃 */
        #collage-preview-area[data-count="1"] {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
        }

        #collage-preview-area[data-count="2"] {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: 1fr;
        }

        #collage-preview-area[data-count="3"] {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: 1fr;
        }

        #collage-preview-area[data-count="4"] {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }

        #collage-preview-area[data-count="5"],
        #collage-preview-area[data-count="6"] {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }

        #collage-preview-area[data-count="7"],
        #collage-preview-area[data-count="8"],
        #collage-preview-area[data-count="9"] {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
        }

        #collage-preview-area[data-count="10"] {
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
        }

        /* 기본값: 2열 그리드 */
        #collage-preview-area:not([data-count]) {
            grid-template-columns: repeat(2, 1fr);
        }

        .collage-card {
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .collage-card-header {
            padding: 12px 16px;
            background: #111827;
            border-bottom: 1px solid #4b5563;
        }

        .collage-card-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #fff;
        }

        .collage-card-desc {
            padding: 12px 16px;
            font-size: 0.9rem;
            color: #e5e7eb;
            border-bottom: 1px solid #4b5563;
            background: #2a3342;
        }

        .collage-card-image {
            position: relative;
            height: auto;
            min-height: 200px;
            flex: 1;
            background: #000;
            overflow: hidden;
        }

        .collage-card-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 콜라주 이미지가 영역을 꽉 채우도록 */
        .collage-card-image .image-wrapper {
            width: 100%;
            height: 100%;
        }

        .collage-card-image .image-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 콜라주 수량에 따른 이미지 높이 조정 */
        #collage-preview-area[data-count="1"] .collage-card-image {
            min-height: 60vh;
        }

        #collage-preview-area[data-count="2"] .collage-card-image {
            min-height: 50vh;
        }

        #collage-preview-area[data-count="3"] .collage-card-image,
        #collage-preview-area[data-count="4"] .collage-card-image {
            min-height: 40vh;
        }

        #collage-preview-area[data-count="5"] .collage-card-image,
        #collage-preview-area[data-count="6"] .collage-card-image {
            min-height: 35vh;
        }

        #collage-preview-area[data-count="7"] .collage-card-image,
        #collage-preview-area[data-count="8"] .collage-card-image,
        #collage-preview-area[data-count="9"] .collage-card-image {
            min-height: 30vh;
        }

        #collage-preview-area[data-count="10"] .collage-card-image {
            min-height: 25vh;
        }

        .step-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #3b82f6;
            margin-right: 10px;
        }

        .modal-resize-handle {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, transparent 50%, #4b5563 50%);
            position: absolute;
            bottom: 0;
            right: 0;
            cursor: se-resize;
            z-index: 10;
            border-bottom-right-radius: 8px;
        }

        .thumb-item {
            position: relative;
            width: 60px;
            height: 40px;
            border: 2px solid #4b5563;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .thumb-item:hover {
            border-color: #3b82f6;
            transform: scale(1.1);
        }

        .thumb-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .thumb-tag {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 8px;
            text-align: center;
            padding: 1px 0;
        }

        .thumb-delete-btn {
            position: absolute;
            top: 0;
            right: 0;
            width: 18px;
            height: 18px;
            background-color: rgba(220, 38, 38, 0.9);
            color: white;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom-left-radius: 6px;
            cursor: pointer;
            z-index: 20;
            transition: background-color 0.2s;
        }

        .thumb-delete-btn:hover {
            background-color: #ef4444;
        }

        .step-section {
            transition: all 0.5s ease-out;
            max-height: 2000px;
            opacity: 1;
            transform: scale(1);
            overflow: visible;
            margin-bottom: 0;
            padding-bottom: 120px;
            /* [개선] 기호가 카드 아래 여유공간에 표시되도록 패딩 추가 (flow-connector height: 6rem ≈ 96px + 여유) */
            position: relative;
            z-index: 1;
            isolation: isolate;
            /* stacking context 생성하여 flow-connector가 위에 표시되도록 */
        }

        .step-section:hover {
            z-index: 10;
        }

        .step-section.collapsed-step {
            max-height: 0;
            opacity: 0;
            transform: scale(0.9);
            margin-bottom: 0;
            padding: 0;
            border: none;
            overflow: hidden;
        }

        .step-section.step-fullscreen {
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 5000;
            /* 최상위 */
            background-color: #1f2937;
            margin: 0 !important;
            padding: 2rem !important;
            border-radius: 0 !important;
            overflow-y: auto;
            display: grid !important;
            grid-template-columns: 30% 70% !important;
            gap: 2rem;
            align-content: center;
        }

        .step-section.step-fullscreen .image-wrapper {
            height: 80vh !important;
        }

        /* Grid Layout (4:6) */
        .step-grid-layout {
            display: grid;
            gap: 2rem;
            align-items: start;
        }

        @media (min-width: 768px) {
            .step-grid-layout {
                grid-template-columns: 4fr 6fr;
            }
        }

        /* Building Badge Style */
        .building-badge {
            background-color: rgba(59, 130, 246, 0.15);
            color: #93c5fd;
            border: 1px solid #2563eb;
            border-radius: 9999px;
            padding: 4px 16px;
            font-size: 1.1rem;
            margin-left: 16px;
            vertical-align: middle;
            display: inline-block;
            cursor: text;
            font-weight: bold;
            transition: all 0.2s;
        }

        .building-badge:focus {
            outline: none;
            background-color: rgba(59, 130, 246, 0.25);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }

        /* Creative Flow Connectors */
        .flow-connector {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #60a5fa;
            z-index: 100;
            /* 카드 섹션 위에 확실히 표시되도록 높은 z-index 설정 */
            pointer-events: none;
        }

        /* 1. 세로 모드 (Vertical) 연결선 */
        #report-container:not(.layout-horizontal) .step-section .flow-connector {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: column;
            height: 6rem;
            width: 2px;
            /* 카드 섹션의 하단 끝에 맞춰서 배치, 카드 섹션 위에 표시 */
        }

        #report-container:not(.layout-horizontal) .step-section .flow-line {
            width: 2px;
            flex-grow: 1;
            background: linear-gradient(to bottom, #4b5563, #3b82f6);
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
            position: relative;
            overflow: hidden;
        }

        /* 전류 흐름 애니메이션 (세로 모드) */
        #report-container:not(.layout-horizontal) .step-section .flow-line::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(to bottom,
                    transparent 0px,
                    transparent 8px,
                    #60a5fa 8px,
                    #60a5fa 10px,
                    transparent 10px,
                    transparent 18px);
            background-size: 100% 18px;
            animation: flowDown 1.2s linear infinite;
            opacity: 0.9;
        }

        @keyframes flowDown {
            0% {
                transform: translateY(-18px);
            }

            100% {
                transform: translateY(100%);
            }
        }

        /* 흐름 방향 기호 이동 애니메이션 (세로 모드) */
        #report-container:not(.layout-horizontal) .step-section .flow-node {
            animation: pulseGlow 2s infinite, flowNodeMoveDown 1.2s linear infinite;
        }

        @keyframes flowNodeMoveDown {
            0% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(3px);
            }

            100% {
                transform: translateY(0);
            }
        }

        #report-container:not(.layout-horizontal) .step-section .flow-node {
            width: 30px;
            height: 30px;
            background: #111827;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.6);
            margin-top: -15px;
            /* 화살표 끝이 카드 섹션의 하단 끝에 정확히 맞춰지도록 조정 */
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #report-container:not(.layout-horizontal) .step-section .flow-node:hover {
            transform: scale(1.2);
            background: #2563eb;
        }

        /* 2. 가로 모드 (Horizontal) 연결선 */
        #report-container.layout-horizontal .step-section .flow-connector {
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            flex-direction: row;
            width: 8rem;
            height: 2px;
            display: flex !important;
            /* 파노라마 모드에서도 항상 표시 */
            z-index: 100;
            /* 카드 섹션 위에 확실히 표시되도록 높은 z-index 설정 */
            opacity: 0.8;
            /* 기본 투명도 */
            transition: opacity 0.3s ease, transform 0.3s ease;
            margin-left: 0;
            /* 카드 섹션 외곽 끝에서 시작 */
            pointer-events: auto;
            /* 클릭 가능하도록 */
            position: absolute;
            /* 절대 위치로 카드 섹션 외곽에 정확히 배치 */
        }

        #report-container.layout-horizontal .step-section.is-visible .flow-connector {
            opacity: 1;
            /* 보이는 섹션의 흐름 방향 표시 강조 */
            transform: translateY(-50%) scale(1.05);
            /* 약간 확대 */
        }

        #report-container.layout-horizontal .step-section .flow-line {
            height: 2px;
            flex-grow: 1;
            background: linear-gradient(to right, #4b5563, #3b82f6);
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
            transition: all 0.3s ease;
            /* 부드러운 전환 */
            position: relative;
            overflow: hidden;
        }

        /* 전류 흐름 애니메이션 (가로 모드) */
        #report-container.layout-horizontal .step-section .flow-line::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(to right,
                    transparent 0px,
                    transparent 8px,
                    #60a5fa 8px,
                    #60a5fa 10px,
                    transparent 10px,
                    transparent 18px);
            background-size: 18px 100%;
            animation: flowRight 1.2s linear infinite;
            opacity: 0.9;
        }

        @keyframes flowRight {
            0% {
                transform: translateX(-18px);
            }

            100% {
                transform: translateX(100%);
            }
        }

        /* 흐름 방향 기호 이동 애니메이션 (가로 모드) */
        #report-container.layout-horizontal .step-section .flow-node {
            animation: pulseGlow 2s infinite, flowNodeMoveRight 1.2s linear infinite;
        }

        @keyframes flowNodeMoveRight {
            0% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(3px);
            }

            100% {
                transform: translateX(0);
            }
        }

        #report-container.layout-horizontal .step-section .flow-node {
            width: 30px;
            height: 30px;
            background: #111827;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.6);
            margin-left: -15px;
            /* 화살표 끝이 카드 섹션의 오른쪽 끝에 정확히 맞춰지도록 조정 */
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #report-container.layout-horizontal .step-section .flow-node:hover {
            transform: scale(1.2);
            background: #2563eb;
        }

        #report-container.layout-horizontal .flow-node i {
            transform: rotate(-90deg);
        }

        /* 파노라마 모드 스크롤 시 흐름 방향 표시 강조 */
        #report-container.layout-horizontal .step-section:target .flow-connector,
        #report-container.layout-horizontal .step-section.is-visible .flow-connector {
            opacity: 1;
        }

        @keyframes pulseGlow {
            0% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }

        /* [개선] 첫 번째와 두 번째 카드 섹션에서도 흐름 표시 정상 표시 (명시적 보장) */
        #report-container .step-section:nth-child(1) .flow-connector,
        #report-container .step-section:nth-child(2) .flow-connector {
            display: flex !important;
            /* 명시적 표시 */
            visibility: visible !important;
            /* 명시적 표시 */
            opacity: 1 !important;
            /* 명시적 표시 */
        }

        /* 마지막 카드 섹션에서 흐름 표시 제거 (리포트 모드 및 파노라마 모드 모두 적용) */
        #report-container .step-section:last-child .flow-connector,
        #report-container.layout-horizontal .step-section:last-child .flow-connector,
        #report-container:not(.layout-horizontal) .step-section:last-child .flow-connector {
            display: none !important;
            /* 강제로 숨김 */
            visibility: hidden !important;
            /* 추가 보장 */
            opacity: 0 !important;
            /* 추가 보장 */
        }

        /* [개선] 마지막 카드는 기호가 없으므로 하단 여유공간 제거 */
        #report-container:not(.layout-horizontal) .step-section:last-child {
            padding-bottom: 40px;
            /* 기호 대신 최소 여유공간만 유지 */
        }

        #report-container.layout-horizontal .step-section:last-child {
            margin-right: 40px;
            /* 파노라마 모드에서도 최소 여유공간만 유지 */
        }

        .finish-marker {
            position: absolute;
            bottom: -15px;
            right: -15px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #10b981, #059669);
            border: 4px solid #1f2937;
            border-radius: 50%;
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.6);
            z-index: 10;
            animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from {
                transform: scale(0);
            }

            to {
                transform: scale(1);
            }
        }

        #report-container .step-section:last-child .finish-marker {
            display: flex;
        }

        #report-container.layout-grid-custom {
            display: grid;
            gap: 6rem;
        }

        #report-container.layout-grid-custom .step-section {
            display: block;
        }

        #report-container.layout-grid-custom .step-grid-layout {
            grid-template-columns: 1fr;
        }

        #report-container.layout-horizontal {
            display: grid;
            grid-auto-flow: column;
            overflow-x: auto;
            gap: 8rem;
            padding: 0 0 40px 0;
            align-items: start;
            scroll-snap-type: x proximity;
            scrollbar-width: thin;
            scrollbar-color: #4b5563 #1f2937;
            scroll-behavior: smooth;
            /* 부드러운 스크롤 */
            -webkit-overflow-scrolling: touch;
            /* iOS 부드러운 스크롤 */
            scroll-padding: 0;
            /* 스크롤 패딩 제거 */
            overscroll-behavior-x: contain;
            /* 스크롤 튀김 방지 */
            max-width: 100% !important;
            /* 파노라마 모드에서 최대 너비 제한 제거 */
            margin: 0 !important;
            /* 좌우 마진 제거 */
            width: 100vw;
            /* 화면 전체 너비 사용 */
        }

        #report-container.layout-horizontal .step-section {
            min-width: 500px;
            width: calc(100vw - 8rem);
            max-width: 72rem;
            scroll-snap-align: start;
            flex-shrink: 0;
            margin-top: 0 !important;
            margin-right: 24px;
            /* 조정: 파노라마 모드에서 흐름 기호가 카드 외곽과 붙도록 여유 축소 */
            display: grid !important;
            grid-template-columns: 4fr 6fr !important;
            gap: 2rem !important;
            align-items: start !important;
            scroll-snap-stop: normal;
            /* 부드러운 스크롤을 위해 normal로 변경 */
            position: relative;
            /* 흐름 방향 표시를 위한 relative */
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.3s ease;
            /* 영화 필름처럼 부드러운 전환 */
            will-change: transform;
            /* 성능 최적화 */
        }

        /* [개선] 첫 번째 섹션에 왼쪽 마진 추가 (파노라마 모드) */
        #report-container.layout-horizontal .step-section:first-of-type {
            margin-left: 0 !important;
            /* 왼쪽 끝에 정렬 */
        }

        #report-container.layout-horizontal .step-section.is-visible {
            opacity: 1;
        }

        #report-container.layout-horizontal .step-section:not(.is-visible) {
            opacity: 0.95;
            /* 보이지 않는 섹션은 약간 투명하게 */
        }

        #report-container.layout-horizontal::-webkit-scrollbar {
            height: 12px;
        }

        #report-container.layout-horizontal::-webkit-scrollbar-track {
            background: #1f2937;
        }

        #report-container.layout-horizontal::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 6px;
            transition: background-color 0.2s;
            cursor: grab;
        }

        #report-container.layout-horizontal::-webkit-scrollbar-thumb:hover {
            background-color: #6b7280;
        }

        #report-container.layout-horizontal::-webkit-scrollbar-thumb:active {
            background-color: #3b82f6;
            cursor: grabbing;
        }

        .add-step-btn {
            display: block;
            width: 100%;
            padding: 20px;
            border: 2px dashed #4b5563;
            border-radius: 12px;
            background-color: rgba(31, 41, 55, 0.5);
            color: #9ca3af;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
        }

        .add-step-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
        }

        /* 방향 선택 모달 */
        #direction-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 6000;
            justify-content: center;
            align-items: center;
        }

        #direction-box {
            background: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 12px;
            padding: 30px;
            width: 400px;
            max-width: 90%;
            text-align: center;
            animation: popup 0.3s;
        }

        .direction-btn {
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            width: 100%;
            background: #374151;
            color: white;
            border: 1px solid #4b5563;
            transition: all 0.2s;
        }

        .direction-btn:hover {
            background: #3b82f6;
            border-color: #2563eb;
        }

        #confirm-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 5000;
            justify-content: center;
            align-items: center;
        }

        #confirm-box {
            background: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 10px;
            padding: 25px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            animation: popup 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #confirm-msg {
            color: #fff;
            font-size: 1.1rem;
            margin-bottom: 25px;
        }

        #confirm-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .confirm-btn {
            padding: 8px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            border: none;
        }

        .confirm-yes {
            background-color: #ef4444;
            color: white;
        }

        .confirm-yes:hover {
            background-color: #dc2626;
        }

        .confirm-no {
            background-color: #4b5563;
            color: white;
        }

        .confirm-no:hover {
            background-color: #374151;
        }

        .grid-controller {
            display: flex;
            align-items: center;
            background: #1f2937;
            border-radius: 6px;
            border: 1px solid #4b5563;
            overflow: hidden;
            margin-left: 8px;
        }

        .grid-btn {
            padding: 4px 10px;
            cursor: pointer;
            color: #d1d5db;
            font-weight: bold;
            font-size: 0.8rem;
            transition: background 0.2s;
        }

        .grid-btn:hover {
            background: #374151;
            color: white;
        }

        .grid-display {
            padding: 4px 10px;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            background: #374151;
            border-left: 1px solid #4b5563;
            border-right: 1px solid #4b5563;
            min-width: 50px;
            text-align: center;
        }

        @keyframes popup {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes rise {
            0% {
                transform: translateY(0) scale(1);
                opacity: 0.8;
            }

            100% {
                transform: translateY(-50px) scale(0.2);
                opacity: 0;
            }
        }

        /* [NEW] 기존 UI 압축 컨트롤 숨김 (DOM 보존, 비노출) */
        #image-compression-select {
            display: none !important;
        }

        [id^="compression-select-"] {
            display: none !important;
        }

        /* [NEW] 툴바에서 압축 관련 UI 완전히 숨김 */
        div:has(> #image-compression-select),
        div:has(> #export-max-width) {
            display: none !important;
        }

        /* [NEW] 이미지 영역에서 per-wrapper 압축 컨트롤 숨김 */
        .image-compression-controls {
            display: none !important;
        }

        /* [NEW] 압축 선택 모달 스타일 */
        #compression-choice-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 7000;
            justify-content: center;
            align-items: center;
        }

        #compression-choice-modal.active {
            display: flex;
        }

        .compression-modal-box {
            background: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 12px;
            padding: 30px;
            width: 450px;
            max-width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: scale(0.9) translateY(-20px);
                opacity: 0;
            }

            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        .compression-modal-title {
            color: white;
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .compression-modal-desc {
            color: #9ca3af;
            font-size: 0.9rem;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .compression-option-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }

        .compression-option-label {
            display: flex;
            align-items: center;
            padding: 12px 14px;
            background: #374151;
            border: 2px solid #4b5563;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .compression-option-label:hover {
            background: #2d3748;
            border-color: #3b82f6;
        }

        .compression-option-label input[type="radio"] {
            margin-right: 12px;
            margin-left: 0;
            accent-color: #3b82f6;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .compression-option-label.selected {
            background: #1e3a8a;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .compression-option-text {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .compression-option-title {
            color: white;
            font-weight: bold;
            font-size: 0.95rem;
        }

        .compression-option-info {
            color: #d1d5db;
            font-size: 0.8rem;
            margin-top: 2px;
        }

        .compression-recommended-badge {
            background: #10b981;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: auto;
        }

        .compression-modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .compression-modal-btn {
            flex: 1;
            padding: 11px 16px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .compression-modal-btn.confirm {
            background: #3b82f6;
            color: white;
        }

        .compression-modal-btn.confirm:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .compression-modal-btn.cancel {
            background: #4b5563;
            color: #d1d5db;
        }

        .compression-modal-btn.cancel:hover {
            background: #374151;
        }

        @media print {
            body {
                padding-top: 0 !important;
                overflow: visible !important;
            }

            .no-print,
            #main-header,
            .toolbar,
            #laser-pointer,
            #collage-modal,
            .add-step-btn,
            #confirm-modal,
            #drawing-settings-popover,
            #direction-modal,
            #compression-choice-modal {
                display: none !important;
            }

            #report-container.layout-horizontal {
                display: block !important;
                overflow: visible !important;
            }

            .step-section {
                margin-bottom: 20px;
                break-inside: avoid;
            }

            .step-grid-layout {
                grid-template-columns: 1fr !important;
            }

            .image-wrapper {
                border: none;
                background: white;
                height: auto;
                transform: none !important;
                box-shadow: none !important;
            }

            .annotation {
                border-width: 2px !important;
                box-shadow: none !important;
                transform: none !important;
                background: transparent !important;
            }

            .resize-handle,
            .delete-btn,
            .step-select-wrapper,
            .section-delete-btn,
            .thumb-delete-btn,
            .flow-connector,
            .finish-marker,
            .style-toggle-btn,
            .section-expand-btn {
                display: none !important;
            }

            #fullscreen-modal {
                display: none !important;
            }
        }
    </style>
</head>

<body class="bg-gray-900 min-h-screen p-8">

    <div id="laser-pointer"></div>

    <!-- 선택된 요소 툴팁 -->
    <div id="element-tooltip" class="element-tooltip"></div>

    <!-- [NEW] 압축 선택 모달 (파일 선택 직후 표시) -->
    <div id="compression-choice-modal">
        <div class="compression-modal-box">
            <div class="compression-modal-title">
                <i class="fas fa-image"></i>
                이미지 압축률 선택
            </div>
            <div class="compression-modal-desc">
                선택된 이미지의 품질과 파일 크기를 조정합니다.<br>
                <span id="compression-recommended-hint" style="color: #60a5fa; font-weight: bold;"></span>
            </div>
            <div class="compression-option-group" id="compression-options-container">
                <!-- JS로 동적 생성 -->
            </div>
            <div class="compression-modal-actions">
                <button class="compression-modal-btn confirm" onclick="confirmCompressionChoice()">확인</button>
                <button class="compression-modal-btn cancel" onclick="cancelCompressionChoice()">취소</button>
            </div>
        </div>
    </div>

    <!-- [NEW] 방향 선택 모달 -->
    <div id="direction-modal">
        <div id="direction-box">
            <h3 class="text-white text-lg font-bold mb-4">단계 추가 위치 선택</h3>
            <div class="flex flex-col gap-2" id="direction-buttons">
                <!-- JS로 버튼 동적 생성 -->
            </div>
            <button onclick="closeDirectionModal()"
                class="mt-4 text-gray-400 hover:text-white text-sm underline">취소</button>
        </div>
    </div>

    <!-- [NEW] 그리기 설정 팝업 (글자 크기/굵기 추가 & 그리드 배치) -->
    <div id="drawing-settings-popover">
        <div class="popover-header">
            <div class="flex items-center">
                <span class="popover-title">도구 설정</span>
                <!-- [NEW] 선택된 요소 정보 -->
                <span id="selected-element-info"></span>
            </div>
            <i class="fas fa-times popover-close" onclick="closeSettingsPopover()"></i>
        </div>

        <div class="settings-grid">
            <!-- 1. 선 스타일 -->
            <div class="setting-item full-width">
                <div class="setting-label">선 스타일 (Line)</div>
                <div class="style-radio-group">
                    <label class="style-radio-label"><input type="radio" name="lineStyle" value="solid" checked
                            onchange="setGlobalLineStyle('solid')"> 실선</label>
                    <label class="style-radio-label"><input type="radio" name="lineStyle" value="dashed"
                            onchange="setGlobalLineStyle('dashed')"> 점선</label>
                </div>
            </div>

            <!-- 2. 선 굵기 -->
            <div class="setting-item">
                <div class="setting-label"><span>선 굵기</span> <span id="val-stroke">5px</span></div>
                <input type="range" min="1" max="20" value="5" class="setting-input"
                    oninput="document.getElementById('val-stroke').innerText=this.value+'px'; setGlobalStrokeWidth(this.value)"
                    title="선 굵기">
            </div>

            <!-- 3. 투명도 -->
            <div class="setting-item">
                <div class="setting-label"><span>투명도</span> <span id="val-opacity">100%</span></div>
                <input type="range" min="10" max="100" value="100" class="setting-input"
                    oninput="document.getElementById('val-opacity').innerText=this.value+'%'; setGlobalOpacity(this.value)"
                    title="투명도">
            </div>

            <!-- 4. 글자 크기 (New) -->
            <div class="setting-item">
                <div class="setting-label"><span>글자 크기</span> <span id="val-fontsize">16px</span></div>
                <input type="range" min="12" max="40" value="16" class="setting-input"
                    oninput="document.getElementById('val-fontsize').innerText=this.value+'px'; setGlobalFontSize(this.value)"
                    title="글자 크기">
            </div>

            <!-- 5. 글자 굵기 (New) -->
            <div class="setting-item">
                <div class="setting-label"><span>글자 굵기</span> <span id="val-fontweight">900</span></div>
                <input type="range" min="100" max="900" step="100" value="900" class="setting-input"
                    oninput="document.getElementById('val-fontweight').innerText=this.value; setGlobalFontWeight(this.value)"
                    title="글자 굵기">
            </div>

            <!-- 6. 텍스트 색상 (텍스트 박스일 때만 표시) -->
            <div class="setting-item full-width" id="text-color-setting" style="display: none;">
                <div class="setting-label">텍스트 색상</div>
                <div class="text-color-picker">
                    <div class="text-color-option" style="background-color: #ffffff;" onclick="setTextColor('#ffffff')"
                        title="흰색"></div>
                    <div class="text-color-option" style="background-color: #000000;" onclick="setTextColor('#000000')"
                        title="검정색"></div>
                    <div class="text-color-option" style="background-color: #ef4444;" onclick="setTextColor('#ef4444')"
                        title="빨간색"></div>
                    <div class="text-color-option" style="background-color: #eab308;" onclick="setTextColor('#eab308')"
                        title="노란색"></div>
                    <div class="text-color-option" style="background-color: #22c55e;" onclick="setTextColor('#22c55e')"
                        title="초록색"></div>
                    <div class="text-color-option" style="background-color: #3b82f6;" onclick="setTextColor('#3b82f6')"
                        title="파란색"></div>
                    <div class="text-color-option" style="background-color: #a855f7;" onclick="setTextColor('#a855f7')"
                        title="보라색"></div>
                    <div class="text-color-option" style="background-color: #f97316;" onclick="setTextColor('#f97316')"
                        title="주황색"></div>
                    <div class="text-color-option" style="background-color: #ec4899;" onclick="setTextColor('#ec4899')"
                        title="분홍색"></div>
                    <div class="text-color-option" style="background-color: #06b6d4;" onclick="setTextColor('#06b6d4')"
                        title="청록색"></div>
                </div>
            </div>

            <!-- 7. 외곽선 색상 (텍스트 박스일 때만 표시) -->
            <div class="setting-item full-width" id="border-color-setting" style="display: none;">
                <div class="setting-label">외곽선 색상</div>
                <div class="text-color-picker">
                    <div class="text-color-option border-color-option" style="background-color: #ef4444;"
                        onclick="setBorderColor('red')" title="빨간색"></div>
                    <div class="text-color-option border-color-option" style="background-color: #eab308;"
                        onclick="setBorderColor('yellow')" title="노란색"></div>
                    <div class="text-color-option border-color-option" style="background-color: #22c55e;"
                        onclick="setBorderColor('green')" title="초록색"></div>
                    <div class="text-color-option border-color-option" style="background-color: #3b82f6;"
                        onclick="setBorderColor('blue')" title="파란색"></div>
                    <div class="text-color-option border-color-option" style="background-color: #a855f7;"
                        onclick="setBorderColor('purple')" title="보라색"></div>
                    <div class="text-color-option border-color-option" style="background-color: #ffffff;"
                        onclick="setBorderColor('white')" title="흰색"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="confirm-modal">
        <div id="confirm-box">
            <div id="confirm-msg">확인 메시지</div>
            <div id="confirm-actions">
                <button class="confirm-btn confirm-yes" id="btn-confirm-yes">확인</button>
                <button class="confirm-btn confirm-no" onclick="closeConfirm()">취소</button>
            </div>
        </div>
    </div>

    <!-- 배경 설정 모달 -->
    <div id="background-modal" onclick="if(event.target.id === 'background-modal') closeBackgroundSettings()"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 3000; justify-content: center; align-items: center;">
        <div onclick="event.stopPropagation()"
            style="background: #1f2937; border: 1px solid #4b5563; border-radius: 8px; padding: 20px; width: 400px; max-width: 90%; box-shadow: 0 10px 30px rgba(0,0,0,0.6);">
            <div
                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #374151; padding-bottom: 10px;">
                <h3 style="color: white; font-size: 16px; font-weight: bold;">배경 설정</h3>
                <button onclick="closeBackgroundSettings()"
                    style="background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 18px;">&times;</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div>
                    <label style="color: #9ca3af; font-size: 12px; display: block; margin-bottom: 8px;">적용 대상:</label>
                    <div style="display: flex; gap: 10px;">
                        <label id="bg-target-body-label"
                            style="flex: 1; padding: 10px; background: #3b82f6; border: 2px solid #3b82f6; border-radius: 4px; cursor: pointer; text-align: center; color: white; transition: all 0.2s;">
                            <input type="radio" name="bg-target" value="body" checked style="margin-right: 5px;"
                                onchange="updateBackgroundTarget()">
                            바탕 화면
                        </label>
                        <label id="bg-target-sections-label"
                            style="flex: 1; padding: 10px; background: #374151; border: 2px solid #4b5563; border-radius: 4px; cursor: pointer; text-align: center; color: white; transition: all 0.2s;">
                            <input type="radio" name="bg-target" value="sections" style="margin-right: 5px;"
                                onchange="updateBackgroundTarget()">
                            카드 섹션
                        </label>
                    </div>
                </div>
                <div>
                    <label style="color: #9ca3af; font-size: 12px; display: block; margin-bottom: 5px;">배경 색상:</label>
                    <input type="color" id="bg-color-input" value="#1f2937"
                        style="width: 100%; height: 40px; border: 1px solid #4b5563; border-radius: 4px; cursor: pointer;">
                </div>
                <div>
                    <label style="color: #9ca3af; font-size: 12px; display: block; margin-bottom: 5px;">배경 이미지:</label>
                    <input type="file" id="bg-image-input" accept="image/*"
                        style="width: 100%; padding: 8px; background: #374151; border: 1px solid #4b5563; border-radius: 4px; color: white; cursor: pointer;">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="applyBackgroundColor()"
                        style="flex: 1; padding: 10px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">색상
                        적용</button>
                    <button onclick="applyBackgroundImage()"
                        style="flex: 1; padding: 10px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">이미지
                        적용</button>
                </div>
                <button onclick="resetBackground()"
                    style="width: 100%; padding: 8px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">기본값으로
                    복원</button>
            </div>
        </div>
    </div>

    <div id="collage-modal">
        <div id="collage-container">
            <div id="collage-header">
                <h2 class="text-xl font-bold text-white"><i class="fas fa-th-large mr-2"></i>현장 요약 대시보드</h2>
                <div class="flex gap-2">
                    <button onclick="saveCollageImage()"
                        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-bold text-sm">이미지
                        저장</button>
                    <button onclick="closeCollageModal()"
                        class="bg-gray-600 hover:bg-gray-500 text-white px-4 py-2 rounded font-bold text-sm">닫기</button>
                </div>
            </div>
            <div id="collage-preview-area"></div>
            <div class="modal-resize-handle" id="collage-resizer"></div>
        </div>
    </div>

    <!-- 헤더 -->
    <div id="main-header" class="no-print collapsed">
        <div class="bg-gray-800 p-2 flex items-center justify-center border-b border-gray-700 flex-wrap gap-2">
            <span class="text-xs text-gray-400 mr-2"><i class="fas fa-font"></i> 서식:</span>

            <!-- 텍스트 스타일 -->
            <div class="fmt-group flex gap-1">
                <button class="fmt-btn" onclick="formatText('bold')" title="굵게"><i class="fas fa-bold"></i></button>
                <button class="fmt-btn" onclick="formatText('italic')" title="기울임"><i
                        class="fas fa-italic"></i></button>
                <button class="fmt-btn" onclick="formatText('underline')" title="밑줄"><i
                        class="fas fa-underline"></i></button>
                <button class="fmt-btn" onclick="formatText('strikeThrough')" title="취소선"><i
                        class="fas fa-strikethrough"></i></button>
                <button class="fmt-btn" onclick="formatText('superscript')" title="위첨자"><i
                        class="fas fa-superscript"></i></button>
                <button class="fmt-btn" onclick="formatText('subscript')" title="아래첨자"><i
                        class="fas fa-subscript"></i></button>
            </div>

            <!-- 편집 도구 -->
            <div class="fmt-group flex gap-1">
                <button class="fmt-btn" onclick="formatText('undo')" title="실행 취소"><i class="fas fa-undo"></i></button>
                <button class="fmt-btn" onclick="formatText('redo')" title="다시 실행"><i class="fas fa-redo"></i></button>
                <button class="fmt-btn" onclick="formatText('removeFormat')" title="서식 제거"><i
                        class="fas fa-remove-format"></i></button>
                <button class="fmt-btn" onclick="insertLink()" title="링크 삽입"><i class="fas fa-link"></i></button>
                <button class="fmt-btn" onclick="formatText('unlink')" title="링크 제거"><i
                        class="fas fa-unlink"></i></button>
            </div>

            <!-- 정렬 -->
            <div class="fmt-group flex gap-1">
                <button class="fmt-btn" onclick="formatText('justifyLeft')" title="왼쪽 정렬"><i
                        class="fas fa-align-left"></i></button>
                <button class="fmt-btn" onclick="formatText('justifyCenter')" title="가운데 정렬"><i
                        class="fas fa-align-center"></i></button>
                <button class="fmt-btn" onclick="formatText('justifyRight')" title="오른쪽 정렬"><i
                        class="fas fa-align-right"></i></button>
                <button class="fmt-btn" onclick="formatText('justifyFull')" title="양쪽 정렬"><i
                        class="fas fa-align-justify"></i></button>
            </div>

            <!-- 목록 -->
            <div class="fmt-group flex gap-1">
                <button class="fmt-btn" onclick="formatText('insertUnorderedList')" title="글머리 기호"><i
                        class="fas fa-list-ul"></i></button>
                <button class="fmt-btn" onclick="formatText('insertOrderedList')" title="번호 매기기"><i
                        class="fas fa-list-ol"></i></button>
                <button class="fmt-btn" onclick="formatText('outdent')" title="내어쓰기"><i
                        class="fas fa-outdent"></i></button>
                <button class="fmt-btn" onclick="formatText('indent')" title="들여쓰기"><i
                        class="fas fa-indent"></i></button>
            </div>

            <!-- 머리글 -->
            <div class="fmt-group flex gap-1">
                <button class="fmt-btn" onclick="formatText('formatBlock', 'p')" title="본문">본문</button>
                <button class="fmt-btn" onclick="formatText('formatBlock', 'h1')" title="제목 1">H1</button>
                <button class="fmt-btn" onclick="formatText('formatBlock', 'h2')" title="제목 2">H2</button>
                <button class="fmt-btn" onclick="formatText('formatBlock', 'h3')" title="제목 3">H3</button>
            </div>

            <!-- 폰트 선택 -->
            <div class="fmt-group flex gap-1 items-center">
                <label class="text-xs text-gray-400 mr-1">폰트:</label>
                <select class="fmt-btn text-xs px-2 py-1" onchange="formatText('fontName', this.value)" title="폰트 선택">
                    <option value="Arial">Arial</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Comic Sans MS">Comic Sans MS</option>
                    <option value="Impact">Impact</option>
                    <option value="Noto Sans KR">Noto Sans KR</option>
                </select>
            </div>

            <!-- 글자 크기 -->
            <div class="fmt-group flex gap-1 items-center">
                <label class="text-xs text-gray-400 mr-1">크기:</label>
                <input type="number" id="font-size-input" min="8" max="72" value="16" step="1"
                    class="fmt-btn text-xs px-2 py-1 w-16 text-center" onchange="setFontSize(this.value)"
                    onmousedown="saveRange()" title="글자 크기">
                <span class="text-xs text-gray-400">px</span>
            </div>

            <!-- 줄 간격 (자유 조정) -->
            <div class="fmt-group flex gap-1 items-center">
                <label class="text-xs text-gray-400 mr-1">줄간격:</label>
                <input type="number" id="line-height-input" min="0.5" max="5.0" value="1.5" step="0.1"
                    class="fmt-btn text-xs px-2 py-1 w-16 text-center" onchange="setLineHeight(this.value)"
                    onmousedown="saveRange()" title="줄 간격">
            </div>

            <!-- 색상 선택 -->
            <div class="flex items-center gap-1">
                <label class="text-xs text-gray-400">글자색:</label>
                <input type="color" id="fore-color-input" onmousedown="saveRange()"
                    onchange="applyColor('foreColor', this.value)"
                    class="w-6 h-6 bg-transparent cursor-pointer border border-gray-600 rounded" title="글자 색상">
                <label class="text-xs text-gray-400 ml-2">배경색:</label>
                <input type="color" id="hilite-color-input" onmousedown="saveRange()"
                    onchange="applyColor('hiliteColor', this.value)" value="#ffffff"
                    class="w-6 h-6 bg-transparent cursor-pointer border border-gray-600 rounded" title="배경 색상">
            </div>

            <!-- 배경 설정 -->
            <div class="fmt-group flex gap-1 items-center">
                <button class="fmt-btn" onclick="openBackgroundSettings()" title="배경 설정"><i class="fas fa-image"></i>
                    배경</button>
            </div>
        </div>

        <div class="bg-gray-900 p-3 flex justify-between items-center px-6 border-b border-gray-700">
            <div class="text-gray-300 text-sm flex gap-4 items-center">
                <span class="font-bold text-blue-400"><i class="fas fa-edit"></i> 편집 모드</span>
                <div class="flex bg-gray-800 rounded-lg p-1 ml-4 border border-gray-600 items-center">
                    <button onclick="setLayout('vertical')" id="btn-layout-v"
                        class="px-3 py-1 rounded text-xs font-bold bg-blue-600 text-white transition-all"
                        title="리포트 모드 (세로)">
                        <i class="fas fa-list-ul mr-1"></i> 리포트
                    </button>

                    <div class="grid-controller" id="grid-controller">
                        <div class="grid-btn" onclick="changeGridCount(-1)"><i class="fas fa-minus"></i></div>
                        <div class="grid-display" id="grid-count-display">1열</div>
                        <div class="grid-btn" onclick="changeGridCount(1)"><i class="fas fa-plus"></i></div>
                    </div>

                    <button onclick="setLayout('horizontal')" id="btn-layout-h"
                        class="px-3 py-1 rounded text-xs font-bold text-gray-400 hover:text-white transition-all ml-2"
                        title="파노라마 모드 (가로)">
                        <i class="fas fa-film mr-1"></i> 파노라마
                    </button>
                </div>
            </div>

            <div class="flex gap-2 items-center">
                <div class="flex items-center mr-2">
                    <input type="checkbox" id="select-all-steps" class="w-4 h-4 accent-purple-500 cursor-pointer"
                        onchange="toggleAllSteps(this)">
                    <label for="select-all-steps"
                        class="ml-2 text-xs text-gray-400 cursor-pointer select-none">전체</label>
                </div>

                <button onclick="createCollage()"
                    class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded text-xs flex items-center gap-1">
                    <i class="fas fa-th-large"></i> 콜라주
                </button>

                <div id="collage-history" class="flex gap-2 ml-2 items-center overflow-x-auto"
                    style="max-width: 150px;"></div>
                <div class="mr-2 flex items-center">
                    <label class="text-xs text-gray-400 mr-2">압축:</label>
                    <select id="image-compression-select" class="fmt-btn text-xs px-2 py-1" title="이미지 압축률">
                        <option value="high">상 (원본 유지 우선)</option>
                        <option value="medium" selected>중 (기본)</option>
                        <option value="low">하 (저용량)</option>
                    </select>
                    <span class="text-xs text-gray-400 ml-2">상:≈98% 품질(원본 유지 우선), 중:≈80%(권장), 하:≈60% 용량최적화</span>
                </div>
                <!-- 항상 접근 가능한 '원본 유지' 토글 (툴바) -->
                <div class="mr-2 flex items-center" style="align-items:center;">
                    <label for="preserve-original-toolbar" class="text-xs text-gray-400 mr-2">원본 유지:</label>
                    <input id="preserve-original-toolbar" type="checkbox" title="원본 유지(상 선택 시 가능하면 재인코딩 건너뜀)"
                        onchange="preserveOriginalWhenHigh = this.checked; var m = document.getElementById('preserve-original-toggle'); if(m) m.checked = this.checked;" />
                </div>
                <div class="mr-2 flex items-center">
                    <label class="text-xs text-gray-400 mr-2">내보내기 최대너비:</label>
                    <input id="export-max-width" type="number" min="200" step="100" value="2000"
                        class="fmt-btn text-xs px-2 py-1 w-24" title="내보내기 시 이미지 최대 가로 픽셀" />
                    <span class="text-xs text-gray-400 ml-2">(화면 보존 기반으로 고품질 리사이징)</span>
                </div>
                <div class="h-6 w-px bg-gray-600 mx-2"></div>

                <button onclick="downloadSelfContainedHtml()"
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded text-xs flex items-center gap-1">
                    <i class="fas fa-save"></i> 저장
                </button>
                <button onclick="window.print()"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded text-xs flex items-center gap-1">
                    <i class="fas fa-file-pdf"></i> 인쇄
                </button>
            </div>
        </div>

        <div class="curtain-handle" onclick="toggleHeader()" title="툴바 접기/펴기">
            <i id="toggle-icon" class="fas fa-chevron-down"></i>
        </div>
    </div>

    <div id="fullscreen-modal">
        <div id="fullscreen-close" onclick="closeFullscreen()">&times;</div>
        <div id="fullscreen-title" contenteditable="true">전체 화면 보기</div>
        <div id="fullscreen-content" class="perspective-container"></div>
        <div class="text-gray-400 mt-4 text-sm flex gap-2 items-center">
            <i class="fas fa-mouse-pointer text-red-500"></i> <span class="text-gray-300">판서 가능 (ESC: 닫기)</span>
        </div>
    </div>

    <div class="max-w-6xl mx-auto mb-6 text-center border-b border-gray-700 pb-6 mt-0">
        <div class="flex justify-center items-center flex-wrap gap-2 mb-4">
            <h1 class="text-4xl md:text-5xl font-black text-white tracking-tight" contenteditable="true">
                <span class="text-blue-500">작업 완료 현황</span> 보고서
            </h1>
            <span class="building-badge" contenteditable="true" title="클릭하여 수정">A동 101호</span>
        </div>
        <p class="text-xl text-gray-400" contenteditable="true">안전 사고 예방을 위한 배선 재구조화 작업 완료 보고</p>
    </div>

    <!-- 상단 추가 버튼 -->
    <!-- [수정됨] 상단 '새로운 작업 단계 추가' 버튼 제거 요청 반영? 아니면 유지? "제거 하고" 라고 하셨는데,
         지시사항 1번: '새로운 작업 단계 추가' 메뉴바를 제거 하고...
         -> 상단/하단의 큰 버튼을 제거하고 카드 섹션 내부에 추가하는 것이 맞음.
    -->
    <!-- 
    <div class="max-w-6xl mx-auto mb-8 no-print">
        <button class="add-step-btn" onclick="addNewStep('end')">
            <i class="fas fa-plus-circle mr-2"></i> 새로운 작업 단계 추가
        </button>
    </div> 
    -->

    <!-- 컨텐츠 그리드 -->
    <div class="max-w-6xl mx-auto pb-20 pt-4" id="report-container" style="display: grid; gap: 6rem;"></div>

    <!-- 하단 추가 버튼 제거 -->
    <!-- 
    <div class="max-w-6xl mx-auto pb-24 no-print">
        <button class="add-step-btn" onclick="addNewStep('end')">
            <i class="fas fa-plus-circle mr-2"></i> 새로운 작업 단계 추가
        </button>
    </div> 
    -->

    <script>
        // 전역 변수
        let globalTool = 'select';
        let globalColor = 'red';
        let selectedElement = null;

        // [NEW] Target ID for adding step
        let targetStepIdForAdd = null;

        // [NEW] 콜라주 모드 상태 관리 (각 wrapper별로 관리)
        let collageModeState = {}; // wrapper-id => 'draw' | 'move'

        // [NEW] 압축 선택 모달 상태
        let pendingCompressionChoice = null; // { quality, callback }
        let compressionModalOpen = false;
        let selectedCompressionQuality = 'medium';
        // 사용자 설정: '원본 유지' 토글 (기본 false). true면 '상' 선택 시 가능한 경우 원본 사용.
        let preserveOriginalWhenHigh = false;


        // [NEW] 권장 품질 계산 함수 (이미지 크기 기반)
        function calculateRecommendedCompression(imageFiles, wrapperWidth, wrapperHeight) {
            if (!imageFiles || imageFiles.length === 0) return Promise.resolve('medium');
            // 첫 파일의 크기만 확인 (다중 선택시)
            const file = imageFiles[0];
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = wrapperWidth * dpr;
            const displayHeight = wrapperHeight * dpr;

            // 이미지 메타정보 읽기 (비동기 처리)
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = function () {
                        const natW = this.naturalWidth;
                        const natH = this.naturalHeight;

                        // 원본 크기가 화면 표시 크기보다 2배 이상 크면 "중" 이상 권장
                        if (natW >= displayWidth * 2 || natH >= displayHeight * 2) {
                            // 매우 큰 경우 "하" 권장 (용량 우선)
                            resolve('low');
                        } else if (Math.abs(natW - displayWidth) < displayWidth * 0.2 && Math.abs(natH - displayHeight) < displayHeight * 0.2) {
                            // 원본 ≈ 표시 크기 (±20%) → "상" 권장 (품질 우선)
                            resolve('high');
                        } else {
                            // 중간 크기 → "중" 권장 (균형)
                            resolve('medium');
                        }
                    };
                    img.onerror = function () {
                        resolve('medium'); // 오류 발생시 기본값
                    };
                    img.src = e.target.result;
                };
                reader.onerror = function () {
                    resolve('medium'); // 오류 발생시 기본값
                };
                reader.readAsDataURL(file);
            });
        }

        // [NEW] 압축 모달 표시 함수
        async function showCompressionModal(imageFiles, wrapperWidth, wrapperHeight, callback) {
            if (!imageFiles || imageFiles.length === 0) {
                if (callback) callback(null);
                return;
            }

            compressionModalOpen = true;
            pendingCompressionChoice = { quality: null, callback };

            const modal = document.getElementById('compression-choice-modal');
            const container = document.getElementById('compression-options-container');
            const hintSpan = document.getElementById('compression-recommended-hint');

            if (!modal || !container) return;

            // 권장 품질 계산
            const recommended = await calculateRecommendedCompression(imageFiles, wrapperWidth, wrapperHeight);
            hintSpan.textContent = `권장: ${recommended === 'high' ? '상 (고품질)' : recommended === 'low' ? '하 (용량최적화)' : '중 (균형)'}`;

            // 옵션 생성
            const options = [
                { value: 'none', title: '원본 그대로', desc: '100% 원본, 압축 없음', info: '글자 선명도 최고' },
                { value: 'high', title: '상 (원본 유지 우선)', desc: '≈98% 품질, 최대 화질 보존', info: '파일 크기 큼' },
                { value: 'medium', title: '중 (균형)', desc: '≈80% 품질, 균형잡힌 선택', info: '권장되는 옵션' },
                { value: 'low', title: '하 (용량최적화)', desc: '≈60% 품질, 파일 크기 최소화', info: '용량 최우선' }
            ];

            container.innerHTML = '';
            options.forEach(opt => {
                const label = document.createElement('label');
                label.className = 'compression-option-label' + (opt.value === recommended ? ' selected' : '');
                label.innerHTML = `
                    <input type="radio" name="compression-choice" value="${opt.value}" ${opt.value === recommended ? 'checked' : ''} />
                    <div class="compression-option-text">
                        <span class="compression-option-title">${opt.title}</span>
                        <span class="compression-option-info">${opt.desc}</span>
                    </div>
                    ${opt.value === recommended ? '<span class="compression-recommended-badge">권장</span>' : ''}
                `;
                label.addEventListener('change', (e) => {
                    document.querySelectorAll('.compression-option-label').forEach(l => l.classList.remove('selected'));
                    if (e.target.checked) label.classList.add('selected');
                });
                container.appendChild(label);
            });
            // '원본 유지' 토글 및 EXIF 안내 추가 (비침해적, 모달 내에 노출)
            const preserveWrapper = document.createElement('div');
            preserveWrapper.style.marginTop = '12px';
            preserveWrapper.style.display = 'flex';
            preserveWrapper.style.alignItems = 'center';
            preserveWrapper.innerHTML = `
                <input type="checkbox" id="preserve-original-toggle" ${preserveOriginalWhenHigh ? 'checked' : ''} />
                <label for="preserve-original-toggle" style="margin-left:8px;color:#cbd5e1;font-size:13px;">원본 유지(상 선택 시 가능하면 재인코딩 건너뜀)</label>
            `;
            container.appendChild(preserveWrapper);

            const exifNote = document.createElement('div');
            exifNote.style.marginTop = '8px';
            exifNote.style.color = '#9ca3af';
            exifNote.style.fontSize = '12px';
            exifNote.innerText = '참고: 재인코딩(캔버스→JPEG) 시 EXIF/메타데이터가 제거될 수 있습니다.';
            container.appendChild(exifNote);

            modal.classList.add('active');
        }

        // [NEW] 압축 선택 확인
        function confirmCompressionChoice() {
            const selected = document.querySelector('input[name="compression-choice"]:checked');
            if (!selected) return;

            const quality = selected.value;
            selectedCompressionQuality = quality;
            // '원본 그대로' 선택 시 preserveOriginalWhenHigh=true로 설정하여 원본 그대로 삽입되도록
            if (quality === 'none') {
                preserveOriginalWhenHigh = true;
            }
            // 모달의 '원본 유지' 체크 상태를 전역 변수에 반영
            try {
                const chk = document.getElementById('preserve-original-toggle');
                preserveOriginalWhenHigh = !!(chk && chk.checked);
            } catch (e) { /* ignore */ }
            const callback = pendingCompressionChoice?.callback;
            const modal = document.getElementById('compression-choice-modal');

            if (modal) modal.classList.remove('active');
            compressionModalOpen = false;
            pendingCompressionChoice = null;

            if (callback) callback(quality);
        }

        // [NEW] 압축 선택 취소
        function cancelCompressionChoice() {
            const modal = document.getElementById('compression-choice-modal');
            if (modal) modal.classList.remove('active');
            compressionModalOpen = false;

            const callback = pendingCompressionChoice?.callback;
            pendingCompressionChoice = null;

            if (callback) callback(null);
        }

        const toolSettings = {
            'pen': { width: 5, opacity: 100, style: 'solid' },
            'polyline': { width: 5, opacity: 100, style: 'solid' },
            'circle': { width: 5, opacity: 100, style: 'solid' },
            'ellipse': { width: 5, opacity: 100, style: 'solid' },
            'line': { width: 5, opacity: 100, style: 'solid' },
            'arrow': { width: 5, opacity: 100, style: 'solid' },
            'rect': { width: 5, opacity: 100, style: 'solid' },
            'box': { width: 3, opacity: 100, style: 'dashed', fontSize: 16, fontWeight: 900, textColor: '#ffffff', borderColor: 'red' }
        };
        // [NEW] 가시 영역 보존하면서 고품질 리샘플링·압축 적용
        function compressImageWithVisibleAreaPreservation(sourceImg, canvas, targetCanvas, quality) {
            const ctx = targetCanvas.getContext('2d');
            if (!ctx) return null;

            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // 원본에서 대상 캔버스로 고품질로 그리기
            // 대상 크기가 원본보다 작으면 다단계 리샘플링 사용
            const srcW = sourceImg.naturalWidth || sourceImg.width;
            const srcH = sourceImg.naturalHeight || sourceImg.height;
            const dstW = targetCanvas.width;
            const dstH = targetCanvas.height;

            // 다단계 리샘플링 (매우 큰 원본을 작은 대상으로 축소할 때 품질 향상)
            if (srcW > dstW * 2 || srcH > dstH * 2) {
                // 원본이 대상보다 2배 이상 큰 경우: 중간 크기로 한 번 더 그리기
                let intermediateW = Math.max(dstW * 1.5, 512);
                let intermediateH = Math.round(intermediateW * (srcH / srcW));

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = intermediateW;
                tempCanvas.height = intermediateH;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.imageSmoothingEnabled = true;
                tempCtx.imageSmoothingQuality = 'high';
                tempCtx.drawImage(sourceImg, 0, 0, intermediateW, intermediateH);

                // 중간 이미지에서 최종 대상으로 그리기
                ctx.drawImage(tempCanvas, 0, 0, dstW, dstH);
            } else {
                // 일반적인 경우: 직접 그리기
                ctx.drawImage(sourceImg, 0, 0, dstW, dstH);
            }

            // JPEG 압축 시도, 실패시 PNG
            try {
                return targetCanvas.toDataURL('image/jpeg', quality);
            } catch (e) {
                console.warn('JPEG compression failed, trying PNG');
                return targetCanvas.toDataURL('image/png');
            }
        }

        // [NEW] 선택된 압축 품질값을 가져오기
        function getSelectedCompressionQuality() {
            const qualityMap = {
                'high': 0.98,
                'medium': 0.80,
                'low': 0.60
            };
            return qualityMap[selectedCompressionQuality] || 0.80;
        }

        // 이미지 압축 품질 반환 (0~1) - 기존 호환성을 위해 유지
        function getCompressionQuality() {
            const sel = document.getElementById('image-compression-select');
            if (!sel) return 0.8;
            const v = sel.value;
            if (v === 'high') return 0.98;
            if (v === 'low') return 0.6;
            return 0.8; // medium
        }

        // 내보내기시 사용할 최대 너비(px) 반환
        function getExportMaxWidth() {
            const el = document.getElementById('export-max-width');
            if (!el) return 2000;
            const val = parseInt(el.value, 10);
            if (isNaN(val) || val <= 0) return 2000;
            return val;
        }

        // 개별 wrapper의 압축 품질 반환 (0~1)
        function getCompressionQualityForWrapper(id) {
            const sel = document.getElementById(`compression-select-${id}`);
            if (!sel) return getCompressionQuality();
            const v = sel.value;
            if (v === 'high') return 0.98;
            if (v === 'low') return 0.6;
            return 0.8; // medium
        }

        // 특정 wrapper에 대해 화면 품질을 보존하면서 고품질로 리사이즈/압축 적용
        function applyCompressionToWrapper(id) {
            const wrapper = document.getElementById(`wrapper-${id}`);
            if (!wrapper) return;
            const img = wrapper.querySelector('img:not(.collage-layer img)');
            if (!img) return;

            // 원본 또는 현재 표시 이미지 가져오기
            const originalSrc = img.getAttribute('data-original-src') || img.src;
            const sourceImg = new Image();
            sourceImg.crossOrigin = 'anonymous';
            sourceImg.onload = function () {
                try {
                    const dpr = window.devicePixelRatio || 1;
                    const maxWidth = getExportMaxWidth();

                    // 화면상 보여지는 영역(visible source rect) 계산
                    function getVisibleSourceRect(imgEl, srcImg) {
                        const wrapperRect = imgEl.closest('.image-wrapper').getBoundingClientRect();
                        const imgRect = imgEl.getBoundingClientRect();
                        const naturalW = srcImg.naturalWidth || imgEl.naturalWidth || imgEl.width;
                        const naturalH = srcImg.naturalHeight || imgEl.naturalHeight || imgEl.height;

                        // objectFit (cover / contain / fill)
                        const objectFit = (imgEl.style.objectFit || imgEl.getAttribute('data-object-fit') || 'cover').toLowerCase();
                        // objectPosition like 'center 50%'
                        let pos = (imgEl.style.objectPosition || '50% 50%').trim();
                        // normalize
                        const parts = pos.split(/\s+/);
                        let posX = '50%', posY = '50%';
                        if (parts.length === 1) { posX = parts[0]; posY = '50%'; }
                        if (parts.length >= 2) { posX = parts[0]; posY = parts[1]; }
                        const pctX = (posX.endsWith('%') ? parseFloat(posX) : 50) / 100;
                        const pctY = (posY.endsWith('%') ? parseFloat(posY) : 50) / 100;

                        // wrapper size (destination display area)
                        const dw = Math.max(1, Math.round(imgRect.width * dpr));
                        const dh = Math.max(1, Math.round(imgRect.height * dpr));

                        // If objectFit is cover or fill, image is scaled to cover wrapper
                        if (objectFit === 'cover' || objectFit === 'fill') {
                            const scale = Math.max((imgRect.width * dpr) / naturalW, (imgRect.height * dpr) / naturalH);
                            const renderedW = naturalW * scale;
                            const renderedH = naturalH * scale;
                            const offsetX = Math.max(0, (renderedW - imgRect.width * dpr) * pctX);
                            const offsetY = Math.max(0, (renderedH - imgRect.height * dpr) * pctY);
                            const sx = Math.round(offsetX / scale);
                            const sy = Math.round(offsetY / scale);
                            const sw = Math.max(1, Math.round((imgRect.width * dpr) / scale));
                            const sh = Math.max(1, Math.round((imgRect.height * dpr) / scale));
                            return { sx, sy, sw, sh, dw, dh };
                        } else if (objectFit === 'contain') {
                            // contain: entire image visible, may have letterbox; we use full image but scale down to dw x dh
                            const sx = 0, sy = 0, sw = naturalW, sh = naturalH;
                            return { sx, sy, sw, sh, dw, dh };
                        } else {
                            // default: assume image fills wrapper; use full image
                            const sx = 0, sy = 0, sw = naturalW, sh = naturalH;
                            return { sx, sy, sw, sh, dw, dh };
                        }
                    }

                    const rect = getVisibleSourceRect(img, sourceImg);
                    // determine final canvas size (avoid upscaling beyond natural)
                    const finalWidth = Math.min(Math.max(1, rect.dw), sourceImg.naturalWidth, maxWidth);
                    const aspect = rect.sh / rect.sw;
                    const finalHeight = Math.max(1, Math.round(finalWidth * aspect));

                    const canvas = document.createElement('canvas');
                    canvas.width = finalWidth;
                    canvas.height = finalHeight;

                    // 고품질(상) 선택 시 원본 크기와 같다면 재인코딩을 생략
                    // '원본 그대로' 옵션(none)이 선택되었으면 항상 원본을 그대로 사용
                    try {
                        const q_check = getCompressionQualityForWrapper(id);
                        // 원본 그대로 삽입: selectedCompressionQuality === 'none'이면 조건 없이 원본 사용
                        if (selectedCompressionQuality === 'none') {
                            img.src = originalSrc;
                            img.setAttribute('data-original-src', originalSrc);
                            img.setAttribute('data-rotation', '0');
                            img.setAttribute('data-flip-h', '1');
                            img.setAttribute('data-flip-v', '1');
                            updateImageTransform(img);
                            return;
                        }
                        // 원본 유지 조건: 사용자가 '원본 유지' 옵션을 켰고, '상'이 선택된 경우만 허용
                        if (preserveOriginalWhenHigh && selectedCompressionQuality === 'high' && q_check >= 0.97 && finalWidth >= sourceImg.naturalWidth && finalHeight >= sourceImg.naturalHeight) {
                            img.src = originalSrc;
                            img.setAttribute('data-original-src', originalSrc);
                            img.setAttribute('data-rotation', '0');
                            img.setAttribute('data-flip-h', '1');
                            img.setAttribute('data-flip-v', '1');
                            updateImageTransform(img);
                            return;
                        }
                    } catch (preserveErr) {
                        console.warn('applyCompressionToWrapper: 원본 보존 검사 실패', preserveErr);
                    }

                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';

                    // draw visible portion of source into canvas preserving visible composition
                    ctx.drawImage(sourceImg, rect.sx, rect.sy, rect.sw, rect.sh, 0, 0, canvas.width, canvas.height);

                    const q = getCompressionQualityForWrapper(id);
                    let dataUrl;
                    try {
                        dataUrl = canvas.toDataURL('image/jpeg', q);
                    } catch (e) {
                        dataUrl = canvas.toDataURL('image/png');
                    }

                    img.src = dataUrl;
                    img.setAttribute('data-original-src', dataUrl);
                    img.setAttribute('data-rotation', '0');
                    img.setAttribute('data-flip-h', '1');
                    img.setAttribute('data-flip-v', '1');
                    updateImageTransform(img);
                } catch (err) {
                    console.warn('applyCompressionToWrapper failed', err);
                }
            };
            sourceImg.onerror = function () {
                console.warn('applyCompressionToWrapper: source image load failed');
            };
            sourceImg.src = originalSrc;
        }

        // 선택된 요소 타입 이름 가져오기
        function getElementTypeName(element) {
            if (!element) return '';

            if (element.tagName) {
                // SVG 요소
                const tagMap = {
                    'path': '펜 그림',
                    'line': '직선',
                    'circle': '원',
                    'ellipse': '타원',
                    'polyline': '폴리선',
                    'rect': '사각형'
                };
                return tagMap[element.tagName.toLowerCase()] || element.tagName;
            } else if (element.classList && element.classList.contains('annotation')) {
                return '텍스트';
            }
            return '';
        }

        // 선택된 요소 정보 업데이트 함수
        function updateSelectedElementInfo(element) {
            const infoSpan = document.getElementById('selected-element-info');
            if (!infoSpan) return;

            const typeName = getElementTypeName(element);

            if (typeName) {
                let text = `선택됨: [${typeName}]`;
                try {
                    if (element && element.getAttribute && element.getAttribute('data-href')) {
                        const href = element.getAttribute('data-href');
                        if (href) text += ` - 링크: ${href}`;
                    }
                } catch (err) { /* ignore */ }
                infoSpan.innerText = text;
            } else {
                infoSpan.innerText = '';
            }
        }

        // 툴팁 표시 함수
        function showElementTooltip(e, element) {
            const tooltip = document.getElementById('element-tooltip');
            if (!tooltip || !element) return;

            const typeName = getElementTypeName(element);
            if (!typeName) {
                tooltip.style.display = 'none';
                return;
            }

            tooltip.innerText = `선택됨: [${typeName}]`;
            tooltip.style.display = 'block';
            // event 좌표가 없는 경우(또는 0)를 대비해 element의 bounding rect를 사용한 폴백 위치 계산
            try {
                let x = (e && typeof e.clientX === 'number') ? e.clientX : null;
                let y = (e && typeof e.clientY === 'number') ? e.clientY : null;
                if (x === null || y === null) {
                    const r = element.getBoundingClientRect();
                    x = Math.round(r.left + r.width / 2);
                    // tooltip을 요소 위에 표시하려면 r.top을 사용
                    y = Math.round(r.top - 8);
                }
                // 화면 바깥으로 나가지 않도록 클램프
                const padding = 8;
                const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
                const ttRect = tooltip.getBoundingClientRect();
                let left = x + 10;
                let top = y + 10;
                if (left + ttRect.width + padding > vw) left = vw - ttRect.width - padding;
                if (left < padding) left = padding;
                if (top + ttRect.height + padding > vh) top = vh - ttRect.height - padding;
                if (top < padding) top = padding;
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
            } catch (errPos) {
                // 최후의 수단: 중앙 상단으로 고정
                tooltip.style.left = '50%';
                tooltip.style.top = '8px';
                tooltip.style.transform = 'translateX(-50%)';
            }
        }

        // 툴팁 숨기기 함수
        function hideElementTooltip() {
            const tooltip = document.getElementById('element-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        // 포맷 툴 버튼을 위한 도움말 툴팁 표시 함수
        function showHelpTooltip(e, text) {
            const tooltip = document.getElementById('element-tooltip');
            if (!tooltip) return;
            tooltip.innerText = text || '';
            tooltip.style.display = 'block';
            try {
                let x = (e && typeof e.clientX === 'number') ? e.clientX : null;
                let y = (e && typeof e.clientY === 'number') ? e.clientY : null;
                if (x === null || y === null) {
                    const r = e.target.getBoundingClientRect();
                    x = Math.round(r.left + r.width / 2);
                    y = Math.round(r.top - 8);
                }
                const padding = 8;
                const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
                const ttRect = tooltip.getBoundingClientRect();
                let left = x + 10;
                let top = y + 10;
                if (left + ttRect.width + padding > vw) left = vw - ttRect.width - padding;
                if (left < padding) left = padding;
                if (top + ttRect.height + padding > vh) top = vh - ttRect.height - padding;
                if (top < padding) top = padding;
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
            } catch (err) {
                tooltip.style.left = '50%';
                tooltip.style.top = '8px';
                tooltip.style.transform = 'translateX(-50%)';
            }
        }

        // 서식 툴바 버튼에 도움말 툴팁을 연결
        function initFormatTooltips() {
            const helpMap = {
                '굵게': '선택한 텍스트를 굵게(Bold)로 만듭니다. 단축키: Ctrl/Cmd+B',
                '기울임': '선택한 텍스트를 기울임(Italic)으로 만듭니다. 단축키: Ctrl/Cmd+I',
                '밑줄': '선택한 텍스트에 밑줄을 추가합니다. 단축키: Ctrl/Cmd+U',
                '취소선': '선택한 텍스트에 취소선을 추가합니다.',
                '위첨자': '선택한 텍스트를 위첨자로 변경합니다.',
                '아래첨자': '선택한 텍스트를 아래첨자로 변경합니다.',
                '실행 취소': '마지막 작업을 실행 취소합니다. 단축키: Ctrl/Cmd+Z',
                '다시 실행': '마지막 실행 취소를 다시 실행합니다. 단축키: Ctrl/Cmd+Y',
                '서식 제거': '선택한 텍스트의 모든 서식을 제거합니다.',
                '링크 삽입': '선택한 텍스트에 링크(URL)를 삽입합니다.',
                '링크 제거': '선택 영역의 링크를 제거합니다.',
                '왼쪽 정렬': '텍스트를 왼쪽 정렬합니다.',
                '가운데 정렬': '텍스트를 가운데 정렬합니다.',
                '오른쪽 정렬': '텍스트를 오른쪽 정렬합니다.',
                '양쪽 정렬': '텍스트를 양쪽 정렬합니다.',
                '글머리 기호': '선택 영역에 글머리 기호 목록을 만듭니다.',
                '번호 매기기': '선택 영역에 번호 매기기 목록을 만듭니다.',
                '내어쓰기': '들여쓰기 수준을 줄입니다.',
                '들여쓰기': '들여쓰기 수준을 늘립니다.'
            };

            document.querySelectorAll('.fmt-btn').forEach(el => {
                const title = el.getAttribute('title') || el.title || '';
                const help = helpMap[title] || title;
                el.addEventListener('mouseenter', (e) => showHelpTooltip(e, help));
                el.addEventListener('focus', (e) => showHelpTooltip(e, help));
                el.addEventListener('mouseleave', hideElementTooltip);
                el.addEventListener('blur', hideElementTooltip);
            });
            // selects with fmt-btn class
            document.querySelectorAll('select.fmt-btn').forEach(sel => {
                const title = sel.getAttribute('title') || sel.title || '옵션 선택';
                sel.addEventListener('mouseenter', (e) => showHelpTooltip(e, title));
                sel.addEventListener('mouseleave', hideElementTooltip);
                sel.addEventListener('focus', (e) => showHelpTooltip(e, title));
                sel.addEventListener('blur', hideElementTooltip);
            });
        }

        // DOM 준비되면 포맷 툴팁 초기화
        document.addEventListener('DOMContentLoaded', () => {
            initFormatTooltips();
        });

        function setGlobalStrokeWidth(val) {
            const width = parseInt(val);
            if (toolSettings[globalTool]) toolSettings[globalTool].width = width;

            if (selectedElement) {
                if (selectedElement.tagName) {
                    selectedElement.setAttribute('stroke-width', width);
                } else if (selectedElement.classList.contains('annotation')) {
                    selectedElement.style.borderWidth = width + 'px';
                }
            }
        }

        function setGlobalOpacity(val) {
            const opacity = parseInt(val);
            if (toolSettings[globalTool]) toolSettings[globalTool].opacity = opacity;

            if (selectedElement) {
                const opVal = opacity / 100;
                if (selectedElement.tagName) {
                    selectedElement.setAttribute('opacity', opVal);
                } else if (selectedElement.classList.contains('annotation')) {
                    selectedElement.style.opacity = opVal;
                }
            }
        }

        function setGlobalLineStyle(val) {
            if (toolSettings[globalTool]) {
                toolSettings[globalTool].style = val;
            }

            if (selectedElement) {
                const dashArray = val === 'dashed' ? "10,5" : "none";
                if (selectedElement.tagName) {
                    // SVG 요소
                    selectedElement.setAttribute('stroke-dasharray', dashArray);
                    // 선택된 요소의 스타일이 변경되었으므로 툴팁의 라디오 버튼도 업데이트
                    const radios = document.getElementsByName('lineStyle');
                    radios.forEach(r => {
                        if (r.value === val) r.checked = true;
                        else r.checked = false;
                    });
                } else if (selectedElement.classList.contains('annotation')) {
                    // 텍스트 박스 - borderStyle 즉시 적용
                    selectedElement.style.borderStyle = val;
                    selectedElement.style.setProperty('border-style', val, 'important');
                    // 선택된 요소의 스타일이 변경되었으므로 툴팁의 라디오 버튼도 업데이트
                    const radios = document.getElementsByName('lineStyle');
                    radios.forEach(r => {
                        if (r.value === val) r.checked = true;
                        else r.checked = false;
                    });
                }
            }
        }

        function setGlobalFontSize(val) {
            const size = parseInt(val);
            if (toolSettings[globalTool]) toolSettings[globalTool].fontSize = size;

            if (selectedElement && selectedElement.classList.contains('annotation')) {
                const textEl = selectedElement.querySelector('.annotation-text');
                if (textEl) textEl.style.fontSize = size + 'px';
            }
        }

        // 도구 아이콘 위치를 기준으로 카드 섹션 내부에 팝오버 위치 계산
        function calculatePopoverPositionInCard(buttonRect, cardSection) {
            let left = buttonRect.left;
            let top = buttonRect.bottom + 8;

            // 카드 섹션이 있으면 그 경계 내로 클램프
            if (cardSection) {
                const cardRect = cardSection.getBoundingClientRect();
                const popover = document.getElementById('drawing-settings-popover');
                const popoverWidth = popover ? popover.offsetWidth || 300 : 300;
                const popoverHeight = popover ? popover.offsetHeight || 400 : 400;

                // 카드 섹션 내에서 팝오버를 배치
                // left: 카드 내 좌측 여유 8px 유지, 팝오버가 카드를 벗어나지 않도록
                left = Math.max(cardRect.left + 8, Math.min(cardRect.right - popoverWidth - 8, buttonRect.left));

                // top: 버튼 아래 배치, 카드 하단을 넘지 않도록
                top = Math.min(buttonRect.bottom + 8, cardRect.bottom - popoverHeight - 8);

                // 최소값 확보 (뷰포트 상단 너무 가까우면 아래로 조정)
                if (top < cardRect.top + 8) {
                    top = Math.max(cardRect.top + 8, buttonRect.bottom + 8);
                }
            } else {
                // 카드 섹션이 없으면 뷰포트 기준으로 클램프 (기존 로직)
                left = Math.max(8, Math.min(window.innerWidth - 8, left));
                top = Math.max(8, Math.min(window.innerHeight - 8, top));
            }

            return { left, top };
        }

        function setGlobalFontSize(val) {
            const size = parseInt(val);
            if (toolSettings[globalTool]) toolSettings[globalTool].fontSize = size;

            if (selectedElement && selectedElement.classList.contains('annotation')) {
                const textEl = selectedElement.querySelector('.annotation-text');
                if (textEl) textEl.style.fontSize = size + 'px';
            }
        }

        function setGlobalFontWeight(val) {
            const weight = parseInt(val);
            if (toolSettings[globalTool]) toolSettings[globalTool].fontWeight = weight;

            if (selectedElement && selectedElement.classList.contains('annotation')) {
                const textEl = selectedElement.querySelector('.annotation-text');
                if (textEl) textEl.style.fontWeight = weight;
            }
        }

        function closeSettingsPopover() {
            document.getElementById('drawing-settings-popover').style.display = 'none';
        }

        // 팝업 드래그 기능
        let isDraggingPopover = false;
        let popoverDragStart = { x: 0, y: 0 };
        let popoverInitialPos = { left: 0, top: 0 };

        function initPopoverDrag() {
            const popover = document.getElementById('drawing-settings-popover');
            if (!popover) return;

            const header = popover.querySelector('.popover-header');
            if (!header) return;

            // 기존 이벤트 리스너 제거 후 새로 추가 (중복 방지)
            const newHeader = header.cloneNode(true);
            header.parentNode.replaceChild(newHeader, header);

            newHeader.addEventListener('mousedown', function (e) {
                // 닫기 버튼 클릭 시 드래그 방지
                if (e.target.classList.contains('popover-close') || e.target.closest('.popover-close')) {
                    return;
                }

                isDraggingPopover = true;
                popoverDragStart.x = e.clientX;
                popoverDragStart.y = e.clientY;

                const rect = popover.getBoundingClientRect();
                // 현재 position이 fixed인지 absolute인지 확인
                const currentPosition = window.getComputedStyle(popover).position;
                if (currentPosition === 'fixed') {
                    popoverInitialPos.left = parseFloat(popover.style.left) || rect.left;
                    popoverInitialPos.top = parseFloat(popover.style.top) || rect.top;
                } else {
                    popoverInitialPos.left = rect.left;
                    popoverInitialPos.top = rect.top;
                }

                // position을 fixed로 변경하여 드래그 가능하게
                popover.style.position = 'fixed';
                popover.style.left = popoverInitialPos.left + 'px';
                popover.style.top = popoverInitialPos.top + 'px';

                // 드래그 중 표시
                popover.classList.add('dragging');

                document.addEventListener('mousemove', onPopoverDrag);
                document.addEventListener('mouseup', stopPopoverDrag);
                e.preventDefault();
                e.stopPropagation();
            });
        }

        function onPopoverDrag(e) {
            if (!isDraggingPopover) return;

            const popover = document.getElementById('drawing-settings-popover');
            if (!popover) {
                stopPopoverDrag();
                return;
            }

            const deltaX = e.clientX - popoverDragStart.x;
            const deltaY = e.clientY - popoverDragStart.y;

            popover.style.left = (popoverInitialPos.left + deltaX) + 'px';
            popover.style.top = (popoverInitialPos.top + deltaY) + 'px';
            e.preventDefault();
        }

        function stopPopoverDrag() {
            if (!isDraggingPopover) return;

            isDraggingPopover = false;
            const popover = document.getElementById('drawing-settings-popover');
            if (popover) {
                popover.classList.remove('dragging');
            }
            document.removeEventListener('mousemove', onPopoverDrag);
            document.removeEventListener('mouseup', stopPopoverDrag);
        }

        // 텍스트 색상 변경 함수
        function setTextColor(color) {
            // toolSettings에 색상 저장
            if (toolSettings['box']) {
                toolSettings['box'].textColor = color;
            }

            if (!selectedElement || !selectedElement.classList.contains('annotation')) {
                return;
            }

            const textEl = selectedElement.querySelector('.annotation-text');
            if (textEl) {
                // 색상 적용 (중요도 높게)
                textEl.style.setProperty('color', color, 'important');
                textEl.style.setProperty('-webkit-text-fill-color', color, 'important');

                // 선택된 색상 표시 업데이트 (텍스트 색상 옵션만)
                document.querySelectorAll('.text-color-option:not(.border-color-option)').forEach(opt => {
                    opt.classList.remove('active');
                    const optBgColor = opt.style.backgroundColor || window.getComputedStyle(opt).backgroundColor;
                    // RGB를 HEX로 변환하여 비교
                    const rgbToHex = (rgb) => {
                        if (rgb.startsWith('#')) return rgb.toLowerCase();
                        const match = rgb.match(/\d+/g);
                        if (!match || match.length < 3) return '';
                        return '#' + match.map(x => {
                            const hex = parseInt(x).toString(16);
                            return hex.length === 1 ? '0' + hex : hex;
                        }).join('');
                    };
                    const optHex = rgbToHex(optBgColor);
                    const targetHex = color.toLowerCase();
                    if (optHex === targetHex || opt.style.backgroundColor === color) {
                        opt.classList.add('active');
                    }
                });
            }
        }

        // 외곽선 색상 변경 함수
        function setBorderColor(color) {
            // toolSettings에 색상 저장
            if (toolSettings['box']) {
                toolSettings['box'].borderColor = color;
            }

            if (!selectedElement || !selectedElement.classList.contains('annotation')) {
                return;
            }

            // 기존 색상 클래스 제거
            const colorClasses = ['style-red', 'style-yellow', 'style-green', 'style-blue', 'style-purple', 'style-white'];
            colorClasses.forEach(cls => selectedElement.classList.remove(cls));

            // 새 색상 클래스 추가
            selectedElement.classList.add(`style-${color}`);

            // 선택된 색상 표시 업데이트 (외곽선 색상 옵션만)
            document.querySelectorAll('.border-color-option').forEach(opt => {
                opt.classList.remove('active');
                const optColor = opt.getAttribute('onclick').match(/'(\w+)'/);
                if (optColor && optColor[1] === color) {
                    opt.classList.add('active');
                }
            });
        }

        const initialSteps = [
            { id: 1, title: "작업 전 (Before)", subTitle: "위험 요소 진단", desc: ["- 구형 차단기 노후화로 인한 차단 성능 저하", "- 난잡한 배선으로 인한 합선 위험"], badgeColor: "bg-red-600", img: "20251111_132849.jpg" },
            { id: 2, title: "철거 및 준비", subTitle: "철거 및 안전 조치", desc: ["- 노후 부품 전면 철거", "- 활선 구역 절연 및 안전 확보"], badgeColor: "bg-yellow-600", img: "20251112_134153.jpg" },
            { id: 3, title: "신규 설치", subTitle: "전원 간선 작업", desc: ["- 난연성 케이블 시공", "- 상(Phase) 구분 및 밸런싱"], badgeColor: "bg-blue-600", img: "20251111_153803.jpg" },
            { id: 4, title: "작업 완료", subTitle: "최종 마감 및 라벨링", desc: ["- 라벨 부착으로 식별성 확보", "- 케이블 정리(Dressing) 완료"], badgeColor: "bg-green-600", img: "1762992975743-9.jpg" },
            { id: 5, title: "개선 사항", subTitle: "지속적인 안전 관리 제안", desc: ["- 정기적인 열화상 카메라 측정으로 발열 체크", "- 부하 불평형율 주기적 점검 및 관리"], badgeColor: "bg-purple-600", img: "1762992975743-9.jpg" }
        ];

        const colorMap = { 'red': '#ef4444', 'yellow': '#eab308', 'green': '#22c55e', 'blue': '#3b82f6', 'purple': '#a855f7', 'white': '#ffffff' };
        const badgePalette = ['bg-red-600', 'bg-yellow-600', 'bg-green-600', 'bg-blue-600', 'bg-purple-600', 'bg-pink-600', 'bg-indigo-600', 'bg-teal-600', 'bg-orange-600'];

        let currentMode = 'vertical';
        let verticalCols = 1;
        let horizontalRows = 1;

        window.onload = function () {
            // [개선 1] 브라우저 화면 비율을 100%로 강제 설정
            if (document.documentElement.style.zoom === '' || document.documentElement.style.zoom === '100%') {
                document.documentElement.style.zoom = '100%';
                document.body.style.zoom = '100%';
            }

            const container = document.getElementById('report-container');
            if (container.dataset.savedMode) {
                currentMode = container.dataset.savedMode;
                verticalCols = parseInt(container.dataset.savedCols || 1);
                horizontalRows = parseInt(container.dataset.savedRows || 1);
            }
            const isSavedFile = container.children.length > 0;
            if (!isSavedFile) { initialSteps.forEach(data => appendStepToDom(data)); }
            else {
                document.querySelectorAll('.image-wrapper').forEach(wrapper => {
                    const id = wrapper.id.split('-')[1];
                    initDrawingEvents(id);
                    // 이미지 원본 소스 저장
                    const img = wrapper.querySelector('img');
                    if (img && !img.getAttribute('data-original-src')) {
                        img.setAttribute('data-original-src', img.src);
                        img.setAttribute('data-rotation', '0');
                        img.setAttribute('data-flip-h', '1');
                        img.setAttribute('data-flip-v', '1');
                        // 이미지 방향 확인
                        checkImageOrientation(img);
                        // 이미지 선택 및 드래그 기능 초기화
                        const wrapperId = wrapper.id.split('-')[1];
                        if (wrapperId) {
                            const stepId = parseInt(wrapperId);
                            selectImage(stepId, { target: { closest: () => null } });
                            initImageDrag(stepId);
                        }
                    }
                });
            }
            setLayout(currentMode);
            document.body.style.paddingTop = '0px';

            // [개선 2] 상단 툴바를 접힌 상태로 초기화
            const header = document.getElementById('main-header');
            if (header) {
                header.classList.add('collapsed');
                const toggleIcon = document.getElementById('toggle-icon');
                if (toggleIcon) {
                    toggleIcon.className = 'fas fa-chevron-down';
                }
                document.body.style.paddingTop = '0px';
            }

            // 팝업 드래그 기능 초기화
            initPopoverDrag();

            // 파노라마 모드 스크롤 초기화
            initPanoramaScroll();

            // 전역 ESC 키 핸들러 등록 (레이어 선택 해제용)
            document.addEventListener('keydown', handleEsc);

            // [개선 3] 첫 번째 카드와 다음 기호가 화면에 보이도록 초기 위치 조정
            setTimeout(() => {
                const firstSection = document.querySelector('.step-section');
                if (firstSection) {
                    if (currentMode === 'horizontal') {
                        // 파노라마 모드: 첫 번째 섹션을 왼쪽에 정렬
                        container.scrollLeft = 0;
                        firstSection.classList.add('is-visible');
                    } else {
                        // 리포트 모드: 제목부터 첫 번째 카드까지 보이도록 스크롤
                        const title = document.querySelector('.max-w-6xl.text-center');
                        if (title) {
                            title.scrollIntoView({ behavior: 'auto', block: 'start' });
                        }
                    }
                }
            }, 100);
        };

        function toggleStepFullscreen(btn, stepId) {
            const section = document.getElementById(`step-section-${stepId}`);
            const icon = btn.querySelector('i');
            if (section.classList.contains('step-fullscreen')) {
                section.classList.remove('step-fullscreen');
                icon.className = 'fas fa-search-plus';
                document.body.style.overflow = '';
                btn.innerHTML = '<i class="fas fa-search-plus"></i> 집중 모드';
            } else {
                section.classList.add('step-fullscreen');
                icon.className = 'fas fa-search-minus';
                document.body.style.overflow = 'hidden';
                btn.innerHTML = '<i class="fas fa-search-minus"></i> 복원';
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        toggleStepFullscreen(btn, stepId);
                        document.removeEventListener('keydown', escHandler);
                    }
                };
                document.addEventListener('keydown', escHandler);
            }
        }

        function changeGridCount(delta) {
            if (currentMode === 'vertical') { verticalCols = Math.max(1, verticalCols + delta); }
            else { horizontalRows = Math.max(1, horizontalRows + delta); }
            renderLayout(); updateGridDisplay();
        }

        function updateGridDisplay() {
            const display = document.getElementById('grid-count-display');
            if (currentMode === 'vertical') { display.innerText = `${verticalCols}열`; }
            else { display.innerText = `${horizontalRows}행`; }
        }

        function setLayout(mode) {
            currentMode = mode;
            const btnV = document.getElementById('btn-layout-v');
            const btnH = document.getElementById('btn-layout-h');
            if (mode === 'horizontal') {
                btnH.classList.remove('text-gray-400'); btnH.classList.add('bg-blue-600', 'text-white');
                btnV.classList.remove('bg-blue-600', 'text-white'); btnV.classList.add('text-gray-400');
            } else {
                btnV.classList.remove('text-gray-400'); btnV.classList.add('bg-blue-600', 'text-white');
                btnH.classList.remove('bg-blue-600', 'text-white'); btnH.classList.add('text-gray-400');
            }
            renderLayout(); updateGridDisplay();
        }

        function renderLayout() {
            const container = document.getElementById('report-container');
            container.style.display = 'grid'; container.style.gap = '6rem'; container.style.overflowX = 'visible';
            if (currentMode === 'vertical') {
                container.style.gridTemplateColumns = `repeat(${verticalCols}, 1fr)`;
                container.style.gridTemplateRows = 'none'; container.style.gridAutoFlow = 'row';
                container.classList.remove('layout-horizontal');
                if (verticalCols > 1) container.classList.add('layout-grid-custom');
                else container.classList.remove('layout-grid-custom');
            } else {
                container.classList.add('layout-horizontal');
                container.style.gridTemplateColumns = 'none';
                container.style.gridTemplateRows = `repeat(${horizontalRows}, auto)`;
                container.style.gridAutoFlow = 'column'; container.style.overflowX = 'auto';
                container.style.alignItems = 'start'; container.style.padding = '0 0 40px 0'; container.style.gap = '8rem';
                container.style.maxWidth = '100%'; /* 파노라마 모드에서 최대 너비 제한 제거 */
                container.style.margin = '0'; /* 좌우 마진 제거 */
                container.style.width = '100vw'; /* 화면 전체 너비 사용 */
                container.classList.remove('layout-grid-custom');

                // 파노라마 모드 전환 시 첫 번째 섹션의 우측 외곽과 흐름 방향 표시가 보이도록 스크롤 위치 조정
                setTimeout(() => {
                    // 컨테이너의 스크롤 위치를 0으로 설정하여 첫 번째 섹션이 완전히 보이도록
                    container.scrollLeft = 0;

                    const firstSection = container.querySelector('.step-section');
                    if (firstSection) {
                        // 첫 번째 섹션에 is-visible 클래스 추가
                        firstSection.classList.add('is-visible');

                        // 첫 번째 섹션의 우측 외곽과 흐름 방향 표시가 보이도록 스크롤 위치 조정
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                // 스크롤 위치를 0으로 확실히 설정하여 첫 번째 섹션이 왼쪽에서 시작하도록
                                container.scrollLeft = 0;

                                // 추가 확인: 첫 번째 섹션의 우측과 흐름 방향 표시가 보이는지 확인
                                const containerRect = container.getBoundingClientRect();
                                const sectionRect = firstSection.getBoundingClientRect();

                                // 첫 번째 섹션이 컨테이너 왼쪽 경계와 정렬되도록 보장
                                if (sectionRect.left > containerRect.left) {
                                    container.scrollLeft = 0;
                                }

                                // 흐름 방향 표시 너비(8rem ≈ 128px)를 고려하여 우측이 보이도록 확인
                                const flowConnectorWidth = 128; // 8rem
                                const sectionRightWithFlow = sectionRect.right + flowConnectorWidth;

                                // 우측이 잘리지 않도록 확인 (카드 섹션 너비가 calc(100vw - 8rem)으로 자동 조정되어 흐름 방향 표시까지 포함하여 보일 수 있음)
                                if (sectionRightWithFlow > containerRect.right) {
                                    // 우측이 잘리면 스크롤을 약간 조정하지 않고, 카드 섹션 너비가 이미 자동 조정되어 있으므로 그대로 유지
                                    // 스크롤 위치는 0으로 유지하여 첫 번째 섹션이 완전히 보이도록
                                }
                            });
                        });
                    }
                }, 150);
            }
        }

        function showConfirm(message, yesCallback) {
            const modal = document.getElementById('confirm-modal');
            const msgDiv = document.getElementById('confirm-msg');
            const yesBtn = document.getElementById('btn-confirm-yes');
            msgDiv.innerText = message; modal.style.display = 'flex';
            const newYesBtn = yesBtn.cloneNode(true); yesBtn.parentNode.replaceChild(newYesBtn, yesBtn);
            newYesBtn.onclick = function () { modal.style.display = 'none'; if (yesCallback) yesCallback(); };
        }
        function closeConfirm() { document.getElementById('confirm-modal').style.display = 'none'; }
        function scrollToNextStep(node) {
            const currentSection = node.closest('.step-section');
            const nextSection = currentSection.nextElementSibling;
            if (nextSection && nextSection.classList.contains('step-section')) {
                const reportContainer = document.getElementById('report-container');
                const nextNextSection = nextSection.nextElementSibling;

                if (reportContainer.classList.contains('layout-horizontal')) {
                    // 파노라마 모드: 다음 섹션을 화면 왼쪽 끝에 정렬 (scrollIntoView만 사용)
                    nextSection.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });

                    // [개선 2] 스크롤 완료 후 화면 확대 계산 및 적용
                    setTimeout(() => {
                        const containerRect = reportContainer.getBoundingClientRect();
                        const nextSectionWidth = nextSection.offsetWidth;
                        const containerWidth = containerRect.width;

                        // 다음 섹션 + 다음 다음 섹션의 기호까지만 보이도록 필요한 너비 계산
                        let requiredWidth = nextSectionWidth;

                        if (nextNextSection && nextNextSection.classList.contains('step-section')) {
                            // 다음 다음 섹션의 기호 너비 추가
                            requiredWidth += 120; // 흐름 기호 너비 (8rem ≈ 128px 정도)
                        }

                        // 필요한 너비를 정확히 계산하여 다음 섹션은 완전 표시, 다음 다음 기호만 표시
                        let zoomRatio = 1;
                        if (requiredWidth > containerWidth * 0.95) {
                            // 필요한 너비에 맞춰 정확히 축소
                            zoomRatio = Math.max(0.5, (containerWidth * 0.9) / requiredWidth);
                        }

                        // 확대/축소 적용 (부드러운 애니메이션)
                        if (Math.abs(zoomRatio - 1) > 0.05) {
                            document.documentElement.style.transition = 'zoom 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                            document.documentElement.style.zoom = (zoomRatio * 100) + '%';

                            // 일정 시간 후 원래 크기로 복원
                            setTimeout(() => {
                                document.documentElement.style.transition = 'zoom 0.4s ease-out';
                                document.documentElement.style.zoom = '100%';
                            }, 3500);
                        }
                    }, 500);
                } else {
                    // 리포트 모드: 다음 카드를 화면 상단에 정확히 배치 (scrollIntoView만 사용)
                    nextSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

                    // [개선 2] 화면 확대 계산 및 적용
                    setTimeout(() => {
                        const nextSectionHeight = nextSection.offsetHeight;
                        const windowHeight = window.innerHeight;

                        // 다음 섹션과 다음 다음 섹션의 기호까지 보이도록 필요한 높이 계산
                        let requiredHeight = nextSectionHeight;

                        if (nextNextSection && nextNextSection.classList.contains('step-section')) {
                            const nextNextFlowConnector = nextNextSection.querySelector('.flow-connector');
                            if (nextNextFlowConnector) {
                                requiredHeight += 50; // 흐름 기호 높이 (최소)
                            }
                        }

                        // 필요한 높이에 맞춰 정확히 축소
                        let zoomRatio = 1;
                        if (requiredHeight > windowHeight * 0.95) {
                            zoomRatio = Math.max(0.5, (windowHeight * 0.9) / requiredHeight);
                        }

                        // 확대/축소 적용
                        if (Math.abs(zoomRatio - 1) > 0.05) {
                            document.documentElement.style.transition = 'zoom 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                            document.documentElement.style.zoom = (zoomRatio * 100) + '%';

                            // 일정 시간 후 원래 크기로 복원
                            setTimeout(() => {
                                document.documentElement.style.transition = 'zoom 0.4s ease-out';
                                document.documentElement.style.zoom = '100%';
                            }, 3500);
                        }
                    }, 500);
                }

                // 스크롤 완료 후 기호 강조
                setTimeout(() => {
                    const targetFlowNode = nextNextSection?.querySelector('.flow-node') || nextSection.querySelector('.flow-node');
                    if (targetFlowNode) {
                        targetFlowNode.style.animation = 'none';
                        void targetFlowNode.offsetWidth;
                        targetFlowNode.style.animation = '';
                    }
                }, 900);
            }
        }

        // 마지막 카드의 완료(체크) 버튼을 클릭하면 첫 번째 카드로 이동
        function scrollToFirstStep(node) {
            try {
                const container = document.getElementById('report-container');
                if (!container) return;
                const firstSection = container.querySelector('.step-section');
                if (!firstSection) return;

                if (container.classList.contains('layout-horizontal')) {
                    // 파노라마 모드: 첫 섹션을 왼쪽 끝으로 정렬
                    firstSection.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                } else {
                    // 리포트 모드: 첫 섹션을 상단으로 정렬
                    firstSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }

                // 강조를 위해 잠깐 is-visible 추가
                setTimeout(() => {
                    document.querySelectorAll('.step-section').forEach(s => s.classList.remove('is-visible'));
                    firstSection.classList.add('is-visible');
                }, 300);
            } catch (e) {
                console.warn('scrollToFirstStep error', e);
            }
        }

        // 파노라마 모드 스크롤 이벤트 핸들러
        function initPanoramaScroll() {
            const container = document.getElementById('report-container');
            if (!container) return;

            let scrollTimeout;
            let isScrolling = false;
            let lastScrollLeft = container.scrollLeft;
            let scrollVelocity = 0;

            // 스크롤 이벤트
            container.addEventListener('scroll', function () {
                if (!container.classList.contains('layout-horizontal')) return;

                const currentScrollLeft = container.scrollLeft;
                scrollVelocity = currentScrollLeft - lastScrollLeft;
                lastScrollLeft = currentScrollLeft;

                // 스크롤 중 표시
                if (!isScrolling) {
                    isScrolling = true;
                    container.style.scrollBehavior = 'smooth';
                }

                // 현재 보이는 섹션 찾기 (영화 필름처럼 자연스럽게)
                const sections = container.querySelectorAll('.step-section');
                const containerRect = container.getBoundingClientRect();
                const containerCenter = containerRect.left + (containerRect.width / 2);

                sections.forEach(section => {
                    section.classList.remove('is-visible', 'is-entering', 'is-leaving');
                    const sectionRect = section.getBoundingClientRect();
                    const sectionCenter = sectionRect.left + (sectionRect.width / 2);
                    const distanceFromCenter = Math.abs(sectionCenter - containerCenter);

                    // 섹션이 화면에 보이는지 확인
                    if (sectionRect.left < containerRect.right && sectionRect.right > containerRect.left) {
                        const visibleWidth = Math.min(sectionRect.right, containerRect.right) - Math.max(sectionRect.left, containerRect.left);
                        const sectionWidth = sectionRect.width;
                        const visibilityRatio = visibleWidth / sectionWidth;

                        // 섹션이 화면 중앙에 가까울수록 더 강조
                        if (visibilityRatio > 0.3) {
                            section.classList.add('is-visible');
                            // 중앙에 가까운 섹션은 더 강조
                            if (distanceFromCenter < containerRect.width * 0.3) {
                                section.style.transform = 'scale(1.02)';
                                section.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                            } else {
                                section.style.transform = 'scale(1)';
                            }
                        }
                    } else {
                        section.style.transform = 'scale(1)';
                    }
                });

                // 스크롤이 끝났을 때
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    isScrolling = false;
                    scrollVelocity = 0;
                }, 150);
            }, { passive: true });

            // 스크롤바 드래그 시 부드러운 스크롤 (개선)
            let isDraggingScrollbar = false;
            let scrollbarDragStart = 0;
            let scrollbarScrollStart = 0;
            let scrollbarAnimationFrame = null;

            container.addEventListener('mousedown', function (e) {
                if (!container.classList.contains('layout-horizontal')) return;
                // 스크롤바 영역 클릭 감지
                const scrollbarHeight = 12;
                const containerRect = container.getBoundingClientRect();
                const scrollbarY = containerRect.bottom - scrollbarHeight;

                if (e.clientY >= scrollbarY && e.clientY <= containerRect.bottom) {
                    isDraggingScrollbar = true;
                    scrollbarDragStart = e.clientX;
                    scrollbarScrollStart = container.scrollLeft;
                    container.style.scrollBehavior = 'auto'; // 드래그 중에는 자동 스크롤
                    e.preventDefault();
                }
            });

            function smoothScrollTo(targetScrollLeft) {
                if (scrollbarAnimationFrame) {
                    cancelAnimationFrame(scrollbarAnimationFrame);
                }

                const startScrollLeft = container.scrollLeft;
                const distance = targetScrollLeft - startScrollLeft;
                const duration = 300; // 300ms 동안 부드럽게 이동
                const startTime = performance.now();

                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // easing 함수 (ease-out)
                    const easeOut = 1 - Math.pow(1 - progress, 3);

                    container.scrollLeft = startScrollLeft + (distance * easeOut);

                    if (progress < 1) {
                        scrollbarAnimationFrame = requestAnimationFrame(animate);
                    } else {
                        scrollbarAnimationFrame = null;
                        container.style.scrollBehavior = 'smooth'; // 드래그 종료 후 smooth 복원
                    }
                }

                scrollbarAnimationFrame = requestAnimationFrame(animate);
            }

            document.addEventListener('mousemove', function (e) {
                if (isDraggingScrollbar && container.classList.contains('layout-horizontal')) {
                    const deltaX = e.clientX - scrollbarDragStart;
                    const scrollRatio = container.scrollWidth / container.clientWidth;
                    const newScrollLeft = scrollbarScrollStart + (deltaX * scrollRatio);

                    // 즉시 스크롤 (드래그 중)
                    container.scrollLeft = newScrollLeft;
                }
            });

            document.addEventListener('mouseup', function () {
                if (isDraggingScrollbar) {
                    isDraggingScrollbar = false;
                    // 드래그 종료 시 현재 위치에서 가장 가까운 섹션으로 부드럽게 이동
                    const sections = container.querySelectorAll('.step-section');
                    let closestSection = null;
                    let closestDistance = Infinity;
                    const containerRect = container.getBoundingClientRect();

                    sections.forEach(section => {
                        const sectionRect = section.getBoundingClientRect();
                        const sectionCenter = sectionRect.left + (sectionRect.width / 2);
                        const containerCenter = containerRect.left + (containerRect.width / 2);
                        const distance = Math.abs(sectionCenter - containerCenter);

                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestSection = section;
                        }
                    });

                    if (closestSection) {
                        closestSection.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    }
                }
            });
        }

        function appendStepToDom(data) {
            const container = document.getElementById('report-container');
            const section = document.createElement('div');
            section.className = `step-section step-grid-layout bg-gray-800 p-6 rounded-2xl border border-gray-700 shadow-xl ${data.id > 1 ? 'page-break' : ''}`;
            section.id = `step-section-${data.id}`;
            section.innerHTML = `
                <div class="flow-connector"><div class="flow-line"></div><div class="flow-node" onclick="scrollToNextStep(this)" title="다음 단계로 이동"><i class="fas fa-caret-down"></i></div></div>
                <div class="finish-marker" onclick="scrollToFirstStep(this)" title="처음으로 이동"><i class="fas fa-check"></i></div>
                <div class="flex flex-col h-full justify-between">
                    <div>
                        <div class="flex items-center justify-between mb-4">
                            <div class="flex items-center gap-3">
                                <input type="checkbox" class="step-checkbox step-select-wrapper w-5 h-5 accent-blue-500" data-step-id="${data.id}" title="콜라주에 포함하기">
                                <div class="step-badge inline-block ${data.badgeColor} text-white font-bold px-3 py-1 rounded-full text-sm shadow-lg" contenteditable="true">STEP 0${data.id}. ${data.title}</div>
                            </div>
                        </div>
                        <h2 class="text-3xl font-bold mb-4 outline-none border-b border-transparent hover:border-gray-500 focus:border-blue-500 transition-colors" contenteditable="true">${data.subTitle}</h2>
                        <div class="text-gray-300 space-y-3 text-lg" contenteditable="true">${data.desc.map(d => `<p>${d}</p>`).join('')}</div>
                    </div>
                    <!-- [수정됨] 3개의 버튼 배치: 삭제 | 추가 | 집중 -->
                    <div class="mt-4 pt-4 border-t border-gray-700 flex justify-between items-center">
                        <button class="text-gray-400 hover:text-red-500 transition-colors flex items-center gap-2 text-xs font-bold" title="이 단계 삭제" onclick="deleteStep(${data.id})"><i class="fas fa-trash-alt"></i> 삭제</button>
                        
                        <!-- [NEW] STEP 추가 버튼 -->
                        <button class="text-gray-400 hover:text-green-500 transition-colors flex items-center gap-2 text-xs font-bold" title="새 단계 추가" onclick="openAddStepModal(${data.id})"><i class="fas fa-plus-circle"></i> STEP 추가</button>
                        
                        <button class="section-expand-btn text-gray-400 hover:text-blue-500 transition-colors flex items-center gap-2 text-xs font-bold" title="이 단계만 크게 보기" onclick="toggleStepFullscreen(this, ${data.id})"><i class="fas fa-search-plus"></i> 집중</button>
                    </div>
                </div>
                <div class="perspective-container ml-auto w-full">
                    <div class="toolbar no-print" id="toolbar-${data.id}">
                        <div class="flex gap-2 items-center">
                             <div class="color-dot bg-red active" onclick="setColor('red')" title="Red"></div>
                             <div class="color-dot bg-yellow" onclick="setColor('yellow')" title="Yellow"></div>
                             <div class="color-dot bg-green" onclick="setColor('green')" title="Green"></div>
                             <div class="color-dot bg-blue" onclick="setColor('blue')" title="Blue"></div>
                             <div class="color-dot bg-purple" onclick="setColor('purple')" title="Purple"></div>
                             <div class="color-dot bg-white" onclick="setColor('white')" title="White"></div>
                        </div>
                        <div class="toolbar-divider"></div>
                        <div class="flex gap-1 items-center">
                            <button class="tool-btn active" onclick="setTool('select', this, ${data.id})" title="선택"><i class="fas fa-mouse-pointer"></i></button>
                            <button class="tool-btn" onclick="setTool('pen', this, ${data.id})" title="자유선"><i class="fas fa-signature"></i></button>
                            <button class="tool-btn" onclick="setTool('polyline', this, ${data.id})" title="폴리선"><i class="fas fa-project-diagram"></i></button>
                            <button class="tool-btn" onclick="setTool('circle', this, ${data.id})" title="원"><i class="far fa-circle"></i></button>
                            <button class="tool-btn" onclick="setTool('ellipse', this, ${data.id})" title="타원"><i class="fas fa-bullseye"></i></button>
                            <button class="tool-btn" onclick="setTool('arrow', this, ${data.id})" title="화살표"><i class="fas fa-long-arrow-alt-right"></i></button>
                            <button class="tool-btn" onclick="setTool('line', this, ${data.id})" title="직선"><i class="fas fa-minus"></i></button>
                            <button class="tool-btn" onclick="setTool('box', this, ${data.id})" title="텍스트"><i class="fas fa-font"></i></button>
                            <button class="tool-btn" onclick="setTool('rect', this, ${data.id})" title="박스"><i class="far fa-square"></i></button>
                        </div>
                        <div class="toolbar-divider"></div>
                        <div class="flex gap-1 items-center ml-auto">
                            <button class="tool-btn hover:bg-red-900 text-gray-400 hover:text-white" title="지우기" onclick="clearDrawings(${data.id})"><i class="fas fa-trash"></i></button>
                            <button class="tool-btn accent" title="크게보기" onclick="openFullscreen(${data.id}, '${data.subTitle}')"><i class="fas fa-search-plus"></i></button>
                            <label class="tool-btn bg-gray-600 text-gray-300 hover:bg-gray-500 cursor-pointer" title="사진변경"><i class="fas fa-image"></i><input type="file" class="hidden" accept="image/*" multiple onchange="changeImage(this, ${data.id})"></label>
                        </div>
                    </div>
                    <div class="image-wrapper" id="wrapper-${data.id}" onclick="selectImage(${data.id}, event)">
                        <img src="${data.img}" draggable="false" crossorigin="anonymous" onerror="this.src='https://placehold.co/600x400?text=No+Image'" data-original-src="${data.img}" data-rotation="0" data-flip-h="1" data-flip-v="1">
                        <!-- 이미지 편집 컨트롤 (호버 시 표시) -->
                        <div class="image-edit-controls">
                            <button class="image-edit-btn" onclick="startCrop(${data.id})" title="자르기"><i class="fas fa-crop"></i></button>
                            <button class="collage-mode-toggle-btn draw-mode" id="collage-mode-btn-${data.id}" onclick="toggleCollageMode(${data.id})" title="콜라주 그리기 및 텍스트 삽입"><i class="fas fa-pen"></i></button>
                            <button class="image-edit-btn" onclick="rotateImage(${data.id}, 90)" title="90° 회전"><i class="fas fa-redo"></i></button>
                            <button class="image-edit-btn" onclick="flipImage(${data.id}, 'horizontal')" title="좌우 반전"><i class="fas fa-arrows-alt-h"></i></button>
                            <button class="image-edit-btn" onclick="flipImage(${data.id}, 'vertical')" title="상하 반전"><i class="fas fa-arrows-alt-v"></i></button>
                            <button class="image-edit-btn" onclick="deleteImage(${data.id})" title="이미지 삭제" style="background: rgba(239, 68, 68, 0.8);"><i class="fas fa-trash"></i></button>
                        </div>
                        <!-- 자르기 오버레이 -->
                        <div class="crop-overlay" id="crop-overlay-${data.id}">
                            <div class="crop-selection" id="crop-selection-${data.id}">
                                <div class="crop-handle nw"></div>
                                <div class="crop-handle ne"></div>
                                <div class="crop-handle sw"></div>
                                <div class="crop-handle se"></div>
                                <div class="crop-handle n"></div>
                                <div class="crop-handle s"></div>
                                <div class="crop-handle w"></div>
                                <div class="crop-handle e"></div>
                            </div>
                            <div class="crop-controls">
                                <button class="crop-control-btn" onclick="applyCrop(${data.id})">적용</button>
                                <button class="crop-control-btn cancel" onclick="cancelCrop(${data.id})">취소</button>
                            </div>
                        </div>
                        <svg class="drawing-layer mode-select" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet" id="svg-${data.id}">
                            <defs>
                                <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#ef4444" /></marker>
                                <marker id="arrowhead-yellow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#eab308" /></marker>
                                <marker id="arrowhead-green" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#22c55e" /></marker>
                                <marker id="arrowhead-blue" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" /></marker>
                                <marker id="arrowhead-purple" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#a855f7" /></marker>
                                <marker id="arrowhead-white" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#ffffff" /></marker>
                            </defs>
                        </svg>
                        <div class="html-layer" id="html-layer-${data.id}"></div>
                        <!-- 개별 이미지 압축 컨트롤 -->
                        <div class="image-compression-controls" style="position:absolute; left:8px; bottom:8px; z-index:105; background:rgba(0,0,0,0.6); padding:6px; border-radius:6px; display:flex; gap:6px; align-items:center;">
                            <select id="compression-select-${data.id}" class="fmt-btn text-xs px-2 py-1" title="개별 이미지 압축률">
                                <option value="high">상</option>
                                <option value="medium" selected>중</option>
                                <option value="low">하</option>
                            </select>
                            <button class="fmt-btn text-xs px-2 py-1" onclick="applyCompressionToWrapper(${data.id})" title="선택한 압축률로 이 이미지를 재압축">압축 적용</button>
                        </div>
                    </div>
                </div>
            `;

            // [수정됨] 특정 ID 다음에 삽입 (insertAfter)
            if (targetStepIdForAdd) {
                const targetSection = document.getElementById(`step-section-${targetStepIdForAdd}`);
                // 방향에 따라 처리 (DOM 순서는 리스트 순서)
                // '이전/좌측'이면 target 전에, '다음/우측'이면 target 후에 삽입
                if (data.position === 'before') {
                    container.insertBefore(section, targetSection);
                } else {
                    // insertAfter logic
                    if (targetSection.nextSibling) {
                        container.insertBefore(section, targetSection.nextSibling);
                    } else {
                        container.appendChild(section);
                    }
                }
                targetStepIdForAdd = null; // Reset
            } else {
                container.appendChild(section); // 초기 로딩
            }

            initDrawingEvents(data.id);

            // 이미지 방향 확인 및 기능 초기화
            const wrapper = document.getElementById(`wrapper-${data.id}`);
            if (wrapper) {
                const img = wrapper.querySelector('img');
                if (img) {
                    checkImageOrientation(img);
                    // 이미지 선택 및 드래그 기능 초기화
                    selectImage(data.id, { target: { closest: () => null } });
                    initImageDrag(data.id);
                }
            }
        }

        function addNewStep(position, targetId) {
            // position: 'before' (Up/Left) or 'after' (Down/Right)
            targetStepIdForAdd = targetId;

            // Generate new ID
            const sections = document.querySelectorAll('.step-section');
            let maxId = 0;
            sections.forEach(sec => {
                const id = parseInt(sec.id.split('-')[2]);
                if (id > maxId) maxId = id;
            });
            const newId = maxId + 1;

            // Color Cycle
            const colorIndex = (sections.length) % badgePalette.length;
            const newColor = badgePalette[colorIndex];

            const newData = {
                id: newId,
                title: "새로운 작업 단계",
                subTitle: "작업 내용 입력",
                desc: ["- 상세 내용을 입력하세요."],
                badgeColor: newColor,
                img: "https://placehold.co/600x400?text=New+Step",
                position: position // pass pos
            };

            appendStepToDom(newData);
            renumberSteps();

            setTimeout(() => {
                document.getElementById(`step-section-${newId}`).scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }

        // [NEW] Open Add Step Modal with Direction
        function openAddStepModal(targetId) {
            const modal = document.getElementById('direction-modal');
            const container = document.getElementById('direction-buttons');
            container.innerHTML = ''; // Clear previous

            // Check current mode
            const isVertical = currentMode === 'vertical';

            const btn1 = document.createElement('button');
            btn1.className = 'direction-btn';
            btn1.innerHTML = isVertical ? '<i class="fas fa-arrow-up"></i> 현재 단계의 위로 추가' : '<i class="fas fa-arrow-left"></i> 현재 단계의 좌측에 추가';
            btn1.onclick = () => { closeDirectionModal(); addNewStep('before', targetId); };

            const btn2 = document.createElement('button');
            btn2.className = 'direction-btn';
            btn2.innerHTML = isVertical ? '<i class="fas fa-arrow-down"></i> 현재 단계의 아래로 추가' : '<i class="fas fa-arrow-right"></i> 현재 단계의 우측에 추가';
            btn2.onclick = () => { closeDirectionModal(); addNewStep('after', targetId); };

            container.appendChild(btn1);
            container.appendChild(btn2);

            modal.style.display = 'flex';
        }

        function closeDirectionModal() {
            document.getElementById('direction-modal').style.display = 'none';
        }

        // [NEW] 콜라주 모드 토글 함수
        function toggleCollageMode(stepId) {
            const wrapper = document.getElementById(`wrapper-${stepId}`);
            const wrapperId = wrapper.id;
            if (!wrapper) return;

            // 현재 모드 확인 (기본값: draw)
            const currentMode = collageModeState[wrapperId] || 'draw';
            const newMode = currentMode === 'draw' ? 'move' : 'draw';

            // 모드 상태 업데이트
            collageModeState[wrapperId] = newMode;

            // 버튼 스타일 업데이트
            const btn = document.getElementById(`collage-mode-btn-${stepId}`);
            if (btn) {
                btn.classList.remove('draw-mode', 'move-mode');
                if (newMode === 'move') {
                    btn.classList.add('move-mode');
                    btn.title = '콜라주 이동 모드';
                    btn.innerHTML = '<i class="fas fa-arrows-alt"></i>';
                } else {
                    btn.classList.add('draw-mode');
                    btn.title = '콜라주 그리기 및 텍스트 삽입';
                    btn.innerHTML = '<i class="fas fa-pen"></i>';
                }
            }

            // 콜라주 레이어가 있는 경우 처리
            const allLayers = collageLayers[wrapperId] || [];
            if (allLayers.length > 0) {
                allLayers.forEach(layer => {
                    if (newMode === 'move') {
                        // 이동 모드: 모든 레이어가 드래그 가능
                        layer.style.cursor = 'move';
                        layer.classList.remove('selected');
                    } else {
                        // 그리기 모드: 레이어는 일반 그리기 대상
                        layer.style.cursor = 'crosshair';
                        layer.classList.remove('selected');
                    }
                });
            }

            // 도구 상태 업데이트
            if (newMode === 'move') {
                // 이동 모드로 전환 - 도구 상태 유지
                globalTool = 'select';
            } else {
                // 그리기/텍스트 모드로 전환 - 도구 상태 유지
                // 도구를 자동으로 변경하지 않음
            }
        }

        // [NEW] 콜라주 모드 상태 업데이트 함수
        function updateCollageModeToggleButton(stepId) {
            const wrapper = document.getElementById(`wrapper-${stepId}`);
            const wrapperId = wrapper.id;
            const btn = document.getElementById(`collage-mode-btn-${stepId}`);

            if (!btn) return;

            // 콜라주 레이어가 있는지 확인
            const hasLayers = (collageLayers[wrapperId] && collageLayers[wrapperId].length > 0);

            if (hasLayers) {
                // 콜라주가 있으면 버튼 활성화
                const currentMode = collageModeState[wrapperId] || 'draw';
                btn.classList.remove('draw-mode', 'move-mode');
                if (currentMode === 'move') {
                    btn.classList.add('move-mode');
                    btn.title = '콜라주 이동 모드';
                    btn.innerHTML = '<i class="fas fa-arrows-alt"></i>';
                } else {
                    btn.classList.add('draw-mode');
                    btn.title = '콜라주 그리기 및 텍스트 삽입';
                    btn.innerHTML = '<i class="fas fa-pen"></i>';
                }
            }
        }

        function deleteStep(id) {
            showConfirm("정말 이 작업 단계를 삭제하시겠습니까?", function () {
                const section = document.getElementById(`step-section-${id}`);
                if (section) { section.classList.add('collapsed-step'); setTimeout(() => { section.remove(); renumberSteps(); }, 500); }
            });
        }

        function renumberSteps() {
            const sections = document.querySelectorAll('.step-section');
            sections.forEach((sec, index) => {
                const badge = sec.querySelector('.step-badge');
                let currentText = badge.innerText;
                let titlePart = currentText.substring(currentText.indexOf('.') + 2);
                if (currentText.indexOf('.') === -1) titlePart = "제목";
                const newNum = String(index + 1).padStart(2, '0');
                badge.innerText = `STEP ${newNum}. ${titlePart}`;
            });
        }

        function toggleHeader() {
            const header = document.getElementById('main-header');
            const icon = document.getElementById('toggle-icon');
            header.classList.toggle('collapsed');
            if (header.classList.contains('collapsed')) { icon.className = 'fas fa-chevron-down'; document.body.style.paddingTop = '0px'; }
            else { icon.className = 'fas fa-chevron-up'; adjustBodyPadding(); }
        }
        function adjustBodyPadding() {
            const header = document.getElementById('main-header');
            if (!header.classList.contains('collapsed')) { document.body.style.paddingTop = (header.offsetHeight + 30) + 'px'; }
        }
        window.addEventListener('resize', () => {
            const header = document.getElementById('main-header');
            if (!header.classList.contains('collapsed')) adjustBodyPadding();
        });

        let savedRange = null;
        function saveRange() { const sel = window.getSelection(); if (sel.rangeCount > 0) savedRange = sel.getRangeAt(0); }
        function applyColor(cmd, val) {
            if (savedRange) {
                const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(savedRange);
                document.execCommand(cmd, false, val);
            }
        }
        function formatText(command, value = null) {
            // 선택 범위 저장
            const selection = window.getSelection();
            let range = null;

            if (selection.rangeCount > 0) {
                range = selection.getRangeAt(0);
            } else if (savedRange) {
                // 저장된 범위가 있으면 사용
                selection.removeAllRanges();
                selection.addRange(savedRange);
                range = savedRange;
            } else {
                // 선택 범위가 없으면 현재 포커스된 contenteditable 요소 찾기
                const activeElement = document.activeElement;
                if (activeElement && activeElement.isContentEditable) {
                    range = document.createRange();
                    range.selectNodeContents(activeElement);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }

            // 특수 처리: 선택된 객체(selectedElement)에 대한 링크 제거 처리
            if ((command === 'unlink' || command === 'removeLink') && (!range || range.collapsed) && selectedElement) {
                // 요소에 연결된 data-href 속성 제거
                try {
                    if (selectedElement.hasAttribute && selectedElement.hasAttribute('data-href')) {
                        selectedElement.removeAttribute('data-href');
                        selectedElement.classList.remove('linked-element');
                        updateSelectedElementInfo(selectedElement);
                    }
                } catch (err) { console.warn('unlink element failed', err); }
                return;
            }

            // 일반적인 execCommand 실행 (텍스트 기반 편집에 사용)
            if (range || selection.rangeCount > 0) {
                try {
                    document.execCommand(command, false, value);

                    // unlink 명령 후 스타일 정리
                    if (command === 'unlink' || command === 'removeLink') {
                        try {
                            let container = document.activeElement;
                            if (range && range.commonAncestorContainer) {
                                container = range.commonAncestorContainer.nodeType === 3 ? range.commonAncestorContainer.parentNode : range.commonAncestorContainer;
                            }
                            removeAnchorStyles(container);
                        } catch (cleanErr) { /* ignore cleanup errors */ }
                    }
                } catch (e) {
                    console.warn('Format command failed:', command, e);
                }
            }
        }

        function setFontSize(value) {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                if (savedRange) {
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(savedRange);
                }
                document.execCommand('fontSize', false, '7'); // 기본값 설정
                const fontElements = range.commonAncestorContainer.parentElement.querySelectorAll('font[size="7"]');
                fontElements.forEach(el => {
                    el.removeAttribute('size');
                    el.style.fontSize = value + 'px';
                });
            }
        }

        function setLineHeight(value) {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                let parent = range.commonAncestorContainer;
                if (parent.nodeType === 3) parent = parent.parentNode;
                const block = parent.closest('div, p, h1, h2, h3, h4, h5, h6, li');
                if (block) block.style.lineHeight = value;
                else if (parent.isContentEditable) parent.style.lineHeight = value;
            }
        }

        // 선택된 텍스트의 현재 스타일 정보 업데이트
        function updateFormatInfo() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                let element = container.nodeType === 3 ? container.parentElement : container;

                // 글자 크기 업데이트
                const fontSize = window.getComputedStyle(element).fontSize;
                const fontSizeValue = parseInt(fontSize);
                if (fontSizeValue && !isNaN(fontSizeValue)) {
                    const fontSizeInput = document.getElementById('font-size-input');
                    if (fontSizeInput) fontSizeInput.value = fontSizeValue;
                }

                // 줄 간격 업데이트
                const lineHeight = window.getComputedStyle(element).lineHeight;
                const lineHeightValue = parseFloat(lineHeight);
                if (lineHeightValue && !isNaN(lineHeightValue)) {
                    const lineHeightInput = document.getElementById('line-height-input');
                    if (lineHeightInput) {
                        // lineHeight가 'normal'이거나 픽셀 값인 경우 처리
                        if (lineHeight === 'normal') {
                            lineHeightInput.value = '1.2';
                        } else if (lineHeight.includes('px')) {
                            const fontSize = parseFloat(window.getComputedStyle(element).fontSize);
                            lineHeightInput.value = (lineHeightValue / fontSize).toFixed(1);
                        } else {
                            lineHeightInput.value = lineHeightValue.toFixed(1);
                        }
                    }
                }

                // 글자 색상 업데이트
                const textColor = window.getComputedStyle(element).color;
                const rgbToHex = (rgb) => {
                    if (rgb.startsWith('#')) return rgb;
                    const match = rgb.match(/\d+/g);
                    if (!match || match.length < 3) return '#000000';
                    return '#' + match.map(x => {
                        const hex = parseInt(x).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                };
                const foreColorInput = document.getElementById('fore-color-input');
                if (foreColorInput) foreColorInput.value = rgbToHex(textColor);

                // 배경 색상 업데이트
                const bgColor = window.getComputedStyle(element).backgroundColor;
                const hiliteColorInput = document.getElementById('hilite-color-input');
                if (hiliteColorInput) hiliteColorInput.value = rgbToHex(bgColor);
            }
        }

        // 링크 제거 후 스타일 정리 헬퍼 - 모든 자식 요소의 a[href] CSS 강제 무효화
        function removeAnchorStyles(container) {
            try {
                if (!container) return;

                // 컨테이너 내 모든 a[href] 앵커 요소 찾기
                const anchors = container.querySelectorAll('a[href]');
                anchors.forEach(a => {
                    // 앵커 내 텍스트를 span으로 래핑하여 a[href] CSS로부터 탈출
                    const textNodes = [];
                    for (let node of a.childNodes) {
                        if (node.nodeType === 3 && node.textContent.trim()) { // 텍스트 노드
                            textNodes.push(node);
                        }
                    }

                    textNodes.forEach(textNode => {
                        const span = document.createElement('span');
                        span.className = 'plain-text';
                        span.style.cssText = 'color: #ffffff !important; text-decoration: none !important; cursor: text;';
                        a.insertBefore(span, textNode);
                        span.appendChild(textNode);
                    });

                    // 앵커 태그 자체도 제거하고 내용만 유지
                    while (a.firstChild) {
                        a.parentNode.insertBefore(a.firstChild, a);
                    }
                    a.parentNode.removeChild(a);
                });
            } catch (err) { console.warn('removeAnchorStyles error:', err); }
        }

        // 링크 삽입 함수
        // 선택된 요소(도형, 이미지, 주석 등)에 링크를 적용하거나
        // 텍스트 선택이 있을 때는 기존의 createLink 동작을 사용합니다.
        function insertLink() {
            const url = prompt('링크 URL을 입력하세요:', 'https://');
            if (!url || url.trim() === '') return;

            // 요소(객체)가 선택되어 있으면 요소에 data-href로 링크를 설정
            if (selectedElement) {
                try {
                    selectedElement.setAttribute('data-href', url.trim());
                    selectedElement.classList.add('linked-element');
                    // 시각적 표시(커서 변경 등)를 위해 스타일 적용 가능
                    // update selected info
                    updateSelectedElementInfo(selectedElement);
                } catch (err) {
                    console.warn('apply link to element failed', err);
                }
                return;
            }

            // text selection인 경우 기존 동작 유지
            if (savedRange) {
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(savedRange);
            }
            formatText('createLink', url.trim());
            // 생성된 앵커가 있으면 새탭으로 열리도록 속성 추가
            try {
                ensureAnchorAttributes(url.trim());
            } catch (e) { /* ignore */ }
        }

        // 생성 또는 존재하는 앵커에 대해 target, rel, data-href를 보장하고 시각적 표시 추가 (원본 색상 저장)
        function ensureAnchorAttributes(url) {
            try {
                const sel = window.getSelection();
                let container = document.activeElement;
                if (sel && sel.rangeCount > 0) {
                    const range = sel.getRangeAt(0);
                    container = range.commonAncestorContainer.nodeType === 3 ? range.commonAncestorContainer.parentNode : range.commonAncestorContainer;
                }
                if (!container) container = document.body;
                // 가장 가까운 a[href] 찾기
                let a = null;
                if (container.nodeType === 1) {
                    if (container.matches && container.matches('a[href]')) a = container;
                    else a = container.querySelector('a[href]');
                }
                // fallback: 문서 전체 검색 (최소 침투)
                if (!a) a = document.querySelector('a[href]');
                if (a) {
                    // 원본 색상 저장 (처음 링크 생성 시에만)
                    if (!a.getAttribute('data-original-color')) {
                        const currentColor = window.getComputedStyle(a).color || '#ffffff';
                        a.setAttribute('data-original-color', currentColor);
                    }

                    a.setAttribute('target', '_blank');
                    a.setAttribute('rel', 'noopener');
                    if (!a.getAttribute('data-href')) a.setAttribute('data-href', a.getAttribute('href') || url);
                    // 시각적 표시: 링크 스타일 적용 (CSS a[href] 선택자로 담당하지만, 인라인 스타일로 확실하게)
                    a.style.color = '#60a5fa';
                    a.style.webkitTextFillColor = '#60a5fa'; // webkit 기반 브라우저용
                    a.style.textDecoration = 'underline';
                    a.style.textDecorationColor = '#60a5fa';
                    a.style.textDecorationThickness = '2px';
                    a.style.textUnderlineOffset = '3px';
                    a.style.cursor = 'pointer';
                }
            } catch (err) { /* ignore */ }
        }

        // 요소에 링크가 걸려있을 때 클릭 동작을 위임 처리하여 새탭으로 열기
        // (페이지 내 편집 동작과 충돌하지 않도록 클릭 이벤트 캡처 시 최소한의 제어만 수행)
        (function initDelegatedLinkClicks() {
            document.addEventListener('click', function (e) {
                try {
                    let el = e.target;
                    // 올라가며 data-href를 찾음
                    while (el && el !== document) {
                        if (el.getAttribute && el.getAttribute('data-href')) {
                            const href = el.getAttribute('data-href');
                            if (href) {
                                // 편집 모드에서 바로 이동하는 것을 방지하려면
                                // 예: Ctrl/Cmd 클릭만 이동하도록 하려면 아래 조건을 수정
                                // 사용자 요청에 따라 '클릭 시 이동'으로 구현
                                window.open(href, '_blank');
                                e.preventDefault();
                                return;
                            }
                        }
                        el = el.parentNode;
                    }
                } catch (err) { /* 무시 */ }
            }, false);
        })();

        // 배경 설정 모달 열기
        function openBackgroundSettings() {
            const modal = document.getElementById('background-modal');
            if (modal) {
                modal.style.display = 'flex';

                const rgbToHex = (rgb) => {
                    if (rgb.startsWith('#')) return rgb;
                    const match = rgb.match(/\d+/g);
                    if (!match || match.length < 3) return '#1f2937';
                    return '#' + match.map(x => {
                        const hex = parseInt(x).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                };

                // 현재 선택된 대상에 따라 배경 색상 가져오기
                const target = getBackgroundTarget();
                let bgColor;
                if (target === 'body') {
                    bgColor = window.getComputedStyle(document.body).backgroundColor;
                } else {
                    const firstSection = document.querySelector('.step-section');
                    bgColor = firstSection ? window.getComputedStyle(firstSection).backgroundColor : '#1f2937';
                }

                const bgColorInput = document.getElementById('bg-color-input');
                if (bgColorInput) bgColorInput.value = rgbToHex(bgColor);

                // 라디오 버튼 스타일 업데이트
                updateBackgroundTarget();
            }
        }

        // 배경 설정 모달 닫기
        function closeBackgroundSettings() {
            const modal = document.getElementById('background-modal');
            if (modal) modal.style.display = 'none';
        }

        // 배경 적용 대상 가져오기
        function getBackgroundTarget() {
            const targetRadio = document.querySelector('input[name="bg-target"]:checked');
            return targetRadio ? targetRadio.value : 'body';
        }

        // 배경 대상 업데이트 (라디오 버튼 스타일)
        function updateBackgroundTarget() {
            const bodyLabel = document.getElementById('bg-target-body-label');
            const sectionsLabel = document.getElementById('bg-target-sections-label');
            const target = getBackgroundTarget();

            if (bodyLabel && sectionsLabel) {
                if (target === 'body') {
                    bodyLabel.style.borderColor = '#3b82f6';
                    bodyLabel.style.background = '#3b82f6';
                    sectionsLabel.style.borderColor = '#4b5563';
                    sectionsLabel.style.background = '#374151';
                } else {
                    bodyLabel.style.borderColor = '#4b5563';
                    bodyLabel.style.background = '#374151';
                    sectionsLabel.style.borderColor = '#3b82f6';
                    sectionsLabel.style.background = '#3b82f6';
                }
            }
        }

        // 배경 색상 적용
        function applyBackgroundColor() {
            const bgColorInput = document.getElementById('bg-color-input');
            const target = getBackgroundTarget();

            if (bgColorInput) {
                const color = bgColorInput.value;

                if (target === 'body') {
                    document.body.style.backgroundColor = color;
                    localStorage.setItem('bodyBackgroundColor', color);
                    localStorage.removeItem('bodyBackgroundImage');
                } else {
                    // 카드 섹션에 적용
                    document.querySelectorAll('.step-section').forEach(section => {
                        section.style.backgroundColor = color;
                    });
                    localStorage.setItem('sectionBackgroundColor', color);
                    localStorage.removeItem('sectionBackgroundImage');
                }
            }
        }

        // 배경 이미지 적용
        function applyBackgroundImage() {
            const bgImageInput = document.getElementById('bg-image-input');
            const target = getBackgroundTarget();

            if (bgImageInput && bgImageInput.files && bgImageInput.files[0]) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const imageUrl = e.target.result;

                    if (target === 'body') {
                        document.body.style.backgroundImage = `url(${imageUrl})`;
                        document.body.style.backgroundSize = 'cover';
                        document.body.style.backgroundPosition = 'center';
                        document.body.style.backgroundRepeat = 'no-repeat';
                        localStorage.setItem('bodyBackgroundImage', imageUrl);
                        localStorage.removeItem('bodyBackgroundColor');
                    } else {
                        // 카드 섹션에 적용
                        document.querySelectorAll('.step-section').forEach(section => {
                            section.style.backgroundImage = `url(${imageUrl})`;
                            section.style.backgroundSize = 'cover';
                            section.style.backgroundPosition = 'center';
                            section.style.backgroundRepeat = 'no-repeat';
                        });
                        localStorage.setItem('sectionBackgroundImage', imageUrl);
                        localStorage.removeItem('sectionBackgroundColor');
                    }
                };
                reader.readAsDataURL(bgImageInput.files[0]);
            }
        }

        // 배경 기본값으로 복원
        function resetBackground() {
            const target = getBackgroundTarget();

            if (target === 'body') {
                document.body.style.backgroundColor = '#1f2937';
                document.body.style.backgroundImage = 'none';
                localStorage.removeItem('bodyBackgroundColor');
                localStorage.removeItem('bodyBackgroundImage');
            } else {
                document.querySelectorAll('.step-section').forEach(section => {
                    section.style.backgroundColor = '';
                    section.style.backgroundImage = 'none';
                });
                localStorage.removeItem('sectionBackgroundColor');
                localStorage.removeItem('sectionBackgroundImage');
            }
        }

        // 페이지 로드 시 저장된 배경 설정 불러오기
        window.addEventListener('load', function () {
            // [개선: 초기 화면 보정] 브라우저 줌 100% 설정 및 스크롤 초기화
            document.body.style.zoom = '100%';
            window.scrollTo(0, 0);

            // [개선: 초기 화면 위치] 첫 카드 섹션과 "다음 단계로 이동" 기호까지만 표시되도록 조정
            const firstSection = document.querySelector('.step-section');
            if (firstSection) {
                const reportContainer = document.getElementById('report-container');

                // 첫 카드 섹션의 높이 + 기호 높이 계산
                const firstFlowConnector = firstSection.querySelector('.flow-connector');

                if (reportContainer && reportContainer.classList.contains('layout-horizontal')) {
                    // 파노라마 모드: 가로 스크롤 - 첫 카드 + 기호까지만 보이도록
                    setTimeout(() => {
                        if (firstFlowConnector) {
                            const flowNodeRect = firstFlowConnector.querySelector('.flow-node')?.getBoundingClientRect();
                            if (flowNodeRect) {
                                // 첫 카드의 기호 끝이 화면 오른쪽 끝에 맞도록 스크롤
                                const targetScrollLeft = Math.max(0, flowNodeRect.right - window.innerWidth + 100);
                                reportContainer.scrollLeft = targetScrollLeft;
                            }
                        }
                    }, 100);
                } else {
                    // 리포트 모드: 수직 스크롤 - 첫 카드 + 기호까지만 보이도록
                    setTimeout(() => {
                        if (firstFlowConnector) {
                            const flowNodeRect = firstFlowConnector.querySelector('.flow-node')?.getBoundingClientRect();
                            if (flowNodeRect) {
                                // 첫 카드의 기호 끝이 화면 아래 끝에 맞도록 스크롤
                                const targetScrollTop = Math.max(0, flowNodeRect.bottom - window.innerHeight + 80);
                                window.scrollTo({ top: targetScrollTop, left: 0, behavior: 'auto' });
                            }
                        }
                    }, 100);
                }
            }

            // 바탕 화면 배경
            const savedBodyBgColor = localStorage.getItem('bodyBackgroundColor');
            const savedBodyBgImage = localStorage.getItem('bodyBackgroundImage');
            if (savedBodyBgColor) {
                document.body.style.backgroundColor = savedBodyBgColor;
            } else if (savedBodyBgImage) {
                document.body.style.backgroundImage = `url(${savedBodyBgImage})`;
                document.body.style.backgroundSize = 'cover';
                document.body.style.backgroundPosition = 'center';
                document.body.style.backgroundRepeat = 'no-repeat';
            }

            // 카드 섹션 배경
            const savedSectionBgColor = localStorage.getItem('sectionBackgroundColor');
            const savedSectionBgImage = localStorage.getItem('sectionBackgroundImage');
            if (savedSectionBgColor || savedSectionBgImage) {
                document.querySelectorAll('.step-section').forEach(section => {
                    if (savedSectionBgColor) {
                        section.style.backgroundColor = savedSectionBgColor;
                    } else if (savedSectionBgImage) {
                        section.style.backgroundImage = `url(${savedSectionBgImage})`;
                        section.style.backgroundSize = 'cover';
                        section.style.backgroundPosition = 'center';
                        section.style.backgroundRepeat = 'no-repeat';
                    }
                });
            }
        });

        // 선택 변경 시 스타일 정보 업데이트
        document.addEventListener('selectionchange', updateFormatInfo);
        document.addEventListener('mouseup', updateFormatInfo);
        document.addEventListener('keyup', updateFormatInfo);

        function toggleAllSteps(source) {
            const checkboxes = document.querySelectorAll('.step-checkbox');
            checkboxes.forEach(cb => cb.checked = source.checked);
        }

        let isDraggingModal = false, dragStartX, dragStartY, initialModalLeft, initialModalTop;
        const collageContainer = document.getElementById('collage-container');
        document.getElementById('collage-header').addEventListener('mousedown', function (e) {
            isDraggingModal = true; dragStartX = e.clientX; dragStartY = e.clientY;
            const rect = collageContainer.getBoundingClientRect();
            if (collageContainer.style.transform !== 'none') {
                collageContainer.style.left = rect.left + 'px'; collageContainer.style.top = rect.top + 'px'; collageContainer.style.transform = 'none';
            }
            initialModalLeft = collageContainer.offsetLeft; initialModalTop = collageContainer.offsetTop;
            document.addEventListener('mousemove', onModalDrag); document.addEventListener('mouseup', stopModalDrag);
        });
        function onModalDrag(e) {
            if (!isDraggingModal) return;
            collageContainer.style.left = (initialModalLeft + (e.clientX - dragStartX)) + 'px';
            collageContainer.style.top = (initialModalTop + (e.clientY - dragStartY)) + 'px';
        }
        function stopModalDrag() { isDraggingModal = false; document.removeEventListener('mousemove', onModalDrag); document.removeEventListener('mouseup', stopModalDrag); }

        let isResizingModal = false, resizeStartX, resizeStartY, initialWidth, initialHeight;
        document.getElementById('collage-resizer').addEventListener('mousedown', function (e) {
            isResizingModal = true; resizeStartX = e.clientX; resizeStartY = e.clientY;
            initialWidth = collageContainer.offsetWidth; initialHeight = collageContainer.offsetHeight; e.stopPropagation();
            document.addEventListener('mousemove', onModalResize); document.addEventListener('mouseup', stopModalResize);
        });
        function onModalResize(e) {
            if (!isResizingModal) return;
            collageContainer.style.width = (initialWidth + (e.clientX - resizeStartX)) + 'px';
            collageContainer.style.height = (initialHeight + (e.clientY - resizeStartY)) + 'px';
        }
        function stopModalResize() { isResizingModal = false; document.removeEventListener('mousemove', onModalResize); document.removeEventListener('mouseup', stopModalResize); }

        function createCollage() {
            const checkboxes = document.querySelectorAll('.step-checkbox:checked');
            if (checkboxes.length === 0) { showConfirm("콜라주에 포함할 단계를 하나 이상 선택해주세요.", null); return; }
            const modal = document.getElementById('collage-modal');
            const previewArea = document.getElementById('collage-preview-area');
            const collageContainer = document.getElementById('collage-container');
            previewArea.innerHTML = '';

            // 콜라주 수량에 따라 그리드 레이아웃 설정
            const count = checkboxes.length;
            previewArea.setAttribute('data-count', count);

            // 콜라주 수량에 따라 컨테이너 크기 조정 (전체 화면 활용)
            if (count === 1) {
                collageContainer.style.width = '95vw';
                collageContainer.style.height = '95vh';
                collageContainer.style.maxWidth = '95vw';
            } else if (count === 2) {
                collageContainer.style.width = '95vw';
                collageContainer.style.height = '95vh';
                collageContainer.style.maxWidth = '95vw';
            } else if (count <= 4) {
                collageContainer.style.width = '95vw';
                collageContainer.style.height = '95vh';
                collageContainer.style.maxWidth = '95vw';
            } else {
                collageContainer.style.width = '95vw';
                collageContainer.style.height = '95vh';
                collageContainer.style.maxWidth = '95vw';
            }

            modal.style.display = 'block';
            checkboxes.forEach(cb => {
                const stepId = cb.dataset.stepId;
                const stepContainer = cb.closest('.step-section');
                const stepBadge = stepContainer.querySelector('.step-badge').innerText;
                const title = stepContainer.querySelector('h2').innerText;
                const descHtml = stepContainer.querySelector('.text-gray-300').innerHTML;
                const cloneWrapper = document.getElementById(`wrapper-${stepId}`).cloneNode(true);
                cloneWrapper.id = ''; cloneWrapper.style.height = '100%'; cloneWrapper.style.border = 'none';
                cloneWrapper.querySelectorAll('.resize-handle, .delete-btn').forEach(el => el.remove());
                cloneWrapper.querySelectorAll('.annotation-text').forEach(el => el.removeAttribute('contenteditable'));
                const card = document.createElement('div'); card.className = 'collage-card';
                card.innerHTML = `<div class="collage-card-header"><div class="text-xs text-blue-400 font-bold mb-1">${stepBadge}</div><div class="collage-card-title">${title}</div></div><div class="collage-card-image"></div><div class="collage-card-desc">${descHtml}</div><div class="collage-card-details" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #4b5563; font-size: 0.75rem; color: #9ca3af;"><div><strong>상세 내용:</strong></div><div style="margin-top: 4px;">${descHtml}</div></div>`;
                card.querySelector('.collage-card-image').appendChild(cloneWrapper);
                previewArea.appendChild(card);
            });
        }
        function closeCollageModal() { document.getElementById('collage-modal').style.display = 'none'; }

        function saveCollageImage() {
            const element = document.getElementById('collage-preview-area');
            const checkboxes = document.querySelectorAll('.step-checkbox:checked');
            const stepNums = []; checkboxes.forEach(cb => stepNums.push(cb.dataset.stepId));
            let stepsLabel = stepNums.join(", ");
            html2canvas(element, { backgroundColor: '#1f2937', scale: 2, useCORS: true }).then(canvas => {
                const dataUrl = canvas.toDataURL();
                const link = document.createElement('a'); const date = new Date().toISOString().slice(0, 10).replace(/-/g, "");
                link.download = `현장요약_콜라주_${date}.png`; link.href = dataUrl; link.click();
                addCollageThumbnail(dataUrl, stepsLabel);
            });
        }

        function reDownloadCollage(el) {
            const img = el.querySelector('img');
            if (img) {
                const link = document.createElement('a'); const date = new Date().toISOString().slice(0, 10).replace(/-/g, "");
                link.download = `현장요약_콜라주_${date}_re.png`; link.href = img.src; link.click();
            }
        }
        function deleteCollage(event, btn) {
            event.stopPropagation();
            showConfirm('이 콜라주 썸네일을 영구 삭제하시겠습니까?', function () {
                const item = btn.closest('.thumb-item'); if (item) item.remove();
            });
        }
        function addCollageThumbnail(dataUrl, label) {
            const container = document.getElementById('collage-history');
            const thumb = document.createElement('div'); thumb.className = 'thumb-item'; thumb.title = label + " 다시 다운로드";
            thumb.setAttribute('onclick', 'reDownloadCollage(this)');
            thumb.innerHTML = `<img src="${dataUrl}"><div class="thumb-tag">${label}</div><div class="thumb-delete-btn" onclick="deleteCollage(event, this)">X</div>`;
            container.appendChild(thumb);
        }

        function initAntiGravity(id) {
            // Function body removed to stop anti-gravity effect
        }
        function createParticle(wrapper, rect) {
            const p = document.createElement('div'); p.className = 'particle';
            p.style.left = (rect.left - wrapper.getBoundingClientRect().left + Math.random() * rect.width) + 'px';
            p.style.top = (rect.top - wrapper.getBoundingClientRect().top + Math.random() * rect.height) + 'px';
            p.style.width = (Math.random() * 6 + 2) + 'px'; p.style.height = p.style.width;
            wrapper.appendChild(p); setTimeout(() => p.remove(), 2000);
        }
        // 선택된 요소의 타입에 맞는 도구 이름 반환
        function getToolForElement(element) {
            if (!element) return null;

            if (element.tagName) {
                // SVG 요소
                const tagName = element.tagName.toLowerCase();
                if (tagName === 'path') return 'pen';
                if (tagName === 'line') {
                    // 화살표인지 확인
                    if (element.getAttribute('marker-end')) return 'arrow';
                    return 'line';
                }
                if (tagName === 'circle') return 'circle';
                if (tagName === 'ellipse') return 'ellipse';
                if (tagName === 'polyline') return 'polyline';
                if (tagName === 'rect') return 'rect';
            } else if (element.classList && element.classList.contains('annotation')) {
                return 'box';
            }
            return null;
        }

        function setTool(t, b, id) {
            // 선택된 요소가 있고, 해당 요소의 타입에 맞는 도구를 클릭한 경우 팝업 열기
            if (selectedElement && globalTool === 'select') {
                const elementTool = getToolForElement(selectedElement);
                if (elementTool === t) {
                    // 선택된 요소의 타입에 맞는 도구 아이콘을 클릭한 경우
                    const popover = document.getElementById('drawing-settings-popover');
                    if (!toolSettings[t]) return;
                    const rect = b.getBoundingClientRect();
                    if (popover.style.display === 'block') {
                        popover.style.display = 'none';
                    } else {
                        // 버튼을 포함하는 카드 섹션 검색
                        let cardSection = b.closest('.step-section');
                        popover.style.position = 'fixed';
                        const pos = calculatePopoverPositionInCard(rect, cardSection);
                        popover.style.left = pos.left + 'px';
                        popover.style.top = pos.top + 'px';
                        popover.style.transform = 'none';
                        popover.style.display = 'block';

                        // 선택된 요소 정보 표시
                        updateSelectedElementInfo(selectedElement);

                        // 선택된 요소에 맞는 설정 표시
                        let currentWidth = 5;
                        let currentOpacity = 100;
                        let currentStyle = 'solid';
                        let currentFontSize = 16;
                        let currentFontWeight = 900;

                        if (selectedElement.tagName) { // SVG
                            currentWidth = parseInt(selectedElement.getAttribute('stroke-width')) || currentWidth;
                            currentOpacity = (parseFloat(selectedElement.getAttribute('opacity')) || 1) * 100;
                            const dashAttr = selectedElement.getAttribute('stroke-dasharray');
                            currentStyle = (dashAttr === "10,5" || dashAttr === "10, 5") ? 'dashed' : 'solid';

                            // SVG 요소는 글자 크기/굵기 숨김
                            const fontSizeInput = popover.querySelector('input[title="글자 크기"]');
                            const fontWeightInput = popover.querySelector('input[title="글자 굵기"]');
                            if (fontSizeInput) fontSizeInput.closest('.setting-item').style.display = 'none';
                            if (fontWeightInput) fontWeightInput.closest('.setting-item').style.display = 'none';
                        } else if (selectedElement.classList.contains('annotation')) { // Box
                            currentWidth = parseInt(selectedElement.style.borderWidth) || currentWidth;
                            currentOpacity = (parseFloat(selectedElement.style.opacity) || 1) * 100;
                            const computedStyle = window.getComputedStyle(selectedElement);
                            currentStyle = computedStyle.borderStyle || selectedElement.style.borderStyle || 'solid';
                            // 'none'이나 빈 문자열인 경우 'solid'로 처리
                            if (!currentStyle || currentStyle === 'none') {
                                currentStyle = 'solid';
                            }

                            const textEl = selectedElement.querySelector('.annotation-text');
                            if (textEl) {
                                currentFontSize = parseInt(textEl.style.fontSize) || currentFontSize;
                                currentFontWeight = parseInt(textEl.style.fontWeight) || currentFontWeight;
                            }

                            // 텍스트 요소는 글자 크기/굵기 표시
                            const fontSizeInput = popover.querySelector('input[title="글자 크기"]');
                            const fontWeightInput = popover.querySelector('input[title="글자 굵기"]');
                            if (fontSizeInput) {
                                fontSizeInput.value = currentFontSize;
                                fontSizeInput.closest('.setting-item').style.display = 'flex';
                                document.getElementById('val-fontsize').innerText = currentFontSize + 'px';
                            }
                            if (fontWeightInput) {
                                fontWeightInput.value = currentFontWeight;
                                fontWeightInput.closest('.setting-item').style.display = 'flex';
                                document.getElementById('val-fontweight').innerText = currentFontWeight;
                            }

                            // 텍스트 색상 설정 표시
                            const textColorSetting = document.getElementById('text-color-setting');
                            if (textColorSetting) {
                                textColorSetting.style.display = 'flex';

                                // 현재 텍스트 색상 가져오기
                                const textEl = selectedElement.querySelector('.annotation-text');
                                if (textEl) {
                                    const currentColor = window.getComputedStyle(textEl).color;
                                    const rgbToHex = (rgb) => {
                                        const match = rgb.match(/\d+/g);
                                        if (!match || match.length < 3) return '#ffffff';
                                        return '#' + match.map(x => {
                                            const hex = parseInt(x).toString(16);
                                            return hex.length === 1 ? '0' + hex : hex;
                                        }).join('');
                                    };
                                    const hexColor = rgbToHex(currentColor);

                                    // 선택된 색상 표시 (텍스트 색상 옵션만)
                                    document.querySelectorAll('.text-color-option:not(.border-color-option)').forEach(opt => {
                                        opt.classList.remove('active');
                                        const optColor = window.getComputedStyle(opt).backgroundColor;
                                        if (rgbToHex(optColor).toLowerCase() === hexColor.toLowerCase()) {
                                            opt.classList.add('active');
                                        }
                                    });
                                }
                            }

                            // 외곽선 색상 설정 표시
                            const borderColorSetting = document.getElementById('border-color-setting');
                            if (borderColorSetting) {
                                borderColorSetting.style.display = 'flex';

                                // 현재 외곽선 색상 가져오기
                                const colorClasses = ['style-red', 'style-yellow', 'style-green', 'style-blue', 'style-purple', 'style-white'];
                                let currentBorderColor = 'red'; // 기본값
                                colorClasses.forEach(cls => {
                                    if (selectedElement.classList.contains(cls)) {
                                        currentBorderColor = cls.replace('style-', '');
                                    }
                                });

                                // 선택된 색상 표시 (외곽선 색상 옵션만)
                                document.querySelectorAll('.border-color-option').forEach(opt => {
                                    opt.classList.remove('active');
                                    const optColor = opt.getAttribute('onclick').match(/'(\w+)'/);
                                    if (optColor && optColor[1] === currentBorderColor) {
                                        opt.classList.add('active');
                                    }
                                });
                            }
                        } else {
                            // SVG 요소일 때 텍스트 색상 설정 숨김
                            const textColorSetting = document.getElementById('text-color-setting');
                            if (textColorSetting) textColorSetting.style.display = 'none';
                        }

                        // 팝업 UI 업데이트
                        const strokeInput = popover.querySelector('input[title="선 굵기"]');
                        if (strokeInput) {
                            strokeInput.value = currentWidth;
                            document.getElementById('val-stroke').innerText = currentWidth + 'px';
                        }

                        const opacityInput = popover.querySelector('input[title="투명도"]');
                        if (opacityInput) {
                            opacityInput.value = currentOpacity;
                            document.getElementById('val-opacity').innerText = currentOpacity + '%';
                        }

                        const radios = document.getElementsByName('lineStyle');
                        radios.forEach(r => { if (r.value === currentStyle) r.checked = true; });
                    }
                    return;
                }
            }

            // 선택 모드에서도 도구 설정 팝업 열기 가능
            if (globalTool === t && b.classList.contains('active')) {
                if (t === 'select') {
                    // 선택 모드에서 선택된 요소가 있으면 팝업 열기
                    if (selectedElement) {
                        const popover = document.getElementById('drawing-settings-popover');
                        const rect = b.getBoundingClientRect();
                        if (popover.style.display === 'block') {
                            popover.style.display = 'none';
                        } else {
                            // 버튼을 포함하는 카드 섹션 검색
                            let cardSection = b.closest('.step-section');
                            popover.style.position = 'fixed';
                            const pos = calculatePopoverPositionInCard(rect, cardSection);
                            popover.style.left = pos.left + 'px';
                            popover.style.top = pos.top + 'px';
                            popover.style.transform = 'none';
                            popover.style.display = 'block';

                            // 선택된 요소 정보 표시
                            updateSelectedElementInfo(selectedElement);

                            // 선택된 요소에 맞는 설정 표시
                            let currentWidth = 5;
                            let currentOpacity = 100;
                            let currentStyle = 'solid';
                            let currentFontSize = 16;
                            let currentFontWeight = 900;

                            if (selectedElement.tagName) { // SVG
                                currentWidth = parseInt(selectedElement.getAttribute('stroke-width')) || currentWidth;
                                currentOpacity = (parseFloat(selectedElement.getAttribute('opacity')) || 1) * 100;
                                const dashAttr = selectedElement.getAttribute('stroke-dasharray');
                                currentStyle = (dashAttr === "10,5" || dashAttr === "10, 5") ? 'dashed' : 'solid';

                                // SVG 요소는 글자 크기/굵기 숨김
                                const fontSizeInput = popover.querySelector('input[title="글자 크기"]');
                                const fontWeightInput = popover.querySelector('input[title="글자 굵기"]');
                                if (fontSizeInput) fontSizeInput.closest('.setting-item').style.display = 'none';
                                if (fontWeightInput) fontWeightInput.closest('.setting-item').style.display = 'none';
                            } else if (selectedElement.classList.contains('annotation')) { // Box
                                currentWidth = parseInt(selectedElement.style.borderWidth) || currentWidth;
                                currentOpacity = (parseFloat(selectedElement.style.opacity) || 1) * 100;
                                const computedStyle = window.getComputedStyle(selectedElement);
                                currentStyle = computedStyle.borderStyle || selectedElement.style.borderStyle || 'solid';
                                // 'none'이나 빈 문자열인 경우 'solid'로 처리
                                if (!currentStyle || currentStyle === 'none') {
                                    currentStyle = 'solid';
                                }

                                const textEl = selectedElement.querySelector('.annotation-text');
                                if (textEl) {
                                    currentFontSize = parseInt(textEl.style.fontSize) || currentFontSize;
                                    currentFontWeight = parseInt(textEl.style.fontWeight) || currentFontWeight;
                                }

                                // 텍스트 요소는 글자 크기/굵기 표시
                                const fontSizeInput = popover.querySelector('input[title="글자 크기"]');
                                const fontWeightInput = popover.querySelector('input[title="글자 굵기"]');
                                if (fontSizeInput) {
                                    fontSizeInput.value = currentFontSize;
                                    fontSizeInput.closest('.setting-item').style.display = 'flex';
                                    document.getElementById('val-fontsize').innerText = currentFontSize + 'px';
                                }
                                if (fontWeightInput) {
                                    fontWeightInput.value = currentFontWeight;
                                    fontWeightInput.closest('.setting-item').style.display = 'flex';
                                    document.getElementById('val-fontweight').innerText = currentFontWeight;
                                }

                                // 텍스트 색상 설정 표시
                                const textColorSetting = document.getElementById('text-color-setting');
                                if (textColorSetting) {
                                    textColorSetting.style.display = 'flex';

                                    // 현재 텍스트 색상 가져오기
                                    const textEl = selectedElement.querySelector('.annotation-text');
                                    if (textEl) {
                                        const currentColor = window.getComputedStyle(textEl).color;
                                        const rgbToHex = (rgb) => {
                                            const match = rgb.match(/\d+/g);
                                            if (!match || match.length < 3) return '#ffffff';
                                            return '#' + match.map(x => {
                                                const hex = parseInt(x).toString(16);
                                                return hex.length === 1 ? '0' + hex : hex;
                                            }).join('');
                                        };
                                        const hexColor = rgbToHex(currentColor);

                                        // 선택된 색상 표시 (텍스트 색상 옵션만)
                                        document.querySelectorAll('.text-color-option:not(.border-color-option)').forEach(opt => {
                                            opt.classList.remove('active');
                                            const optColor = window.getComputedStyle(opt).backgroundColor;
                                            if (rgbToHex(optColor).toLowerCase() === hexColor.toLowerCase()) {
                                                opt.classList.add('active');
                                            }
                                        });
                                    }
                                }

                                // 외곽선 색상 설정 표시
                                const borderColorSetting = document.getElementById('border-color-setting');
                                if (borderColorSetting) {
                                    borderColorSetting.style.display = 'flex';

                                    // 현재 외곽선 색상 가져오기
                                    const colorClasses = ['style-red', 'style-yellow', 'style-green', 'style-blue', 'style-purple', 'style-white'];
                                    let currentBorderColor = 'red'; // 기본값
                                    colorClasses.forEach(cls => {
                                        if (selectedElement.classList.contains(cls)) {
                                            currentBorderColor = cls.replace('style-', '');
                                        }
                                    });

                                    // 선택된 색상 표시 (외곽선 색상 옵션만)
                                    document.querySelectorAll('.border-color-option').forEach(opt => {
                                        opt.classList.remove('active');
                                        const optColor = opt.getAttribute('onclick').match(/'(\w+)'/);
                                        if (optColor && optColor[1] === currentBorderColor) {
                                            opt.classList.add('active');
                                        }
                                    });
                                }
                            } else {
                                // SVG 요소일 때 텍스트 색상 및 외곽선 색상 설정 숨김
                                const textColorSetting = document.getElementById('text-color-setting');
                                const borderColorSetting = document.getElementById('border-color-setting');
                                if (textColorSetting) textColorSetting.style.display = 'none';
                                if (borderColorSetting) borderColorSetting.style.display = 'none';
                            }

                            // 팝업 UI 업데이트
                            const strokeInput = popover.querySelector('input[title="선 굵기"]');
                            if (strokeInput) {
                                strokeInput.value = currentWidth;
                                document.getElementById('val-stroke').innerText = currentWidth + 'px';
                            }

                            const opacityInput = popover.querySelector('input[title="투명도"]');
                            if (opacityInput) {
                                opacityInput.value = currentOpacity;
                                document.getElementById('val-opacity').innerText = currentOpacity + '%';
                            }

                            const radios = document.getElementsByName('lineStyle');
                            radios.forEach(r => { if (r.value === currentStyle) r.checked = true; });
                        }
                    }
                    return;
                }

                // 다른 도구들에 대한 기존 로직
                const popover = document.getElementById('drawing-settings-popover');
                if (!toolSettings[t]) return;
                const rect = b.getBoundingClientRect();
                if (popover.style.display === 'block') {
                    popover.style.display = 'none';
                } else {
                    // 드래그된 위치가 있으면 유지, 없으면 기본 위치
                    if (popover.style.position === 'fixed' && popover.style.left && popover.style.top) {
                        // 이미 fixed 위치가 설정되어 있으면 유지
                    } else {
                        let cardSection = b.closest('.step-section');
                        popover.style.position = 'fixed';
                        const pos = calculatePopoverPositionInCard(rect, cardSection);
                        popover.style.left = pos.left + 'px';
                        popover.style.top = pos.top + 'px';
                    }
                    popover.style.display = 'block';

                    // 선택된 요소 정보 표시
                    updateSelectedElementInfo(selectedElement);

                    const settings = toolSettings[t];

                    // 선택된 요소가 있으면 그 값으로, 없으면 기본값으로 팝업 초기화
                    let currentWidth = settings.width;
                    let currentOpacity = settings.opacity;
                    let currentStyle = settings.style || 'solid';
                    let currentFontSize = settings.fontSize || 16;
                    let currentFontWeight = settings.fontWeight || 900;

                    // 선택된 요소 값 가져오기 (Sync)
                    if (selectedElement) {
                        if (selectedElement.tagName) { // SVG
                            currentWidth = parseInt(selectedElement.getAttribute('stroke-width')) || currentWidth;
                            currentOpacity = (parseFloat(selectedElement.getAttribute('opacity')) || 1) * 100;
                            const dashAttr = selectedElement.getAttribute('stroke-dasharray');
                            currentStyle = (dashAttr === "10,5" || dashAttr === "10, 5") ? 'dashed' : 'solid';
                        } else if (selectedElement.classList.contains('annotation')) { // Box
                            currentWidth = parseInt(selectedElement.style.borderWidth) || currentWidth;
                            currentOpacity = (parseFloat(selectedElement.style.opacity) || 1) * 100;
                            const computedStyle = window.getComputedStyle(selectedElement);
                            currentStyle = computedStyle.borderStyle || selectedElement.style.borderStyle || 'solid';
                            // 'none'이나 빈 문자열인 경우 'solid'로 처리
                            if (!currentStyle || currentStyle === 'none') {
                                currentStyle = 'solid';
                            }

                            const textEl = selectedElement.querySelector('.annotation-text');
                            if (textEl) {
                                currentFontSize = parseInt(textEl.style.fontSize) || currentFontSize;
                                currentFontWeight = parseInt(textEl.style.fontWeight) || currentFontWeight;
                            }
                        }
                    }

                    // 텍스트 색상 설정 표시/숨김
                    const textColorSetting = document.getElementById('text-color-setting');
                    const borderColorSetting = document.getElementById('border-color-setting');
                    if (selectedElement && selectedElement.classList.contains('annotation')) {
                        if (textColorSetting) {
                            textColorSetting.style.display = 'flex';

                            // 현재 텍스트 색상 가져오기
                            const textEl = selectedElement.querySelector('.annotation-text');
                            if (textEl) {
                                const currentColor = window.getComputedStyle(textEl).color;
                                const rgbToHex = (rgb) => {
                                    const match = rgb.match(/\d+/g);
                                    if (!match || match.length < 3) return '#ffffff';
                                    return '#' + match.map(x => {
                                        const hex = parseInt(x).toString(16);
                                        return hex.length === 1 ? '0' + hex : hex;
                                    }).join('');
                                };
                                const hexColor = rgbToHex(currentColor);

                                // 선택된 색상 표시 (텍스트 색상 옵션만)
                                document.querySelectorAll('.text-color-option:not(.border-color-option)').forEach(opt => {
                                    opt.classList.remove('active');
                                    const optColor = window.getComputedStyle(opt).backgroundColor;
                                    if (rgbToHex(optColor).toLowerCase() === hexColor.toLowerCase()) {
                                        opt.classList.add('active');
                                    }
                                });
                            }
                        }

                        // 외곽선 색상 설정 표시
                        if (borderColorSetting) {
                            borderColorSetting.style.display = 'flex';

                            // 현재 외곽선 색상 가져오기
                            const colorClasses = ['style-red', 'style-yellow', 'style-green', 'style-blue', 'style-purple', 'style-white'];
                            let currentBorderColor = 'red'; // 기본값
                            colorClasses.forEach(cls => {
                                if (selectedElement.classList.contains(cls)) {
                                    currentBorderColor = cls.replace('style-', '');
                                }
                            });

                            // 선택된 색상 표시 (외곽선 색상 옵션만)
                            document.querySelectorAll('.border-color-option').forEach(opt => {
                                opt.classList.remove('active');
                                const optColor = opt.getAttribute('onclick').match(/'(\w+)'/);
                                if (optColor && optColor[1] === currentBorderColor) {
                                    opt.classList.add('active');
                                }
                            });
                        }
                    } else {
                        if (textColorSetting) textColorSetting.style.display = 'none';
                        if (borderColorSetting) borderColorSetting.style.display = 'none';
                    }

                    // 팝업 UI 업데이트
                    const strokeInput = popover.querySelector('input[title="선 굵기"]');
                    if (strokeInput) {
                        strokeInput.value = currentWidth;
                        document.getElementById('val-stroke').innerText = currentWidth + 'px';
                    }

                    const opacityInput = popover.querySelector('input[title="투명도"]');
                    if (opacityInput) {
                        opacityInput.value = currentOpacity;
                        document.getElementById('val-opacity').innerText = currentOpacity + '%';
                    }

                    const radios = document.getElementsByName('lineStyle');
                    radios.forEach(r => { if (r.value === currentStyle) r.checked = true; });

                    const fontSizeInput = popover.querySelector('input[title="글자 크기"]');
                    const fontWeightInput = popover.querySelector('input[title="글자 굵기"]');

                    if (t === 'box') {
                        if (fontSizeInput) {
                            fontSizeInput.value = currentFontSize;
                            fontSizeInput.closest('.setting-item').style.display = 'flex';
                            document.getElementById('val-fontsize').innerText = currentFontSize + 'px';
                        }
                        if (fontWeightInput) {
                            fontWeightInput.value = currentFontWeight;
                            fontWeightInput.closest('.setting-item').style.display = 'flex';
                            document.getElementById('val-fontweight').innerText = currentFontWeight;
                        }
                    } else {
                        if (fontSizeInput) fontSizeInput.closest('.setting-item').style.display = 'none';
                        if (fontWeightInput) fontWeightInput.closest('.setting-item').style.display = 'none';
                    }
                }
                return;
            }

            globalTool = t;

            // 선택되지 않은 콜라주 레이어의 커서를 현재 도구에 맞게 업데이트
            updateCollageLayerCursors(t);
            document.getElementById(`toolbar-${id}`).querySelectorAll('.tool-btn').forEach(x => x.classList.remove('active'));
            if (b) b.classList.add('active');

            // 도구 변경시 선택된 요소가 있으면 정보 업데이트
            if (selectedElement) {
                updateSelectedElementInfo(selectedElement);
            } else {
                updateSelectedElementInfo(null);
            }

            document.getElementById('drawing-settings-popover').style.display = 'none';

            const svg = document.getElementById(`svg-${id}`);
            if (t === 'select') { svg.classList.add('mode-select'); svg.style.pointerEvents = 'auto'; } else { svg.classList.remove('mode-select'); svg.style.pointerEvents = 'auto'; }
        }
        function setColor(c) {
            globalColor = c;
            document.querySelectorAll('.color-dot').forEach(x => x.classList.remove('active'));
            document.querySelectorAll(`.color-dot.bg-${c}`).forEach(x => x.classList.add('active'));
        }
        function changeImage(input, stepId) {
            if (!input.files || input.files.length === 0) return;

            const wrapper = document.getElementById(`wrapper-${stepId}`);
            if (!wrapper) {
                console.error(`changeImage: wrapper-${stepId}를 찾을 수 없습니다`);
                return;
            }

            const img = wrapper.querySelector('img');
            const wrapperRect = wrapper.getBoundingClientRect();
            const wrapperWidth = wrapperRect.width;
            const wrapperHeight = wrapperRect.height;

            // [NEW] 파일 선택 직후 모달 표시
            showCompressionModal(Array.from(input.files), wrapperWidth, wrapperHeight, (selectedQuality) => {
                if (selectedQuality === null) {
                    console.log('압축 선택 취소됨');
                    return;
                }

                // 선택된 품질값 저장
                selectedCompressionQuality = selectedQuality;

                // 다중 파일 선택 처리
                if (input.files.length > 1) {
                    // 여러 이미지를 콜라주로 삽입
                    const imageFiles = Array.from(input.files);
                    console.log(`${imageFiles.length}개의 파일이 선택되었습니다. 콜라주 생성 시작...`);
                    createImageCollage(wrapper, img, imageFiles);
                } else {
                    // 단일 이미지 처리 - 여백과 경계선 내부에서 이미지가 가득 차도록 처리
                    const reader = new FileReader();
                    reader.onload = e => {
                        const tempImg = new Image();
                        tempImg.onload = function () {
                            // 원본 보존 조건: '상' 선택(높음)이고 원본이 현재 표시 영역 및 export 제한보다 작거나 같으면
                            // 재인코딩(캔버스→toDataURL)을 하지 않고 원본 데이터 URL을 그대로 사용합니다.
                            try {
                                const q_check = getSelectedCompressionQuality();
                                const maxW_check = getExportMaxWidth();
                                // e.target.result는 outer reader.onload의 이벤트에서 캡쳐됨
                                // '원본 그대로' 옵션(none)이 선택되었으면 항상 원본 그대로 사용
                                if (selectedCompressionQuality === 'none') {
                                    img.src = e.target.result;
                                    img.setAttribute('data-original-src', e.target.result);
                                    img.setAttribute('data-rotation', '0');
                                    img.setAttribute('data-flip-h', '1');
                                    img.setAttribute('data-flip-v', '1');
                                    checkImageOrientation(img);
                                    updateImageTransform(img);
                                    wrapper.classList.remove('selected');
                                    img.classList.remove('selected');
                                    const wrapperId = wrapper.id.split('-')[1];
                                    if (wrapperId) {
                                        const stepId = parseInt(wrapperId);
                                        initImageDrag(stepId);
                                    }
                                    return; // 재인코딩 분기에서 바로 종료
                                }
                                // 원본 유지 동작은 사용자가 토글을 켰고 '상'을 선택했을 때만 적용
                                if (preserveOriginalWhenHigh && selectedCompressionQuality === 'high' && q_check >= 0.97 && this.naturalWidth <= innerWidth && this.naturalHeight <= innerHeight && this.naturalWidth <= maxW_check) {
                                    // 원본 그대로 사용
                                    img.src = e.target.result;
                                    img.setAttribute('data-original-src', e.target.result);
                                    img.setAttribute('data-rotation', '0');
                                    img.setAttribute('data-flip-h', '1');
                                    img.setAttribute('data-flip-v', '1');
                                    checkImageOrientation(img);
                                    updateImageTransform(img);
                                    wrapper.classList.remove('selected');
                                    img.classList.remove('selected');
                                    const wrapperId = wrapper.id.split('-')[1];
                                    if (wrapperId) {
                                        const stepId = parseInt(wrapperId);
                                        initImageDrag(stepId);
                                    }
                                    return; // 재인코딩 분기에서 바로 종료
                                }
                            } catch (errPreserve) {
                                console.warn('원본 보존 분기 검사 중 오류:', errPreserve);
                            }
                            // 여백 설정 (사면에 약간의 여백)
                            const margin = 12; // 12px 여백
                            const innerWidth = wrapperWidth - (margin * 2);
                            const innerHeight = wrapperHeight - (margin * 2);

                            // Canvas 생성하여 이미지를 영역에 맞게 조정
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = wrapperWidth;
                            canvas.height = wrapperHeight;

                            // 배경을 검은색으로
                            ctx.fillStyle = '#000';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // 여백 부분을 어두운 회색 테두리로 표시 (경계선)
                            ctx.strokeStyle = '#444';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(margin - 0.5, margin - 0.5, innerWidth + 1, innerHeight + 1);

                            // 고품질 리샘플링: imageSmoothingQuality 설정
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';

                            // 이미지 비율과 관계없이 여백 내부 영역을 가득 채우도록 (fill 방식)
                            ctx.drawImage(
                                this,
                                0, 0, this.width, this.height, // 소스 영역 (이미지 전체)
                                margin, margin, innerWidth, innerHeight // 대상 영역 (여백 내부)
                            );

                            // 처리된 이미지를 원본 이미지로 교체 (선택된 압축률 적용)
                            try {
                                const q = getSelectedCompressionQuality();
                                const dataUrl = canvas.toDataURL('image/jpeg', q);
                                img.src = dataUrl;
                                img.setAttribute('data-original-src', dataUrl);
                            } catch (e) {
                                // toDataURL 가 실패하면 PNG fallback
                                const dataUrl = canvas.toDataURL('image/png');
                                img.src = dataUrl;
                                img.setAttribute('data-original-src', dataUrl);
                            }
                            img.setAttribute('data-rotation', '0');
                            img.setAttribute('data-flip-h', '1');
                            img.setAttribute('data-flip-v', '1');
                            checkImageOrientation(img);
                            updateImageTransform(img);
                            // 이미지 선택 해제 (주황색 점선 제거)
                            wrapper.classList.remove('selected');
                            img.classList.remove('selected');
                            // 이미지 드래그 기능 초기화
                            const wrapperId = wrapper.id.split('-')[1];
                            if (wrapperId) {
                                const stepId = parseInt(wrapperId);
                                initImageDrag(stepId);
                            }
                        };
                        tempImg.src = e.target.result;
                    };
                    reader.readAsDataURL(input.files[0]);
                    // [NEW] input value 초기화 - 같은 파일 재선택 가능하도록
                    input.value = '';
                }
            }); // [NEW] 모달 콜백 닫음
        }

        // 이미지 방향 확인 (세로/가로)
        function checkImageOrientation(img) {
            const tempImg = new Image();
            tempImg.onload = function () {
                const isVertical = this.height > this.width;
                const isHorizontal = this.width > this.height;
                img.setAttribute('data-vertical', isVertical);
                img.setAttribute('data-horizontal', isHorizontal);
                if (isVertical) {
                    initImagePositionControl(img, 'vertical');
                } else if (isHorizontal) {
                    initImagePositionControl(img, 'horizontal');
                } else {
                    // 정사각형 이미지
                    img.removeAttribute('data-vertical');
                    img.removeAttribute('data-horizontal');
                    img.style.objectPosition = 'center center';
                }
            };
            tempImg.src = img.src;
        }

        // 이미지 위치 조정 기능 (세로/가로 모두 지원)
        function initImagePositionControl(img, orientation) {
            const wrapper = img.closest('.image-wrapper');
            if (!wrapper.querySelector('.image-position-indicator')) {
                const indicator = document.createElement('div');
                indicator.className = 'image-position-indicator';
                indicator.innerHTML = '위치 조정 가능';
                wrapper.appendChild(indicator);
            }

            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let startPositionX = 50;
            let startPositionY = 50;

            img.addEventListener('mousedown', (e) => {
                if (orientation === 'vertical' && !img.getAttribute('data-vertical')) return;
                if (orientation === 'horizontal' && !img.getAttribute('data-horizontal')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                const currentPosition = img.style.objectPosition || 'center center';
                const matchX = currentPosition.match(/(\d+)%\s+center|center\s+(\d+)%/);
                const matchY = currentPosition.match(/(\d+)%/);
                if (matchX) {
                    startPositionX = parseInt(matchX[1] || matchX[2] || '50');
                }
                if (matchY) {
                    startPositionY = parseInt(matchY[1] || '50');
                }
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                if (orientation === 'vertical' && !img.getAttribute('data-vertical')) return;
                if (orientation === 'horizontal' && !img.getAttribute('data-horizontal')) return;

                const wrapperRect = wrapper.getBoundingClientRect();

                if (orientation === 'vertical') {
                    // 세로 이미지: Y축 이동
                    const deltaY = e.clientY - startY;
                    const percentage = Math.max(0, Math.min(100, startPositionY + (deltaY / wrapperRect.height) * 100));
                    img.style.objectPosition = `center ${percentage}%`;
                } else if (orientation === 'horizontal') {
                    // 가로 이미지: X축 이동
                    const deltaX = e.clientX - startX;
                    const percentage = Math.max(0, Math.min(100, startPositionX + (deltaX / wrapperRect.width) * 100));
                    img.style.objectPosition = `${percentage}% center`;
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // 콜라주 이미지 레이어 데이터 저장
        let collageLayers = {};

        // 다중 이미지 콜라주 생성
        function createImageCollage(wrapper, originalImg, imageFiles) {
            if (!wrapper) {
                console.error('createImageCollage: wrapper가 null입니다');
                return;
            }

            console.log('createImageCollage 호출됨. 파일 개수:', imageFiles.length);

            const wrapperRect = wrapper.getBoundingClientRect();
            const wrapperWidth = wrapperRect.width;
            const wrapperHeight = wrapperRect.height;
            const gap = 10; // 사진 사이 여백
            const padding = gap;
            const availableWidth = wrapperWidth - (padding * 2);
            const availableHeight = wrapperHeight - (padding * 2);

            // 기존 레이어 제거
            const wrapperId = wrapper.id;
            if (collageLayers[wrapperId]) {
                console.log('기존 콜라주 레이어 제거:', collageLayers[wrapperId].length);
                collageLayers[wrapperId].forEach(layer => layer.remove());
            }
            collageLayers[wrapperId] = [];

            const images = [];
            let loadedCount = 0;

            imageFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.onload = function () {
                        console.log(`이미지 ${index + 1}/${imageFiles.length} 로드됨:`, this.width, 'x', this.height);
                        images[index] = {
                            img: this,
                            width: this.width,
                            height: this.height,
                            dataUrl: e.target.result
                        };
                        loadedCount++;
                        console.log(`로드된 이미지: ${loadedCount}/${imageFiles.length}`);

                        if (loadedCount === imageFiles.length) {
                            console.log('모든 이미지 로드 완료. 그리드 계산 시작...');
                            // 그리드 레이아웃 계산
                            const grid = calculateOptimalGrid(images.length, availableWidth, availableHeight, gap);
                            console.log('계산된 그리드:', grid);
                            // 스케일 계산
                            const totalGridWidth = grid.cols * grid.cellWidth + gap * (grid.cols - 1);
                            const totalGridHeight = grid.rows * grid.cellHeight + gap * (grid.rows - 1);
                            const scaleX = availableWidth / totalGridWidth;
                            const scaleY = availableHeight / totalGridHeight;
                            const scale = Math.min(scaleX, scaleY);

                            const scaledCellWidth = grid.cellWidth * scale;
                            const scaledCellHeight = grid.cellHeight * scale;
                            const scaledGap = gap * scale;

                            const scaledGridWidth = grid.cols * scaledCellWidth + scaledGap * (grid.cols - 1);
                            const scaledGridHeight = grid.rows * scaledCellHeight + scaledGap * (grid.rows - 1);

                            const startX = Math.max(padding, padding + (availableWidth - scaledGridWidth) / 2);
                            const startY = Math.max(padding, padding + (availableHeight - scaledGridHeight) / 2);

                            // 원본 이미지 숨기기
                            originalImg.style.display = 'none';
                            originalImg.style.visibility = 'hidden';
                            originalImg.style.pointerEvents = 'none';
                            originalImg.style.zIndex = '0';

                            // 각 이미지를 개별 레이어로 생성
                            images.forEach((item, idx) => {
                                const row = Math.floor(idx / grid.cols);
                                const col = idx % grid.cols;

                                const cellX = Math.max(padding, startX + col * (scaledCellWidth + scaledGap));
                                const cellY = Math.max(padding, startY + row * (scaledCellHeight + scaledGap));

                                const actualCellWidth = Math.min(scaledCellWidth, wrapperWidth - cellX - padding);
                                const actualCellHeight = Math.min(scaledCellHeight, wrapperHeight - cellY - padding);

                                console.log(`레이어 ${idx + 1}/${images.length} 생성:`, { cellX, cellY, actualCellWidth, actualCellHeight });
                                createCollageLayer(wrapper, item, cellX, cellY, actualCellWidth, actualCellHeight, idx);
                            });

                            console.log(`총 ${images.length}개의 콜라주 레이어가 생성되었습니다`);

                            // 초기 렌더링 (레이어가 모두 로드된 후)
                            setTimeout(() => {
                                // 레이어가 제대로 표시되도록 확인
                                const wrapperId = wrapper.id;
                                if (collageLayers[wrapperId]) {
                                    console.log(`콜라주 레이어 표시: ${collageLayers[wrapperId].length}개`);
                                    collageLayers[wrapperId].forEach((layer, idx) => {
                                        layer.style.display = 'block';
                                        layer.style.visibility = 'visible';
                                        layer.style.pointerEvents = 'auto';
                                        layer.style.zIndex = (40 + idx).toString(); /* 그리기 레이어(z-index: 70)와 텍스트 레이어(z-index: 70)보다 아래에 위치 */
                                    });
                                }
                                // 초기 렌더링은 하지 않고 레이어만 표시 (드래그 가능하도록)
                                // renderCollageFromLayers(wrapper, originalImg);
                                originalImg.style.display = 'none';
                                originalImg.style.visibility = 'hidden';
                                originalImg.style.pointerEvents = 'none';
                                originalImg.style.zIndex = '0';

                                // 이미지 선택 해제 (주황색 점선 제거)
                                wrapper.classList.remove('selected');
                                const img = wrapper.querySelector('img:not(.collage-layer img)');
                                if (img) {
                                    img.classList.remove('selected');
                                    img.style.display = 'none';
                                    img.style.visibility = 'hidden';
                                }
                                // 모든 콜라주 레이어 선택 해제
                                wrapper.querySelectorAll('.collage-layer').forEach(l => l.classList.remove('selected'));

                                // 콜라주 모드 토글 버튼 업데이트
                                const stepId = parseInt(wrapperId.split('-')[1]);
                                updateCollageModeToggleButton(stepId);
                            }, 100);
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        // 콜라주 레이어 생성
        function createCollageLayer(wrapper, imageData, x, y, width, height, index) {
            if (!wrapper) {
                console.error('createCollageLayer: wrapper가 null입니다');
                return;
            }

            const layer = document.createElement('div');
            layer.className = 'collage-layer';
            // 레이어가 항상 보이도록 스타일 명시적 설정
            layer.style.position = 'absolute';
            layer.style.left = x + 'px';
            layer.style.top = y + 'px';
            layer.style.width = width + 'px';
            layer.style.height = height + 'px';
            layer.style.display = 'block';
            layer.style.visibility = 'visible';
            layer.style.pointerEvents = 'auto';
            layer.style.zIndex = '40'; /* 그리기 레이어(z-index: 70)와 텍스트 레이어(z-index: 70)보다 아래에 위치 */
            layer.style.overflow = 'hidden';
            layer.dataset.index = index;
            // 초기 커서 설정 (현재 도구에 맞게, 선택되지 않은 레이어는 그리기 도구 커서)
            const currentCursor = globalTool === 'select' ? 'default' : 'crosshair';
            layer.style.cursor = currentCursor;

            const img = document.createElement('img');
            console.log(`이미지 요소 생성 (레이어 ${index}):`, imageData.dataUrl ? 'dataUrl 있음' : 'dataUrl 없음');
            // 지정된 레이어 크기에 맞춰 압축하여 적용 (성능 및 파일 크기 최적화)
            try {
                const tmpCanvas = document.createElement('canvas');
                tmpCanvas.width = Math.max(1, Math.floor(width));
                tmpCanvas.height = Math.max(1, Math.floor(height));

                // 고품질(상) 선택 시 원본이 타겟 셀보다 작거나 같고 export 제한보다 작으면
                // 재인코딩을 건너뛰고 원본 dataUrl을 그대로 사용합니다.
                try {
                    const q_check = getSelectedCompressionQuality();
                    const maxW = getExportMaxWidth();
                    // 원본 유지 동작은 사용자가 토글을 켰고 '상'을 선택했을 때만 적용
                    if (preserveOriginalWhenHigh && selectedCompressionQuality === 'high' && q_check >= 0.97 && imageData.width <= tmpCanvas.width && imageData.height <= tmpCanvas.height && imageData.width <= maxW) {
                        img.src = imageData.dataUrl;
                    } else {
                        const tctx = tmpCanvas.getContext('2d');
                        tctx.fillStyle = '#000'; tctx.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);
                        tctx.imageSmoothingEnabled = true;
                        tctx.imageSmoothingQuality = 'high';
                        tctx.drawImage(imageData.img, 0, 0, imageData.width, imageData.height, 0, 0, tmpCanvas.width, tmpCanvas.height);
                        const q = getSelectedCompressionQuality();
                        const compressed = tmpCanvas.toDataURL('image/jpeg', q);
                        img.src = compressed;
                    }
                } catch (innerErr) {
                    console.warn('createCollageLayer: 원본 보존 검사 실패, 기본 압축 실행', innerErr);
                    const tctx = tmpCanvas.getContext('2d');
                    tctx.fillStyle = '#000'; tctx.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);
                    tctx.imageSmoothingEnabled = true;
                    tctx.imageSmoothingQuality = 'high';
                    tctx.drawImage(imageData.img, 0, 0, imageData.width, imageData.height, 0, 0, tmpCanvas.width, tmpCanvas.height);
                    const q = getSelectedCompressionQuality();
                    const compressed = tmpCanvas.toDataURL('image/jpeg', q);
                    img.src = compressed;
                }
            } catch (err) {
                // fallback
                img.src = imageData.dataUrl;
            }
            img.draggable = false;
            img.dataset.rotation = '0';
            img.dataset.flipH = '1';
            img.dataset.flipV = '1';
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'fill';
            img.style.display = 'block';

            // 이미지 로드 확인
            img.onload = function () {
                console.log(`레이어 ${index} 이미지 로드 완료`);
            };
            img.onerror = function (e) {
                console.error(`레이어 ${index} 이미지 로드 실패:`, e);
            };

            layer.appendChild(img);

            // 드래그 기능 추가
            initCollageLayerDrag(layer, wrapper);

            layer.addEventListener('click', (e) => {
                // 편집 버튼을 클릭한 경우 선택하지 않음
                if (e.target.closest('.image-edit-btn')) {
                    return;
                }

                // 드래그가 발생했으면 click 이벤트 무시
                if (layer.dataset.dragJustEnded === 'true') {
                    layer.dataset.dragJustEnded = 'false'; // 플래그 초기화
                    return;
                }

                // 콜라주 모드 확인
                const wrapperId = wrapper.id;
                const currentMode = collageModeState[wrapperId] || 'draw';

                // 이동 모드일 때: 클릭만으로 선택 (Shift/Ctrl 키 불필요)
                if (currentMode === 'move') {
                    e.stopPropagation();
                    e.preventDefault();

                    const allLayers = collageLayers[wrapperId] || [];
                    // 다른 레이어 선택 해제
                    allLayers.forEach(l => l.classList.remove('selected'));
                    // 일반 이미지 선택도 해제
                    wrapper.classList.remove('selected');
                    const img = wrapper.querySelector('img:not(.collage-layer img)');
                    if (img) img.classList.remove('selected');
                    // 현재 레이어 선택
                    layer.classList.add('selected');
                    layer.style.cursor = 'move';

                    // 이동 모드에서는 도구 상태를 변경하지 않음
                    return;
                }

                // 그리기/텍스트 모드일 때: Shift/Ctrl 키 필요 (완전히 분리)
                if (e.shiftKey || e.ctrlKey || e.metaKey) {
                    e.stopPropagation();
                    e.preventDefault();

                    const allLayers = collageLayers[wrapperId] || [];
                    // 다른 레이어 선택 해제
                    allLayers.forEach(l => l.classList.remove('selected'));
                    // 일반 이미지 선택도 해제
                    wrapper.classList.remove('selected');
                    const img = wrapper.querySelector('img:not(.collage-layer img)');
                    if (img) img.classList.remove('selected');
                    // 현재 레이어 선택
                    layer.classList.add('selected');
                    layer.style.cursor = 'move';

                    // 도구를 select로 자동 전환
                    const toolbar = wrapper.closest('.perspective-container').querySelector('.toolbar');
                    if (toolbar) {
                        toolbar.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                        const selectBtn = toolbar.querySelector('[onclick*="setTool(\'select\'"]');
                        if (selectBtn) {
                            setTool('select', selectBtn, parseInt(wrapperId.split('-')[1]));
                        }
                    }
                    globalTool = 'select';
                    return;
                }
                // 그리기 모드에서 수정 키가 없으면 이벤트 전파 (그리기 도구 사용)
            });

            // wrapper에 레이어 추가
            console.log(`레이어 ${index} wrapper에 추가 시도:`, {
                wrapperId: wrapper.id,
                wrapperExists: !!wrapper,
                parentElement: wrapper.parentElement?.tagName
            });
            wrapper.appendChild(layer);
            console.log(`레이어 ${index} 추가 완료. 현재 자식 요소 수:`, wrapper.children.length);

            const wrapperId = wrapper.id;
            if (!collageLayers[wrapperId]) {
                collageLayers[wrapperId] = [];
            }
            collageLayers[wrapperId].push(layer);
        }

        // 콜라주 레이어 드래그 초기화
        function initCollageLayerDrag(layer, wrapper) {
            let isDragging = false;
            let hasDragged = false; // 실제로 드래그가 발생했는지 추적
            let startX = 0;
            let startY = 0;
            let startLeft = 0;
            let startTop = 0;
            let originalLeft = 0; // 드래그 시작 시 원래 위치
            let originalTop = 0; // 드래그 시작 시 원래 위치
            let snapThreshold = 10; // 스냅 거리 (픽셀)
            let targetLayer = null; // 위치 교환 대상 레이어
            let isDoubleClick = false;

            layer.addEventListener('dblclick', (e) => {
                // 편집 버튼을 클릭한 경우 제외
                if (e.target.closest('.image-edit-btn')) {
                    return;
                }

                // 더블 클릭으로 콜라주 레이어 선택
                const wrapperId = wrapper.id;
                const currentMode = collageModeState[wrapperId] || 'draw';

                const allLayers = collageLayers[wrapperId] || [];
                // 다른 레이어 선택 해제
                allLayers.forEach(l => l.classList.remove('selected'));
                // 일반 이미지 선택도 해제
                wrapper.classList.remove('selected');
                const img = wrapper.querySelector('img:not(.collage-layer img)');
                if (img) img.classList.remove('selected');
                // 현재 레이어 선택
                layer.classList.add('selected');

                // 이동 모드일 때는 도구 상태 변경 금지
                if (currentMode !== 'move') {
                    // 모든 그리기 도구 비활성화
                    const toolbar = wrapper.closest('.perspective-container').querySelector('.toolbar');
                    if (toolbar) {
                        toolbar.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                        const selectBtn = toolbar.querySelector('[onclick*="setTool(\'select\'"]');
                        if (selectBtn) {
                            setTool('select', selectBtn, parseInt(wrapper.id.split('-')[1]));
                        }
                    }
                }

                e.stopPropagation();
            });

            layer.addEventListener('mousedown', (e) => {
                // 편집 버튼을 클릭한 경우 드래그하지 않음
                if (e.target.closest('.image-edit-btn')) {
                    return;
                }

                const wrapperId = wrapper.id;
                const currentMode = collageModeState[wrapperId] || 'draw';
                const isSelected = layer.classList.contains('selected');
                const isModifierPressed = e.shiftKey || e.ctrlKey || e.metaKey;

                // [IMPROVED] 모드에 따른 완전히 분리된 동작
                if (currentMode === 'move') {
                    // === 이동 모드: Shift/Ctrl 키 없이 바로 드래그 가능 ===
                    e.stopPropagation();

                    // 모든 레이어 선택 해제
                    const allLayers = collageLayers[wrapperId] || [];
                    allLayers.forEach(l => l.classList.remove('selected'));
                    wrapper.classList.remove('selected');
                    const img = wrapper.querySelector('img:not(.collage-layer img)');
                    if (img) img.classList.remove('selected');

                    // 현재 레이어 선택
                    layer.classList.add('selected');
                    layer.style.cursor = 'move';

                    // 드래그 시작 (아래의 드래그 로직 실행)
                    isDragging = true;
                    hasDragged = false;
                    layer.dataset.dragJustEnded = 'false';
                    layer.classList.add('dragging');
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = layer.getBoundingClientRect();
                    const wrapperRect = wrapper.getBoundingClientRect();
                    startLeft = rect.left - wrapperRect.left;
                    startTop = rect.top - wrapperRect.top;
                    originalLeft = startLeft;
                    originalTop = startTop;
                    targetLayer = null;
                    e.preventDefault();
                } else if (currentMode === 'draw') {
                    // === 그리기/텍스트 모드: Shift/Ctrl 키 필수로 드래그 ===
                    if (!isModifierPressed && !isSelected) {
                        // 수정 키 없고 선택되지 않은 상태 -> 그리기 도구 사용 (이벤트 전파)
                        return;
                    }

                    // Shift/Ctrl 키가 있거나 이미 선택된 레이어만 드래그 가능
                    e.stopPropagation();

                    // 모든 레이어 선택 해제
                    const allLayers = collageLayers[wrapperId] || [];
                    allLayers.forEach(l => l.classList.remove('selected'));
                    wrapper.classList.remove('selected');
                    const img = wrapper.querySelector('img:not(.collage-layer img)');
                    if (img) img.classList.remove('selected');

                    // 현재 레이어 선택
                    layer.classList.add('selected');
                    layer.style.cursor = 'move';

                    // 드래그 시작
                    isDragging = true;
                    hasDragged = false;
                    layer.dataset.dragJustEnded = 'false';
                    layer.classList.add('dragging');
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = layer.getBoundingClientRect();
                    const wrapperRect = wrapper.getBoundingClientRect();
                    startLeft = rect.left - wrapperRect.left;
                    startTop = rect.top - wrapperRect.top;
                    originalLeft = startLeft;
                    originalTop = startTop;
                    targetLayer = null;
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const wrapperRect = wrapper.getBoundingClientRect();
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                // 작은 이동이라도 발생하면 드래그로 간주
                if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
                    hasDragged = true;
                }

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // 경계 체크
                const layerWidth = parseFloat(layer.style.width);
                const layerHeight = parseFloat(layer.style.height);
                newLeft = Math.max(0, Math.min(newLeft, wrapperRect.width - layerWidth));
                newTop = Math.max(0, Math.min(newTop, wrapperRect.height - layerHeight));

                // 다른 레이어들과의 스냅 및 위치 교환 체크
                const wrapperId = wrapper.id;
                const otherLayers = collageLayers[wrapperId] || [];

                let snappedLeft = newLeft;
                let snappedTop = newTop;
                let newTargetLayer = null;

                // 현재 드래그 중인 레이어의 중심점 및 경계
                const currentCenterX = newLeft + layerWidth / 2;
                const currentCenterY = newTop + layerHeight / 2;
                const currentTop = newTop;
                const currentBottom = newTop + layerHeight;
                const currentLeft = newLeft;
                const currentRight = newLeft + layerWidth;

                // 좌우 중간 배치를 위한 변수
                let leftLayer = null;
                let rightLayer = null;
                let leftLayerRight = -Infinity;
                let rightLayerLeft = Infinity;

                // 상하 중간 배치를 위한 변수
                let topLayer = null;
                let bottomLayer = null;
                let topLayerBottom = -Infinity;
                let bottomLayerTop = Infinity;

                otherLayers.forEach(otherLayer => {
                    if (otherLayer === layer) return;

                    const otherLeft = parseFloat(otherLayer.style.left) || 0;
                    const otherTop = parseFloat(otherLayer.style.top) || 0;
                    const otherWidth = parseFloat(otherLayer.style.width) || 0;
                    const otherHeight = parseFloat(otherLayer.style.height) || 0;
                    const otherRight = otherLeft + otherWidth;
                    const otherBottom = otherTop + otherHeight;
                    const otherCenterX = otherLeft + otherWidth / 2;
                    const otherCenterY = otherTop + otherHeight / 2;

                    // 위치 교환 체크: 드래그 중인 레이어의 중심이 다른 레이어 위에 있는지
                    if (currentCenterX >= otherLeft && currentCenterX <= otherRight &&
                        currentCenterY >= otherTop && currentCenterY <= otherBottom) {
                        newTargetLayer = otherLayer;
                    }

                    // 좌우 중간 배치 체크: Y 좌표가 겹치는 범위에 있고, X 좌표가 좌우에 있는지
                    const yOverlap = !(currentBottom <= otherTop || currentTop >= otherBottom);
                    if (yOverlap) {
                        // 왼쪽에 있는 이미지
                        if (otherRight < currentCenterX && otherRight > leftLayerRight) {
                            leftLayer = otherLayer;
                            leftLayerRight = otherRight;
                        }
                        // 오른쪽에 있는 이미지
                        if (otherLeft > currentCenterX && otherLeft < rightLayerLeft) {
                            rightLayer = otherLayer;
                            rightLayerLeft = otherLeft;
                        }
                    }

                    // 상하 중간 배치 체크: X 좌표가 겹치는 범위에 있고, Y 좌표가 상하에 있는지
                    const xOverlap = !(currentRight <= otherLeft || currentLeft >= otherRight);
                    if (xOverlap) {
                        // 위에 있는 이미지
                        if (otherBottom < currentCenterY && otherBottom > topLayerBottom) {
                            topLayer = otherLayer;
                            topLayerBottom = otherBottom;
                        }
                        // 아래에 있는 이미지
                        if (otherTop > currentCenterY && otherTop < bottomLayerTop) {
                            bottomLayer = otherLayer;
                            bottomLayerTop = otherTop;
                        }
                    }

                    // 스냅 체크: 외곽 사면 정렬
                    // 왼쪽 정렬
                    if (Math.abs(newLeft - otherLeft) < snapThreshold) {
                        snappedLeft = otherLeft;
                    }
                    // 오른쪽 정렬
                    if (Math.abs((newLeft + layerWidth) - (otherLeft + otherWidth)) < snapThreshold) {
                        snappedLeft = otherLeft + otherWidth - layerWidth;
                    }
                    // 위 정렬
                    if (Math.abs(newTop - otherTop) < snapThreshold) {
                        snappedTop = otherTop;
                    }
                    // 아래 정렬
                    if (Math.abs((newTop + layerHeight) - (otherTop + otherHeight)) < snapThreshold) {
                        snappedTop = otherTop + otherHeight - layerHeight;
                    }

                    // 추가 스냅: 왼쪽-오른쪽 정렬
                    if (Math.abs(newLeft - (otherLeft + otherWidth)) < snapThreshold) {
                        snappedLeft = otherLeft + otherWidth;
                    }
                    if (Math.abs((newLeft + layerWidth) - otherLeft) < snapThreshold) {
                        snappedLeft = otherLeft - layerWidth;
                    }
                    // 위-아래 정렬
                    if (Math.abs(newTop - (otherTop + otherHeight)) < snapThreshold) {
                        snappedTop = otherTop + otherHeight;
                    }
                    if (Math.abs((newTop + layerHeight) - otherTop) < snapThreshold) {
                        snappedTop = otherTop - layerHeight;
                    }
                });

                // 좌우 중간 배치: 좌우에 이미지가 있으면 중간에 배치
                if (leftLayer && rightLayer) {
                    const leftRight = parseFloat(leftLayer.style.left) + parseFloat(leftLayer.style.width);
                    const rightLeft = parseFloat(rightLayer.style.left);
                    const middleX = (leftRight + rightLeft) / 2;
                    snappedLeft = middleX - layerWidth / 2;
                }

                // 상하 중간 배치: 상하에 이미지가 있으면 중간에 배치
                if (topLayer && bottomLayer) {
                    const topBottom = parseFloat(topLayer.style.top) + parseFloat(topLayer.style.height);
                    const bottomTop = parseFloat(bottomLayer.style.top);
                    const middleY = (topBottom + bottomTop) / 2;
                    snappedTop = middleY - layerHeight / 2;
                }

                // 경계 재체크 (스냅 후)
                snappedLeft = Math.max(0, Math.min(snappedLeft, wrapperRect.width - layerWidth));
                snappedTop = Math.max(0, Math.min(snappedTop, wrapperRect.height - layerHeight));

                layer.style.left = snappedLeft + 'px';
                layer.style.top = snappedTop + 'px';

                // 위치 교환 대상 업데이트
                if (newTargetLayer !== targetLayer) {
                    targetLayer = newTargetLayer;
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    const wasDragging = hasDragged;
                    isDragging = false;
                    hasDragged = false;
                    layer.classList.remove('dragging');

                    // 드래그가 발생했으면 click 이벤트를 방지하기 위해 짧은 지연 후 플래그 리셋
                    if (wasDragging) {
                        setTimeout(() => {
                            layer.dataset.dragJustEnded = 'false';
                        }, 100);
                    } else {
                        layer.dataset.dragJustEnded = 'false';
                    }

                    // 위치 교환: 다른 레이어 위에 있으면 기존 이미지를 빈 공간(원래 위치)으로 이동
                    if (targetLayer) {
                        const layerLeft = parseFloat(layer.style.left) || 0;
                        const layerTop = parseFloat(layer.style.top) || 0;

                        // 드래그 중인 레이어는 현재 위치에 유지
                        // 기존 레이어(타겟)는 드래그 중인 레이어의 원래 위치로 이동
                        targetLayer.style.left = originalLeft + 'px';
                        targetLayer.style.top = originalTop + 'px';

                        // 드래그 중인 레이어는 타겟 레이어의 위치로 이동 (스냅된 위치 유지)
                        layer.style.left = layerLeft + 'px';
                        layer.style.top = layerTop + 'px';

                        targetLayer = null;
                    }

                    // 위치 변경 시 레이어는 그대로 유지 (드래그 가능하게)
                    // Canvas 재렌더링은 저장 시에만 수행
                    // const originalImg = wrapper.querySelector('img:not(.collage-layer img)');
                    // if (originalImg) {
                    //     renderCollageFromLayers(wrapper, originalImg);
                    // }
                }
            });
        }

        // 레이어에서 Canvas로 렌더링
        function renderCollageFromLayers(wrapper, originalImg) {
            const wrapperRect = wrapper.getBoundingClientRect();
            const wrapperWidth = wrapperRect.width;
            const wrapperHeight = wrapperRect.height;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = wrapperWidth;
            canvas.height = wrapperHeight;

            // 배경을 검은색으로
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 모든 레이어를 Canvas에 그리기
            const wrapperId = wrapper.id;
            if (collageLayers[wrapperId]) {
                collageLayers[wrapperId].forEach(layer => {
                    const img = layer.querySelector('img');
                    if (img && img.complete) {
                        const x = parseFloat(layer.style.left);
                        const y = parseFloat(layer.style.top);
                        const width = parseFloat(layer.style.width);
                        const height = parseFloat(layer.style.height);

                        // 회전 및 반전 상태 가져오기
                        const rotation = parseInt(img.dataset.rotation || '0');
                        const flipH = parseFloat(img.dataset.flipH || '1');
                        const flipV = parseFloat(img.dataset.flipV || '1');

                        ctx.save();

                        // 회전 및 반전을 위한 변환
                        const centerX = x + width / 2;
                        const centerY = y + height / 2;
                        ctx.translate(centerX, centerY);
                        ctx.rotate((rotation * Math.PI) / 180);
                        ctx.scale(flipH, flipV);

                        // 이미지 그리기 (중심 기준으로 그리기 위해 음수 오프셋 사용)
                        ctx.drawImage(img, -width / 2, -height / 2, width, height);

                        ctx.restore();
                    }
                });
            }

            // Canvas를 이미지로 교체 (선택 압축률 적용)
            try {
                const q = getCompressionQuality();
                const dataUrl = canvas.toDataURL('image/jpeg', q);
                originalImg.src = dataUrl;
                originalImg.setAttribute('data-original-src', dataUrl);
            } catch (e) {
                const dataUrl = canvas.toDataURL('image/png');
                originalImg.src = dataUrl;
                originalImg.setAttribute('data-original-src', dataUrl);
            }
            originalImg.setAttribute('data-rotation', '0');
            originalImg.setAttribute('data-flip-h', '1');
            originalImg.setAttribute('data-flip-v', '1');
            originalImg.removeAttribute('data-vertical');
            originalImg.style.objectPosition = 'center center';
            updateImageTransform(originalImg);

            // 레이어가 있을 때는 원본 이미지를 숨기고 레이어를 표시
            if (collageLayers[wrapperId] && collageLayers[wrapperId].length > 0) {
                originalImg.style.display = 'none';
                collageLayers[wrapperId].forEach(layer => {
                    layer.style.display = 'block';
                    layer.style.visibility = 'visible';
                    layer.style.pointerEvents = 'auto';
                    layer.style.zIndex = '40'; /* 그리기 레이어(z-index: 70)와 텍스트 레이어(z-index: 70)보다 아래에 위치 */
                });
            } else {
                originalImg.style.display = 'block';
            }
        }

        // 최적의 그리드 레이아웃 계산
        function calculateOptimalGrid(imageCount, availableWidth, availableHeight, gap) {
            let bestLayout = { cols: 1, rows: 1, score: 0 };

            // 가능한 모든 그리드 조합 시도
            for (let cols = 1; cols <= imageCount; cols++) {
                const rows = Math.ceil(imageCount / cols);
                if (rows * cols < imageCount) continue; // 이미지 수보다 적으면 스킵

                // 각 셀의 크기 계산
                const cellWidth = (availableWidth - (gap * (cols - 1))) / cols;
                const cellHeight = (availableHeight - (gap * (rows - 1))) / rows;

                // 사용률 계산 (이미지 영역을 얼마나 채우는지)
                const totalUsedWidth = cols * cellWidth + gap * (cols - 1);
                const totalUsedHeight = rows * cellHeight + gap * (rows - 1);
                const usageRatio = (totalUsedWidth * totalUsedHeight) / (availableWidth * availableHeight);

                // 가로세로 비율이 영역 비율에 가까울수록 좋음
                const areaRatio = availableWidth / availableHeight;
                const gridRatio = cols / rows;
                const ratioScore = 1 - Math.abs(areaRatio - gridRatio) / Math.max(areaRatio, gridRatio);

                // 종합 점수 (사용률 + 비율 점수)
                let score = usageRatio * 0.7 + ratioScore * 0.3;
                // 다중 이미지 배치 시 '열 수'가 짝수인 구성을 우선
                if (imageCount > 1 && (cols % 2) === 1) {
                    // 홀수 열에는 소폭 패널티 적용
                    score = score * 0.88;
                }

                if (score > bestLayout.score) {
                    bestLayout = { cols, rows, score, cellWidth, cellHeight };
                }
            }

            // 추가 보정: 가능한 경우 짝수 열 구성을 강제로 선택 (이미지 여러 장일 때)
            if (imageCount > 1 && (bestLayout.cols % 2) === 1) {
                const tryPlus = bestLayout.cols + 1 <= imageCount ? bestLayout.cols + 1 : null;
                const tryMinus = bestLayout.cols - 1 >= 1 ? bestLayout.cols - 1 : null;
                let altCols = null;
                if (tryPlus) altCols = tryPlus; else if (tryMinus) altCols = tryMinus;
                if (altCols) {
                    const rows = Math.ceil(imageCount / altCols);
                    const cellWidth = (availableWidth - (gap * (altCols - 1))) / altCols;
                    const cellHeight = (availableHeight - (gap * (rows - 1))) / rows;
                    bestLayout.cols = altCols;
                    bestLayout.rows = rows;
                    bestLayout.cellWidth = cellWidth;
                    bestLayout.cellHeight = cellHeight;
                }
            }

            return bestLayout;
        }

        // 콜라주 렌더링
        function renderCollage(canvas, ctx, images, gap, wrapper, originalImg) {
            // wrapper 크기 가져오기
            const wrapperRect = wrapper.getBoundingClientRect();
            const wrapperWidth = wrapperRect.width;
            const wrapperHeight = wrapperRect.height;

            // 상하좌우 여백 설정 (최소화하여 영역 최대 활용)
            const padding = gap;
            const availableWidth = wrapperWidth - (padding * 2);
            const availableHeight = wrapperHeight - (padding * 2);

            // 최적의 그리드 레이아웃 계산
            const grid = calculateOptimalGrid(images.length, availableWidth, availableHeight, gap);

            // Canvas 크기 설정 (wrapper 크기와 정확히 일치)
            canvas.width = wrapperWidth;
            canvas.height = wrapperHeight;

            // 배경을 검은색으로
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 그리드가 가용 영역을 최대한 채우도록 스케일 계산
            const totalGridWidth = grid.cols * grid.cellWidth + gap * (grid.cols - 1);
            const totalGridHeight = grid.rows * grid.cellHeight + gap * (grid.rows - 1);

            // 가용 영역에 맞추기 위한 스케일 계산
            const scaleX = availableWidth / totalGridWidth;
            const scaleY = availableHeight / totalGridHeight;
            const scale = Math.min(scaleX, scaleY); // 비율 유지하면서 최대한 크게

            // 스케일 적용된 셀 크기
            const scaledCellWidth = grid.cellWidth * scale;
            const scaledCellHeight = grid.cellHeight * scale;
            const scaledGap = gap * scale;

            // 스케일 적용된 그리드 크기
            const scaledGridWidth = grid.cols * scaledCellWidth + scaledGap * (grid.cols - 1);
            const scaledGridHeight = grid.rows * scaledCellHeight + scaledGap * (grid.rows - 1);

            // 그리드 시작 위치 계산 (중앙 정렬, 경계 내부에 위치하도록 보장)
            const startX = Math.max(padding, padding + (availableWidth - scaledGridWidth) / 2);
            const startY = Math.max(padding, padding + (availableHeight - scaledGridHeight) / 2);

            // 각 이미지를 그리드에 배치
            images.forEach((item, index) => {
                const row = Math.floor(index / grid.cols);
                const col = index % grid.cols;

                // 셀 위치 계산 (경계 체크)
                const cellX = Math.max(padding, startX + col * (scaledCellWidth + scaledGap));
                const cellY = Math.max(padding, startY + row * (scaledCellHeight + scaledGap));

                // 셀 크기 (경계를 넘지 않도록 보정)
                const actualCellWidth = Math.min(scaledCellWidth, wrapperWidth - cellX - padding);
                const actualCellHeight = Math.min(scaledCellHeight, wrapperHeight - cellY - padding);

                // 이미지 비율을 무시하고 셀을 완전히 채우도록 조정 (fill 방식)
                // 이미지 전체를 셀 크기에 맞춰서 늘리거나 줄여서 셀을 완전히 채움
                ctx.drawImage(
                    item.img,
                    0, 0, item.width, item.height, // 소스 영역 (이미지 전체)
                    cellX, cellY, actualCellWidth, actualCellHeight // 대상 영역 (셀 전체, 경계 내부)
                );
            });

            // 콜라주 이미지를 원본 이미지로 교체 (선택 압축률 적용)
            try {
                const q = getCompressionQuality();
                const dataUrl = canvas.toDataURL('image/jpeg', q);
                originalImg.src = dataUrl;
                originalImg.setAttribute('data-original-src', dataUrl);
            } catch (e) {
                const dataUrl = canvas.toDataURL('image/png');
                originalImg.src = dataUrl;
                originalImg.setAttribute('data-original-src', dataUrl);
            }
            originalImg.setAttribute('data-rotation', '0');
            originalImg.setAttribute('data-flip-h', '1');
            originalImg.setAttribute('data-flip-v', '1');
            originalImg.removeAttribute('data-vertical');
            originalImg.style.objectPosition = 'center center';
            updateImageTransform(originalImg);
        }

        // 이미지 변환 업데이트 함수
        function updateImageTransform(img) {
            const rotation = parseInt(img.getAttribute('data-rotation') || '0');
            const flipH = parseFloat(img.getAttribute('data-flip-h') || '1');
            const flipV = parseFloat(img.getAttribute('data-flip-v') || '1');

            let transform = `rotate(${rotation}deg) scaleX(${flipH}) scaleY(${flipV})`;
            img.style.transform = transform;
            img.style.transformOrigin = 'center center';
        }

        // 이미지 선택
        let selectedImageId = null;
        function selectImage(id, event) {
            if (event && event.target && event.target.closest && event.target.closest('.image-edit-btn')) return;

            const wrapper = document.getElementById(`wrapper-${id}`);
            if (!wrapper) return;

            // 클릭된 요소가 콜라주 레이어인지 확인
            const clickedLayer = event && event.target ? event.target.closest('.collage-layer') : null;

            if (clickedLayer) {
                // 콜라주 레이어 선택
                const wrapperId = wrapper.id;
                const allLayers = collageLayers[wrapperId] || [];
                // 다른 레이어 선택 해제
                allLayers.forEach(l => l.classList.remove('selected'));
                document.querySelectorAll('.image-wrapper').forEach(w => {
                    w.classList.remove('selected');
                    const img = w.querySelector('img:not(.collage-layer img)');
                    if (img) img.classList.remove('selected');
                });
                // 현재 레이어 선택
                clickedLayer.classList.add('selected');
                selectedImageId = id;
            } else {
                // 일반 이미지 선택
                // 다른 이미지 선택 해제
                document.querySelectorAll('.image-wrapper').forEach(w => {
                    w.classList.remove('selected');
                    const img = w.querySelector('img:not(.collage-layer img)');
                    if (img) img.classList.remove('selected');
                });
                document.querySelectorAll('.collage-layer').forEach(l => l.classList.remove('selected'));

                // 현재 이미지 선택
                wrapper.classList.add('selected');
                const img = wrapper.querySelector('img:not(.collage-layer img)');
                if (img) {
                    img.classList.add('selected');
                    selectedImageId = id;
                }
            }
        }

        // 이미지 삭제 (해당 섹션에만 종속, 다른 섹션에 영향 없음)
        function deleteImage(id) {
            if (confirm('이미지를 삭제하시겠습니까?')) {
                const wrapper = document.getElementById(`wrapper-${id}`);
                if (!wrapper) return;

                // 콜라주 레이어가 있는 경우 제거
                const wrapperId = wrapper.id;
                if (collageLayers[wrapperId] && collageLayers[wrapperId].length > 0) {
                    collageLayers[wrapperId].forEach(layer => layer.remove());
                    collageLayers[wrapperId] = [];
                }

                // 기존 콜라주 레이어들도 제거
                wrapper.querySelectorAll('.collage-layer').forEach(layer => layer.remove());

                // 일반 이미지 초기화
                const img = wrapper.querySelector('img:not(.collage-layer img)');
                if (img) {
                    // placeholder 이미지로 복원
                    const placeholderSrc = 'https://placehold.co/600x400?text=No+Image';
                    img.src = placeholderSrc;
                    img.setAttribute('data-original-src', placeholderSrc);
                    img.setAttribute('data-rotation', '0');
                    img.setAttribute('data-flip-h', '1');
                    img.setAttribute('data-flip-v', '1');
                    img.style.display = 'block';
                    img.style.visibility = 'visible';
                    img.style.pointerEvents = 'auto';
                    img.style.zIndex = '1';
                    img.removeAttribute('data-vertical');
                    img.removeAttribute('data-horizontal');
                    img.style.objectPosition = 'center center';
                    updateImageTransform(img);
                }

                // 이미지 선택 해제
                wrapper.classList.remove('selected');
                if (img) img.classList.remove('selected');
                selectedImageId = null;
            }
        }

        // 이미지 회전
        function rotateImage(id, angle) {
            const wrapper = document.getElementById(`wrapper-${id}`);
            const img = wrapper.querySelector('img:not(.collage-layer img)');
            if (!img) return;

            // 콜라주 레이어가 있는 경우 선택된 레이어 회전
            const wrapperId = `wrapper-${id}`;
            const selectedLayer = wrapper.querySelector('.collage-layer.selected');
            if (selectedLayer) {
                const layerImg = selectedLayer.querySelector('img');
                if (layerImg) {
                    const currentRotation = parseInt(layerImg.dataset.rotation || '0');
                    const newRotation = (currentRotation + angle) % 360;
                    layerImg.dataset.rotation = newRotation;

                    const currentFlipH = parseFloat(layerImg.dataset.flipH || '1');
                    const currentFlipV = parseFloat(layerImg.dataset.flipV || '1');
                    layerImg.style.transform = `rotate(${newRotation}deg) scaleX(${currentFlipH}) scaleY(${currentFlipV})`;
                    layerImg.style.transformOrigin = 'center center';

                    // 원본 이미지 업데이트
                    const originalImg = wrapper.querySelector('img:not(.collage-layer img)');
                    if (originalImg) {
                        renderCollageFromLayers(wrapper, originalImg);
                    }
                }
            } else {
                // 일반 이미지 회전
                const currentRotation = parseInt(img.getAttribute('data-rotation') || '0');
                const newRotation = (currentRotation + angle) % 360;
                img.setAttribute('data-rotation', newRotation.toString());
                updateImageTransform(img);
            }
        }

        // 이미지 반전
        function flipImage(id, direction) {
            const wrapper = document.getElementById(`wrapper-${id}`);
            const img = wrapper.querySelector('img:not(.collage-layer img)');
            if (!img) return;

            // 콜라주 레이어가 있는 경우 선택된 레이어 반전
            const wrapperId = `wrapper-${id}`;
            const selectedLayer = wrapper.querySelector('.collage-layer.selected');
            if (selectedLayer) {
                const layerImg = selectedLayer.querySelector('img');
                if (layerImg) {
                    const currentRotation = parseInt(layerImg.dataset.rotation || '0');
                    let currentFlipH = parseFloat(layerImg.dataset.flipH || '1');
                    let currentFlipV = parseFloat(layerImg.dataset.flipV || '1');

                    if (direction === 'horizontal') {
                        currentFlipH = currentFlipH * -1;
                        layerImg.dataset.flipH = currentFlipH;
                    } else if (direction === 'vertical') {
                        currentFlipV = currentFlipV * -1;
                        layerImg.dataset.flipV = currentFlipV;
                    }

                    layerImg.style.transform = `rotate(${currentRotation}deg) scaleX(${currentFlipH}) scaleY(${currentFlipV})`;
                    layerImg.style.transformOrigin = 'center center';

                    // 원본 이미지 업데이트
                    const originalImg = wrapper.querySelector('img:not(.collage-layer img)');
                    if (originalImg) {
                        renderCollageFromLayers(wrapper, originalImg);
                    }
                }
            } else {
                // 일반 이미지 반전
                if (direction === 'horizontal') {
                    const currentFlip = parseFloat(img.getAttribute('data-flip-h') || '1');
                    img.setAttribute('data-flip-h', (currentFlip * -1).toString());
                } else if (direction === 'vertical') {
                    const currentFlip = parseFloat(img.getAttribute('data-flip-v') || '1');
                    img.setAttribute('data-flip-v', (currentFlip * -1).toString());
                }
                updateImageTransform(img);
            }
        }

        // 이미지 드래그 이동 (일반 화면)
        function initImageDrag(id) {
            const wrapper = document.getElementById(`wrapper-${id}`);
            const img = wrapper.querySelector('img:not(.collage-layer img)');
            if (!img) return;

            // 세로/가로 이미지는 initImagePositionControl에서 처리하므로 여기서는 처리하지 않음
            if (img.getAttribute('data-vertical') === 'true' || img.getAttribute('data-horizontal') === 'true') {
                return;
            }

            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let startPosition = '';

            img.addEventListener('mousedown', (e) => {
                if (e.target.closest('.image-edit-btn')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startPosition = img.style.objectPosition || 'center center';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                const wrapperRect = wrapper.getBoundingClientRect();

                const match = startPosition.match(/(\d+)%\s+(\d+)%/);
                let currentX = match ? parseInt(match[1]) : 50;
                let currentY = match ? parseInt(match[2]) : 50;

                const percentageX = Math.max(0, Math.min(100, currentX + (deltaX / wrapperRect.width) * 100));
                const percentageY = Math.max(0, Math.min(100, currentY + (deltaY / wrapperRect.height) * 100));

                img.style.objectPosition = `${percentageX}% ${percentageY}%`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                }
            });
        }

        // 자르기 모드 시작
        let cropState = {};
        function startCrop(id) {
            const wrapper = document.getElementById(`wrapper-${id}`);
            if (!wrapper) return;

            const overlay = document.getElementById(`crop-overlay-${id}`);
            const selection = document.getElementById(`crop-selection-${id}`);
            if (!overlay || !selection) return;

            // 콜라주 레이어가 있는 경우 선택된 레이어 자르기
            const selectedLayer = wrapper.querySelector('.collage-layer.selected');
            if (selectedLayer) {
                // 콜라주 레이어는 자르기 불가 (이미 개별 이미지이므로)
                alert('콜라주 이미지의 개별 레이어는 자르기 기능을 사용할 수 없습니다.');
                return;
            }

            const img = wrapper.querySelector('img:not(.collage-layer img)');
            if (!img) return;

            overlay.classList.add('active');
            const wrapperRect = wrapper.getBoundingClientRect();
            const imgRect = img.getBoundingClientRect();

            // 이미지의 실제 위치와 크기 계산 (wrapper 내부에서의 상대 위치)
            const imgLeft = imgRect.left - wrapperRect.left;
            const imgTop = imgRect.top - wrapperRect.top;
            const imgWidth = imgRect.width;
            const imgHeight = imgRect.height;

            // 초기 선택 영역 설정 (이미지의 80% 크기, 이미지 영역 내부에만)
            const initWidth = Math.min(imgWidth * 0.8, imgWidth);
            const initHeight = Math.min(imgHeight * 0.8, imgHeight);
            const initLeft = imgLeft + (imgWidth - initWidth) / 2;
            const initTop = imgTop + (imgHeight - initHeight) / 2;

            cropState[id] = {
                startX: initLeft,
                startY: initTop,
                width: initWidth,
                height: initHeight,
                isDragging: false,
                dragHandle: null,
                wrapperRect: wrapperRect,
                imgLeft: imgLeft,
                imgTop: imgTop,
                imgWidth: imgWidth,
                imgHeight: imgHeight
            };

            updateCropSelection(id);
            initCropHandlers(id);
        }

        // 자르기 선택 영역 업데이트
        function updateCropSelection(id) {
            const state = cropState[id];
            if (!state) return;

            const selection = document.getElementById(`crop-selection-${id}`);
            selection.style.left = state.startX + 'px';
            selection.style.top = state.startY + 'px';
            selection.style.width = state.width + 'px';
            selection.style.height = state.height + 'px';
        }

        // 자르기 핸들러 초기화
        function initCropHandlers(id) {
            const wrapper = document.getElementById(`wrapper-${id}`);
            const overlay = document.getElementById(`crop-overlay-${id}`);
            const selection = document.getElementById(`crop-selection-${id}`);
            const state = cropState[id];

            // 선택 영역 이동
            let isMoving = false;
            let moveStartX = 0, moveStartY = 0;

            selection.addEventListener('mousedown', (e) => {
                if (e.target === selection || e.target.classList.contains('crop-handle')) return;
                isMoving = true;
                moveStartX = e.clientX - state.startX;
                moveStartY = e.clientY - state.startY;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isMoving || !cropState[id]) return;
                const wrapperRect = wrapper.getBoundingClientRect();
                const img = wrapper.querySelector('img');
                const imgRect = img.getBoundingClientRect();

                // 이미지의 실제 위치와 크기 계산 (wrapper 내부에서의 상대 위치)
                const imgLeft = imgRect.left - wrapperRect.left;
                const imgTop = imgRect.top - wrapperRect.top;
                const imgWidth = imgRect.width;
                const imgHeight = imgRect.height;

                let newX = e.clientX - moveStartX - wrapperRect.left;
                let newY = e.clientY - moveStartY - wrapperRect.top;

                // 이미지 영역 내부에만 제한
                newX = Math.max(imgLeft, Math.min(newX, imgLeft + imgWidth - state.width));
                newY = Math.max(imgTop, Math.min(newY, imgTop + imgHeight - state.height));

                state.startX = newX;
                state.startY = newY;
                updateCropSelection(id);
            });

            document.addEventListener('mouseup', () => {
                isMoving = false;
            });

            // 핸들 드래그
            const handles = selection.querySelectorAll('.crop-handle');
            handles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    state.isDragging = true;
                    state.dragHandle = handle.className.split(' ').find(c => c !== 'crop-handle');
                    const handleRect = handle.getBoundingClientRect();
                    const wrapperRect = wrapper.getBoundingClientRect();
                    state.dragStartX = e.clientX - wrapperRect.left;
                    state.dragStartY = e.clientY - wrapperRect.top;
                    state.dragStartWidth = state.width;
                    state.dragStartHeight = state.height;
                    state.dragStartLeft = state.startX;
                    state.dragStartTop = state.startY;
                });
            });

            document.addEventListener('mousemove', (e) => {
                if (!state.isDragging || !state.dragHandle) return;
                const wrapperRect = wrapper.getBoundingClientRect();
                const img = wrapper.querySelector('img');
                const imgRect = img.getBoundingClientRect();

                // 이미지의 실제 위치와 크기 계산 (wrapper 내부에서의 상대 위치)
                const imgLeft = imgRect.left - wrapperRect.left;
                const imgTop = imgRect.top - wrapperRect.top;
                const imgWidth = imgRect.width;
                const imgHeight = imgRect.height;

                const currentX = e.clientX - wrapperRect.left;
                const currentY = e.clientY - wrapperRect.top;

                const handle = state.dragHandle;
                let newLeft = state.dragStartLeft;
                let newTop = state.dragStartTop;
                let newWidth = state.dragStartWidth;
                let newHeight = state.dragStartHeight;

                if (handle.includes('e')) {
                    newWidth = Math.max(20, currentX - state.dragStartLeft);
                    // 이미지 오른쪽 경계 체크
                    if (newLeft + newWidth > imgLeft + imgWidth) {
                        newWidth = imgLeft + imgWidth - newLeft;
                    }
                }
                if (handle.includes('w')) {
                    const diff = state.dragStartLeft - currentX;
                    newLeft = Math.max(imgLeft, state.dragStartLeft - diff);
                    newWidth = Math.max(20, state.dragStartWidth + diff);
                    // 이미지 왼쪽 경계 체크
                    if (newLeft < imgLeft) {
                        newWidth = newWidth - (imgLeft - newLeft);
                        newLeft = imgLeft;
                    }
                }
                if (handle.includes('s')) {
                    newHeight = Math.max(20, currentY - state.dragStartTop);
                    // 이미지 하단 경계 체크
                    if (newTop + newHeight > imgTop + imgHeight) {
                        newHeight = imgTop + imgHeight - newTop;
                    }
                }
                if (handle.includes('n')) {
                    const diff = state.dragStartTop - currentY;
                    newTop = Math.max(imgTop, state.dragStartTop - diff);
                    newHeight = Math.max(20, state.dragStartHeight + diff);
                    // 이미지 상단 경계 체크
                    if (newTop < imgTop) {
                        newHeight = newHeight - (imgTop - newTop);
                        newTop = imgTop;
                    }
                }

                // 최종 경계 체크 (이미지 영역 내부에만 제한)
                if (newLeft < imgLeft) {
                    newWidth = newWidth - (imgLeft - newLeft);
                    newLeft = imgLeft;
                }
                if (newTop < imgTop) {
                    newHeight = newHeight - (imgTop - newTop);
                    newTop = imgTop;
                }
                if (newLeft + newWidth > imgLeft + imgWidth) {
                    newWidth = imgLeft + imgWidth - newLeft;
                }
                if (newTop + newHeight > imgTop + imgHeight) {
                    newHeight = imgTop + imgHeight - newTop;
                }

                // 최소 크기 보장
                if (newWidth < 20) newWidth = 20;
                if (newHeight < 20) newHeight = 20;

                state.startX = newLeft;
                state.startY = newTop;
                state.width = newWidth;
                state.height = newHeight;
                updateCropSelection(id);
            });

            document.addEventListener('mouseup', () => {
                state.isDragging = false;
                state.dragHandle = null;
            });
        }

        // 자르기 적용
        function applyCrop(id) {
            const wrapper = document.getElementById(`wrapper-${id}`);
            const img = wrapper.querySelector('img');
            const state = cropState[id];
            if (!state) return;

            const image = new Image();
            image.crossOrigin = 'anonymous';

            image.onload = function () {
                const wrapperRect = wrapper.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();

                // 이미지의 실제 위치와 크기 계산 (wrapper 내부에서의 상대 위치)
                const imgLeft = imgRect.left - wrapperRect.left;
                const imgTop = imgRect.top - wrapperRect.top;
                const imgWidth = imgRect.width;
                const imgHeight = imgRect.height;

                // 자르기 선택 영역이 이미지 영역 내부에 있는지 확인
                const cropLeft = Math.max(0, state.startX - imgLeft);
                const cropTop = Math.max(0, state.startY - imgTop);
                const cropRight = Math.min(imgWidth, state.startX + state.width - imgLeft);
                const cropBottom = Math.min(imgHeight, state.startY + state.height - imgTop);

                const actualCropWidth = cropRight - cropLeft;
                const actualCropHeight = cropBottom - cropTop;

                // 실제 이미지 크기 대비 선택 영역 비율 계산
                const scaleX = image.width / imgWidth;
                const scaleY = image.height / imgHeight;

                const cropX = cropLeft * scaleX;
                const cropY = cropTop * scaleY;
                const cropWidth = actualCropWidth * scaleX;
                const cropHeight = actualCropHeight * scaleY;

                // 원본 이미지에서 직접 자르기
                const finalCanvas = document.createElement('canvas');
                const finalCtx = finalCanvas.getContext('2d');
                finalCanvas.width = cropWidth;
                finalCanvas.height = cropHeight;

                // 원본 이미지에서 선택 영역만 자르기
                finalCtx.drawImage(image, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                // 자른 이미지로 교체하고 변환 상태 초기화 (압축 적용)
                try {
                    const q = getCompressionQuality();
                    const dataUrl = finalCanvas.toDataURL('image/jpeg', q);
                    img.src = dataUrl;
                    img.setAttribute('data-original-src', dataUrl);
                } catch (e) {
                    const dataUrl = finalCanvas.toDataURL('image/png');
                    img.src = dataUrl;
                    img.setAttribute('data-original-src', dataUrl);
                }
                img.setAttribute('data-rotation', '0');
                img.setAttribute('data-flip-h', '1');
                img.setAttribute('data-flip-v', '1');
                updateImageTransform(img);

                cancelCrop(id);
            };

            // 원본 이미지 소스 사용 (변환 전 원본)
            const originalSrc = img.getAttribute('data-original-src');
            if (originalSrc && originalSrc.startsWith('data:')) {
                image.src = originalSrc;
            } else {
                // 원본이 없으면 현재 이미지 사용 (변환 적용 전 원본을 찾기 위해 새 이미지 로드)
                const tempImg = new Image();
                tempImg.crossOrigin = 'anonymous';
                tempImg.onload = function () {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = tempImg.width;
                    canvas.height = tempImg.height;
                    ctx.drawImage(tempImg, 0, 0);
                    try {
                        const q = getCompressionQuality();
                        const dataUrl = canvas.toDataURL('image/jpeg', q);
                        img.setAttribute('data-original-src', dataUrl);
                        image.src = dataUrl;
                    } catch (e) {
                        const dataUrl = canvas.toDataURL('image/png');
                        img.setAttribute('data-original-src', dataUrl);
                        image.src = dataUrl;
                    }
                };
                tempImg.src = img.src;
                return;
            }
        }

        // 자르기 취소
        function cancelCrop(id) {
            const overlay = document.getElementById(`crop-overlay-${id}`);
            overlay.classList.remove('active');
            delete cropState[id];
        }
        function clearDrawings(id) {
            showConfirm('현재 화면의 모든 [그리기 도형, 선, 박스]를 삭제하시겠습니까?\n(배경 사진은 삭제되지 않습니다.)', function () {
                const svg = document.getElementById(`svg-${id}`);
                const defs = svg.querySelector('defs'); svg.innerHTML = ''; if (defs) svg.appendChild(defs);
                document.getElementById(`html-layer-${id}`).innerHTML = '';
            });
        }
        function clearDrawings(id) {
            showConfirm('현재 화면의 모든 [그리기 도형, 선, 박스]를 삭제하시겠습니까?\n(배경 사진은 삭제되지 않습니다.)', function () {
                const svg = document.getElementById(`svg-${id}`);
                const defs = svg.querySelector('defs');
                // SVG의 모든 자식 요소 제거 (defs 제외)
                while (svg.firstChild) {
                    svg.removeChild(svg.firstChild);
                }
                // defs 다시 추가 (그래디언트 등 필요한 요소)
                if (defs) {
                    svg.appendChild(defs);
                }

                // html-layer의 모든 annotation 제거
                const htmlLayer = document.getElementById(`html-layer-${id}`);
                if (htmlLayer) {
                    htmlLayer.innerHTML = '';
                }

                // 선택된 요소가 이 단계에 속한 경우 선택 해제
                if (selectedElement) {
                    const wrapper = document.getElementById(`wrapper-${id}`);
                    if (wrapper && (wrapper.contains(selectedElement) ||
                        (selectedElement.tagName && wrapper.querySelector('svg').contains(selectedElement)))) {
                        // 선택 상태 초기화
                        selectedElement.classList.remove('selected');
                        selectedElement.classList.remove('selected-svg');
                        selectedElement = null;
                        // 팝오버 닫기
                        const popover = document.getElementById('drawing-settings-popover');
                        if (popover) {
                            popover.style.display = 'none';
                        }
                    }
                }

                // 모든 선택 상태 CSS 클래스 제거
                const wrapper = document.getElementById(`wrapper-${id}`);
                if (wrapper) {
                    wrapper.querySelectorAll('.selected-svg').forEach(el => el.classList.remove('selected-svg'));
                    wrapper.querySelectorAll('.annotation.selected').forEach(el => el.classList.remove('selected'));
                }
            });
        }
        function toggleAnnotationStyle(event, btn) {
            event.stopPropagation();
            const box = btn.closest('.annotation');
            box.classList.toggle('text-only');
        }

        function createBox(layer, x, y, color) {
            const div = document.createElement('div');
            // 외곽선 색상은 toolSettings에서 가져오거나 기본값 사용
            const settings = toolSettings['box'];
            const borderColor = settings.borderColor || color;
            div.className = `annotation style-${borderColor}`;
            div.style.left = (x / 10) + '%'; div.style.top = (y / 10) + '%';
            div.style.width = '20%'; div.style.height = '15%';

            div.style.borderWidth = settings.width + 'px';
            div.style.opacity = settings.opacity / 100;
            div.style.borderStyle = settings.style;

            const fontSize = settings.fontSize || 16;
            const fontWeight = settings.fontWeight || 900;
            // 텍스트 색상은 toolSettings에서 가져오거나 기본값 사용
            const textColor = settings.textColor || '#ffffff';

            div.innerHTML = `
                <div class="annotation-text" contenteditable="true" style="font-size: ${fontSize}px; font-weight: ${fontWeight}; color: ${textColor}; -webkit-text-fill-color: ${textColor}; -webkit-text-stroke: 1.0px #000000 !important;">텍스트 입력</div>
                <div class="resize-handle"></div>
                <div class="delete-btn" onclick="this.parentElement.remove()">×</div>
                <div class="style-toggle-btn" onclick="toggleAnnotationStyle(event, this)" title="배경/테두리 켜기/끄기">T</div>
            `;
            layer.appendChild(div);

            // 텍스트 박스 내부 더블 클릭 이벤트 추가
            const textEl = div.querySelector('.annotation-text');
            textEl.addEventListener('dblclick', function (e) {
                e.stopPropagation();
                // 텍스트 입력 종료
                textEl.blur();
                // 텍스트 위치 확정 (드래그 불가 상태로 전환)
                const annotation = textEl.closest('.annotation');
                if (annotation) {
                    annotation.classList.remove('selected');
                    selectedElement = null;
                    updateSelectedElementInfo(null);
                }
                // 텍스트 아이콘 비활성화 (select 모드로 전환)
                const wrapper = layer.closest('.image-wrapper');
                if (wrapper) {
                    const wrapperId = wrapper.id.split('-')[1];
                    const toolbar = document.getElementById(`toolbar-${wrapperId}`);
                    if (toolbar) {
                        // 모든 도구 아이콘 비활성화
                        toolbar.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                        // select 모드로 전환
                        const selectBtn = toolbar.querySelector('[onclick*="setTool(\'select\'"]');
                        if (selectBtn) {
                            setTool('select', selectBtn, wrapperId);
                        }
                    }
                }
            });

            // 텍스트 박스를 선택 상태로 만들고 툴팁 열기
            setTimeout(() => {
                const textEl = div.querySelector('.annotation-text');
                textEl.focus();
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(textEl);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);

                // 텍스트 박스 선택 및 툴팁 표시
                document.querySelectorAll('.annotation.selected').forEach(a => a.classList.remove('selected'));
                document.querySelectorAll('.selected-svg').forEach(s => s.classList.remove('selected-svg'));
                div.classList.add('selected');
                selectedElement = div;
                updateSelectedElementInfo(div);

                // 툴팁 열기
                const toolbar = layer.previousElementSibling;
                if (toolbar) {
                    const wrapperId = layer.closest('.image-wrapper').id.split('-')[1];
                    const boxBtn = toolbar.querySelector('[onclick*="setTool(\'box\'"]');
                    if (boxBtn) {
                        // 약간의 지연 후 툴팁 표시 (렌더링 완료 후)
                        setTimeout(() => {
                            // setTool 함수를 호출하여 툴팁 열기
                            globalTool = 'box';
                            const popover = document.getElementById('drawing-settings-popover');
                            if (popover && toolSettings['box']) {
                                const rect = boxBtn.getBoundingClientRect();
                                // 드래그된 위치가 있으면 유지, 없으면 기본 위치
                                if (popover.style.position === 'fixed' && popover.style.left && popover.style.top) {
                                    // 이미 fixed 위치가 설정되어 있으면 유지
                                } else {
                                    let cardSection = boxBtn.closest('.step-section');
                                    popover.style.position = 'fixed';
                                    const pos = calculatePopoverPositionInCard(rect, cardSection);
                                    popover.style.left = pos.left + 'px';
                                    popover.style.top = pos.top + 'px';
                                }
                                popover.style.display = 'block';

                                // 선택된 요소 정보 표시
                                updateSelectedElementInfo(div);

                                // 텍스트 박스 설정 표시
                                const settings = toolSettings['box'];
                                let currentWidth = parseInt(div.style.borderWidth) || settings.width;
                                let currentOpacity = (parseFloat(div.style.opacity) || settings.opacity / 100) * 100;
                                let currentStyle = div.style.borderStyle || settings.style;
                                let currentFontSize = parseInt(textEl.style.fontSize) || settings.fontSize;
                                let currentFontWeight = parseInt(textEl.style.fontWeight) || settings.fontWeight;

                                // 텍스트 색상 설정 표시
                                const textColorSetting = document.getElementById('text-color-setting');
                                if (textColorSetting) {
                                    textColorSetting.style.display = 'flex';

                                    // 현재 텍스트 색상 가져오기
                                    const currentColor = window.getComputedStyle(textEl).color;
                                    const rgbToHex = (rgb) => {
                                        const match = rgb.match(/\d+/g);
                                        if (!match || match.length < 3) return '#ffffff';
                                        return '#' + match.map(x => {
                                            const hex = parseInt(x).toString(16);
                                            return hex.length === 1 ? '0' + hex : hex;
                                        }).join('');
                                    };
                                    const hexColor = rgbToHex(currentColor);

                                    // 선택된 색상 표시 (텍스트 색상 옵션만)
                                    document.querySelectorAll('.text-color-option:not(.border-color-option)').forEach(opt => {
                                        opt.classList.remove('active');
                                        const optColor = window.getComputedStyle(opt).backgroundColor;
                                        if (rgbToHex(optColor).toLowerCase() === hexColor.toLowerCase()) {
                                            opt.classList.add('active');
                                        }
                                    });
                                }

                                // 외곽선 색상 설정 표시
                                const borderColorSetting = document.getElementById('border-color-setting');
                                if (borderColorSetting) {
                                    borderColorSetting.style.display = 'flex';

                                    // 현재 외곽선 색상 가져오기
                                    const colorClasses = ['style-red', 'style-yellow', 'style-green', 'style-blue', 'style-purple', 'style-white'];
                                    let currentBorderColor = settings.borderColor || 'red';
                                    colorClasses.forEach(cls => {
                                        if (div.classList.contains(cls)) {
                                            currentBorderColor = cls.replace('style-', '');
                                        }
                                    });

                                    // 선택된 색상 표시 (외곽선 색상 옵션만)
                                    document.querySelectorAll('.border-color-option').forEach(opt => {
                                        opt.classList.remove('active');
                                        const optColor = opt.getAttribute('onclick').match(/'(\w+)'/);
                                        if (optColor && optColor[1] === currentBorderColor) {
                                            opt.classList.add('active');
                                        }
                                    });
                                }

                                // 팝업 UI 업데이트
                                const strokeInput = popover.querySelector('input[title="선 굵기"]');
                                if (strokeInput) {
                                    strokeInput.value = currentWidth;
                                    document.getElementById('val-stroke').innerText = currentWidth + 'px';
                                }

                                const opacityInput = popover.querySelector('input[title="투명도"]');
                                if (opacityInput) {
                                    opacityInput.value = currentOpacity;
                                    document.getElementById('val-opacity').innerText = currentOpacity + '%';
                                }

                                const radios = document.getElementsByName('lineStyle');
                                radios.forEach(r => { if (r.value === currentStyle) r.checked = true; });

                                const fontSizeInput = popover.querySelector('input[title="글자 크기"]');
                                const fontWeightInput = popover.querySelector('input[title="글자 굵기"]');
                                if (fontSizeInput) {
                                    fontSizeInput.value = currentFontSize;
                                    fontSizeInput.closest('.setting-item').style.display = 'flex';
                                    document.getElementById('val-fontsize').innerText = currentFontSize + 'px';
                                }
                                if (fontWeightInput) {
                                    fontWeightInput.value = currentFontWeight;
                                    fontWeightInput.closest('.setting-item').style.display = 'flex';
                                    document.getElementById('val-fontweight').innerText = currentFontWeight;
                                }
                            }
                        }, 100);
                    }
                }
            }, 0);

            initDraggable(div);
        }

        function initDraggable(el) {
            let isDragging = false, isResizing = false, startX, startY, startLeft, startTop, startW, startH;

            el.addEventListener('mousedown', e => {
                if (globalTool !== 'select' && globalTool !== 'box') return;

                if (e.target.classList.contains('annotation-text')) return;
                if (e.target.closest('.delete-btn') || e.target.closest('.style-toggle-btn')) return;

                e.stopPropagation();

                if (globalTool === 'select') {
                    document.querySelectorAll('.annotation.selected').forEach(a => a.classList.remove('selected'));
                    document.querySelectorAll('.selected-svg').forEach(s => s.classList.remove('selected-svg'));
                    el.classList.add('selected');
                    selectedElement = el;
                    // 선택된 요소 정보 업데이트
                    updateSelectedElementInfo(el);

                    // 텍스트 박스에 마우스 이벤트 추가 (중복 방지)
                    if (!el.dataset.tooltipAdded) {
                        el.addEventListener('mouseenter', function (e) {
                            if (globalTool === 'select' && selectedElement === el) {
                                showElementTooltip(e, el);
                            }
                        });
                        el.addEventListener('mousemove', function (e) {
                            if (globalTool === 'select' && selectedElement === el) {
                                showElementTooltip(e, el);
                            }
                        });
                        el.addEventListener('mouseleave', function () {
                            hideElementTooltip();
                        });
                        el.dataset.tooltipAdded = 'true';
                    }
                }

                const wrapper = el.closest('.image-wrapper');
                const rect = wrapper.getBoundingClientRect();

                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true; startX = e.clientX; startY = e.clientY;
                    startW = el.offsetWidth; startH = el.offsetHeight;
                    e.stopPropagation();
                } else {
                    isDragging = true; startX = e.clientX; startY = e.clientY;
                    startLeft = el.offsetLeft; startTop = el.offsetTop;
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            function onMouseMove(e) {
                if (isResizing) {
                    el.style.width = (startW + e.clientX - startX) + 'px';
                    el.style.height = (startH + e.clientY - startY) + 'px';
                } else if (isDragging) {
                    const wrapper = el.closest('.image-wrapper');
                    const rect = wrapper.getBoundingClientRect();

                    let nl = startLeft + e.clientX - startX, nt = startTop + e.clientY - startY;
                    if (nl < 0) nl = 0; if (nt < 0) nt = 0;
                    if (nl + el.offsetWidth > rect.width) nl = rect.width - el.offsetWidth;
                    if (nt + el.offsetHeight > rect.height) nt = rect.height - el.offsetHeight;

                    el.style.left = nl + 'px'; el.style.top = nt + 'px';
                }
            }

            function onMouseUp() {
                isDragging = false;
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
        }

        function initDrawingEvents(id) {
            const wrapper = document.getElementById(`wrapper-${id}`);
            const svg = document.getElementById(`svg-${id}`);
            const htmlLayer = document.getElementById(`html-layer-${id}`);
            let isDrawing = false, currentElement = null, startPoint = { x: 0, y: 0 }, activePolyline = null, polylinePoints = [];
            let isDraggingSvg = false, svgDragStart = { x: 0, y: 0 }, svgDragOffset = { x: 0, y: 0 };
            function getPoint(e) {
                // Prefer SVG coordinate transformation which accounts for CSS transforms,
                // devicePixelRatio and screen CTM. Fallback to bounding-rect/viewBox math.
                try {
                    if (svg && typeof svg.createSVGPoint === 'function' && svg.getScreenCTM) {
                        const pt = svg.createSVGPoint();
                        pt.x = e.clientX;
                        pt.y = e.clientY;
                        const inv = svg.getScreenCTM().inverse();
                        const transformed = pt.matrixTransform(inv);
                        return { x: transformed.x, y: transformed.y };
                    }

                    const svgRect = svg.getBoundingClientRect();
                    const viewBox = (svg && svg.viewBox && svg.viewBox.baseVal) ? svg.viewBox.baseVal : { width: 1000, height: 1000 };
                    const x = (e.clientX - svgRect.left) / svgRect.width * viewBox.width;
                    const y = (e.clientY - svgRect.top) / svgRect.height * viewBox.height;
                    return { x: x, y: y };
                } catch (err) {
                    const r = wrapper.getBoundingClientRect();
                    return { x: (e.clientX - r.left) / r.width * 1000, y: (e.clientY - r.top) / r.height * 1000 };
                }
            }

            // SVG 요소의 transform 파싱 및 적용 헬퍼 함수
            function parseTransform(element) {
                const transform = element.getAttribute('transform') || '';
                let translateX = 0, translateY = 0;
                if (transform) {
                    const match = transform.match(/translate\(([^,]+),([^)]+)\)/);
                    if (match) {
                        translateX = parseFloat(match[1]) || 0;
                        translateY = parseFloat(match[2]) || 0;
                    }
                }
                return { x: translateX, y: translateY };
            }

            function applyTransform(element, x, y) {
                element.setAttribute('transform', `translate(${x},${y})`);
            }

            wrapper.addEventListener('mousedown', e => {
                if (e.target.closest('.annotation')) return;
                if (!e.target.closest('.annotation-text')) e.preventDefault();

                if (e.target.closest('.toolbar') || e.target.closest('.delete-btn')) return;

                // 콜라주 레이어를 클릭했을 때
                const clickedCollageLayer = e.target.closest('.collage-layer');
                if (clickedCollageLayer) {
                    // [IMPROVED] 모드에 따른 완전히 분리된 동작
                    const wrapperId = wrapper.id;
                    const currentMode = collageModeState[wrapperId] || 'draw';
                    const isModifierPressed = e.shiftKey || e.ctrlKey || e.metaKey;
                    const isSelected = clickedCollageLayer.classList.contains('selected');

                    if (currentMode === 'move') {
                        // 이동 모드: 수정 키 없이 바로 드래그 가능
                        return; // 레이어의 mousedown에서 처리
                    } else if (currentMode === 'draw') {
                        // 그리기 모드: 수정 키가 있거나 이미 선택된 경우만 드래그
                        if (isModifierPressed || isSelected) {
                            return; // 레이어의 mousedown에서 처리
                        }
                        // 수정 키가 없고 선택되지 않으면 그리기 도구 사용 (이벤트 계속 진행)
                    }
                }

                if (globalTool === 'select') {
                    if (e.target === wrapper || e.target === svg || e.target.tagName === 'IMG') {
                        document.querySelectorAll('.annotation.selected').forEach(a => a.classList.remove('selected'));
                        document.querySelectorAll('.selected-svg').forEach(s => s.classList.remove('selected-svg'));
                        selectedElement = null;
                        // 정보 초기화
                        const infoSpan = document.getElementById('selected-element-info');
                        if (infoSpan) infoSpan.innerText = '';
                        hideElementTooltip();

                        // 콜라주 레이어 선택 해제
                        const wrapperId = wrapper.id;
                        const allLayers = collageLayers[wrapperId] || [];
                        allLayers.forEach(l => {
                            l.classList.remove('selected');
                            // 선택 해제 후 커서를 현재 도구에 맞게 업데이트
                            updateCollageLayerCursors(globalTool);
                        });
                        wrapper.classList.remove('selected');
                        const img = wrapper.querySelector('img:not(.collage-layer img)');
                        if (img) img.classList.remove('selected');

                        // 그리기 도구 모드로 전환 (이전 도구가 있으면 복원, 없으면 pen 도구)
                        const stepId = parseInt(wrapperId.split('-')[1]);
                        const toolbar = wrapper.closest('.perspective-container').querySelector('.toolbar');
                        if (toolbar) {
                            // 이전 도구 복원 (저장된 도구가 있으면)
                            const savedTool = wrapper.dataset.previousTool || 'pen';
                            const toolBtn = toolbar.querySelector(`[onclick*="setTool('${savedTool}'"]`);
                            if (toolBtn) {
                                setTool(savedTool, toolBtn, stepId);
                            } else {
                                // pen 도구로 전환
                                const penBtn = toolbar.querySelector('[onclick*="setTool(\'pen\'"]');
                                if (penBtn) {
                                    setTool('pen', penBtn, stepId);
                                }
                            }
                        }

                        return;
                    }
                    if (['path', 'line', 'circle', 'ellipse', 'polyline', 'rect'].includes(e.target.tagName)) {
                        document.querySelectorAll('.annotation.selected').forEach(a => a.classList.remove('selected'));
                        document.querySelectorAll('.selected-svg').forEach(s => s.classList.remove('selected-svg'));
                        e.target.classList.add('selected-svg');
                        selectedElement = e.target;

                        // SVG 드래그 시작
                        isDraggingSvg = true;
                        const p = getPoint(e);
                        const currentTransform = parseTransform(e.target);
                        svgDragStart = { x: p.x, y: p.y };
                        svgDragOffset = { x: currentTransform.x, y: currentTransform.y };

                        // 선택된 요소 정보 업데이트
                        updateSelectedElementInfo(e.target);

                        // SVG 요소에 마우스 이벤트 추가 (중복 방지)
                        if (!e.target.dataset.tooltipAdded) {
                            e.target.addEventListener('mouseenter', function (evt) {
                                if (globalTool === 'select' && selectedElement === e.target) {
                                    showElementTooltip(evt, e.target);
                                }
                            });
                            e.target.addEventListener('mousemove', function (evt) {
                                if (globalTool === 'select' && selectedElement === e.target) {
                                    showElementTooltip(evt, e.target);
                                }
                            });
                            e.target.addEventListener('mouseleave', function () {
                                hideElementTooltip();
                            });
                            e.target.dataset.tooltipAdded = 'true';
                        }

                        e.stopPropagation();
                        e.preventDefault();
                        return;
                    }
                }

                const p = getPoint(e); const color = colorMap[globalColor];

                if (globalTool === 'box') {
                    createBox(htmlLayer, p.x, p.y, globalColor);
                    // 텍스트 박스 생성 후 아이콘은 텍스트 박스 내부 더블 클릭 시 비활성화됨
                    return;
                }

                if (globalTool !== 'select') {
                    isDrawing = true; startPoint = p;

                    const settings = toolSettings[globalTool];
                    const strokeWidth = settings ? settings.width : 5;
                    const opacity = settings ? settings.opacity / 100 : 1;
                    const dashArray = (settings && settings.style === 'dashed') ? "10,5" : "none";

                    if (globalTool === 'polyline') {
                        if (!activePolyline) {
                            activePolyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
                            activePolyline.setAttribute("stroke", color);
                            activePolyline.setAttribute("stroke-width", strokeWidth);
                            activePolyline.setAttribute("opacity", opacity);
                            activePolyline.setAttribute("stroke-dasharray", dashArray);
                            activePolyline.setAttribute("fill", "none"); activePolyline.setAttribute("stroke-linecap", "round"); activePolyline.setAttribute("stroke-linejoin", "round");
                            svg.appendChild(activePolyline); polylinePoints = [[p.x, p.y]];
                        } else polylinePoints.push([p.x, p.y]);
                        updatePolyline(); isDrawing = false; return;
                    }

                    if (globalTool === 'pen') {
                        currentElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        currentElement.setAttribute("d", `M ${p.x} ${p.y}`);
                        currentElement.setAttribute("fill", "none"); currentElement.setAttribute("stroke-linecap", "round"); currentElement.setAttribute("stroke-linejoin", "round");
                    } else if (globalTool === 'circle') {
                        currentElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        currentElement.setAttribute("cx", p.x); currentElement.setAttribute("cy", p.y); currentElement.setAttribute("r", "0"); currentElement.setAttribute("fill", "none");
                    } else if (globalTool === 'ellipse') {
                        currentElement = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
                        currentElement.setAttribute("cx", p.x); currentElement.setAttribute("cy", p.y); currentElement.setAttribute("rx", "0"); currentElement.setAttribute("ry", "0"); currentElement.setAttribute("fill", "none");
                    } else if (globalTool === 'line') {
                        currentElement = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        currentElement.setAttribute("x1", p.x); currentElement.setAttribute("y1", p.y); currentElement.setAttribute("x2", p.x); currentElement.setAttribute("y2", p.y);
                    } else if (globalTool === 'arrow') {
                        currentElement = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        currentElement.setAttribute("x1", p.x); currentElement.setAttribute("y1", p.y); currentElement.setAttribute("x2", p.x); currentElement.setAttribute("y2", p.y);
                        currentElement.setAttribute("marker-end", `url(#arrowhead-${globalColor})`);
                    }
                    else if (globalTool === 'rect') {
                        currentElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        currentElement.setAttribute("x", p.x); currentElement.setAttribute("y", p.y);
                        currentElement.setAttribute("width", "0"); currentElement.setAttribute("height", "0");
                        currentElement.setAttribute("fill", "none");
                    }

                    if (currentElement) {
                        currentElement.setAttribute("stroke", color);
                        currentElement.setAttribute("stroke-width", strokeWidth);
                        currentElement.setAttribute("opacity", opacity);
                        currentElement.setAttribute("stroke-dasharray", dashArray);
                        svg.appendChild(currentElement);
                    }
                }
            });

            window.addEventListener('mousemove', e => {
                const p = getPoint(e);

                // SVG 요소 드래그 이동
                if (globalTool === 'select' && isDraggingSvg && selectedElement && selectedElement.tagName) {
                    const deltaX = p.x - svgDragStart.x;
                    const deltaY = p.y - svgDragStart.y;
                    applyTransform(selectedElement, svgDragOffset.x + deltaX, svgDragOffset.y + deltaY);
                    return;
                }

                if (globalTool === 'polyline' && activePolyline) {
                    const tmp = [...polylinePoints, [p.x, p.y]];
                    activePolyline.setAttribute("points", tmp.map(pt => pt.join(',')).join(' ')); return;
                }
                if (!isDrawing || !currentElement) return;
                if (globalTool === 'pen') {
                    const d = currentElement.getAttribute("d"); currentElement.setAttribute("d", `${d} L ${p.x} ${p.y}`);
                } else if (globalTool === 'circle') {
                    const r = Math.sqrt((p.x - startPoint.x) ** 2 + (p.y - startPoint.y) ** 2); currentElement.setAttribute("r", r);
                } else if (globalTool === 'ellipse') {
                    currentElement.setAttribute("rx", Math.abs(p.x - startPoint.x)); currentElement.setAttribute("ry", Math.abs(p.y - startPoint.y));
                } else if (globalTool === 'line' || globalTool === 'arrow') {
                    let endX = p.x, endY = p.y;
                    // 직선/화살표 그리기 중 Shift 키가 눌려있으면 직각선으로 제한
                    if ((globalTool === 'line' || globalTool === 'arrow') && e.shiftKey) {
                        const deltaX = Math.abs(p.x - startPoint.x);
                        const deltaY = Math.abs(p.y - startPoint.y);
                        // 더 큰 차이를 가진 축으로 제한
                        if (deltaX > deltaY) {
                            // 수평선 (y 좌표 고정)
                            endY = startPoint.y;
                        } else {
                            // 수직선 (x 좌표 고정)
                            endX = startPoint.x;
                        }
                    }
                    currentElement.setAttribute("x2", endX); currentElement.setAttribute("y2", endY);
                } else if (globalTool === 'rect') {
                    const w = p.x - startPoint.x; const h = p.y - startPoint.y;
                    currentElement.setAttribute("width", Math.abs(w)); currentElement.setAttribute("height", Math.abs(h));
                    if (w < 0) currentElement.setAttribute("x", p.x); if (h < 0) currentElement.setAttribute("y", p.y);
                }
            });
            window.addEventListener('mouseup', () => {
                if (globalTool !== 'polyline') {
                    isDrawing = false;
                    // 그리기 도구 완료 시 아이콘 비활성화 (select 모드로 전환)
                    if (currentElement) {
                        const toolbar = document.getElementById(`toolbar-${id}`);
                        if (toolbar) {
                            // 모든 도구 아이콘 비활성화
                            toolbar.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                            // select 모드로 전환
                            const selectBtn = toolbar.querySelector('[onclick*="setTool(\'select\'"]');
                            if (selectBtn) {
                                setTool('select', selectBtn, id);
                            }
                        }
                    }
                    currentElement = null;
                }
                if (isDraggingSvg) {
                    isDraggingSvg = false;
                }
            });
            wrapper.addEventListener('dblclick', (e) => {
                if (globalTool === 'polyline') {
                    activePolyline = null;
                    polylinePoints = [];
                    // 폴리선 완료 시 아이콘 비활성화 (select 모드로 전환)
                    const toolbar = document.getElementById(`toolbar-${id}`);
                    if (toolbar) {
                        // 모든 도구 아이콘 비활성화
                        toolbar.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                        // select 모드로 전환
                        const selectBtn = toolbar.querySelector('[onclick*="setTool(\'select\'"]');
                        if (selectBtn) {
                            setTool('select', selectBtn, id);
                        }
                    }
                }
                // 텍스트 입력 완료 처리
                if (e.target === wrapper || e.target === svg || e.target.tagName === 'IMG') {
                    // 모든 편집 중인 텍스트 박스에서 포커스 제거
                    document.querySelectorAll('.annotation-text').forEach(textEl => {
                        if (document.activeElement === textEl) {
                            textEl.blur();
                            // 선택 해제
                            const annotation = textEl.closest('.annotation');
                            if (annotation) {
                                annotation.classList.remove('selected');
                                selectedElement = null;
                                updateSelectedElementInfo(null);
                            }
                        }
                    });
                }
            });
            function updatePolyline() { if (activePolyline) activePolyline.setAttribute("points", polylinePoints.map(pt => pt.join(',')).join(' ')); }

            svg.addEventListener('dblclick', e => {
                if (globalTool === 'select' && ['path', 'line', 'circle', 'ellipse', 'polyline', 'rect'].includes(e.target.tagName)) {
                    showConfirm('이 요소를 삭제하시겠습니까?', function () { e.target.remove(); selectedElement = null; });
                }
            });
        }
        function openFullscreen(stepId, title) {
            const modal = document.getElementById('fullscreen-modal'); const content = document.getElementById('fullscreen-content');
            const titleEl = document.getElementById('fullscreen-title'); const source = document.getElementById(`wrapper-${stepId}`);
            const laser = document.getElementById('laser-pointer');

            // 현재 스크롤 위치와 섹션 정보 저장 (닫기 후 복원용)
            const stepSection = source.closest('.step-section');
            if (stepSection) {
                window.fullscreenScrollPosition = {
                    stepId: stepId,
                    sectionElement: stepSection,
                    scrollY: window.scrollY,
                    sectionTop: stepSection.getBoundingClientRect().top + window.scrollY
                };
            }

            titleEl.textContent = title + " - 전체 화면"; content.innerHTML = '';
            const clone = source.cloneNode(true); clone.id = ''; clone.style.height = '100%'; clone.style.border = 'none'; clone.style.borderRadius = '0';
            clone.querySelectorAll('.resize-handle, .delete-btn').forEach(el => el.remove());
            clone.querySelectorAll('.annotation-text').forEach(el => el.removeAttribute('contenteditable'));

            // 콜라주 이미지인지 확인 (레이어가 있거나, 원본 이미지가 숨겨져 있는 경우)
            const wrapperId = `wrapper-${stepId}`;
            const isCollage = (collageLayers[wrapperId] && collageLayers[wrapperId].length > 0) ||
                (source.querySelector('.collage-layer') !== null) ||
                (source.querySelector('img') && source.querySelector('img').style.display === 'none');

            // 콜라주 이미지인 경우 이미지에 클래스 추가하여 전체 화면을 가득 채우도록
            if (isCollage) {
                const img = clone.querySelector('img:not(.collage-layer img)');
                const layers = source.querySelectorAll('.collage-layer');

                if (layers.length > 0) {
                    // 원본 이미지는 숨김
                    if (img) {
                        img.style.display = 'none';
                    }

                    // 레이어들을 복제하고 전체 화면에 맞게 재계산하는 함수
                    const resizeCollageLayers = () => {
                        // 원본 wrapper 크기 (실제 렌더링된 크기)
                        const sourceRect = source.getBoundingClientRect();
                        const sourceWidth = sourceRect.width;
                        const sourceHeight = sourceRect.height;

                        // 전체 화면 content 크기 (하단 여백 60px 제외)
                        const contentRect = content.getBoundingClientRect();
                        const contentWidth = contentRect.width;
                        const contentHeight = contentRect.height - 60; // 하단 여백을 고려

                        // 콜라주의 실제 크기 계산 (모든 레이어를 포함한 영역)
                        let minLeft = Infinity, minTop = Infinity;
                        let maxRight = -Infinity, maxBottom = -Infinity;

                        layers.forEach(layer => {
                            const left = parseFloat(layer.style.left) || 0;
                            const top = parseFloat(layer.style.top) || 0;
                            const width = parseFloat(layer.style.width) || 0;
                            const height = parseFloat(layer.style.height) || 0;

                            minLeft = Math.min(minLeft, left);
                            minTop = Math.min(minTop, top);
                            maxRight = Math.max(maxRight, left + width);
                            maxBottom = Math.max(maxBottom, top + height);
                        });

                        const collageWidth = maxRight - minLeft;
                        const collageHeight = maxBottom - minTop;

                        // 스케일 비율 계산 (화면 비율과 관계없이 전체 화면에 가득 차도록)
                        const scaleX = contentWidth / collageWidth;
                        const scaleY = contentHeight / collageHeight;
                        const scale = Math.min(scaleX, scaleY); // 더 작은 비율 사용하여 전체 콜라주가 잘리지 않도록 맞춤 (contain)

                        // 클론된 레이어들 가져오기
                        const clonedLayers = clone.querySelectorAll('.collage-layer');

                        if (clonedLayers.length === 0) {
                            // 레이어가 없으면 복제
                            layers.forEach(layer => {
                                const layerClone = layer.cloneNode(true);
                                const layerImg = layerClone.querySelector('img');
                                const originalImg = layer.querySelector('img');
                                if (layerImg && originalImg) {
                                    // 회전 및 반전 상태 복제
                                    layerImg.dataset.rotation = originalImg.dataset.rotation || '0';
                                    layerImg.dataset.flipH = originalImg.dataset.flipH || '1';
                                    layerImg.dataset.flipV = originalImg.dataset.flipV || '1';

                                    const rotation = parseInt(layerImg.dataset.rotation);
                                    const flipH = parseFloat(layerImg.dataset.flipH);
                                    const flipV = parseFloat(layerImg.dataset.flipV);
                                    layerImg.style.transform = `rotate(${rotation}deg) scaleX(${flipH}) scaleY(${flipV})`;
                                    layerImg.style.transformOrigin = 'center center';
                                }
                                clone.appendChild(layerClone);
                            });
                        }

                        // 스케일 적용된 콜라주 크기
                        const scaledCollageWidth = collageWidth * scale;
                        const scaledCollageHeight = collageHeight * scale;

                        // 중앙 정렬을 위한 오프셋 계산 (전체 화면에 가득 차도록 중앙 정렬)
                        const offsetX = (contentWidth - scaledCollageWidth) / 2;
                        const offsetY = (contentHeight - scaledCollageHeight) / 2;

                        // 모든 레이어 재계산
                        const finalLayers = clone.querySelectorAll('.collage-layer');
                        finalLayers.forEach((layer, index) => {
                            const originalLayer = layers[index];
                            if (!originalLayer) return;

                            // 원본 레이어의 위치와 크기
                            const originalLeft = parseFloat(originalLayer.style.left) || 0;
                            const originalTop = parseFloat(originalLayer.style.top) || 0;
                            const originalWidth = parseFloat(originalLayer.style.width) || 0;
                            const originalHeight = parseFloat(originalLayer.style.height) || 0;

                            // 콜라주 기준 상대 위치 계산
                            const relativeLeft = originalLeft - minLeft;
                            const relativeTop = originalTop - minTop;

                            // 전체 화면에 맞게 스케일 적용
                            const scaledLeft = relativeLeft * scale;
                            const scaledTop = relativeTop * scale;
                            const scaledWidth = originalWidth * scale;
                            const scaledHeight = originalHeight * scale;

                            // 최종 위치 설정 (오프셋 적용, 전체 화면에 가득 차도록)
                            const finalLeft = offsetX + scaledLeft;
                            const finalTop = offsetY + scaledTop;

                            layer.style.position = 'absolute';
                            layer.style.left = finalLeft + 'px';
                            layer.style.top = finalTop + 'px';
                            layer.style.width = scaledWidth + 'px';
                            layer.style.height = scaledHeight + 'px';
                            layer.style.display = 'block';
                            layer.style.visibility = 'visible';
                            layer.style.pointerEvents = 'auto';
                            layer.style.zIndex = '40'; /* 그리기 레이어(z-index: 70)와 텍스트 레이어(z-index: 70)보다 아래에 위치 */
                            layer.style.overflow = 'hidden';
                        });
                    };

                    // 초기 레이어 복제 및 배치
                    resizeCollageLayers();
                } else if (img) {
                    // 레이어가 없지만 콜라주 이미지인 경우 (Canvas로 렌더링된 이미지)
                    img.classList.add('collage-image');
                }
            }

            // 이미지 편집 컨트롤 추가 (전체 화면 모드에서는 제거됨)
            // 전체 화면 모드에서는 이미지 편집 메뉴를 표시하지 않음

            // 전체 화면용 자르기 오버레이 생성 (일반 이미지인 경우)
            if (!isCollage) {
                const cropOverlay = document.createElement('div');
                cropOverlay.className = 'crop-overlay';
                cropOverlay.id = `fullscreen-crop-overlay-${stepId}`;
                cropOverlay.innerHTML = `
                    <div class="crop-selection" id="fullscreen-crop-selection-${stepId}">
                        <div class="crop-handle nw"></div>
                        <div class="crop-handle ne"></div>
                        <div class="crop-handle sw"></div>
                        <div class="crop-handle se"></div>
                        <div class="crop-handle n"></div>
                        <div class="crop-handle s"></div>
                        <div class="crop-handle w"></div>
                        <div class="crop-handle e"></div>
                    </div>
                    <div class="crop-controls">
                        <button class="crop-control-btn" onclick="applyCropFullscreen(${stepId})">적용</button>
                        <button class="crop-control-btn cancel" onclick="cancelCropFullscreen(${stepId})">취소</button>
                    </div>
                `;
                clone.appendChild(cropOverlay);
            }

            // 전체 화면에서 이미지 선택 기능 추가
            clone.addEventListener('click', (e) => {
                if (!e.target.closest('.image-edit-btn') && !e.target.closest('.collage-layer')) {
                    selectImageFullscreen(stepId, e);
                }
            });

            // 일반 이미지 드래그 이동 기능 (전체 화면용)
            if (!isCollage) {
                const fullscreenImg = clone.querySelector('img:not(.collage-layer img)');
                if (fullscreenImg) {
                    initFullscreenImageDrag(fullscreenImg, clone, source, stepId);
                }
            }

            content.appendChild(clone); modal.style.display = 'flex'; laser.style.display = 'block';

            // 콜라주 레이어에 드래그 및 선택 기능 활성화 (전체 화면용)
            if (isCollage) {
                setTimeout(() => {
                    const fullscreenLayers = clone.querySelectorAll('.collage-layer');
                    const sourceLayers = source.querySelectorAll('.collage-layer');
                    fullscreenLayers.forEach((layer, index) => {
                        if (sourceLayers[index]) {
                            initCollageLayerDragFullscreen(layer, clone, source, stepId, index);
                            // 레이어 선택 기능 추가
                            layer.addEventListener('click', (e) => {
                                // 편집 버튼을 클릭한 경우 선택하지 않음
                                if (e.target.closest('.image-edit-btn')) {
                                    return;
                                }

                                // 드래그가 발생했으면 click 이벤트 무시
                                if (layer.dataset.dragJustEnded === 'true') {
                                    return;
                                }

                                // Ctrl 키가 눌려있을 때만 선택
                                if (!e.ctrlKey && !e.metaKey) {
                                    // Ctrl 키 없이 클릭하면 선택하지 않음 (그리기 도구 사용)
                                    return;
                                }

                                // 다른 레이어 선택 해제
                                fullscreenLayers.forEach(l => l.classList.remove('selected'));
                                // 현재 레이어 선택
                                layer.classList.add('selected');
                                // 원본 레이어도 선택
                                sourceLayers.forEach(l => l.classList.remove('selected'));
                                sourceLayers[index].classList.add('selected');
                                e.stopPropagation(); // 선택 후 이벤트 전파 중지
                            });
                        }
                    });
                }, 150);
            }

            // 콜라주 이미지인 경우 레이어들이 제대로 표시되도록 약간의 지연 후 재계산
            if (isCollage) {
                setTimeout(() => {
                    const layers = clone.querySelectorAll('.collage-layer');
                    const sourceLayers = source.querySelectorAll('.collage-layer');
                    if (layers.length > 0 && sourceLayers.length > 0) {
                        const contentRect = content.getBoundingClientRect();
                        const contentWidth = contentRect.width;
                        // 하단 여백을 고려한 실제 사용 가능한 높이 (60px 여백)
                        const contentHeight = contentRect.height - 60;

                        // 콜라주의 실제 크기 계산
                        let minLeft = Infinity, minTop = Infinity;
                        let maxRight = -Infinity, maxBottom = -Infinity;

                        sourceLayers.forEach(layer => {
                            const left = parseFloat(layer.style.left) || 0;
                            const top = parseFloat(layer.style.top) || 0;
                            const width = parseFloat(layer.style.width) || 0;
                            const height = parseFloat(layer.style.height) || 0;

                            minLeft = Math.min(minLeft, left);
                            minTop = Math.min(minTop, top);
                            maxRight = Math.max(maxRight, left + width);
                            maxBottom = Math.max(maxBottom, top + height);
                        });

                        const collageWidth = maxRight - minLeft;
                        const collageHeight = maxBottom - minTop;

                        // 스케일 비율 계산 (화면 비율과 관계없이 전체 화면에 가득 차도록, 하단 여백 제외)
                        const scaleX = contentWidth / collageWidth;
                        const scaleY = contentHeight / collageHeight;
                        const scale = Math.min(scaleX, scaleY); // 더 작은 비율 사용하여 전체 콜라주가 잘리지 않도록 맞춤 (contain)

                        // 스케일 적용된 콜라주 크기
                        const scaledCollageWidth = collageWidth * scale;
                        const scaledCollageHeight = collageHeight * scale;

                        // 중앙 정렬을 위한 오프셋 계산 (전체 화면에 가득 차도록 중앙 정렬)
                        const offsetX = (contentWidth - scaledCollageWidth) / 2;
                        const offsetY = (contentHeight - scaledCollageHeight) / 2;

                        layers.forEach((layer, index) => {
                            const originalLayer = sourceLayers[index];
                            if (!originalLayer) return;

                            const originalLeft = parseFloat(originalLayer.style.left) || 0;
                            const originalTop = parseFloat(originalLayer.style.top) || 0;
                            const originalWidth = parseFloat(originalLayer.style.width) || 0;
                            const originalHeight = parseFloat(originalLayer.style.height) || 0;

                            // 콜라주 기준 상대 위치 계산
                            const relativeLeft = originalLeft - minLeft;
                            const relativeTop = originalTop - minTop;

                            // 스케일 적용
                            const scaledLeft = relativeLeft * scale;
                            const scaledTop = relativeTop * scale;
                            const scaledWidth = originalWidth * scale;
                            const scaledHeight = originalHeight * scale;

                            // 최종 위치 설정 (전체 화면에 가득 차도록)
                            const finalLeft = offsetX + scaledLeft;
                            const finalTop = offsetY + scaledTop;

                            layer.style.position = 'absolute';
                            layer.style.left = finalLeft + 'px';
                            layer.style.top = finalTop + 'px';
                            layer.style.width = scaledWidth + 'px';
                            layer.style.height = scaledHeight + 'px';
                        });
                    }
                }, 100);
            }

            initFullscreenDrawing(clone); document.addEventListener('keydown', handleEsc); document.addEventListener('mousemove', moveLaser);

            // 현재 열려있는 fullscreen의 stepId 저장 (resize 이벤트에서 사용)
            if (!window.currentFullscreenStepId) {
                window.currentFullscreenStepId = stepId;
            } else {
                window.currentFullscreenStepId = stepId;
            }

            // 화면 크기 변경 시 전체 화면에 가득 차도록 재계산하는 전역 핸들러
            if (!window.fullscreenResizeHandler) {
                window.fullscreenResizeHandler = () => {
                    const modal = document.getElementById('fullscreen-modal');
                    if (!modal || modal.style.display !== 'flex') return;

                    const currentStepId = window.currentFullscreenStepId;
                    if (!currentStepId) return;

                    const currentContent = document.getElementById('fullscreen-content');
                    const source = document.getElementById(`wrapper-${currentStepId}`);
                    if (!source || !currentContent) return;

                    const currentClone = currentContent.querySelector('.image-wrapper');
                    if (!currentClone) return;

                    const wrapperId = `wrapper-${currentStepId}`;
                    const isCollage = (collageLayers[wrapperId] && collageLayers[wrapperId].length > 0) ||
                        (source.querySelector('.collage-layer') !== null) ||
                        (source.querySelector('img') && source.querySelector('img').style.display === 'none');

                    if (isCollage) {
                        const currentLayers = currentClone.querySelectorAll('.collage-layer');
                        if (currentLayers.length > 0) {
                            const sourceLayers = source.querySelectorAll('.collage-layer');
                            if (sourceLayers.length > 0) {
                                const contentRect = currentContent.getBoundingClientRect();
                                const contentWidth = contentRect.width;
                                // 하단 여백을 고려한 실제 사용 가능한 높이 (60px 여백)
                                const contentHeight = contentRect.height - 60;

                                // 콜라주의 실제 크기 계산
                                let minLeft = Infinity, minTop = Infinity;
                                let maxRight = -Infinity, maxBottom = -Infinity;

                                sourceLayers.forEach(layer => {
                                    const left = parseFloat(layer.style.left) || 0;
                                    const top = parseFloat(layer.style.top) || 0;
                                    const width = parseFloat(layer.style.width) || 0;
                                    const height = parseFloat(layer.style.height) || 0;

                                    minLeft = Math.min(minLeft, left);
                                    minTop = Math.min(minTop, top);
                                    maxRight = Math.max(maxRight, left + width);
                                    maxBottom = Math.max(maxBottom, top + height);
                                });

                                const collageWidth = maxRight - minLeft;
                                const collageHeight = maxBottom - minTop;

                                if (collageWidth > 0 && collageHeight > 0) {
                                    // 스케일 비율 계산 (화면 비율과 관계없이 전체 화면에 가득 차도록, 하단 여백 제외)
                                    const scaleX = contentWidth / collageWidth;
                                    const scaleY = contentHeight / collageHeight;
                                    const scale = Math.min(scaleX, scaleY); // use smaller ratio so entire collage fits (contain)

                                    // 스케일 적용된 콜라주 크기
                                    const scaledCollageWidth = collageWidth * scale;
                                    const scaledCollageHeight = collageHeight * scale;

                                    // 중앙 정렬을 위한 오프셋 계산 (전체 화면에 가득 차도록 중앙 정렬)
                                    const offsetX = (contentWidth - scaledCollageWidth) / 2;
                                    const offsetY = (contentHeight - scaledCollageHeight) / 2;

                                    currentLayers.forEach((layer, index) => {
                                        const originalLayer = sourceLayers[index];
                                        if (!originalLayer) return;

                                        const originalLeft = parseFloat(originalLayer.style.left) || 0;
                                        const originalTop = parseFloat(originalLayer.style.top) || 0;
                                        const originalWidth = parseFloat(originalLayer.style.width) || 0;
                                        const originalHeight = parseFloat(originalLayer.style.height) || 0;

                                        // 콜라주 기준 상대 위치 계산
                                        const relativeLeft = originalLeft - minLeft;
                                        const relativeTop = originalTop - minTop;

                                        // 스케일 적용
                                        const scaledLeft = relativeLeft * scale;
                                        const scaledTop = relativeTop * scale;
                                        const scaledWidth = originalWidth * scale;
                                        const scaledHeight = originalHeight * scale;

                                        // 최종 위치 설정 (전체 화면에 가득 차도록)
                                        const finalLeft = offsetX + scaledLeft;
                                        const finalTop = offsetY + scaledTop;

                                        layer.style.position = 'absolute';
                                        layer.style.left = finalLeft + 'px';
                                        layer.style.top = finalTop + 'px';
                                        layer.style.width = scaledWidth + 'px';
                                        layer.style.height = scaledHeight + 'px';
                                    });
                                }
                            }
                        }
                    }
                };
                window.addEventListener('resize', window.fullscreenResizeHandler);
            }
        }
        function moveLaser(e) { const l = document.getElementById('laser-pointer'); if (l.style.display === 'block') { l.style.left = e.clientX + 'px'; l.style.top = e.clientY + 'px'; } }
        function initFullscreenDrawing(wrapper) {
            const svg = wrapper.querySelector('svg'); let isDrawing = false, currentPath = null;
            function getPoint(e) {
                // Prefer SVG coordinate transformation for fullscreen as well.
                try {
                    if (svg && typeof svg.createSVGPoint === 'function' && svg.getScreenCTM) {
                        const pt = svg.createSVGPoint();
                        pt.x = e.clientX;
                        pt.y = e.clientY;
                        const inv = svg.getScreenCTM().inverse();
                        const transformed = pt.matrixTransform(inv);
                        return { x: transformed.x, y: transformed.y };
                    }

                    const svgRect = svg.getBoundingClientRect();
                    const viewBox = (svg && svg.viewBox && svg.viewBox.baseVal) ? svg.viewBox.baseVal : { width: 1000, height: 1000 };
                    const x = (e.clientX - svgRect.left) / svgRect.width * viewBox.width;
                    const y = (e.clientY - svgRect.top) / svgRect.height * viewBox.height;
                    return { x: x, y: y };
                } catch (err) {
                    const r = wrapper.getBoundingClientRect();
                    return { x: (e.clientX - r.left) / r.width * 1000, y: (e.clientY - r.top) / r.height * 1000 };
                }
            }
            wrapper.addEventListener('mousedown', e => {
                if (e.button !== 0) return;

                // 콜라주 레이어를 클릭했을 때
                const clickedCollageLayer = e.target.closest('.collage-layer');
                if (clickedCollageLayer) {
                    // Shift 키가 눌려있으면 선택 및 도구 비활성화
                    if (e.shiftKey) {
                        const allLayers = collageLayers[wrapper.id] || [];
                        allLayers.forEach(l => l.classList.remove('selected'));
                        wrapper.classList.remove('selected');
                        const img = wrapper.querySelector('img:not(.collage-layer img)');
                        if (img) img.classList.remove('selected');
                        clickedCollageLayer.classList.add('selected');

                        // 도구 비활성화
                        const toolbar = wrapper.closest('.perspective-container').querySelector('.toolbar');
                        if (toolbar) {
                            toolbar.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                        }
                        globalTool = 'select';
                        return;
                    }
                    // Ctrl 키가 눌려있으면 선택만 하고 그리기 도구 사용하지 않음
                    if (e.ctrlKey || e.metaKey) {
                        return;
                    }
                    // 선택된 레이어를 드래그 중이면 그리기 도구 사용하지 않음
                    if (clickedCollageLayer.classList.contains('selected') && clickedCollageLayer.classList.contains('dragging')) {
                        return;
                    }
                    // 선택된 레이어를 클릭했을 때는 그리기 도구 사용하지 않음 (드래그를 위해)
                    if (clickedCollageLayer.classList.contains('selected')) {
                        return;
                    }
                    // 선택되지 않은 레이어는 그리기 도구 사용 가능 (이벤트 전파 허용)
                }

                isDrawing = true; const p = getPoint(e);
                currentPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                currentPath.setAttribute("d", `M ${p.x} ${p.y}`); currentPath.setAttribute("stroke", "#ff0000"); currentPath.setAttribute("stroke-width", "8");
                currentPath.setAttribute("fill", "none"); currentPath.setAttribute("stroke-linecap", "round"); currentPath.setAttribute("stroke-linejoin", "round");
                svg.appendChild(currentPath);
            });
            wrapper.addEventListener('mousemove', e => { if (!isDrawing || !currentPath) return; const p = getPoint(e); currentPath.setAttribute("d", `${currentPath.getAttribute("d")} L ${p.x} ${p.y}`); });
            wrapper.addEventListener('mouseup', () => { isDrawing = false; currentPath = null; });
        }
        function closeFullscreen() {
            document.getElementById('fullscreen-modal').style.display = 'none'; document.getElementById('laser-pointer').style.display = 'none';
            document.removeEventListener('keydown', handleEsc); document.removeEventListener('mousemove', moveLaser);
            // 현재 열려있는 fullscreen stepId 초기화
            window.currentFullscreenStepId = null;

            // 전체 보기를 클릭한 섹션으로 스크롤 복원
            if (window.fullscreenScrollPosition) {
                const scrollPos = window.fullscreenScrollPosition;
                // 약간의 지연을 두어 모달이 완전히 닫힌 후 스크롤
                setTimeout(() => {
                    if (scrollPos.sectionElement) {
                        // 섹션 요소가 여전히 DOM에 있는지 확인
                        if (document.body.contains(scrollPos.sectionElement)) {
                            scrollPos.sectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        } else {
                            // 섹션이 없으면 저장된 위치로 스크롤
                            window.scrollTo({ top: scrollPos.sectionTop - 100, behavior: 'smooth' });
                        }
                    } else if (scrollPos.scrollY !== undefined) {
                        // 섹션 정보가 없으면 저장된 스크롤 위치로 복원
                        window.scrollTo({ top: scrollPos.scrollY, behavior: 'smooth' });
                    }
                    // 스크롤 위치 정보 초기화
                    window.fullscreenScrollPosition = null;
                }, 100);
            }
        }
        // 콜라주 레이어 커서 업데이트 함수
        function updateCollageLayerCursors(tool) {
            // 도구에 따른 커서 설정
            let cursor = 'crosshair'; // 기본 그리기 도구 커서
            if (tool === 'select') {
                cursor = 'default';
            } else if (tool === 'box') {
                cursor = 'crosshair';
            } else {
                cursor = 'crosshair'; // pen, polyline 등 그리기 도구
            }

            // 모든 콜라주 레이어의 커서 업데이트 (선택되지 않은 레이어만)
            Object.keys(collageLayers).forEach(wrapperId => {
                const allLayers = collageLayers[wrapperId] || [];
                allLayers.forEach(layer => {
                    // 선택되지 않은 레이어만 커서 업데이트
                    if (!layer.classList.contains('selected') && !layer.classList.contains('dragging')) {
                        layer.style.cursor = cursor;
                    }
                });
            });
        }

        function handleEsc(e) {
            if (e.key === 'Escape') {
                // 전체 화면 모드가 열려있으면 닫기
                const fullscreenModal = document.getElementById('fullscreen-modal');
                if (fullscreenModal && fullscreenModal.style.display === 'block') {
                    closeFullscreen();
                    return;
                }

                // 콜라주 레이어 선택 해제
                let hasSelectedLayers = false;
                Object.keys(collageLayers).forEach(wrapperId => {
                    const wrapper = document.getElementById(wrapperId);
                    if (!wrapper) return;

                    const allLayers = collageLayers[wrapperId] || [];
                    const selectedLayers = allLayers.filter(l => l.classList.contains('selected'));

                    if (selectedLayers.length > 0) {
                        hasSelectedLayers = true;
                        // 모든 레이어 선택 해제
                        allLayers.forEach(l => l.classList.remove('selected'));
                        wrapper.classList.remove('selected');
                        const img = wrapper.querySelector('img:not(.collage-layer img)');
                        if (img) img.classList.remove('selected');

                        // 그리기 도구 모드로 전환 (이전 도구가 있으면 복원, 없으면 pen 도구)
                        const stepId = parseInt(wrapperId.split('-')[1]);
                        const toolbar = wrapper.closest('.perspective-container').querySelector('.toolbar');
                        if (toolbar) {
                            // 이전 도구 복원 (저장된 도구가 있으면)
                            const savedTool = wrapper.dataset.previousTool || 'pen';
                            const toolBtn = toolbar.querySelector(`[onclick*="setTool('${savedTool}'"]`);
                            if (toolBtn) {
                                setTool(savedTool, toolBtn, stepId);
                            } else {
                                // pen 도구로 전환
                                const penBtn = toolbar.querySelector('[onclick*="setTool(\'pen\'"]');
                                if (penBtn) {
                                    setTool('pen', penBtn, stepId);
                                }
                            }
                        }

                        // 레이어 선택 해제 후 커서 업데이트
                        updateCollageLayerCursors(globalTool);
                    }
                });

                // 선택된 레이어가 없으면 다른 선택 요소 해제
                if (!hasSelectedLayers) {
                    document.querySelectorAll('.annotation.selected').forEach(a => a.classList.remove('selected'));
                    document.querySelectorAll('.selected-svg').forEach(s => s.classList.remove('selected-svg'));
                    selectedElement = null;
                    const infoSpan = document.getElementById('selected-element-info');
                    if (infoSpan) infoSpan.innerText = '';
                    hideElementTooltip();
                }
            }
        }

        // 전체 화면 모드에서 이미지 회전
        function rotateImageFullscreen(stepId, angle) {
            const source = document.getElementById(`wrapper-${stepId}`);
            if (!source) return;

            const img = source.querySelector('img:not(.collage-layer img)');
            if (img) {
                const currentRotation = parseInt(img.getAttribute('data-rotation') || '0');
                const newRotation = (currentRotation + angle) % 360;
                img.setAttribute('data-rotation', newRotation.toString());
                updateImageTransform(img);

                // 전체 화면의 이미지도 업데이트
                const fullscreenContent = document.getElementById('fullscreen-content');
                if (fullscreenContent) {
                    const fullscreenImg = fullscreenContent.querySelector('img:not(.collage-layer img)');
                    if (fullscreenImg) {
                        fullscreenImg.setAttribute('data-rotation', newRotation.toString());
                        updateImageTransform(fullscreenImg);
                    }
                }
            }
        }

        // 전체 화면 모드에서 이미지 반전
        function flipImageFullscreen(stepId, direction) {
            const source = document.getElementById(`wrapper-${stepId}`);
            if (!source) return;

            const img = source.querySelector('img:not(.collage-layer img)');
            if (img) {
                if (direction === 'horizontal') {
                    const currentFlip = parseFloat(img.getAttribute('data-flip-h') || '1');
                    img.setAttribute('data-flip-h', (currentFlip * -1).toString());
                } else if (direction === 'vertical') {
                    const currentFlip = parseFloat(img.getAttribute('data-flip-v') || '1');
                    img.setAttribute('data-flip-v', (currentFlip * -1).toString());
                }
                updateImageTransform(img);

                // 전체 화면의 이미지도 업데이트
                const fullscreenContent = document.getElementById('fullscreen-content');
                if (fullscreenContent) {
                    const fullscreenImg = fullscreenContent.querySelector('img:not(.collage-layer img)');
                    if (fullscreenImg) {
                        if (direction === 'horizontal') {
                            const currentFlip = parseFloat(fullscreenImg.getAttribute('data-flip-h') || '1');
                            fullscreenImg.setAttribute('data-flip-h', (currentFlip * -1).toString());
                        } else if (direction === 'vertical') {
                            const currentFlip = parseFloat(fullscreenImg.getAttribute('data-flip-v') || '1');
                            fullscreenImg.setAttribute('data-flip-v', (currentFlip * -1).toString());
                        }
                        updateImageTransform(fullscreenImg);
                    }
                }
            }
        }

        // 전체 화면 모드에서 콜라주 레이어 드래그 초기화
        function initCollageLayerDragFullscreen(layer, fullscreenWrapper, sourceWrapper, stepId, layerIndex) {
            let isDragging = false;
            let hasDragged = false; // 실제로 드래그가 발생했는지 추적
            let startX = 0;
            let startY = 0;
            let startLeft = 0;
            let startTop = 0;
            let originalLeft = 0;
            let originalTop = 0;
            let snapThreshold = 10;
            let targetLayer = null;

            // 원본 레이어 참조
            const sourceLayers = sourceWrapper.querySelectorAll('.collage-layer');
            const sourceLayer = sourceLayers[layerIndex];
            if (!sourceLayer) return;

            layer.addEventListener('mousedown', (e) => {
                // 편집 버튼을 클릭한 경우 드래그하지 않음
                if (e.target.closest('.image-edit-btn')) {
                    return;
                }

                // Ctrl 키가 눌려있으면 선택만 하고 드래그는 시작하지 않음
                if (e.ctrlKey || e.metaKey) {
                    // 선택은 click 이벤트에서 처리됨
                    // 드래그는 시작하지 않음
                    return;
                }

                // Ctrl 키가 눌려있지 않으면 그리기 도구 사용을 위해 이벤트 전파 허용
                // 선택된 레이어만 드래그 가능
                if (!layer.classList.contains('selected')) {
                    // 선택되지 않은 레이어는 그리기 도구 사용을 위해 이벤트 전파 허용
                    return;
                }

                // 선택된 레이어를 드래그 시작
                isDragging = true;
                hasDragged = false; // 드래그 시작 시 초기화
                layer.dataset.dragJustEnded = 'true'; // click 이벤트 방지를 위해 설정
                layer.classList.add('dragging');
                startX = e.clientX;
                startY = e.clientY;
                const rect = layer.getBoundingClientRect();
                const wrapperRect = fullscreenWrapper.getBoundingClientRect();
                startLeft = rect.left - wrapperRect.left;
                startTop = rect.top - wrapperRect.top;
                originalLeft = startLeft;
                originalTop = startTop;
                targetLayer = null;
                e.preventDefault();
                e.stopPropagation();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const wrapperRect = fullscreenWrapper.getBoundingClientRect();
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                // 작은 이동이라도 발생하면 드래그로 간주
                if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
                    hasDragged = true;
                }

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                const layerWidth = parseFloat(layer.style.width);
                const layerHeight = parseFloat(layer.style.height);
                newLeft = Math.max(0, Math.min(newLeft, wrapperRect.width - layerWidth));
                newTop = Math.max(0, Math.min(newTop, wrapperRect.height - layerHeight));

                // 다른 레이어들과의 스냅 및 중간 배치 체크
                const otherLayers = fullscreenWrapper.querySelectorAll('.collage-layer');
                let snappedLeft = newLeft;
                let snappedTop = newTop;
                let newTargetLayer = null;

                const currentCenterX = newLeft + layerWidth / 2;
                const currentCenterY = newTop + layerHeight / 2;
                const currentTop = newTop;
                const currentBottom = newTop + layerHeight;
                const currentLeft = newLeft;
                const currentRight = newLeft + layerWidth;

                let leftLayer = null;
                let rightLayer = null;
                let leftLayerRight = -Infinity;
                let rightLayerLeft = Infinity;
                let topLayer = null;
                let bottomLayer = null;
                let topLayerBottom = -Infinity;
                let bottomLayerTop = Infinity;

                otherLayers.forEach(otherLayer => {
                    if (otherLayer === layer) return;

                    const otherLeft = parseFloat(otherLayer.style.left) || 0;
                    const otherTop = parseFloat(otherLayer.style.top) || 0;
                    const otherWidth = parseFloat(otherLayer.style.width) || 0;
                    const otherHeight = parseFloat(otherLayer.style.height) || 0;
                    const otherRight = otherLeft + otherWidth;
                    const otherBottom = otherTop + otherHeight;

                    if (currentCenterX >= otherLeft && currentCenterX <= otherRight &&
                        currentCenterY >= otherTop && currentCenterY <= otherBottom) {
                        newTargetLayer = otherLayer;
                    }

                    const yOverlap = !(currentBottom <= otherTop || currentTop >= otherBottom);
                    if (yOverlap) {
                        if (otherRight < currentCenterX && otherRight > leftLayerRight) {
                            leftLayer = otherLayer;
                            leftLayerRight = otherRight;
                        }
                        if (otherLeft > currentCenterX && otherLeft < rightLayerLeft) {
                            rightLayer = otherLayer;
                            rightLayerLeft = otherLeft;
                        }
                    }

                    const xOverlap = !(currentRight <= otherLeft || currentLeft >= otherRight);
                    if (xOverlap) {
                        if (otherBottom < currentCenterY && otherBottom > topLayerBottom) {
                            topLayer = otherLayer;
                            topLayerBottom = otherBottom;
                        }
                        if (otherTop > currentCenterY && otherTop < bottomLayerTop) {
                            bottomLayer = otherLayer;
                            bottomLayerTop = otherTop;
                        }
                    }

                    if (Math.abs(newLeft - otherLeft) < snapThreshold) {
                        snappedLeft = otherLeft;
                    }
                    if (Math.abs((newLeft + layerWidth) - (otherLeft + otherWidth)) < snapThreshold) {
                        snappedLeft = otherLeft + otherWidth - layerWidth;
                    }
                    if (Math.abs(newTop - otherTop) < snapThreshold) {
                        snappedTop = otherTop;
                    }
                    if (Math.abs((newTop + layerHeight) - (otherTop + otherHeight)) < snapThreshold) {
                        snappedTop = otherTop + otherHeight - layerHeight;
                    }
                });

                if (leftLayer && rightLayer) {
                    const leftRight = parseFloat(leftLayer.style.left) + parseFloat(leftLayer.style.width);
                    const rightLeft = parseFloat(rightLayer.style.left);
                    const middleX = (leftRight + rightLeft) / 2;
                    snappedLeft = middleX - layerWidth / 2;
                }

                if (topLayer && bottomLayer) {
                    const topBottom = parseFloat(topLayer.style.top) + parseFloat(topLayer.style.height);
                    const bottomTop = parseFloat(bottomLayer.style.top);
                    const middleY = (topBottom + bottomTop) / 2;
                    snappedTop = middleY - layerHeight / 2;
                }

                snappedLeft = Math.max(0, Math.min(snappedLeft, wrapperRect.width - layerWidth));
                snappedTop = Math.max(0, Math.min(snappedTop, wrapperRect.height - layerHeight));

                layer.style.left = snappedLeft + 'px';
                layer.style.top = snappedTop + 'px';

                if (newTargetLayer !== targetLayer) {
                    targetLayer = newTargetLayer;
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    const wasDragging = hasDragged;
                    isDragging = false;
                    hasDragged = false;
                    layer.classList.remove('dragging');

                    // 드래그가 발생했으면 click 이벤트를 방지하기 위해 짧은 지연 후 플래그 리셋
                    if (wasDragging) {
                        setTimeout(() => {
                            layer.dataset.dragJustEnded = 'false';
                        }, 100);
                    } else {
                        layer.dataset.dragJustEnded = 'false';
                    }

                    if (targetLayer) {
                        const layerLeft = parseFloat(layer.style.left) || 0;
                        const layerTop = parseFloat(layer.style.top) || 0;
                        targetLayer.style.left = originalLeft + 'px';
                        targetLayer.style.top = originalTop + 'px';
                        layer.style.left = layerLeft + 'px';
                        layer.style.top = layerTop + 'px';
                        targetLayer = null;
                    }

                    // 전체 화면에서의 변경사항을 원본에 반영
                    const fullscreenRect = fullscreenWrapper.getBoundingClientRect();
                    const sourceRect = sourceWrapper.getBoundingClientRect();
                    const fullscreenWidth = fullscreenRect.width;
                    const fullscreenHeight = fullscreenRect.height;
                    const sourceWidth = sourceRect.width;
                    const sourceHeight = sourceRect.height;

                    // 콜라주 크기 계산
                    let minLeft = Infinity, minTop = Infinity;
                    let maxRight = -Infinity, maxBottom = -Infinity;
                    const allFullscreenLayers = fullscreenWrapper.querySelectorAll('.collage-layer');
                    allFullscreenLayers.forEach(l => {
                        const left = parseFloat(l.style.left) || 0;
                        const top = parseFloat(l.style.top) || 0;
                        const width = parseFloat(l.style.width) || 0;
                        const height = parseFloat(l.style.height) || 0;
                        minLeft = Math.min(minLeft, left);
                        minTop = Math.min(minTop, top);
                        maxRight = Math.max(maxRight, left + width);
                        maxBottom = Math.max(maxBottom, top + height);
                    });

                    const collageWidth = maxRight - minLeft;
                    const collageHeight = maxBottom - minTop;
                    const scaleX = fullscreenWidth / collageWidth;
                    const scaleY = fullscreenHeight / collageHeight;
                    const scale = Math.min(scaleX, scaleY);

                    const scaledCollageWidth = collageWidth * scale;
                    const scaledCollageHeight = collageHeight * scale;
                    const offsetX = (fullscreenWidth - scaledCollageWidth) / 2;
                    const offsetY = (fullscreenHeight - scaledCollageHeight) / 2;

                    // 역 스케일 계산하여 원본에 적용
                    const currentLayerLeft = parseFloat(layer.style.left) || 0;
                    const currentLayerTop = parseFloat(layer.style.top) || 0;
                    const relativeLeft = currentLayerLeft - offsetX;
                    const relativeTop = currentLayerTop - offsetY;

                    // 원본 콜라주 크기 계산
                    let sourceMinLeft = Infinity, sourceMinTop = Infinity;
                    let sourceMaxRight = -Infinity, sourceMaxBottom = -Infinity;
                    sourceLayers.forEach(l => {
                        const left = parseFloat(l.style.left) || 0;
                        const top = parseFloat(l.style.top) || 0;
                        const width = parseFloat(l.style.width) || 0;
                        const height = parseFloat(l.style.height) || 0;
                        sourceMinLeft = Math.min(sourceMinLeft, left);
                        sourceMinTop = Math.min(sourceMinTop, top);
                        sourceMaxRight = Math.max(sourceMaxRight, left + width);
                        sourceMaxBottom = Math.max(sourceMaxBottom, top + height);
                    });

                    const sourceCollageWidth = sourceMaxRight - sourceMinLeft;
                    const sourceCollageHeight = sourceMaxBottom - sourceMinTop;
                    const sourceScaleX = sourceWidth / sourceCollageWidth;
                    const sourceScaleY = sourceHeight / sourceCollageHeight;
                    const sourceScale = Math.min(sourceScaleX, sourceScaleY);

                    const sourceScaledCollageWidth = sourceCollageWidth * sourceScale;
                    const sourceScaledCollageHeight = sourceCollageHeight * sourceScale;
                    const sourceOffsetX = (sourceWidth - sourceScaledCollageWidth) / 2;
                    const sourceOffsetY = (sourceHeight - sourceScaledCollageHeight) / 2;

                    // 역 스케일 계산
                    const reverseScale = sourceScale / scale;
                    const sourceLeft = sourceOffsetX + (relativeLeft * reverseScale);
                    const sourceTop = sourceOffsetY + (relativeTop * reverseScale);

                    sourceLayer.style.left = Math.max(0, Math.min(sourceLeft, sourceWidth - parseFloat(sourceLayer.style.width))) + 'px';
                    sourceLayer.style.top = Math.max(0, Math.min(sourceTop, sourceHeight - parseFloat(sourceLayer.style.height))) + 'px';

                    // 원본 이미지 업데이트
                    const originalImg = sourceWrapper.querySelector('img:not(.collage-layer img)');
                    if (originalImg) {
                        renderCollageFromLayers(sourceWrapper, originalImg);
                    }
                }
            });
        }

        // 전체 화면에서 일반 이미지 드래그 이동
        function initFullscreenImageDrag(img, fullscreenWrapper, sourceWrapper, stepId) {
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let startPosition = '';

            // 세로 이미지인 경우에만 드래그 가능
            if (img.getAttribute('data-vertical') !== 'true') {
                return;
            }

            img.style.cursor = 'move';

            img.addEventListener('mousedown', (e) => {
                if (e.target.closest('.image-edit-btn')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // 현재 object-position 가져오기
                const sourceImg = sourceWrapper.querySelector('img:not(.collage-layer img)');
                if (sourceImg) {
                    startPosition = sourceImg.style.objectPosition || 'center center';
                } else {
                    startPosition = 'center center';
                }

                e.preventDefault();
                e.stopPropagation();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                const fullscreenRect = fullscreenWrapper.getBoundingClientRect();
                const sourceRect = sourceWrapper.getBoundingClientRect();

                // 비율 계산
                const scaleX = sourceRect.width / fullscreenRect.width;
                const scaleY = sourceRect.height / fullscreenRect.height;

                // 현재 위치 파싱
                const match = startPosition.match(/(\d+(?:\.\d+)?)%\s+(\d+(?:\.\d+)?)%/);
                let currentX = match ? parseFloat(match[1]) : 50;
                let currentY = match ? parseFloat(match[2]) : 50;

                // 델타를 퍼센트로 변환
                const deltaPercentX = (deltaX / fullscreenRect.width) * 100;
                const deltaPercentY = (deltaY / fullscreenRect.height) * 100;

                // 새 위치 계산
                const newX = Math.max(0, Math.min(100, currentX + deltaPercentX));
                const newY = Math.max(0, Math.min(100, currentY + deltaPercentY));

                // 전체 화면 이미지 업데이트
                img.style.objectPosition = `${newX}% ${newY}%`;

                // 원본 이미지도 업데이트
                const sourceImg = sourceWrapper.querySelector('img:not(.collage-layer img)');
                if (sourceImg) {
                    sourceImg.style.objectPosition = `${newX}% ${newY}%`;
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                }
            });
        }

        // 전체 화면에서 이미지 선택
        function selectImageFullscreen(stepId, event) {
            if (event && event.target.closest('.image-edit-btn')) return;

            const fullscreenContent = document.getElementById('fullscreen-content');
            const source = document.getElementById(`wrapper-${stepId}`);
            if (!fullscreenContent || !source) return;

            // 클릭된 요소 확인
            const clickedLayer = event && event.target ? event.target.closest('.collage-layer') : null;
            const clickedImg = event && event.target ? (event.target.tagName === 'IMG' && !event.target.closest('.collage-layer')) : null;

            // 다른 이미지 선택 해제
            fullscreenContent.querySelectorAll('.collage-layer').forEach(l => l.classList.remove('selected'));
            source.classList.remove('selected');
            const sourceImg = source.querySelector('img:not(.collage-layer img)');
            if (sourceImg) sourceImg.classList.remove('selected');

            // 원본 레이어도 선택 해제
            source.querySelectorAll('.collage-layer').forEach(l => l.classList.remove('selected'));

            if (clickedLayer) {
                // 콜라주 레이어 선택
                const fullscreenLayers = fullscreenContent.querySelectorAll('.collage-layer');
                const sourceLayers = source.querySelectorAll('.collage-layer');
                const layerIndex = Array.from(fullscreenLayers).indexOf(clickedLayer);

                // 다른 레이어 선택 해제
                fullscreenLayers.forEach(l => l.classList.remove('selected'));
                sourceLayers.forEach(l => l.classList.remove('selected'));

                // 현재 레이어 선택
                if (layerIndex >= 0 && layerIndex < fullscreenLayers.length) {
                    clickedLayer.classList.add('selected');
                    if (sourceLayers[layerIndex]) {
                        sourceLayers[layerIndex].classList.add('selected');
                    }
                }
            } else if (clickedImg || (!clickedLayer && !clickedImg)) {
                // 일반 이미지 선택 (이미지 클릭 또는 배경 클릭)
                source.classList.add('selected');
                if (sourceImg) sourceImg.classList.add('selected');

                // 전체 화면의 이미지도 선택 표시
                const fullscreenImg = fullscreenContent.querySelector('img:not(.collage-layer img)');
                if (fullscreenImg) {
                    fullscreenImg.classList.add('selected');
                }
            }
        }

        // 전체 화면에서 선택된 콜라주 레이어 회전
        function rotateSelectedCollageLayerFullscreen(stepId, angle) {
            const fullscreenContent = document.getElementById('fullscreen-content');
            const source = document.getElementById(`wrapper-${stepId}`);
            if (!fullscreenContent || !source) return;

            const selectedLayer = fullscreenContent.querySelector('.collage-layer.selected');

            if (selectedLayer) {
                const fullscreenLayers = fullscreenContent.querySelectorAll('.collage-layer');
                const layerIndex = Array.from(fullscreenLayers).indexOf(selectedLayer);
                const sourceLayers = source.querySelectorAll('.collage-layer');
                const sourceLayer = sourceLayers[layerIndex];

                if (sourceLayer) {
                    const layerImg = selectedLayer.querySelector('img');
                    const sourceLayerImg = sourceLayer.querySelector('img');

                    if (layerImg && sourceLayerImg) {
                        const currentRotation = parseInt(layerImg.dataset.rotation || sourceLayerImg.dataset.rotation || '0');
                        const newRotation = (currentRotation + angle) % 360;

                        layerImg.dataset.rotation = newRotation;
                        sourceLayerImg.dataset.rotation = newRotation;

                        // 회전 적용
                        const currentFlipH = parseFloat(layerImg.dataset.flipH || sourceLayerImg.dataset.flipH || '1');
                        const currentFlipV = parseFloat(layerImg.dataset.flipV || sourceLayerImg.dataset.flipV || '1');
                        layerImg.style.transform = `rotate(${newRotation}deg) scaleX(${currentFlipH}) scaleY(${currentFlipV})`;
                        layerImg.style.transformOrigin = 'center center';
                        sourceLayerImg.style.transform = `rotate(${newRotation}deg) scaleX(${currentFlipH}) scaleY(${currentFlipV})`;
                        sourceLayerImg.style.transformOrigin = 'center center';

                        // 원본 이미지 업데이트
                        const originalImg = source.querySelector('img:not(.collage-layer img)');
                        if (originalImg) {
                            renderCollageFromLayers(source, originalImg);
                        }
                    }
                }
            } else {
                // 선택된 레이어가 없으면 전체 이미지 회전
                rotateImageFullscreen(stepId, angle);
            }
        }

        // 전체 화면에서 선택된 콜라주 레이어 대칭
        function flipSelectedCollageLayerFullscreen(stepId, direction) {
            const fullscreenContent = document.getElementById('fullscreen-content');
            const source = document.getElementById(`wrapper-${stepId}`);
            if (!fullscreenContent || !source) return;

            const selectedLayer = fullscreenContent.querySelector('.collage-layer.selected');

            if (selectedLayer) {
                const fullscreenLayers = fullscreenContent.querySelectorAll('.collage-layer');
                const layerIndex = Array.from(fullscreenLayers).indexOf(selectedLayer);
                const sourceLayers = source.querySelectorAll('.collage-layer');
                const sourceLayer = sourceLayers[layerIndex];

                if (sourceLayer) {
                    const layerImg = selectedLayer.querySelector('img');
                    const sourceLayerImg = sourceLayer.querySelector('img');

                    if (layerImg && sourceLayerImg) {
                        const currentRotation = parseInt(layerImg.dataset.rotation || sourceLayerImg.dataset.rotation || '0');
                        let currentFlipH = parseFloat(layerImg.dataset.flipH || sourceLayerImg.dataset.flipH || '1');
                        let currentFlipV = parseFloat(layerImg.dataset.flipV || sourceLayerImg.dataset.flipV || '1');

                        if (direction === 'horizontal') {
                            currentFlipH = currentFlipH * -1;
                            layerImg.dataset.flipH = currentFlipH;
                            sourceLayerImg.dataset.flipH = currentFlipH;
                        } else if (direction === 'vertical') {
                            currentFlipV = currentFlipV * -1;
                            layerImg.dataset.flipV = currentFlipV;
                            sourceLayerImg.dataset.flipV = currentFlipV;
                        }

                        // 변환 적용
                        layerImg.style.transform = `rotate(${currentRotation}deg) scaleX(${currentFlipH}) scaleY(${currentFlipV})`;
                        layerImg.style.transformOrigin = 'center center';
                        sourceLayerImg.style.transform = `rotate(${currentRotation}deg) scaleX(${currentFlipH}) scaleY(${currentFlipV})`;
                        sourceLayerImg.style.transformOrigin = 'center center';

                        // 원본 이미지 업데이트
                        const originalImg = source.querySelector('img:not(.collage-layer img)');
                        if (originalImg) {
                            renderCollageFromLayers(source, originalImg);
                        }
                    }
                }
            } else {
                // 선택된 레이어가 없으면 전체 이미지 반전
                flipImageFullscreen(stepId, direction);
            }
        }

        // 전체 화면에서 자르기 시작
        function startCropFullscreen(stepId) {
            const fullscreenContent = document.getElementById('fullscreen-content');
            const source = document.getElementById(`wrapper-${stepId}`);
            if (!fullscreenContent || !source) return;

            // 콜라주 레이어가 있는 경우 선택된 레이어 자르기
            const selectedLayer = fullscreenContent.querySelector('.collage-layer.selected');
            if (selectedLayer) {
                alert('콜라주 이미지의 개별 레이어는 자르기 기능을 사용할 수 없습니다.');
                return;
            }

            // 전체 화면용 자르기 오버레이 확인
            const overlay = document.getElementById(`fullscreen-crop-overlay-${stepId}`);
            const selection = document.getElementById(`fullscreen-crop-selection-${stepId}`);
            const clone = fullscreenContent.querySelector('.image-wrapper');

            if (!overlay || !selection || !clone) {
                // 전체 화면용 오버레이가 없으면 원본에서 자르기 실행
                startCrop(stepId);
                return;
            }

            const img = clone.querySelector('img:not(.collage-layer img)');
            if (!img) return;

            overlay.classList.add('active');
            const cloneRect = clone.getBoundingClientRect();
            const imgRect = img.getBoundingClientRect();

            // 이미지의 실제 위치와 크기 계산
            const imgLeft = imgRect.left - cloneRect.left;
            const imgTop = imgRect.top - cloneRect.top;
            const imgWidth = imgRect.width;
            const imgHeight = imgRect.height;

            // 초기 선택 영역 설정
            const initWidth = Math.min(imgWidth * 0.8, imgWidth);
            const initHeight = Math.min(imgHeight * 0.8, imgHeight);
            const initLeft = imgLeft + (imgWidth - initWidth) / 2;
            const initTop = imgTop + (imgHeight - initHeight) / 2;

            cropState[`fullscreen-${stepId}`] = {
                startX: initLeft,
                startY: initTop,
                width: initWidth,
                height: initHeight,
                isDragging: false,
                dragHandle: null,
                wrapperRect: cloneRect,
                imgLeft: imgLeft,
                imgTop: imgTop,
                imgWidth: imgWidth,
                imgHeight: imgHeight,
                isFullscreen: true,
                stepId: stepId
            };

            selection.style.left = initLeft + 'px';
            selection.style.top = initTop + 'px';
            selection.style.width = initWidth + 'px';
            selection.style.height = initHeight + 'px';

            // 자르기 핸들 이벤트 리스너 추가
            const handles = selection.querySelectorAll('.crop-handle');
            handles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    cropState[`fullscreen-${stepId}`].isDragging = true;
                    cropState[`fullscreen-${stepId}`].dragHandle = handle.className.split(' ')[1];
                    const rect = selection.getBoundingClientRect();
                    cropState[`fullscreen-${stepId}`].startX = e.clientX;
                    cropState[`fullscreen-${stepId}`].startY = e.clientY;
                    cropState[`fullscreen-${stepId}`].startLeft = rect.left - cloneRect.left;
                    cropState[`fullscreen-${stepId}`].startTop = rect.top - cloneRect.top;
                    cropState[`fullscreen-${stepId}`].startWidth = rect.width;
                    cropState[`fullscreen-${stepId}`].startHeight = rect.height;
                });
            });

            // 선택 영역 드래그
            selection.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('crop-handle')) return;
                cropState[`fullscreen-${stepId}`].isDragging = true;
                cropState[`fullscreen-${stepId}`].dragHandle = 'move';
                const rect = selection.getBoundingClientRect();
                cropState[`fullscreen-${stepId}`].startX = e.clientX;
                cropState[`fullscreen-${stepId}`].startY = e.clientY;
                cropState[`fullscreen-${stepId}`].startLeft = rect.left - cloneRect.left;
                cropState[`fullscreen-${stepId}`].startTop = rect.top - cloneRect.top;
            });

            // 마우스 이동 및 업 이벤트 핸들러
            const handleCropMouseMove = (e) => {
                const state = cropState[`fullscreen-${stepId}`];
                if (!state || !state.isDragging || !state.dragHandle) return;

                const cloneRect = clone.getBoundingClientRect();
                const img = clone.querySelector('img:not(.collage-layer img)');
                const imgRect = img.getBoundingClientRect();

                const imgLeft = imgRect.left - cloneRect.left;
                const imgTop = imgRect.top - cloneRect.top;
                const imgWidth = imgRect.width;
                const imgHeight = imgRect.height;

                const currentX = e.clientX - cloneRect.left;
                const currentY = e.clientY - cloneRect.top;

                const handle = state.dragHandle;
                let newLeft = state.startLeft;
                let newTop = state.startTop;
                let newWidth = state.width;
                let newHeight = state.height;

                if (handle === 'move') {
                    const deltaX = currentX - state.startX;
                    const deltaY = currentY - state.startY;
                    newLeft = state.startLeft + deltaX;
                    newTop = state.startTop + deltaY;

                    // 이미지 영역 내부로 제한
                    newLeft = Math.max(state.imgLeft, Math.min(newLeft, state.imgLeft + state.imgWidth - state.width));
                    newTop = Math.max(state.imgTop, Math.min(newTop, state.imgTop + state.imgHeight - state.height));
                } else {
                    if (handle.includes('e')) {
                        newWidth = Math.max(20, currentX - state.startLeft);
                        if (newLeft + newWidth > imgLeft + imgWidth) {
                            newWidth = imgLeft + imgWidth - newLeft;
                        }
                    }
                    if (handle.includes('w')) {
                        const diff = state.startLeft - currentX;
                        newLeft = Math.max(imgLeft, state.startLeft - diff);
                        newWidth = Math.max(20, state.width + diff);
                        if (newLeft < imgLeft) {
                            newWidth = newWidth - (imgLeft - newLeft);
                            newLeft = imgLeft;
                        }
                    }
                    if (handle.includes('s')) {
                        newHeight = Math.max(20, currentY - state.startTop);
                        if (newTop + newHeight > imgTop + imgHeight) {
                            newHeight = imgTop + imgHeight - newTop;
                        }
                    }
                    if (handle.includes('n')) {
                        const diff = state.startTop - currentY;
                        newTop = Math.max(imgTop, state.startTop - diff);
                        newHeight = Math.max(20, state.height + diff);
                        if (newTop < imgTop) {
                            newHeight = newHeight - (imgTop - newTop);
                            newTop = imgTop;
                        }
                    }
                }

                // 최종 경계 체크
                if (newLeft < imgLeft) {
                    newWidth = newWidth - (imgLeft - newLeft);
                    newLeft = imgLeft;
                }
                if (newTop < imgTop) {
                    newHeight = newHeight - (imgTop - newTop);
                    newTop = imgTop;
                }
                if (newLeft + newWidth > imgLeft + imgWidth) {
                    newWidth = imgLeft + imgWidth - newLeft;
                }
                if (newTop + newHeight > imgTop + imgHeight) {
                    newHeight = imgTop + imgHeight - newTop;
                }

                // 최소 크기 보장
                if (newWidth < 20) newWidth = 20;
                if (newHeight < 20) newHeight = 20;

                state.startLeft = newLeft;
                state.startTop = newTop;
                state.width = newWidth;
                state.height = newHeight;

                selection.style.left = newLeft + 'px';
                selection.style.top = newTop + 'px';
                selection.style.width = newWidth + 'px';
                selection.style.height = newHeight + 'px';
            };

            const handleCropMouseUp = () => {
                const state = cropState[`fullscreen-${stepId}`];
                if (state) {
                    state.isDragging = false;
                    state.dragHandle = null;
                }
            };

            document.addEventListener('mousemove', handleCropMouseMove);
            document.addEventListener('mouseup', handleCropMouseUp);

            // 자르기 모드 종료 시 이벤트 리스너 제거를 위한 참조 저장
            cropState[`fullscreen-${stepId}`].removeListeners = () => {
                document.removeEventListener('mousemove', handleCropMouseMove);
                document.removeEventListener('mouseup', handleCropMouseUp);
            };
        }

        // 전체 화면에서 자르기 적용
        function applyCropFullscreen(stepId) {
            const state = cropState[`fullscreen-${stepId}`];
            if (!state) return;

            const fullscreenContent = document.getElementById('fullscreen-content');
            const source = document.getElementById(`wrapper-${stepId}`);
            const clone = fullscreenContent.querySelector('.image-wrapper');
            const overlay = document.getElementById(`fullscreen-crop-overlay-${stepId}`);
            const selection = document.getElementById(`fullscreen-crop-selection-${stepId}`);

            if (!clone || !overlay || !selection) return;

            const img = clone.querySelector('img:not(.collage-layer img)');
            if (!img) return;

            // 자르기 영역 계산
            const cropLeft = (state.startLeft - state.imgLeft) / state.imgWidth;
            const cropTop = (state.startTop - state.imgTop) / state.imgHeight;
            const cropWidth = state.width / state.imgWidth;
            const cropHeight = state.height / state.imgHeight;

            // 원본 이미지에 자르기 적용
            if (source) {
                const sourceImg = source.querySelector('img:not(.collage-layer img)');
                if (sourceImg) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const tempImg = new Image();
                    tempImg.crossOrigin = 'anonymous';
                    tempImg.onload = function () {
                        const sourceWidth = this.width;
                        const sourceHeight = this.height;

                        const sourceX = cropLeft * sourceWidth;
                        const sourceY = cropTop * sourceHeight;
                        const sourceCropWidth = cropWidth * sourceWidth;
                        const sourceCropHeight = cropHeight * sourceHeight;

                        canvas.width = sourceCropWidth;
                        canvas.height = sourceCropHeight;

                        ctx.drawImage(this, sourceX, sourceY, sourceCropWidth, sourceCropHeight, 0, 0, sourceCropWidth, sourceCropHeight);

                        // 전체 화면/원본 교체 (압축 적용)
                        try {
                            const q = getCompressionQuality();
                            const dataUrl = canvas.toDataURL('image/jpeg', q);
                            sourceImg.src = dataUrl;
                            sourceImg.setAttribute('data-original-src', dataUrl);
                            // 전체 화면 이미지도 업데이트
                            img.src = dataUrl;
                        } catch (e) {
                            const dataUrl = canvas.toDataURL('image/png');
                            sourceImg.src = dataUrl;
                            sourceImg.setAttribute('data-original-src', dataUrl);
                            img.src = dataUrl;
                        }

                        // 자르기 모드 종료
                        overlay.classList.remove('active');
                        if (state.removeListeners) {
                            state.removeListeners();
                        }
                        delete cropState[`fullscreen-${stepId}`];
                    };
                    tempImg.src = sourceImg.getAttribute('data-original-src') || sourceImg.src;
                }
            }
        }

        // 전체 화면에서 자르기 취소
        function cancelCropFullscreen(stepId) {
            const overlay = document.getElementById(`fullscreen-crop-overlay-${stepId}`);
            if (overlay) {
                overlay.classList.remove('active');
            }
            const state = cropState[`fullscreen-${stepId}`];
            if (state && state.removeListeners) {
                state.removeListeners();
            }
            delete cropState[`fullscreen-${stepId}`];
        }

        // 전체 화면에서 이미지 삭제 (해당 섹션에만 종속, 다른 섹션에 영향 없음)
        function deleteImageFullscreen(stepId) {
            if (confirm('이미지를 삭제하시겠습니까?')) {
                const source = document.getElementById(`wrapper-${stepId}`);
                if (!source) {
                    closeFullscreen();
                    return;
                }

                // 콜라주 레이어가 있는 경우 제거
                const wrapperId = source.id;
                if (collageLayers[wrapperId] && collageLayers[wrapperId].length > 0) {
                    collageLayers[wrapperId].forEach(layer => layer.remove());
                    collageLayers[wrapperId] = [];
                }

                // 기존 콜라주 레이어들도 제거
                source.querySelectorAll('.collage-layer').forEach(layer => layer.remove());

                // 일반 이미지 초기화
                const img = source.querySelector('img:not(.collage-layer img)');
                if (img) {
                    // placeholder 이미지로 복원
                    const placeholderSrc = 'https://placehold.co/600x400?text=No+Image';
                    img.src = placeholderSrc;
                    img.setAttribute('data-original-src', placeholderSrc);
                    img.setAttribute('data-rotation', '0');
                    img.setAttribute('data-flip-h', '1');
                    img.setAttribute('data-flip-v', '1');
                    img.style.display = 'block';
                    img.style.visibility = 'visible';
                    img.style.pointerEvents = 'auto';
                    img.style.zIndex = '1';
                    img.removeAttribute('data-vertical');
                    img.removeAttribute('data-horizontal');
                    img.style.objectPosition = 'center center';
                    updateImageTransform(img);
                }

                // 이미지 선택 해제
                source.classList.remove('selected');
                if (img) img.classList.remove('selected');
                selectedImageId = null;

                // 전체 화면 닫기
                closeFullscreen();
            }
        }

        async function downloadSelfContainedHtml() {
            document.querySelectorAll('input[type="checkbox"]').forEach(input => {
                if (input.checked) input.setAttribute('checked', 'checked'); else input.removeAttribute('checked');
            });
            document.querySelectorAll('input[type="color"]').forEach(input => {
                input.setAttribute('value', input.value);
            });

            // [중요] 레이아웃 설정값 저장
            const container = document.getElementById('report-container');
            container.dataset.savedMode = currentMode;
            container.dataset.savedCols = verticalCols;
            container.dataset.savedRows = horizontalRows;

            // 현재 선택된 압축률을 복사해 둠
            const selectedQuality = getSelectedCompressionQuality();
            const cloneDoc = document.documentElement.cloneNode(true);
            // 단독 저장 시 상단 아코디언을 '접힌(collapsed)' 상태로 변경하여 저장
            const clonedHeader = cloneDoc.querySelector('#main-header');
            if (clonedHeader) {
                clonedHeader.classList.add('collapsed');
                const clonedIcon = clonedHeader.querySelector('#toggle-icon');
                if (clonedIcon) clonedIcon.className = 'fas fa-chevron-down';
            }
            // 본문이 툴바 접힘 만큼 위로 이동하지 않는 문제 보정: body padding을 collapsed 상태에 맞춤
            const clonedBody = cloneDoc.querySelector('body');
            if (clonedBody) {
                // collapsed일 때 원래 로직에서 사용하는 paddingTop 기본값은 0px
                clonedBody.style.paddingTop = '0px';
            }
            const images = cloneDoc.querySelectorAll('img');
            let processedCount = 0;
            showConfirm("모든 이미지를 파일 내부에 저장하시겠습니까?\n(이미지 크기에 따라 시간이 걸릴 수 있습니다.)", async function () {
                const maxWidth = getExportMaxWidth();
                for (let img of images) {
                    if (img.src.startsWith('data:')) { processedCount++; continue; }
                    try {
                        const originalImg = document.querySelectorAll('img')[processedCount];
                        if (!originalImg) { processedCount++; continue; }

                        // 결정할 목표 너비: 화면 표시 크기 기반(dpr 고려)과 자연크기 및 사용자가 설정한 maxWidth의 최소값
                        const dpr = window.devicePixelRatio || 1;
                        const displayedWidth = Math.max(1, Math.round((originalImg.clientWidth || originalImg.width) * dpr));
                        const naturalWidth = originalImg.naturalWidth || displayedWidth;
                        const targetWidth = Math.min(naturalWidth, displayedWidth, maxWidth);
                        const scale = targetWidth / naturalWidth;
                        const targetHeight = Math.max(1, Math.round((originalImg.naturalHeight || originalImg.height) * scale));

                        // 고품질 리사이즈: 이미지 스무딩 설정
                        const canvas = document.createElement('canvas');
                        canvas.width = targetWidth;
                        canvas.height = targetHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';

                        // drawImage로 스케일링 (원본 크기에서 직접 스케일링)
                        ctx.drawImage(originalImg, 0, 0, naturalWidth, originalImg.naturalHeight || (targetHeight / scale), 0, 0, targetWidth, targetHeight);

                        try {
                            img.src = canvas.toDataURL('image/jpeg', selectedQuality);
                        } catch (e) {
                            img.src = canvas.toDataURL('image/png');
                        }
                        img.removeAttribute('crossorigin');
                    } catch (e) { console.warn("Image Convert Fail:", e); }
                    processedCount++;
                }

                const htmlContent = "<!DOCTYPE html>\n" + cloneDoc.outerHTML;
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                const now = new Date();
                const year = String(now.getFullYear()).slice(-2);
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hour = String(now.getHours()).padStart(2, '0');
                const minute = String(now.getMinutes()).padStart(2, '0');
                const second = String(now.getSeconds()).padStart(2, '0');
                const timestamp = `${year}${month}${day}${hour}${minute}${second}`;
                link.download = `작업 현황 보고_${timestamp}.html`;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
            });
        }
    </script>
</body>

</html>